
badger-os.elf:     file format elf32-littleriscv


Disassembly of section .text:

42000358 <__interrupt_vector_table-0xa8>:
	...

42000400 <__interrupt_vector_table>:
42000400:	1b80006f          	j	420005b8 <__trap_asm>
42000404:	31c0006f          	j	42000720 <__isr_asm>
42000408:	3180006f          	j	42000720 <__isr_asm>
4200040c:	3140006f          	j	42000720 <__isr_asm>
42000410:	3100006f          	j	42000720 <__isr_asm>
42000414:	30c0006f          	j	42000720 <__isr_asm>
42000418:	3080006f          	j	42000720 <__isr_asm>
4200041c:	3040006f          	j	42000720 <__isr_asm>
42000420:	3000006f          	j	42000720 <__isr_asm>
42000424:	2fc0006f          	j	42000720 <__isr_asm>
42000428:	2f80006f          	j	42000720 <__isr_asm>
4200042c:	2f40006f          	j	42000720 <__isr_asm>
42000430:	2f00006f          	j	42000720 <__isr_asm>
42000434:	2ec0006f          	j	42000720 <__isr_asm>
42000438:	2e80006f          	j	42000720 <__isr_asm>
4200043c:	2e40006f          	j	42000720 <__isr_asm>
42000440:	2e00006f          	j	42000720 <__isr_asm>
42000444:	2dc0006f          	j	42000720 <__isr_asm>
42000448:	2d80006f          	j	42000720 <__isr_asm>
4200044c:	2d40006f          	j	42000720 <__isr_asm>
42000450:	2d00006f          	j	42000720 <__isr_asm>
42000454:	2cc0006f          	j	42000720 <__isr_asm>
42000458:	2c80006f          	j	42000720 <__isr_asm>
4200045c:	2c40006f          	j	42000720 <__isr_asm>
42000460:	2c00006f          	j	42000720 <__isr_asm>
42000464:	2bc0006f          	j	42000720 <__isr_asm>
42000468:	2b80006f          	j	42000720 <__isr_asm>
4200046c:	2b40006f          	j	42000720 <__isr_asm>
42000470:	2b00006f          	j	42000720 <__isr_asm>
42000474:	2ac0006f          	j	42000720 <__isr_asm>
42000478:	2a80006f          	j	42000720 <__isr_asm>
4200047c:	2a40006f          	j	42000720 <__isr_asm>

42000480 <isr_context_switch>:
    .global isr_context_switch
    .type isr_context_switch, %function
    .align 2
isr_context_switch:
    # Check for context switch required.
    csrr t0, mscratch
42000480:	340022f3          	csrr	t0,mscratch
    lw t1, isr_ctx_t_ctxswitch(t0)
42000484:	0a02a303          	lw	t1,160(t0)
    bnez t1, .isr_context_switch_do_switch
42000488:	00031663          	bnez	t1,42000494 <.isr_context_switch_do_switch>
    
    # Re-enable interrupts.
    li t1, 1 << RV32_MSTATUS_MIE_BIT
4200048c:	4321                	li	t1,8
    csrs mstatus, t1
4200048e:	30032073          	csrs	mstatus,t1
    ret
42000492:	8082                	ret

42000494 <.isr_context_switch_do_switch>:
    
.isr_context_switch_do_switch:
    # Re-enable interrupts on exit.
    li t1, (1 << RV32_MSTATUS_MPIE_BIT)
42000494:	08000313          	li	t1,128
    csrs mstatus, t1
42000498:	30032073          	csrs	mstatus,t1
    
    # Do the context switching things.
    # Save SP/GP/TP and PC.
    sw ra, isr_ctx_t_regs+cpu_regs_t_pc(t0)
4200049c:	0212a023          	sw	ra,32(t0)
    sw ra, isr_ctx_t_regs+cpu_regs_t_ra(t0)
420004a0:	0212a223          	sw	ra,36(t0)
    sw sp, isr_ctx_t_regs+cpu_regs_t_sp(t0)
420004a4:	0222a423          	sw	sp,40(t0)
    sw gp, isr_ctx_t_regs+cpu_regs_t_gp(t0)
420004a8:	0232a623          	sw	gp,44(t0)
    sw tp, isr_ctx_t_regs+cpu_regs_t_tp(t0)
420004ac:	0242a823          	sw	tp,48(t0)
    save_all_regs
420004b0:	0482a023          	sw	s0,64(t0)
420004b4:	0492a223          	sw	s1,68(t0)
420004b8:	04a2a423          	sw	a0,72(t0)
420004bc:	04b2a623          	sw	a1,76(t0)
420004c0:	04c2a823          	sw	a2,80(t0)
420004c4:	04d2aa23          	sw	a3,84(t0)
420004c8:	04e2ac23          	sw	a4,88(t0)
420004cc:	04f2ae23          	sw	a5,92(t0)
420004d0:	0702a023          	sw	a6,96(t0)
420004d4:	0712a223          	sw	a7,100(t0)
420004d8:	0722a423          	sw	s2,104(t0)
420004dc:	0732a623          	sw	s3,108(t0)
420004e0:	0742a823          	sw	s4,112(t0)
420004e4:	0752aa23          	sw	s5,116(t0)
420004e8:	0762ac23          	sw	s6,120(t0)
420004ec:	0772ae23          	sw	s7,124(t0)
420004f0:	0982a023          	sw	s8,128(t0)
420004f4:	0992a223          	sw	s9,132(t0)
420004f8:	09a2a423          	sw	s10,136(t0)
420004fc:	09b2a623          	sw	s11,140(t0)
42000500:	09d2aa23          	sw	t4,148(t0)
42000504:	09e2ac23          	sw	t5,152(t0)
42000508:	09f2ae23          	sw	t6,156(t0)
    
    # Switch context and set new privilege.
    lw t0, isr_ctx_t_ctxswitch(t0)
4200050c:	0a02a283          	lw	t0,160(t0)
    lw t1, isr_ctx_t_is_kernel_thread(t0)
42000510:	0a82a303          	lw	t1,168(t0)
    li t2, (3 << RV32_MSTATUS_MPP_BASE_BIT)
42000514:	6389                	lui	t2,0x2
42000516:	80038393          	add	t2,t2,-2048 # 1800 <isr_ctx_t_is_kernel_thread+0x1758>
    bnez t1, .isr_context_switch_do_m
4200051a:	00031563          	bnez	t1,42000524 <.isr_context_switch_do_m>
    
    # To U-mode.
    csrc mstatus, t2
4200051e:	3003b073          	csrc	mstatus,t2
    j .isr_context_switch_ret
42000522:	a019                	j	42000528 <.isr_context_switch_ret>

42000524 <.isr_context_switch_do_m>:
    
.isr_context_switch_do_m:
    # To M-mode.
    csrs mstatus, t2
42000524:	3003a073          	csrs	mstatus,t2

42000528 <.isr_context_switch_ret>:
    
.isr_context_switch_ret:
    # Return to new context.
    restore_all_regs
42000528:	0402a403          	lw	s0,64(t0)
4200052c:	0442a483          	lw	s1,68(t0)
42000530:	0482a503          	lw	a0,72(t0)
42000534:	04c2a583          	lw	a1,76(t0)
42000538:	0502a603          	lw	a2,80(t0)
4200053c:	0542a683          	lw	a3,84(t0)
42000540:	0582a703          	lw	a4,88(t0)
42000544:	05c2a783          	lw	a5,92(t0)
42000548:	0602a803          	lw	a6,96(t0)
4200054c:	0642a883          	lw	a7,100(t0)
42000550:	0682a903          	lw	s2,104(t0)
42000554:	06c2a983          	lw	s3,108(t0)
42000558:	0702aa03          	lw	s4,112(t0)
4200055c:	0742aa83          	lw	s5,116(t0)
42000560:	0782ab03          	lw	s6,120(t0)
42000564:	07c2ab83          	lw	s7,124(t0)
42000568:	0802ac03          	lw	s8,128(t0)
4200056c:	0842ac83          	lw	s9,132(t0)
42000570:	0882ad03          	lw	s10,136(t0)
42000574:	08c2ad83          	lw	s11,140(t0)
42000578:	0942ae83          	lw	t4,148(t0)
4200057c:	0982af03          	lw	t5,152(t0)
42000580:	09c2af83          	lw	t6,156(t0)
    isr_exit
42000584:	0202a303          	lw	t1,32(t0)
42000588:	34131073          	csrw	mepc,t1
4200058c:	0242a083          	lw	ra,36(t0)
42000590:	0282a103          	lw	sp,40(t0)
42000594:	02c2a183          	lw	gp,44(t0)
42000598:	0302a203          	lw	tp,48(t0)
4200059c:	0342a303          	lw	t1,52(t0)
420005a0:	34031073          	csrw	mscratch,t1
420005a4:	0902ae03          	lw	t3,144(t0)
420005a8:	03c2a383          	lw	t2,60(t0)
420005ac:	0382a303          	lw	t1,56(t0)
420005b0:	340292f3          	csrrw	t0,mscratch,t0
    mret
420005b4:	30200073          	mret

420005b8 <__trap_asm>:
    # Trap and system call handler.
    .text
    .type __trap_asm, %function
    .align 2
__trap_asm:
    isr_entry
420005b8:	340292f3          	csrrw	t0,mscratch,t0
420005bc:	0062a223          	sw	t1,4(t0)
420005c0:	34029373          	csrrw	t1,mscratch,t0
420005c4:	0062a023          	sw	t1,0(t0)
420005c8:	0272ae23          	sw	t2,60(t0)
420005cc:	09c2a823          	sw	t3,144(t0)
420005d0:	0212a223          	sw	ra,36(t0)
420005d4:	0222a423          	sw	sp,40(t0)
420005d8:	0232a623          	sw	gp,44(t0)
420005dc:	0242a823          	sw	tp,48(t0)
420005e0:	0a02a023          	sw	zero,160(t0)
420005e4:	0002a303          	lw	t1,0(t0)
420005e8:	0262aa23          	sw	t1,52(t0)
420005ec:	0042a303          	lw	t1,4(t0)
420005f0:	0262ac23          	sw	t1,56(t0)
420005f4:	34102373          	csrr	t1,mepc
420005f8:	0262a023          	sw	t1,32(t0)
420005fc:	4201                	li	tp,0
420005fe:	00018193          	mv	gp,gp
42000602:	fe808117          	auipc	sp,0xfe808
42000606:	81e10113          	add	sp,sp,-2018 # 40807e20 <__stack_bottom>
    save_all_regs
4200060a:	0482a023          	sw	s0,64(t0)
4200060e:	0492a223          	sw	s1,68(t0)
42000612:	04a2a423          	sw	a0,72(t0)
42000616:	04b2a623          	sw	a1,76(t0)
4200061a:	04c2a823          	sw	a2,80(t0)
4200061e:	04d2aa23          	sw	a3,84(t0)
42000622:	04e2ac23          	sw	a4,88(t0)
42000626:	04f2ae23          	sw	a5,92(t0)
4200062a:	0702a023          	sw	a6,96(t0)
4200062e:	0712a223          	sw	a7,100(t0)
42000632:	0722a423          	sw	s2,104(t0)
42000636:	0732a623          	sw	s3,108(t0)
4200063a:	0742a823          	sw	s4,112(t0)
4200063e:	0752aa23          	sw	s5,116(t0)
42000642:	0762ac23          	sw	s6,120(t0)
42000646:	0772ae23          	sw	s7,124(t0)
4200064a:	0982a023          	sw	s8,128(t0)
4200064e:	0992a223          	sw	s9,132(t0)
42000652:	09a2a423          	sw	s10,136(t0)
42000656:	09b2a623          	sw	s11,140(t0)
4200065a:	09d2aa23          	sw	t4,148(t0)
4200065e:	09e2ac23          	sw	t5,152(t0)
42000662:	09f2ae23          	sw	t6,156(t0)
    
    # Most of the trap handler is implemented in C.
    jal __trap_handler
42000666:	0090e0ef          	jal	4200ee6e <__trap_handler>
    csrr t0, mscratch
4200066a:	340022f3          	csrr	t0,mscratch
    
    # Check for outstanding context switch.
    # If nonnull, context will be switched.
    lw   t1, isr_ctx_t_ctxswitch(t0)
4200066e:	0a02a303          	lw	t1,160(t0)
    beq  t1, x0, .__trap_asm_restore_regs
42000672:	00030f63          	beqz	t1,42000690 <.__trap_asm_restore_regs>
    # Swap out the context pointer.
    mv   t0, t1
42000676:	829a                	mv	t0,t1
    # Set privilege level.
    lw   t2, isr_ctx_t_is_kernel_thread(t0)
42000678:	0a82a383          	lw	t2,168(t0)
    li   t3, 3 << RV32_MSTATUS_MPP_BASE_BIT
4200067c:	6e09                	lui	t3,0x2
4200067e:	800e0e13          	add	t3,t3,-2048 # 1800 <isr_ctx_t_is_kernel_thread+0x1758>
    bnez t2, .__trap_asm_priv_m
42000682:	00039563          	bnez	t2,4200068c <.__trap_asm_priv_m>
    # Zero; user thread; clear MPP.
    csrc mstatus, t3
42000686:	300e3073          	csrc	mstatus,t3
    j .__trap_asm_restore_regs
4200068a:	a019                	j	42000690 <.__trap_asm_restore_regs>

4200068c <.__trap_asm_priv_m>:
.__trap_asm_priv_m:
    # Nonzero; kernel thread; set MPP.
    csrs mstatus, t3
4200068c:	300e2073          	csrs	mstatus,t3

42000690 <.__trap_asm_restore_regs>:
    
.__trap_asm_restore_regs:
    restore_all_regs
42000690:	0402a403          	lw	s0,64(t0)
42000694:	0442a483          	lw	s1,68(t0)
42000698:	0482a503          	lw	a0,72(t0)
4200069c:	04c2a583          	lw	a1,76(t0)
420006a0:	0502a603          	lw	a2,80(t0)
420006a4:	0542a683          	lw	a3,84(t0)
420006a8:	0582a703          	lw	a4,88(t0)
420006ac:	05c2a783          	lw	a5,92(t0)
420006b0:	0602a803          	lw	a6,96(t0)
420006b4:	0642a883          	lw	a7,100(t0)
420006b8:	0682a903          	lw	s2,104(t0)
420006bc:	06c2a983          	lw	s3,108(t0)
420006c0:	0702aa03          	lw	s4,112(t0)
420006c4:	0742aa83          	lw	s5,116(t0)
420006c8:	0782ab03          	lw	s6,120(t0)
420006cc:	07c2ab83          	lw	s7,124(t0)
420006d0:	0802ac03          	lw	s8,128(t0)
420006d4:	0842ac83          	lw	s9,132(t0)
420006d8:	0882ad03          	lw	s10,136(t0)
420006dc:	08c2ad83          	lw	s11,140(t0)
420006e0:	0942ae83          	lw	t4,148(t0)
420006e4:	0982af03          	lw	t5,152(t0)
420006e8:	09c2af83          	lw	t6,156(t0)
    isr_exit
420006ec:	0202a303          	lw	t1,32(t0)
420006f0:	34131073          	csrw	mepc,t1
420006f4:	0242a083          	lw	ra,36(t0)
420006f8:	0282a103          	lw	sp,40(t0)
420006fc:	02c2a183          	lw	gp,44(t0)
42000700:	0302a203          	lw	tp,48(t0)
42000704:	0342a303          	lw	t1,52(t0)
42000708:	34031073          	csrw	mscratch,t1
4200070c:	0902ae03          	lw	t3,144(t0)
42000710:	03c2a383          	lw	t2,60(t0)
42000714:	0382a303          	lw	t1,56(t0)
42000718:	340292f3          	csrrw	t0,mscratch,t0
    mret
4200071c:	30200073          	mret

42000720 <__isr_asm>:
    .text
    .type __isr_asm, %function
    .align 2
__isr_asm:
    # This is an interrupt; saving all registers is mandatory.
    isr_entry
42000720:	340292f3          	csrrw	t0,mscratch,t0
42000724:	0062a223          	sw	t1,4(t0)
42000728:	34029373          	csrrw	t1,mscratch,t0
4200072c:	0062a023          	sw	t1,0(t0)
42000730:	0272ae23          	sw	t2,60(t0)
42000734:	09c2a823          	sw	t3,144(t0)
42000738:	0212a223          	sw	ra,36(t0)
4200073c:	0222a423          	sw	sp,40(t0)
42000740:	0232a623          	sw	gp,44(t0)
42000744:	0242a823          	sw	tp,48(t0)
42000748:	0a02a023          	sw	zero,160(t0)
4200074c:	0002a303          	lw	t1,0(t0)
42000750:	0262aa23          	sw	t1,52(t0)
42000754:	0042a303          	lw	t1,4(t0)
42000758:	0262ac23          	sw	t1,56(t0)
4200075c:	34102373          	csrr	t1,mepc
42000760:	0262a023          	sw	t1,32(t0)
42000764:	4201                	li	tp,0
42000766:	00018193          	mv	gp,gp
4200076a:	fe807117          	auipc	sp,0xfe807
4200076e:	6b610113          	add	sp,sp,1718 # 40807e20 <__stack_bottom>
    save_all_regs
42000772:	0482a023          	sw	s0,64(t0)
42000776:	0492a223          	sw	s1,68(t0)
4200077a:	04a2a423          	sw	a0,72(t0)
4200077e:	04b2a623          	sw	a1,76(t0)
42000782:	04c2a823          	sw	a2,80(t0)
42000786:	04d2aa23          	sw	a3,84(t0)
4200078a:	04e2ac23          	sw	a4,88(t0)
4200078e:	04f2ae23          	sw	a5,92(t0)
42000792:	0702a023          	sw	a6,96(t0)
42000796:	0712a223          	sw	a7,100(t0)
4200079a:	0722a423          	sw	s2,104(t0)
4200079e:	0732a623          	sw	s3,108(t0)
420007a2:	0742a823          	sw	s4,112(t0)
420007a6:	0752aa23          	sw	s5,116(t0)
420007aa:	0762ac23          	sw	s6,120(t0)
420007ae:	0772ae23          	sw	s7,124(t0)
420007b2:	0982a023          	sw	s8,128(t0)
420007b6:	0992a223          	sw	s9,132(t0)
420007ba:	09a2a423          	sw	s10,136(t0)
420007be:	09b2a623          	sw	s11,140(t0)
420007c2:	09d2aa23          	sw	t4,148(t0)
420007c6:	09e2ac23          	sw	t5,152(t0)
420007ca:	09f2ae23          	sw	t6,156(t0)
    # Most of the interrupt handler is implemented in C.
    jal __interrupt_handler
420007ce:	6aa0f0ef          	jal	4200fe78 <__interrupt_handler>
    csrr t0, mscratch
420007d2:	340022f3          	csrr	t0,mscratch
    
    # Check for outstanding context switch.
    # If nonnull, context will be switched.
    lw   t1, isr_ctx_t_ctxswitch(t0)
420007d6:	0a02a303          	lw	t1,160(t0)
    beq  t1, x0, .__isr_asm_exit
420007da:	00030363          	beqz	t1,420007e0 <.__isr_asm_exit>
    # All that is necessary is swapping out t0.
    mv   t0, t1
420007de:	829a                	mv	t0,t1

420007e0 <.__isr_asm_exit>:
    
.__isr_asm_exit:
    # This is an interrupt; restoring all registers is mandatory.
    restore_all_regs
420007e0:	0402a403          	lw	s0,64(t0)
420007e4:	0442a483          	lw	s1,68(t0)
420007e8:	0482a503          	lw	a0,72(t0)
420007ec:	04c2a583          	lw	a1,76(t0)
420007f0:	0502a603          	lw	a2,80(t0)
420007f4:	0542a683          	lw	a3,84(t0)
420007f8:	0582a703          	lw	a4,88(t0)
420007fc:	05c2a783          	lw	a5,92(t0)
42000800:	0602a803          	lw	a6,96(t0)
42000804:	0642a883          	lw	a7,100(t0)
42000808:	0682a903          	lw	s2,104(t0)
4200080c:	06c2a983          	lw	s3,108(t0)
42000810:	0702aa03          	lw	s4,112(t0)
42000814:	0742aa83          	lw	s5,116(t0)
42000818:	0782ab03          	lw	s6,120(t0)
4200081c:	07c2ab83          	lw	s7,124(t0)
42000820:	0802ac03          	lw	s8,128(t0)
42000824:	0842ac83          	lw	s9,132(t0)
42000828:	0882ad03          	lw	s10,136(t0)
4200082c:	08c2ad83          	lw	s11,140(t0)
42000830:	0942ae83          	lw	t4,148(t0)
42000834:	0982af03          	lw	t5,152(t0)
42000838:	09c2af83          	lw	t6,156(t0)
    isr_exit
4200083c:	0202a303          	lw	t1,32(t0)
42000840:	34131073          	csrw	mepc,t1
42000844:	0242a083          	lw	ra,36(t0)
42000848:	0282a103          	lw	sp,40(t0)
4200084c:	02c2a183          	lw	gp,44(t0)
42000850:	0302a203          	lw	tp,48(t0)
42000854:	0342a303          	lw	t1,52(t0)
42000858:	34031073          	csrw	mscratch,t1
4200085c:	0902ae03          	lw	t3,144(t0)
42000860:	03c2a383          	lw	t2,60(t0)
42000864:	0382a303          	lw	t1,56(t0)
42000868:	340292f3          	csrrw	t0,mscratch,t0
    mret
4200086c:	30200073          	mret
	...

42000872 <kernel_cur_regs_dump>:
	# Print a register dump of the current registers.
	.global kernel_cur_regs_dump
	.type kernel_cur_regs_dump, %function
kernel_cur_regs_dump:
	# Save all registers to stack.
	addi sp, sp, -128
42000872:	7119                	add	sp,sp,-128
	sw ra, cpu_regs_t_pc(sp) # PC inferred.
42000874:	c006                	sw	ra,0(sp)
	sw x0, cpu_regs_t_ra(sp) # RA omitted.
42000876:	c202                	sw	zero,4(sp)
	# sw sp, cpu_regs_t_sp(sp) # SP inferred.
	sw gp, cpu_regs_t_gp(sp)
42000878:	c60e                	sw	gp,12(sp)
	sw tp, cpu_regs_t_tp(sp)
4200087a:	c812                	sw	tp,16(sp)
	sw t0, cpu_regs_t_t0(sp)
4200087c:	ca16                	sw	t0,20(sp)
	sw t1, cpu_regs_t_t1(sp)
4200087e:	cc1a                	sw	t1,24(sp)
	sw t2, cpu_regs_t_t2(sp)
42000880:	ce1e                	sw	t2,28(sp)
	sw s0, cpu_regs_t_s0(sp)
42000882:	d022                	sw	s0,32(sp)
	sw s1, cpu_regs_t_s1(sp)
42000884:	d226                	sw	s1,36(sp)
	sw a0, cpu_regs_t_a0(sp)
42000886:	d42a                	sw	a0,40(sp)
	sw a1, cpu_regs_t_a1(sp)
42000888:	d62e                	sw	a1,44(sp)
	sw a2, cpu_regs_t_a2(sp)
4200088a:	d832                	sw	a2,48(sp)
	sw a3, cpu_regs_t_a3(sp)
4200088c:	da36                	sw	a3,52(sp)
	sw a4, cpu_regs_t_a4(sp)
4200088e:	dc3a                	sw	a4,56(sp)
	sw a5, cpu_regs_t_a5(sp)
42000890:	de3e                	sw	a5,60(sp)
	sw a6, cpu_regs_t_a6(sp)
42000892:	c0c2                	sw	a6,64(sp)
	sw a7, cpu_regs_t_a7(sp)
42000894:	c2c6                	sw	a7,68(sp)
	sw s2, cpu_regs_t_s2(sp)
42000896:	c4ca                	sw	s2,72(sp)
	sw s3, cpu_regs_t_s3(sp)
42000898:	c6ce                	sw	s3,76(sp)
	sw s4, cpu_regs_t_s4(sp)
4200089a:	c8d2                	sw	s4,80(sp)
	sw s5, cpu_regs_t_s5(sp)
4200089c:	cad6                	sw	s5,84(sp)
	sw s6, cpu_regs_t_s6(sp)
4200089e:	ccda                	sw	s6,88(sp)
	sw s7, cpu_regs_t_s7(sp)
420008a0:	cede                	sw	s7,92(sp)
	sw s8, cpu_regs_t_s8(sp)
420008a2:	d0e2                	sw	s8,96(sp)
	sw s9, cpu_regs_t_s9(sp)
420008a4:	d2e6                	sw	s9,100(sp)
	sw s10, cpu_regs_t_s10(sp)
420008a6:	d4ea                	sw	s10,104(sp)
	sw s11, cpu_regs_t_s11(sp)
420008a8:	d6ee                	sw	s11,108(sp)
	sw t3, cpu_regs_t_t3(sp)
420008aa:	d8f2                	sw	t3,112(sp)
	sw t4, cpu_regs_t_t4(sp)
420008ac:	daf6                	sw	t4,116(sp)
	sw t5, cpu_regs_t_t5(sp)
420008ae:	dcfa                	sw	t5,120(sp)
	sw t6, cpu_regs_t_t6(sp)
420008b0:	defe                	sw	t6,124(sp)
	# Store the real value of SP and call the printer.
	addi a0, sp, 128
420008b2:	0108                	add	a0,sp,128
	sw a0, cpu_regs_t_sp(sp)
420008b4:	c42a                	sw	a0,8(sp)
	mv a0, sp
420008b6:	850a                	mv	a0,sp
	jal kernel_reg_dump_arr
420008b8:	7ea0e0ef          	jal	4200f0a2 <kernel_reg_dump_arr>
	# Restore all registers.
	lw ra, cpu_regs_t_pc(sp) # PC inferred.
420008bc:	4082                	lw	ra,0(sp)
	# lw ra, cpu_regs_t_ra(sp) # RA omitted.
	# lw sp, cpu_regs_t_sp(sp) # SP inferred.
	lw gp, cpu_regs_t_gp(sp)
420008be:	41b2                	lw	gp,12(sp)
	lw tp, cpu_regs_t_tp(sp)
420008c0:	4242                	lw	tp,16(sp)
	lw t0, cpu_regs_t_t0(sp)
420008c2:	42d2                	lw	t0,20(sp)
	lw t1, cpu_regs_t_t1(sp)
420008c4:	4362                	lw	t1,24(sp)
	lw t2, cpu_regs_t_t2(sp)
420008c6:	43f2                	lw	t2,28(sp)
	lw s0, cpu_regs_t_s0(sp)
420008c8:	5402                	lw	s0,32(sp)
	lw s1, cpu_regs_t_s1(sp)
420008ca:	5492                	lw	s1,36(sp)
	lw a0, cpu_regs_t_a0(sp)
420008cc:	5522                	lw	a0,40(sp)
	lw a1, cpu_regs_t_a1(sp)
420008ce:	55b2                	lw	a1,44(sp)
	lw a2, cpu_regs_t_a2(sp)
420008d0:	5642                	lw	a2,48(sp)
	lw a3, cpu_regs_t_a3(sp)
420008d2:	56d2                	lw	a3,52(sp)
	lw a4, cpu_regs_t_a4(sp)
420008d4:	5762                	lw	a4,56(sp)
	lw a5, cpu_regs_t_a5(sp)
420008d6:	57f2                	lw	a5,60(sp)
	lw a6, cpu_regs_t_a6(sp)
420008d8:	4806                	lw	a6,64(sp)
	lw a7, cpu_regs_t_a7(sp)
420008da:	4896                	lw	a7,68(sp)
	lw s2, cpu_regs_t_s2(sp)
420008dc:	4926                	lw	s2,72(sp)
	lw s3, cpu_regs_t_s3(sp)
420008de:	49b6                	lw	s3,76(sp)
	lw s4, cpu_regs_t_s4(sp)
420008e0:	4a46                	lw	s4,80(sp)
	lw s5, cpu_regs_t_s5(sp)
420008e2:	4ad6                	lw	s5,84(sp)
	lw s6, cpu_regs_t_s6(sp)
420008e4:	4b66                	lw	s6,88(sp)
	lw s7, cpu_regs_t_s7(sp)
420008e6:	4bf6                	lw	s7,92(sp)
	lw s8, cpu_regs_t_s8(sp)
420008e8:	5c06                	lw	s8,96(sp)
	lw s9, cpu_regs_t_s9(sp)
420008ea:	5c96                	lw	s9,100(sp)
	lw s10, cpu_regs_t_s10(sp)
420008ec:	5d26                	lw	s10,104(sp)
	lw s11, cpu_regs_t_s11(sp)
420008ee:	5db6                	lw	s11,108(sp)
	lw t3, cpu_regs_t_t3(sp)
420008f0:	5e46                	lw	t3,112(sp)
	lw t4, cpu_regs_t_t4(sp)
420008f2:	5ed6                	lw	t4,116(sp)
	lw t5, cpu_regs_t_t5(sp)
420008f4:	5f66                	lw	t5,120(sp)
	lw t6, cpu_regs_t_t6(sp)
420008f6:	5ff6                	lw	t6,124(sp)
	# Return.
	addi sp, sp, 128
420008f8:	6109                	add	sp,sp,128
	ret
420008fa:	8082                	ret

420008fc <_start>:
	.type _start, %function
_start:
	# Set up registers.
	.option push
	.option norelax
	la gp, __global_pointer$
420008fc:	fe7ff197          	auipc	gp,0xfe7ff
42000900:	70418193          	add	gp,gp,1796 # 40800000 <badge_eloc_name>
	mv tp, x0
42000904:	00000213          	li	tp,0
	la sp, __stack_top
42000908:	fe809117          	auipc	sp,0xfe809
4200090c:	51810113          	add	sp,sp,1304 # 40809e20 <__stack_top>
	.option pop
	
	# Zero out .bss section.
	la a0, __start_bss
42000910:	33018513          	add	a0,gp,816 # 40800330 <vfs_table>
	la a1, __stop_bss
42000914:	fe809597          	auipc	a1,0xfe809
42000918:	57c58593          	add	a1,a1,1404 # 40809e90 <__start_free_sram>
	beq a0, a1, .bssinit_skip
4200091c:	00b50763          	beq	a0,a1,4200092a <.bssinit_skip>

42000920 <.bssinit_loop>:
.bssinit_loop:
	sw x0, 0(a0)
42000920:	00052023          	sw	zero,0(a0)
	addi a0, a0, 4
42000924:	0511                	add	a0,a0,4
	bne a0, a1, .bssinit_loop
42000926:	feb51de3          	bne	a0,a1,42000920 <.bssinit_loop>

4200092a <.bssinit_skip>:
.bssinit_skip:
	
	# Run init functions.
	la s0, __start_init_array
4200092a:	00013417          	auipc	s0,0x13
4200092e:	71e40413          	add	s0,s0,1822 # 42014048 <filerom_1>
	la s1, __stop_init_array
42000932:	00013497          	auipc	s1,0x13
42000936:	71648493          	add	s1,s1,1814 # 42014048 <filerom_1>
	beq s0, s1, .initfun_skip
4200093a:	00940963          	beq	s0,s1,4200094c <.initfun_skip>

4200093e <.initfun_loop>:
.initfun_loop:
	lw ra, 0(s0)
4200093e:	00042083          	lw	ra,0(s0)
	jalr ra, ra
42000942:	000080e7          	jalr	ra
	addi s0, s0, 4
42000946:	0411                	add	s0,s0,4
	bne s0, s1, .initfun_loop
42000948:	fe941be3          	bne	s0,s1,4200093e <.initfun_loop>

4200094c <.initfun_skip>:
.initfun_skip:
	
	# Jump to the C entrypoint.
	jal basic_runtime_init
4200094c:	20d0c0ef          	jal	4200d358 <basic_runtime_init>
	# This function isn't allowed to return.
	ebreak
42000950:	9002                	ebreak

42000952 <init_ramfs>:
static size_t const filerom_0_len = 10672;
static uint8_t const filerom_1[] = {
    0x48,0x65,0x6c,0x6c,0x6f,0x2c,0x20,0x57,0x6f,0x72,0x6c,0x64,0x21,0x0a,0x43,0x6f,0x6d,0x70,0x69,0x6c,0x65,0x64,0x20,0x61,0x74,0x20,0x53,0x61,0x74,0x20,0x4a,0x61,0x6e,0x20,0x32,0x30,0x20,0x31,0x32,0x3a,0x33,0x30,0x3a,0x33,0x30,0x20,0x41,0x4d,0x20,0x43,0x45,0x54,0x20,0x32,0x30,0x32,0x34,0x0a,
};
static size_t const filerom_1_len = 58;
void init_ramfs() {
42000952:	1101                	add	sp,sp,-32
    badge_err_t ec = {0};
    file_t fd;
    fs_dir_create(&ec, "/sbin");
42000954:	420175b7          	lui	a1,0x42017
42000958:	dac58593          	add	a1,a1,-596 # 42016dac <hextab+0xe0>
4200095c:	850a                	mv	a0,sp
void init_ramfs() {
4200095e:	cc22                	sw	s0,24(sp)
42000960:	ce06                	sw	ra,28(sp)
42000962:	ca26                	sw	s1,20(sp)
    badge_err_t ec = {0};
42000964:	c002                	sw	zero,0(sp)
42000966:	c202                	sw	zero,4(sp)
42000968:	c402                	sw	zero,8(sp)
4200096a:	c602                	sw	zero,12(sp)
    fs_dir_create(&ec, "/sbin");
4200096c:	567060ef          	jal	420076d2 <fs_dir_create>
    badge_err_assert_dev(&ec);
42000970:	4402                	lw	s0,0(sp)
42000972:	e461                	bnez	s0,42000a3a <init_ramfs+0xe8>
    fs_dir_create(&ec, "/etc");
42000974:	420175b7          	lui	a1,0x42017
42000978:	e1058593          	add	a1,a1,-496 # 42016e10 <hextab+0x144>
4200097c:	850a                	mv	a0,sp
4200097e:	555060ef          	jal	420076d2 <fs_dir_create>
    badge_err_assert_dev(&ec);
42000982:	4402                	lw	s0,0(sp)
42000984:	e469                	bnez	s0,42000a4e <init_ramfs+0xfc>
    fd = fs_open(&ec, "/sbin/init", OFLAGS_CREATE | OFLAGS_WRITEONLY);
42000986:	420175b7          	lui	a1,0x42017
4200098a:	4649                	li	a2,18
4200098c:	e1858593          	add	a1,a1,-488 # 42016e18 <hextab+0x14c>
42000990:	850a                	mv	a0,sp
42000992:	1f9050ef          	jal	4200638a <fs_open>
    badge_err_assert_dev(&ec);
42000996:	4482                	lw	s1,0(sp)
    fd = fs_open(&ec, "/sbin/init", OFLAGS_CREATE | OFLAGS_WRITEONLY);
42000998:	842a                	mv	s0,a0
    badge_err_assert_dev(&ec);
4200099a:	0c049463          	bnez	s1,42000a62 <init_ramfs+0x110>
    fs_write(&ec, fd, filerom_0, filerom_0_len);
4200099e:	668d                	lui	a3,0x3
420009a0:	42014637          	lui	a2,0x42014
420009a4:	85aa                	mv	a1,a0
420009a6:	9b068693          	add	a3,a3,-1616 # 29b0 <__stack_size+0x9b0>
420009aa:	08460613          	add	a2,a2,132 # 42014084 <filerom_0>
420009ae:	850a                	mv	a0,sp
420009b0:	01b070ef          	jal	420081ca <fs_write>
    badge_err_assert_dev(&ec);
420009b4:	4482                	lw	s1,0(sp)
420009b6:	0a049f63          	bnez	s1,42000a74 <init_ramfs+0x122>
    fs_close(&ec, fd);
420009ba:	85a2                	mv	a1,s0
420009bc:	850a                	mv	a0,sp
420009be:	265060ef          	jal	42007422 <fs_close>
    badge_err_assert_dev(&ec);
420009c2:	4402                	lw	s0,0(sp)
420009c4:	0c041163          	bnez	s0,42000a86 <init_ramfs+0x134>
    fd = fs_open(&ec, "/etc/motd", OFLAGS_CREATE | OFLAGS_WRITEONLY);
420009c8:	420175b7          	lui	a1,0x42017
420009cc:	4649                	li	a2,18
420009ce:	e2458593          	add	a1,a1,-476 # 42016e24 <hextab+0x158>
420009d2:	850a                	mv	a0,sp
420009d4:	1b7050ef          	jal	4200638a <fs_open>
    badge_err_assert_dev(&ec);
420009d8:	4482                	lw	s1,0(sp)
    fd = fs_open(&ec, "/etc/motd", OFLAGS_CREATE | OFLAGS_WRITEONLY);
420009da:	842a                	mv	s0,a0
    badge_err_assert_dev(&ec);
420009dc:	0a049f63          	bnez	s1,42000a9a <init_ramfs+0x148>
    fs_write(&ec, fd, filerom_1, filerom_1_len);
420009e0:	42014637          	lui	a2,0x42014
420009e4:	85aa                	mv	a1,a0
420009e6:	03a00693          	li	a3,58
420009ea:	04860613          	add	a2,a2,72 # 42014048 <filerom_1>
420009ee:	850a                	mv	a0,sp
420009f0:	7da070ef          	jal	420081ca <fs_write>
    badge_err_assert_dev(&ec);
420009f4:	4482                	lw	s1,0(sp)
420009f6:	ec89                	bnez	s1,42000a10 <init_ramfs+0xbe>
    fs_close(&ec, fd);
420009f8:	85a2                	mv	a1,s0
420009fa:	850a                	mv	a0,sp
420009fc:	227060ef          	jal	42007422 <fs_close>
    badge_err_assert_dev(&ec);
42000a00:	4402                	lw	s0,0(sp)
42000a02:	0a041563          	bnez	s0,42000aac <init_ramfs+0x15a>
}
42000a06:	40f2                	lw	ra,28(sp)
42000a08:	4462                	lw	s0,24(sp)
42000a0a:	44d2                	lw	s1,20(sp)
42000a0c:	6105                	add	sp,sp,32
42000a0e:	8082                	ret
    badge_err_assert_dev(&ec);
42000a10:	4512                	lw	a0,4(sp)
42000a12:	2e3d                	jal	42000d50 <badge_eloc_get_name>
42000a14:	842a                	mv	s0,a0
42000a16:	8526                	mv	a0,s1
42000a18:	2e9d                	jal	42000d8e <badge_ecause_get_name>
42000a1a:	87aa                	mv	a5,a0
42000a1c:	8722                	mv	a4,s0
42000a1e:	02100693          	li	a3,33
    badge_err_assert_dev(&ec);
42000a22:	42017637          	lui	a2,0x42017
42000a26:	420175b7          	lui	a1,0x42017
42000a2a:	db460613          	add	a2,a2,-588 # 42016db4 <hextab+0xe8>
42000a2e:	df058593          	add	a1,a1,-528 # 42016df0 <hextab+0x124>
42000a32:	4501                	li	a0,0
42000a34:	067020ef          	jal	4200329a <logkf>
42000a38:	9002                	ebreak
    badge_err_assert_dev(&ec);
42000a3a:	4512                	lw	a0,4(sp)
42000a3c:	2e11                	jal	42000d50 <badge_eloc_get_name>
42000a3e:	872a                	mv	a4,a0
42000a40:	8522                	mv	a0,s0
42000a42:	843a                	mv	s0,a4
42000a44:	26a9                	jal	42000d8e <badge_ecause_get_name>
42000a46:	87aa                	mv	a5,a0
42000a48:	8722                	mv	a4,s0
42000a4a:	46d5                	li	a3,21
42000a4c:	bfd9                	j	42000a22 <init_ramfs+0xd0>
    badge_err_assert_dev(&ec);
42000a4e:	4512                	lw	a0,4(sp)
42000a50:	2601                	jal	42000d50 <badge_eloc_get_name>
42000a52:	872a                	mv	a4,a0
42000a54:	8522                	mv	a0,s0
42000a56:	843a                	mv	s0,a4
42000a58:	2e1d                	jal	42000d8e <badge_ecause_get_name>
42000a5a:	87aa                	mv	a5,a0
42000a5c:	8722                	mv	a4,s0
42000a5e:	46dd                	li	a3,23
42000a60:	b7c9                	j	42000a22 <init_ramfs+0xd0>
    badge_err_assert_dev(&ec);
42000a62:	4512                	lw	a0,4(sp)
42000a64:	24f5                	jal	42000d50 <badge_eloc_get_name>
42000a66:	842a                	mv	s0,a0
42000a68:	8526                	mv	a0,s1
42000a6a:	2615                	jal	42000d8e <badge_ecause_get_name>
42000a6c:	87aa                	mv	a5,a0
42000a6e:	8722                	mv	a4,s0
42000a70:	46e5                	li	a3,25
42000a72:	bf45                	j	42000a22 <init_ramfs+0xd0>
    badge_err_assert_dev(&ec);
42000a74:	4512                	lw	a0,4(sp)
42000a76:	2ce9                	jal	42000d50 <badge_eloc_get_name>
42000a78:	842a                	mv	s0,a0
42000a7a:	8526                	mv	a0,s1
42000a7c:	2e09                	jal	42000d8e <badge_ecause_get_name>
42000a7e:	87aa                	mv	a5,a0
42000a80:	8722                	mv	a4,s0
42000a82:	46ed                	li	a3,27
42000a84:	bf79                	j	42000a22 <init_ramfs+0xd0>
    badge_err_assert_dev(&ec);
42000a86:	4512                	lw	a0,4(sp)
42000a88:	24e1                	jal	42000d50 <badge_eloc_get_name>
42000a8a:	872a                	mv	a4,a0
42000a8c:	8522                	mv	a0,s0
42000a8e:	843a                	mv	s0,a4
42000a90:	2cfd                	jal	42000d8e <badge_ecause_get_name>
42000a92:	87aa                	mv	a5,a0
42000a94:	8722                	mv	a4,s0
42000a96:	46f5                	li	a3,29
42000a98:	b769                	j	42000a22 <init_ramfs+0xd0>
    badge_err_assert_dev(&ec);
42000a9a:	4512                	lw	a0,4(sp)
42000a9c:	2c55                	jal	42000d50 <badge_eloc_get_name>
42000a9e:	842a                	mv	s0,a0
42000aa0:	8526                	mv	a0,s1
42000aa2:	24f5                	jal	42000d8e <badge_ecause_get_name>
42000aa4:	87aa                	mv	a5,a0
42000aa6:	8722                	mv	a4,s0
42000aa8:	46fd                	li	a3,31
42000aaa:	bfa5                	j	42000a22 <init_ramfs+0xd0>
    badge_err_assert_dev(&ec);
42000aac:	4512                	lw	a0,4(sp)
42000aae:	244d                	jal	42000d50 <badge_eloc_get_name>
42000ab0:	872a                	mv	a4,a0
42000ab2:	8522                	mv	a0,s0
42000ab4:	843a                	mv	s0,a4
42000ab6:	2ce1                	jal	42000d8e <badge_ecause_get_name>
42000ab8:	87aa                	mv	a5,a0
42000aba:	8722                	mv	a4,s0
42000abc:	02300693          	li	a3,35
42000ac0:	b78d                	j	42000a22 <init_ramfs+0xd0>

42000ac2 <array_binsearch>:


// Binary search for a value in a sorted (ascending order) array.
array_binsearch_t array_binsearch(
    void const *array, size_t ent_size, size_t ent_count, void const *value, array_sort_comp_t comparator
) {
42000ac2:	7139                	add	sp,sp,-64
42000ac4:	de06                	sw	ra,60(sp)
42000ac6:	ce5e                	sw	s7,28(sp)
    size_t ent_start = 0;
    while (ent_count > 0) {
42000ac8:	c651                	beqz	a2,42000b54 <array_binsearch+0x92>
42000aca:	dc22                	sw	s0,56(sp)
42000acc:	d64e                	sw	s3,44(sp)
42000ace:	d452                	sw	s4,40(sp)
42000ad0:	d256                	sw	s5,36(sp)
42000ad2:	d05a                	sw	s6,32(sp)
42000ad4:	da26                	sw	s1,52(sp)
42000ad6:	d84a                	sw	s2,48(sp)
42000ad8:	8432                	mv	s0,a2
42000ada:	89aa                	mv	s3,a0
42000adc:	8a2e                	mv	s4,a1
42000ade:	8ab6                	mv	s5,a3
42000ae0:	8b3a                	mv	s6,a4
    size_t ent_start = 0;
42000ae2:	4b81                	li	s7,0
        size_t midpoint = ent_count >> 1;
42000ae4:	00145493          	srl	s1,s0,0x1
    return (void *)((size_t)array + ent_size * index);
42000ae8:	03448933          	mul	s2,s1,s4
        int    res      = comparator(array_index_const(array, ent_size, midpoint), value);
42000aec:	85d6                	mv	a1,s5
42000aee:	01298533          	add	a0,s3,s2
42000af2:	9b02                	jalr	s6
        if (res > 0) {
42000af4:	02a05463          	blez	a0,42000b1c <array_binsearch+0x5a>
            // The value is to the left of the midpoint.
            ent_count = midpoint;
42000af8:	8426                	mv	s0,s1
    while (ent_count > 0) {
42000afa:	f46d                	bnez	s0,42000ae4 <array_binsearch+0x22>
42000afc:	5462                	lw	s0,56(sp)
42000afe:	54d2                	lw	s1,52(sp)
42000b00:	5942                	lw	s2,48(sp)
42000b02:	59b2                	lw	s3,44(sp)
42000b04:	5a22                	lw	s4,40(sp)
42000b06:	5a92                	lw	s5,36(sp)
42000b08:	5b02                	lw	s6,32(sp)
            return (array_binsearch_t){ent_start + midpoint, true};
        }
    }
    // The value was not found.
    return (array_binsearch_t){ent_start, false};
}
42000b0a:	50f2                	lw	ra,60(sp)
    return (array_binsearch_t){ent_start, false};
42000b0c:	4781                	li	a5,0
            return (array_binsearch_t){ent_start + midpoint, true};
42000b0e:	00f10623          	sb	a5,12(sp)
}
42000b12:	45b2                	lw	a1,12(sp)
42000b14:	855e                	mv	a0,s7
42000b16:	4bf2                	lw	s7,28(sp)
42000b18:	6121                	add	sp,sp,64
42000b1a:	8082                	ret
            ent_start += midpoint + 1;
42000b1c:	001b8793          	add	a5,s7,1
42000b20:	147d                	add	s0,s0,-1
    return (void *)((size_t)array + ent_size * index);
42000b22:	9952                	add	s2,s2,s4
        } else if (res < 0) {
42000b24:	c519                	beqz	a0,42000b32 <array_binsearch+0x70>
            ent_count -= midpoint + 1;
42000b26:	8c05                	sub	s0,s0,s1
            ent_start += midpoint + 1;
42000b28:	00978bb3          	add	s7,a5,s1
    return (void *)((size_t)array + ent_size * index);
42000b2c:	99ca                	add	s3,s3,s2
    while (ent_count > 0) {
42000b2e:	f85d                	bnez	s0,42000ae4 <array_binsearch+0x22>
42000b30:	b7f1                	j	42000afc <array_binsearch+0x3a>
            return (array_binsearch_t){ent_start + midpoint, true};
42000b32:	5462                	lw	s0,56(sp)
}
42000b34:	50f2                	lw	ra,60(sp)
            return (array_binsearch_t){ent_start + midpoint, true};
42000b36:	4785                	li	a5,1
42000b38:	9ba6                	add	s7,s7,s1
42000b3a:	00f10623          	sb	a5,12(sp)
}
42000b3e:	45b2                	lw	a1,12(sp)
42000b40:	54d2                	lw	s1,52(sp)
42000b42:	5942                	lw	s2,48(sp)
42000b44:	59b2                	lw	s3,44(sp)
42000b46:	5a22                	lw	s4,40(sp)
42000b48:	5a92                	lw	s5,36(sp)
42000b4a:	5b02                	lw	s6,32(sp)
42000b4c:	855e                	mv	a0,s7
42000b4e:	4bf2                	lw	s7,28(sp)
42000b50:	6121                	add	sp,sp,64
42000b52:	8082                	ret
    size_t ent_start = 0;
42000b54:	4b81                	li	s7,0
42000b56:	bf55                	j	42000b0a <array_binsearch+0x48>

42000b58 <array_sort_impl>:



// A recursive array sorting implementation.
void array_sort_impl(void *array, void *tmp, size_t ent_size, size_t ent_count, array_sort_comp_t comparator) {
42000b58:	715d                	add	sp,sp,-80
42000b5a:	c686                	sw	ra,76(sp)
    if (ent_count < 2) {
42000b5c:	4785                	li	a5,1
void array_sort_impl(void *array, void *tmp, size_t ent_size, size_t ent_count, array_sort_comp_t comparator) {
42000b5e:	c62e                	sw	a1,12(sp)
    if (ent_count < 2) {
42000b60:	0ed7ff63          	bgeu	a5,a3,42000c5e <array_sort_impl+0x106>
42000b64:	c4a2                	sw	s0,72(sp)
42000b66:	d65e                	sw	s7,44(sp)
42000b68:	d266                	sw	s9,36(sp)
42000b6a:	d06a                	sw	s10,32(sp)
42000b6c:	c2a6                	sw	s1,68(sp)
        // Limit case: 1 entry; no sorting needed.
        return;
    } else if (ent_count == 2) {
42000b6e:	4789                	li	a5,2
42000b70:	8d36                	mv	s10,a3
42000b72:	8baa                	mv	s7,a0
42000b74:	8432                	mv	s0,a2
42000b76:	8cba                	mv	s9,a4
42000b78:	0cf68863          	beq	a3,a5,42000c48 <array_sort_impl+0xf0>
        }
        return;
    }

    // Split array and sort recursively.
    array_sort_impl(array, tmp, ent_size, ent_count / 2, comparator);
42000b7c:	0016d493          	srl	s1,a3,0x1
42000b80:	86a6                	mv	a3,s1
42000b82:	da56                	sw	s5,52(sp)
42000b84:	d462                	sw	s8,40(sp)
42000b86:	c0ca                	sw	s2,64(sp)
42000b88:	de4e                	sw	s3,60(sp)
42000b8a:	dc52                	sw	s4,56(sp)
42000b8c:	d85a                	sw	s6,48(sp)
42000b8e:	37e9                	jal	42000b58 <array_sort_impl>
    return (void *)((size_t)array + ent_size * index);
42000b90:	02940533          	mul	a0,s0,s1
    array_sort_impl(array_index(array, ent_size, ent_count / 2), tmp, ent_size, ent_count - ent_count / 2, comparator);
42000b94:	4ab2                	lw	s5,12(sp)
42000b96:	409d0c33          	sub	s8,s10,s1
42000b9a:	8766                	mv	a4,s9
42000b9c:	86e2                	mv	a3,s8
42000b9e:	8622                	mv	a2,s0
42000ba0:	85d6                	mv	a1,s5
42000ba2:	955e                	add	a0,a0,s7
42000ba4:	3f55                	jal	42000b58 <array_sort_impl>
    size_t avl_a = ent_count / 2;
    size_t avl_b = ent_count - ent_count / 2;
    size_t i = 0, a = 0, b = 0;

    // Continually select the lower value from either array.
    for (; a < avl_a && b < avl_b; i++) {
42000ba6:	100c0a63          	beqz	s8,42000cba <array_sort_impl+0x162>
42000baa:	ce6e                	sw	s11,28(sp)
    size_t i = 0, a = 0, b = 0;
42000bac:	4a01                	li	s4,0
42000bae:	4981                	li	s3,0
42000bb0:	4b01                	li	s6,0
42000bb2:	a811                	j	42000bc6 <array_sort_impl+0x6e>
        void *a_ptr = array_index(array, ent_size, a);
        void *b_ptr = array_index(array, ent_size, avl_a + b);
        if (comparator(a_ptr, b_ptr) > 0) {
            mem_copy(array_index(tmp, ent_size, i), b_ptr, ent_size);
42000bb4:	7b8010ef          	jal	4200236c <mem_copy>
            b++;
42000bb8:	0985                	add	s3,s3,1
    for (; a < avl_a && b < avl_b; i++) {
42000bba:	0a05                	add	s4,s4,1
42000bbc:	029b7e63          	bgeu	s6,s1,42000bf8 <array_sort_impl+0xa0>
42000bc0:	9aa2                	add	s5,s5,s0
42000bc2:	0b89f163          	bgeu	s3,s8,42000c64 <array_sort_impl+0x10c>
        void *b_ptr = array_index(array, ent_size, avl_a + b);
42000bc6:	013485b3          	add	a1,s1,s3
    return (void *)((size_t)array + ent_size * index);
42000bca:	028585b3          	mul	a1,a1,s0
42000bce:	03640933          	mul	s2,s0,s6
42000bd2:	00bb8db3          	add	s11,s7,a1
        if (comparator(a_ptr, b_ptr) > 0) {
42000bd6:	85ee                	mv	a1,s11
    return (void *)((size_t)array + ent_size * index);
42000bd8:	995e                	add	s2,s2,s7
        if (comparator(a_ptr, b_ptr) > 0) {
42000bda:	854a                	mv	a0,s2
42000bdc:	9c82                	jalr	s9
42000bde:	87aa                	mv	a5,a0
            mem_copy(array_index(tmp, ent_size, i), b_ptr, ent_size);
42000be0:	8622                	mv	a2,s0
42000be2:	85ee                	mv	a1,s11
42000be4:	8556                	mv	a0,s5
        if (comparator(a_ptr, b_ptr) > 0) {
42000be6:	fcf047e3          	bgtz	a5,42000bb4 <array_sort_impl+0x5c>
        } else {
            mem_copy(array_index(tmp, ent_size, i), a_ptr, ent_size);
42000bea:	85ca                	mv	a1,s2
            a++;
42000bec:	0b05                	add	s6,s6,1
            mem_copy(array_index(tmp, ent_size, i), a_ptr, ent_size);
42000bee:	77e010ef          	jal	4200236c <mem_copy>
    for (; a < avl_a && b < avl_b; i++) {
42000bf2:	0a05                	add	s4,s4,1
42000bf4:	fc9b66e3          	bltu	s6,s1,42000bc0 <array_sort_impl+0x68>
42000bf8:	4df2                	lw	s11,28(sp)
    // Add any remainder.
    for (; a < avl_a; a++, i++) {
        void *a_ptr = array_index(array, ent_size, a);
        mem_copy(array_index(tmp, ent_size, i), a_ptr, ent_size);
    }
    for (; b < avl_b; b++, i++) {
42000bfa:	0389f463          	bgeu	s3,s8,42000c22 <array_sort_impl+0xca>
42000bfe:	94ce                	add	s1,s1,s3
42000c00:	03440a33          	mul	s4,s0,s4
42000c04:	47b2                	lw	a5,12(sp)
42000c06:	028484b3          	mul	s1,s1,s0
42000c0a:	9a3e                	add	s4,s4,a5
42000c0c:	94de                	add	s1,s1,s7
        void *b_ptr = array_index(array, ent_size, avl_a + b);
        mem_copy(array_index(tmp, ent_size, i), b_ptr, ent_size);
42000c0e:	85a6                	mv	a1,s1
42000c10:	8552                	mv	a0,s4
42000c12:	8622                	mv	a2,s0
    for (; b < avl_b; b++, i++) {
42000c14:	0985                	add	s3,s3,1
        mem_copy(array_index(tmp, ent_size, i), b_ptr, ent_size);
42000c16:	756010ef          	jal	4200236c <mem_copy>
    for (; b < avl_b; b++, i++) {
42000c1a:	9a22                	add	s4,s4,s0
42000c1c:	94a2                	add	s1,s1,s0
42000c1e:	ff3c18e3          	bne	s8,s3,42000c0e <array_sort_impl+0xb6>
    }

    // Copy it all back into the output.
    mem_copy(array, tmp, ent_size * ent_count);
42000c22:	028d0633          	mul	a2,s10,s0
42000c26:	4426                	lw	s0,72(sp)
42000c28:	45b2                	lw	a1,12(sp)
42000c2a:	4496                	lw	s1,68(sp)
42000c2c:	4906                	lw	s2,64(sp)
42000c2e:	59f2                	lw	s3,60(sp)
42000c30:	5a62                	lw	s4,56(sp)
42000c32:	5ad2                	lw	s5,52(sp)
42000c34:	5b42                	lw	s6,48(sp)
42000c36:	5c22                	lw	s8,40(sp)
42000c38:	5c92                	lw	s9,36(sp)
42000c3a:	5d02                	lw	s10,32(sp)
}
42000c3c:	40b6                	lw	ra,76(sp)
    mem_copy(array, tmp, ent_size * ent_count);
42000c3e:	855e                	mv	a0,s7
42000c40:	5bb2                	lw	s7,44(sp)
}
42000c42:	6161                	add	sp,sp,80
    mem_copy(array, tmp, ent_size * ent_count);
42000c44:	7280106f          	j	4200236c <mem_copy>
        if (comparator(array, (void const *)((size_t)array + ent_size)) > 0) {
42000c48:	00a604b3          	add	s1,a2,a0
42000c4c:	85a6                	mv	a1,s1
42000c4e:	9702                	jalr	a4
42000c50:	04a04963          	bgtz	a0,42000ca2 <array_sort_impl+0x14a>
42000c54:	4426                	lw	s0,72(sp)
42000c56:	4496                	lw	s1,68(sp)
42000c58:	5bb2                	lw	s7,44(sp)
42000c5a:	5c92                	lw	s9,36(sp)
42000c5c:	5d02                	lw	s10,32(sp)
}
42000c5e:	40b6                	lw	ra,76(sp)
42000c60:	6161                	add	sp,sp,80
42000c62:	8082                	ret
42000c64:	4df2                	lw	s11,28(sp)
42000c66:	03440ab3          	mul	s5,s0,s4
42000c6a:	47b2                	lw	a5,12(sp)
    return (void *)((size_t)array + ent_size * index);
42000c6c:	8cda                	mv	s9,s6
42000c6e:	03640933          	mul	s2,s0,s6
42000c72:	9abe                	add	s5,s5,a5
42000c74:	995e                	add	s2,s2,s7
        mem_copy(array_index(tmp, ent_size, i), a_ptr, ent_size);
42000c76:	85ca                	mv	a1,s2
42000c78:	8556                	mv	a0,s5
42000c7a:	8622                	mv	a2,s0
    for (; a < avl_a; a++, i++) {
42000c7c:	0c85                	add	s9,s9,1
        mem_copy(array_index(tmp, ent_size, i), a_ptr, ent_size);
42000c7e:	6ee010ef          	jal	4200236c <mem_copy>
    for (; a < avl_a; a++, i++) {
42000c82:	9aa2                	add	s5,s5,s0
42000c84:	9922                	add	s2,s2,s0
42000c86:	fe9ce8e3          	bltu	s9,s1,42000c76 <array_sort_impl+0x11e>
42000c8a:	001b0793          	add	a5,s6,1
42000c8e:	0a05                	add	s4,s4,1
42000c90:	4701                	li	a4,0
42000c92:	00f4e663          	bltu	s1,a5,42000c9e <array_sort_impl+0x146>
42000c96:	fff48713          	add	a4,s1,-1
42000c9a:	41670733          	sub	a4,a4,s6
42000c9e:	9a3a                	add	s4,s4,a4
42000ca0:	bfa9                	j	42000bfa <array_sort_impl+0xa2>
    mem_swap(array_index(array, ent_size, a), array_index(array, ent_size, b), ent_size);
42000ca2:	8622                	mv	a2,s0
42000ca4:	4426                	lw	s0,72(sp)
42000ca6:	5c92                	lw	s9,36(sp)
42000ca8:	5d02                	lw	s10,32(sp)
}
42000caa:	40b6                	lw	ra,76(sp)
    mem_swap(array_index(array, ent_size, a), array_index(array, ent_size, b), ent_size);
42000cac:	85a6                	mv	a1,s1
42000cae:	855e                	mv	a0,s7
42000cb0:	4496                	lw	s1,68(sp)
42000cb2:	5bb2                	lw	s7,44(sp)
}
42000cb4:	6161                	add	sp,sp,80
    mem_swap(array_index(array, ent_size, a), array_index(array, ent_size, b), ent_size);
42000cb6:	1890106f          	j	4200263e <mem_swap>
    size_t i = 0, a = 0, b = 0;
42000cba:	4981                	li	s3,0
42000cbc:	4a01                	li	s4,0
42000cbe:	4b01                	li	s6,0
42000cc0:	b75d                	j	42000c66 <array_sort_impl+0x10e>

42000cc2 <array_sort>:

// Sort a contiguous array given a comparator function.
// The array is sorted into ascending order.
void array_sort(void *array, size_t ent_size, size_t ent_count, array_sort_comp_t comparator) {
    if (ent_count <= 1) {
42000cc2:	4785                	li	a5,1
42000cc4:	06c7f363          	bgeu	a5,a2,42000d2a <array_sort+0x68>
void array_sort(void *array, size_t ent_size, size_t ent_count, array_sort_comp_t comparator) {
42000cc8:	1101                	add	sp,sp,-32
42000cca:	cc22                	sw	s0,24(sp)
42000ccc:	ca26                	sw	s1,20(sp)
42000cce:	c84a                	sw	s2,16(sp)
42000cd0:	c64e                	sw	s3,12(sp)
42000cd2:	ce06                	sw	ra,28(sp)
        // Edge case: 0 or 1 entries; no sorting needed.
    } else if (ent_count == 2) {
42000cd4:	4789                	li	a5,2
42000cd6:	8432                	mv	s0,a2
42000cd8:	892a                	mv	s2,a0
42000cda:	84ae                	mv	s1,a1
42000cdc:	89b6                	mv	s3,a3
42000cde:	00f61f63          	bne	a2,a5,42000cfc <array_sort+0x3a>
        // Edge case: 2 entries; single compare.
        if (comparator(array, (void const *)((size_t)array + ent_size)) > 0) {
42000ce2:	00b50433          	add	s0,a0,a1
42000ce6:	85a2                	mv	a1,s0
42000ce8:	9682                	jalr	a3
42000cea:	04a04163          	bgtz	a0,42000d2c <array_sort+0x6a>
        void *mem = malloc(ent_size * ent_count);
        assert_always(mem != NULL);
        array_sort_impl(array, mem, ent_size, ent_count, comparator);
        free(mem);
    }
}
42000cee:	40f2                	lw	ra,28(sp)
42000cf0:	4462                	lw	s0,24(sp)
42000cf2:	44d2                	lw	s1,20(sp)
42000cf4:	4942                	lw	s2,16(sp)
42000cf6:	49b2                	lw	s3,12(sp)
42000cf8:	6105                	add	sp,sp,32
42000cfa:	8082                	ret
        void *mem = malloc(ent_size * ent_count);
42000cfc:	02b60533          	mul	a0,a2,a1
42000d00:	c452                	sw	s4,8(sp)
42000d02:	44f0c0ef          	jal	4200d950 <malloc>
42000d06:	8a2a                	mv	s4,a0
        assert_always(mem != NULL);
42000d08:	cd0d                	beqz	a0,42000d42 <array_sort+0x80>
        array_sort_impl(array, mem, ent_size, ent_count, comparator);
42000d0a:	874e                	mv	a4,s3
42000d0c:	86a2                	mv	a3,s0
42000d0e:	8626                	mv	a2,s1
42000d10:	85aa                	mv	a1,a0
42000d12:	854a                	mv	a0,s2
42000d14:	3591                	jal	42000b58 <array_sort_impl>
}
42000d16:	4462                	lw	s0,24(sp)
42000d18:	40f2                	lw	ra,28(sp)
42000d1a:	44d2                	lw	s1,20(sp)
42000d1c:	4942                	lw	s2,16(sp)
42000d1e:	49b2                	lw	s3,12(sp)
        free(mem);
42000d20:	8552                	mv	a0,s4
42000d22:	4a22                	lw	s4,8(sp)
}
42000d24:	6105                	add	sp,sp,32
        free(mem);
42000d26:	6370c06f          	j	4200db5c <free>
42000d2a:	8082                	ret
    mem_swap(array_index(array, ent_size, a), array_index(array, ent_size, b), ent_size);
42000d2c:	85a2                	mv	a1,s0
}
42000d2e:	4462                	lw	s0,24(sp)
42000d30:	40f2                	lw	ra,28(sp)
42000d32:	49b2                	lw	s3,12(sp)
    mem_swap(array_index(array, ent_size, a), array_index(array, ent_size, b), ent_size);
42000d34:	8626                	mv	a2,s1
42000d36:	854a                	mv	a0,s2
}
42000d38:	44d2                	lw	s1,20(sp)
42000d3a:	4942                	lw	s2,16(sp)
42000d3c:	6105                	add	sp,sp,32
    mem_swap(array_index(array, ent_size, a), array_index(array, ent_size, b), ent_size);
42000d3e:	1010106f          	j	4200263e <mem_swap>
        assert_always(mem != NULL);
42000d42:	420175b7          	lui	a1,0x42017
42000d46:	e3058593          	add	a1,a1,-464 # 42016e30 <hextab+0x164>
42000d4a:	50a020ef          	jal	42003254 <logk>
42000d4e:	9002                	ebreak

42000d50 <badge_eloc_get_name>:



// Get the name of a badge_eloc_t.
char const *badge_eloc_get_name(badge_eloc_t eloc) {
    return (eloc < 0 || eloc >= _badge_eloc_num) ? "unknown location" : badge_eloc_name[eloc];
42000d50:	47bd                	li	a5,15
42000d52:	02a7e563          	bltu	a5,a0,42000d7c <badge_eloc_get_name+0x2c>
42000d56:	47c1                	li	a5,16
42000d58:	02f57a63          	bgeu	a0,a5,42000d8c <badge_eloc_get_name+0x3c>
42000d5c:	050a                	sll	a0,a0,0x2
42000d5e:	00018793          	mv	a5,gp
42000d62:	00450713          	add	a4,a0,4
42000d66:	04000693          	li	a3,64
42000d6a:	00a78633          	add	a2,a5,a0
42000d6e:	00e6ec63          	bltu	a3,a4,42000d86 <badge_eloc_get_name+0x36>
42000d72:	953e                	add	a0,a0,a5
42000d74:	00f56c63          	bltu	a0,a5,42000d8c <badge_eloc_get_name+0x3c>
42000d78:	4108                	lw	a0,0(a0)
42000d7a:	8082                	ret
42000d7c:	42017537          	lui	a0,0x42017
42000d80:	ea050513          	add	a0,a0,-352 # 42016ea0 <hextab+0x1d4>
}
42000d84:	8082                	ret
    return (eloc < 0 || eloc >= _badge_eloc_num) ? "unknown location" : badge_eloc_name[eloc];
42000d86:	9732                	add	a4,a4,a2
42000d88:	fec765e3          	bltu	a4,a2,42000d72 <badge_eloc_get_name+0x22>
42000d8c:	9002                	ebreak

42000d8e <badge_ecause_get_name>:

// Get the name of a badge_ecause_t.
char const *badge_ecause_get_name(badge_ecause_t ecause) {
    return (ecause < 0 || ecause >= _badge_ecause_num) ? "unknown cause" : badge_ecause_name[ecause];
42000d8e:	47f5                	li	a5,29
42000d90:	02a7e963          	bltu	a5,a0,42000dc2 <badge_ecause_get_name+0x34>
42000d94:	47f9                	li	a5,30
42000d96:	02f57e63          	bgeu	a0,a5,42000dd2 <badge_ecause_get_name+0x44>
42000d9a:	050a                	sll	a0,a0,0x2
42000d9c:	00018793          	mv	a5,gp
42000da0:	04078713          	add	a4,a5,64
42000da4:	00450693          	add	a3,a0,4
42000da8:	07800613          	li	a2,120
42000dac:	00a705b3          	add	a1,a4,a0
42000db0:	00d66e63          	bltu	a2,a3,42000dcc <badge_ecause_get_name+0x3e>
42000db4:	00a706b3          	add	a3,a4,a0
42000db8:	00e6ed63          	bltu	a3,a4,42000dd2 <badge_ecause_get_name+0x44>
42000dbc:	97aa                	add	a5,a5,a0
42000dbe:	43a8                	lw	a0,64(a5)
42000dc0:	8082                	ret
42000dc2:	42017537          	lui	a0,0x42017
42000dc6:	eb450513          	add	a0,a0,-332 # 42016eb4 <hextab+0x1e8>
}
42000dca:	8082                	ret
    return (ecause < 0 || ecause >= _badge_ecause_num) ? "unknown cause" : badge_ecause_name[ecause];
42000dcc:	96ae                	add	a3,a3,a1
42000dce:	feb6e3e3          	bltu	a3,a1,42000db4 <badge_ecause_get_name+0x26>
42000dd2:	9002                	ebreak

42000dd4 <format_str_parse_mult>:

    return false;
}

// Try to parse a multiples specifier.
static bool format_str_parse_mult(char const *substr, size_t length, format_str_mult_t *mult_out) {
42000dd4:	1141                	add	sp,sp,-16
42000dd6:	c226                	sw	s1,4(sp)
42000dd8:	c606                	sw	ra,12(sp)
    if ((length == 5 && cstr_prefix_equals_case(substr, "array", 5)) ||
42000dda:	4795                	li	a5,5
static bool format_str_parse_mult(char const *substr, size_t length, format_str_mult_t *mult_out) {
42000ddc:	84b2                	mv	s1,a2
    if ((length == 5 && cstr_prefix_equals_case(substr, "array", 5)) ||
42000dde:	04f58c63          	beq	a1,a5,42000e36 <format_str_parse_mult+0x62>
42000de2:	478d                	li	a5,3
42000de4:	04f59063          	bne	a1,a5,42000e24 <format_str_parse_mult+0x50>
        (length == 3 && cstr_prefix_equals_case(substr, "arr", 3))) {
42000de8:	420175b7          	lui	a1,0x42017
42000dec:	460d                	li	a2,3
42000dee:	17c58593          	add	a1,a1,380 # 4201717c <hextab+0x4b0>
42000df2:	c422                	sw	s0,8(sp)
42000df4:	842a                	mv	s0,a0
42000df6:	1d4010ef          	jal	42001fca <cstr_prefix_equals_case>
42000dfa:	e935                	bnez	a0,42000e6e <format_str_parse_mult+0x9a>
        // Pointer+length array.
        *mult_out = FMT_MULT_ARR;
        return true;

    } else if ((length == 4 && cstr_prefix_equals_case(substr, "null", 4)) || (length == 3 && cstr_prefix_equals_case(substr, "nul", 3))) {
42000dfc:	420175b7          	lui	a1,0x42017
42000e00:	8522                	mv	a0,s0
42000e02:	460d                	li	a2,3
42000e04:	18858593          	add	a1,a1,392 # 42017188 <hextab+0x4bc>
42000e08:	1c2010ef          	jal	42001fca <cstr_prefix_equals_case>
42000e0c:	87aa                	mv	a5,a0
42000e0e:	4422                	lw	s0,8(sp)
42000e10:	cd11                	beqz	a0,42000e2c <format_str_parse_mult+0x58>
        // Null-terminated array.
        *mult_out = FMT_MULT_NUL;
42000e12:	c0a5                	beqz	s1,42000e72 <format_str_parse_mult+0x9e>
42000e14:	4785                	li	a5,1
42000e16:	c09c                	sw	a5,0(s1)
        return true;
42000e18:	4785                	li	a5,1
        return true;
    }

    return false;
}
42000e1a:	40b2                	lw	ra,12(sp)
42000e1c:	4492                	lw	s1,4(sp)
42000e1e:	853e                	mv	a0,a5
42000e20:	0141                	add	sp,sp,16
42000e22:	8082                	ret
    } else if ((length == 4 && cstr_prefix_equals_case(substr, "null", 4)) || (length == 3 && cstr_prefix_equals_case(substr, "nul", 3))) {
42000e24:	4711                	li	a4,4
    return false;
42000e26:	4781                	li	a5,0
    } else if ((length == 4 && cstr_prefix_equals_case(substr, "null", 4)) || (length == 3 && cstr_prefix_equals_case(substr, "nul", 3))) {
42000e28:	02e58563          	beq	a1,a4,42000e52 <format_str_parse_mult+0x7e>
}
42000e2c:	40b2                	lw	ra,12(sp)
42000e2e:	4492                	lw	s1,4(sp)
42000e30:	853e                	mv	a0,a5
42000e32:	0141                	add	sp,sp,16
42000e34:	8082                	ret
    if ((length == 5 && cstr_prefix_equals_case(substr, "array", 5)) ||
42000e36:	420175b7          	lui	a1,0x42017
42000e3a:	4615                	li	a2,5
42000e3c:	17458593          	add	a1,a1,372 # 42017174 <hextab+0x4a8>
42000e40:	18a010ef          	jal	42001fca <cstr_prefix_equals_case>
42000e44:	87aa                	mv	a5,a0
42000e46:	d17d                	beqz	a0,42000e2c <format_str_parse_mult+0x58>
        *mult_out = FMT_MULT_ARR;
42000e48:	c48d                	beqz	s1,42000e72 <format_str_parse_mult+0x9e>
42000e4a:	4789                	li	a5,2
42000e4c:	c09c                	sw	a5,0(s1)
        return true;
42000e4e:	4785                	li	a5,1
42000e50:	b7e9                	j	42000e1a <format_str_parse_mult+0x46>
    } else if ((length == 4 && cstr_prefix_equals_case(substr, "null", 4)) || (length == 3 && cstr_prefix_equals_case(substr, "nul", 3))) {
42000e52:	420175b7          	lui	a1,0x42017
42000e56:	4611                	li	a2,4
42000e58:	18058593          	add	a1,a1,384 # 42017180 <hextab+0x4b4>
42000e5c:	16e010ef          	jal	42001fca <cstr_prefix_equals_case>
42000e60:	87aa                	mv	a5,a0
42000e62:	f945                	bnez	a0,42000e12 <format_str_parse_mult+0x3e>
}
42000e64:	40b2                	lw	ra,12(sp)
42000e66:	4492                	lw	s1,4(sp)
42000e68:	853e                	mv	a0,a5
42000e6a:	0141                	add	sp,sp,16
42000e6c:	8082                	ret
42000e6e:	4422                	lw	s0,8(sp)
42000e70:	bfe1                	j	42000e48 <format_str_parse_mult+0x74>
42000e72:	c422                	sw	s0,8(sp)
        *mult_out = FMT_MULT_NUL;
42000e74:	9002                	ebreak

42000e76 <format_str_output>:
    bool              lowercase,
    long long         value,
    format_str_cb_t   callback,
    void             *cookie
) {
    char const hextab[] = "0123456789ABCDEF";
42000e76:	42017337          	lui	t1,0x42017
42000e7a:	18c30313          	add	t1,t1,396 # 4201718c <hextab+0x4c0>
42000e7e:	00032283          	lw	t0,0(t1)
42000e82:	00432f83          	lw	t6,4(t1)
42000e86:	00832f03          	lw	t5,8(t1)
42000e8a:	00c32e83          	lw	t4,12(t1)
42000e8e:	01034e03          	lbu	t3,16(t1)
) {
42000e92:	7139                	add	sp,sp,-64
42000e94:	da26                	sw	s1,52(sp)
42000e96:	d84a                	sw	s2,48(sp)
42000e98:	832e                	mv	t1,a1
42000e9a:	de06                	sw	ra,60(sp)
    char const hextab[] = "0123456789ABCDEF";
42000e9c:	c216                	sw	t0,4(sp)
42000e9e:	c47e                	sw	t6,8(sp)
42000ea0:	c67a                	sw	t5,12(sp)
42000ea2:	c876                	sw	t4,16(sp)
42000ea4:	01c10a23          	sb	t3,20(sp)

    if (spec == FMT_SPEC_CHAR) {
42000ea8:	458d                	li	a1,3
) {
42000eaa:	84c2                	mv	s1,a6
42000eac:	8946                	mv	s2,a7
    if (spec == FMT_SPEC_CHAR) {
42000eae:	02b30063          	beq	t1,a1,42000ece <format_str_output+0x58>
        char c = value;
        return callback(&c, 1, cookie);

    } else if (spec == FMT_SPEC_HEX) {
42000eb2:	4805                	li	a6,1
42000eb4:	07030763          	beq	t1,a6,42000f22 <format_str_output+0xac>
            numbuf[i]   = hextab[value & 15] | mask;
            value     >>= 4;
        }
        return callback(numbuf, n_digit, cookie);

    } else if (spec == FMT_SPEC_OCTAL) {
42000eb8:	4689                	li	a3,2
42000eba:	02d30563          	beq	t1,a3,42000ee4 <format_str_output+0x6e>
            n_digit = uint_to_cstr_packed(value, numbuf, sizeof(numbuf));
        }
        return callback(numbuf, n_digit, cookie);
    }

    return false;
42000ebe:	4501                	li	a0,0
    } else if (spec == FMT_SPEC_DEC) {
42000ec0:	02030e63          	beqz	t1,42000efc <format_str_output+0x86>
}
42000ec4:	50f2                	lw	ra,60(sp)
42000ec6:	54d2                	lw	s1,52(sp)
42000ec8:	5942                	lw	s2,48(sp)
42000eca:	6121                	add	sp,sp,64
42000ecc:	8082                	ret
        return callback(&c, 1, cookie);
42000ece:	0828                	add	a0,sp,24
        char c = value;
42000ed0:	00e10c23          	sb	a4,24(sp)
        return callback(&c, 1, cookie);
42000ed4:	8646                	mv	a2,a7
42000ed6:	4585                	li	a1,1
42000ed8:	9802                	jalr	a6
}
42000eda:	50f2                	lw	ra,60(sp)
42000edc:	54d2                	lw	s1,52(sp)
42000ede:	5942                	lw	s2,48(sp)
42000ee0:	6121                	add	sp,sp,64
42000ee2:	8082                	ret
42000ee4:	dc22                	sw	s0,56(sp)
        int  n_digit = (int)(fmt_type_size(type) * 8 - 1) / 3 + 1;
42000ee6:	c161                	beqz	a0,42000fa6 <format_str_output+0x130>
42000ee8:	11050463          	beq	a0,a6,42000ff0 <format_str_output+0x17a>
42000eec:	1579                	add	a0,a0,-2
42000eee:	45d9                	li	a1,22
42000ef0:	46d5                	li	a3,21
42000ef2:	0aa86c63          	bltu	a6,a0,42000faa <format_str_output+0x134>
42000ef6:	45ad                	li	a1,11
42000ef8:	46a9                	li	a3,10
42000efa:	a845                	j	42000faa <format_str_output+0x134>
42000efc:	dc22                	sw	s0,56(sp)
            n_digit = int_to_cstr_packed(value, numbuf, sizeof(numbuf));
42000efe:	46d5                	li	a3,21
42000f00:	0820                	add	s0,sp,24
        if (is_signed) {
42000f02:	ca41                	beqz	a2,42000f92 <format_str_output+0x11c>
            n_digit = int_to_cstr_packed(value, numbuf, sizeof(numbuf));
42000f04:	85be                	mv	a1,a5
42000f06:	8622                	mv	a2,s0
42000f08:	853a                	mv	a0,a4
42000f0a:	23e030ef          	jal	42004148 <int_to_cstr_packed>
42000f0e:	85aa                	mv	a1,a0
        return callback(numbuf, n_digit, cookie);
42000f10:	864a                	mv	a2,s2
42000f12:	8522                	mv	a0,s0
42000f14:	9482                	jalr	s1
}
42000f16:	50f2                	lw	ra,60(sp)
        return callback(numbuf, n_digit, cookie);
42000f18:	5462                	lw	s0,56(sp)
}
42000f1a:	54d2                	lw	s1,52(sp)
42000f1c:	5942                	lw	s2,48(sp)
42000f1e:	6121                	add	sp,sp,64
42000f20:	8082                	ret
        char mask    = lowercase ? 0x20 : 0;
42000f22:	0696                	sll	a3,a3,0x5
42000f24:	dc22                	sw	s0,56(sp)
42000f26:	0ff6fe13          	zext.b	t3,a3
        int  n_digit = fmt_type_size(type) * 2;
42000f2a:	c93d                	beqz	a0,42000fa0 <format_str_output+0x12a>
42000f2c:	0c650863          	beq	a0,t1,42000ffc <format_str_output+0x186>
42000f30:	1579                	add	a0,a0,-2
42000f32:	46bd                	li	a3,15
42000f34:	45c1                	li	a1,16
42000f36:	0ca37063          	bgeu	t1,a0,42000ff6 <format_str_output+0x180>
        for (int i = n_digit - 1; i >= 0; i--) {
42000f3a:	0820                	add	s0,sp,24
42000f3c:	00d40333          	add	t1,s0,a3
42000f40:	00410813          	add	a6,sp,4
            numbuf[i]   = hextab[value & 15] | mask;
42000f44:	4641                	li	a2,16
        for (int i = n_digit - 1; i >= 0; i--) {
42000f46:	5efd                	li	t4,-1
42000f48:	a835                	j	42000f84 <format_str_output+0x10e>
            numbuf[i]   = hextab[value & 15] | mask;
42000f4a:	03050513          	add	a0,a0,48
42000f4e:	950a                	add	a0,a0,sp
42000f50:	fd454503          	lbu	a0,-44(a0)
42000f54:	02c6fe63          	bgeu	a3,a2,42000f90 <format_str_output+0x11a>
42000f58:	00168893          	add	a7,a3,1
42000f5c:	01c56533          	or	a0,a0,t3
42000f60:	0b166563          	bltu	a2,a7,4200100a <format_str_output+0x194>
42000f64:	00d408b3          	add	a7,s0,a3
42000f68:	0288e463          	bltu	a7,s0,42000f90 <format_str_output+0x11a>
            value     >>= 4;
42000f6c:	01c79893          	sll	a7,a5,0x1c
            numbuf[i]   = hextab[value & 15] | mask;
42000f70:	00a30023          	sb	a0,0(t1)
            value     >>= 4;
42000f74:	8311                	srl	a4,a4,0x4
        for (int i = n_digit - 1; i >= 0; i--) {
42000f76:	16fd                	add	a3,a3,-1
            value     >>= 4;
42000f78:	00e8e733          	or	a4,a7,a4
42000f7c:	8791                	sra	a5,a5,0x4
        for (int i = n_digit - 1; i >= 0; i--) {
42000f7e:	137d                	add	t1,t1,-1
42000f80:	f9d688e3          	beq	a3,t4,42000f10 <format_str_output+0x9a>
            numbuf[i]   = hextab[value & 15] | mask;
42000f84:	00f77513          	and	a0,a4,15
42000f88:	00a808b3          	add	a7,a6,a0
42000f8c:	fb08ffe3          	bgeu	a7,a6,42000f4a <format_str_output+0xd4>
            numbuf[i]   = '0' | (value & 7);
42000f90:	9002                	ebreak
            n_digit = uint_to_cstr_packed(value, numbuf, sizeof(numbuf));
42000f92:	85be                	mv	a1,a5
42000f94:	8622                	mv	a2,s0
42000f96:	853a                	mv	a0,a4
42000f98:	2a6030ef          	jal	4200423e <uint_to_cstr_packed>
42000f9c:	85aa                	mv	a1,a0
42000f9e:	bf8d                	j	42000f10 <format_str_output+0x9a>
42000fa0:	4685                	li	a3,1
42000fa2:	4589                	li	a1,2
42000fa4:	bf59                	j	42000f3a <format_str_output+0xc4>
42000fa6:	458d                	li	a1,3
42000fa8:	4689                	li	a3,2
        for (int i = n_digit - 1; i >= 0; i--) {
42000faa:	0820                	add	s0,sp,24
42000fac:	00d40633          	add	a2,s0,a3
            numbuf[i]   = '0' | (value & 7);
42000fb0:	4859                	li	a6,22
        for (int i = n_digit - 1; i >= 0; i--) {
42000fb2:	537d                	li	t1,-1
42000fb4:	a03d                	j	42000fe2 <format_str_output+0x16c>
42000fb6:	00168893          	add	a7,a3,1
            numbuf[i]   = '0' | (value & 7);
42000fba:	0ff57513          	zext.b	a0,a0
42000fbe:	05186263          	bltu	a6,a7,42001002 <format_str_output+0x18c>
42000fc2:	00d408b3          	add	a7,s0,a3
42000fc6:	fc88e5e3          	bltu	a7,s0,42000f90 <format_str_output+0x11a>
            value     >>= 3;
42000fca:	01d79893          	sll	a7,a5,0x1d
            numbuf[i]   = '0' | (value & 7);
42000fce:	00a60023          	sb	a0,0(a2)
            value     >>= 3;
42000fd2:	830d                	srl	a4,a4,0x3
        for (int i = n_digit - 1; i >= 0; i--) {
42000fd4:	16fd                	add	a3,a3,-1
            value     >>= 3;
42000fd6:	00e8e733          	or	a4,a7,a4
42000fda:	878d                	sra	a5,a5,0x3
        for (int i = n_digit - 1; i >= 0; i--) {
42000fdc:	167d                	add	a2,a2,-1
42000fde:	f26689e3          	beq	a3,t1,42000f10 <format_str_output+0x9a>
            numbuf[i]   = '0' | (value & 7);
42000fe2:	00777513          	and	a0,a4,7
42000fe6:	03056513          	or	a0,a0,48
42000fea:	fd06e6e3          	bltu	a3,a6,42000fb6 <format_str_output+0x140>
42000fee:	9002                	ebreak
42000ff0:	4599                	li	a1,6
42000ff2:	4695                	li	a3,5
42000ff4:	bf5d                	j	42000faa <format_str_output+0x134>
        int  n_digit = fmt_type_size(type) * 2;
42000ff6:	469d                	li	a3,7
42000ff8:	45a1                	li	a1,8
42000ffa:	b781                	j	42000f3a <format_str_output+0xc4>
42000ffc:	468d                	li	a3,3
42000ffe:	4591                	li	a1,4
42001000:	bf2d                	j	42000f3a <format_str_output+0xc4>
            numbuf[i]   = '0' | (value & 7);
42001002:	98b2                	add	a7,a7,a2
42001004:	fac8efe3          	bltu	a7,a2,42000fc2 <format_str_output+0x14c>
42001008:	9002                	ebreak
            numbuf[i]   = hextab[value & 15] | mask;
4200100a:	989a                	add	a7,a7,t1
4200100c:	f468ece3          	bltu	a7,t1,42000f64 <format_str_output+0xee>
            numbuf[i]   = '0' | (value & 7);
42001010:	9002                	ebreak

42001012 <format_str_va>:

// Format a string and output characters via callback.
bool format_str_va(char const *msg, size_t length, format_str_cb_t callback, void *cookie, va_list vararg) {
42001012:	7159                	add	sp,sp,-112
42001014:	d686                	sw	ra,108(sp)
42001016:	c236                	sw	a3,4(sp)
    // Current read index.
    size_t i = 0;

    while (i < length) {
42001018:	6e058263          	beqz	a1,420016fc <format_str_va+0x6ea>

                // Get the format specifier.
                if (!sublen)
                    goto illegal_format;
                lowercase = substr[0] & 0x20;
                switch (lower(substr[0])) {
4200101c:	420177b7          	lui	a5,0x42017
42001020:	a3478793          	add	a5,a5,-1484 # 42016a34 <filerom_0+0x29b0>
42001024:	d4a2                	sw	s0,104(sp)
42001026:	d0ca                	sw	s2,96(sp)
42001028:	cece                	sw	s3,92(sp)
4200102a:	ccd2                	sw	s4,88(sp)
4200102c:	c8da                	sw	s6,80(sp)
4200102e:	c2e6                	sw	s9,68(sp)
42001030:	d2a6                	sw	s1,100(sp)
42001032:	cad6                	sw	s5,84(sp)
42001034:	c6de                	sw	s7,76(sp)
42001036:	c4e2                	sw	s8,72(sp)
42001038:	c0ea                	sw	s10,64(sp)
4200103a:	de6e                	sw	s11,60(sp)
4200103c:	8a2e                	mv	s4,a1
4200103e:	89aa                	mv	s3,a0
42001040:	8932                	mv	s2,a2
42001042:	8b3a                	mv	s6,a4
42001044:	4c81                	li	s9,0
        if (msg[i] == '%' && i + 1 < length && msg[i + 1] == '%') {
42001046:	02500413          	li	s0,37
                switch (lower(substr[0])) {
4200104a:	c63e                	sw	a5,12(sp)
        if (msg[i] == '%' && i + 1 < length && msg[i + 1] == '%') {
4200104c:	01998d33          	add	s10,s3,s9
42001050:	080cc263          	bltz	s9,420010d4 <format_str_va+0xc2>
42001054:	093d6263          	bltu	s10,s3,420010d8 <format_str_va+0xc6>
42001058:	440d02e3          	beqz	s10,42001c9c <format_str_va+0xc8a>
4200105c:	000d4783          	lbu	a5,0(s10)
42001060:	08878063          	beq	a5,s0,420010e0 <format_str_va+0xce>
        } else if (msg[i] == '%' && i + 3 < length) {
42001064:	060ccb63          	bltz	s9,420010da <format_str_va+0xc8>
42001068:	073d6b63          	bltu	s10,s3,420010de <format_str_va+0xcc>

            } else if (mult == FMT_MULT_ARR) {
                // Get pointer.
                void const *ptr    = va_arg(vararg, void const *);
                // Get length.
                size_t      length = va_arg(vararg, size_t);
4200106c:	84e6                	mv	s1,s9
4200106e:	87ea                	mv	a5,s10
            i = fmt_end + 1;

        } else {
            // Normal text.
            size_t start = i;
            while (i < length && msg[i] != '%') i++;
42001070:	0344f463          	bgeu	s1,s4,42001098 <format_str_va+0x86>
42001074:	00998733          	add	a4,s3,s1
42001078:	0404cb63          	bltz	s1,420010ce <format_str_va+0xbc>
4200107c:	05376b63          	bltu	a4,s3,420010d2 <format_str_va+0xc0>
42001080:	400785e3          	beqz	a5,42001c8a <format_str_va+0xc78>
42001084:	0007c703          	lbu	a4,0(a5)
42001088:	00148693          	add	a3,s1,1
4200108c:	0785                	add	a5,a5,1
4200108e:	2e870d63          	beq	a4,s0,42001388 <format_str_va+0x376>
42001092:	84b6                	mv	s1,a3
42001094:	ff44e0e3          	bltu	s1,s4,42001074 <format_str_va+0x62>
            if (!callback(&msg[start], i - start, cookie))
42001098:	2e0cc563          	bltz	s9,42001382 <format_str_va+0x370>
4200109c:	2f3d6563          	bltu	s10,s3,42001386 <format_str_va+0x374>
420010a0:	4612                	lw	a2,4(sp)
420010a2:	419485b3          	sub	a1,s1,s9
420010a6:	856a                	mv	a0,s10
420010a8:	9902                	jalr	s2
420010aa:	62051d63          	bnez	a0,420016e4 <format_str_va+0x6d2>
420010ae:	5426                	lw	s0,104(sp)
    return true;

// When the format specifier is malformed, the rest is printed verbatim.
illegal_format:
    return callback(&msg[i], length - i, cookie);
}
420010b0:	50b6                	lw	ra,108(sp)
420010b2:	5496                	lw	s1,100(sp)
420010b4:	5906                	lw	s2,96(sp)
420010b6:	49f6                	lw	s3,92(sp)
420010b8:	4a66                	lw	s4,88(sp)
420010ba:	4ad6                	lw	s5,84(sp)
420010bc:	4b46                	lw	s6,80(sp)
420010be:	4bb6                	lw	s7,76(sp)
420010c0:	4c26                	lw	s8,72(sp)
420010c2:	4c96                	lw	s9,68(sp)
420010c4:	4d06                	lw	s10,64(sp)
420010c6:	5df2                	lw	s11,60(sp)
                return false;
420010c8:	4501                	li	a0,0
}
420010ca:	6165                	add	sp,sp,112
420010cc:	8082                	ret
            while (i < length && msg[i] != '%') i++;
420010ce:	fae9f9e3          	bgeu	s3,a4,42001080 <format_str_va+0x6e>
420010d2:	9002                	ebreak
        if (msg[i] == '%' && i + 1 < length && msg[i + 1] == '%') {
420010d4:	f9a9f2e3          	bgeu	s3,s10,42001058 <format_str_va+0x46>
420010d8:	9002                	ebreak
        } else if (msg[i] == '%' && i + 3 < length) {
420010da:	f9a9f9e3          	bgeu	s3,s10,4200106c <format_str_va+0x5a>
420010de:	9002                	ebreak
420010e0:	001c8493          	add	s1,s9,1
        if (msg[i] == '%' && i + 1 < length && msg[i + 1] == '%') {
420010e4:	2d44f263          	bgeu	s1,s4,420013a8 <format_str_va+0x396>
420010e8:	009987b3          	add	a5,s3,s1
420010ec:	2c04d963          	bgez	s1,420013be <format_str_va+0x3ac>
420010f0:	2cf9e963          	bltu	s3,a5,420013c2 <format_str_va+0x3b0>
420010f4:	440783e3          	beqz	a5,42001d3a <format_str_va+0xd28>
420010f8:	0007c703          	lbu	a4,0(a5)
420010fc:	02500793          	li	a5,37
42001100:	60f70263          	beq	a4,a5,42001704 <format_str_va+0x6f2>
        } else if (msg[i] == '%' && i + 3 < length) {
42001104:	2c0cd363          	bgez	s9,420013ca <format_str_va+0x3b8>
42001108:	2da9e363          	bltu	s3,s10,420013ce <format_str_va+0x3bc>
4200110c:	003c8b93          	add	s7,s9,3
42001110:	f54bfee3          	bgeu	s7,s4,4200106c <format_str_va+0x5a>
            ptrdiff_t fmt_end = mem_index(&msg[i], length - i, '}');
42001114:	260cc163          	bltz	s9,42001376 <format_str_va+0x364>
42001118:	273d6163          	bltu	s10,s3,4200137a <format_str_va+0x368>
4200111c:	419a07b3          	sub	a5,s4,s9
42001120:	85be                	mv	a1,a5
42001122:	07d00613          	li	a2,125
42001126:	856a                	mv	a0,s10
42001128:	c43e                	sw	a5,8(sp)
4200112a:	046010ef          	jal	42002170 <mem_index>
            if (msg[i + 1] != '{' || fmt_end == -1) {
4200112e:	009987b3          	add	a5,s3,s1
42001132:	2204cf63          	bltz	s1,42001370 <format_str_va+0x35e>
42001136:	2337ef63          	bltu	a5,s3,42001374 <format_str_va+0x362>
4200113a:	400786e3          	beqz	a5,42001d46 <format_str_va+0xd34>
4200113e:	0007c783          	lbu	a5,0(a5)
42001142:	07b00713          	li	a4,123
42001146:	002c8693          	add	a3,s9,2
4200114a:	1ee79b63          	bne	a5,a4,42001340 <format_str_va+0x32e>
4200114e:	57fd                	li	a5,-1
42001150:	1ef50863          	beq	a0,a5,42001340 <format_str_va+0x32e>
            fmt_end += (ptrdiff_t)i;
42001154:	00ac8ab3          	add	s5,s9,a0
42001158:	019aa7b3          	slt	a5,s5,s9
4200115c:	00052513          	slti	a0,a0,0
42001160:	3cf51ee3          	bne	a0,a5,42001d3c <format_str_va+0xd2a>
            format_str_type_t type       = FMT_TYPE_INT;
42001164:	4789                	li	a5,2
42001166:	d43e                	sw	a5,40(sp)
            bool              is_signed  = true;
42001168:	4785                	li	a5,1
            if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'c' && lower(msg[i + 3]) == 's') {
4200116a:	00d984b3          	add	s1,s3,a3
            bool              is_signed  = true;
4200116e:	02f103a3          	sb	a5,39(sp)
            format_str_mult_t mult       = FMT_MULT_ONE;
42001172:	d602                	sw	zero,44(sp)
            if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'c' && lower(msg[i + 3]) == 's') {
42001174:	004c8793          	add	a5,s9,4
42001178:	8c26                	mv	s8,s1
4200117a:	15578163          	beq	a5,s5,420012bc <format_str_va+0x2aa>
                char const *substr = &msg[i + 2];
4200117e:	1e06cf63          	bltz	a3,4200137c <format_str_va+0x36a>
42001182:	1f34ef63          	bltu	s1,s3,42001380 <format_str_va+0x36e>
                size_t      sublen = fmt_end - i - 2;
42001186:	419a8db3          	sub	s11,s5,s9
4200118a:	1df9                	add	s11,s11,-2
                ptrdiff_t delim = mem_index(substr, sublen, ';');
4200118c:	03b00613          	li	a2,59
42001190:	85ee                	mv	a1,s11
42001192:	8526                	mv	a0,s1
42001194:	7dd000ef          	jal	42002170 <mem_index>
                    is_signed = true;
42001198:	4785                	li	a5,1
                if (delim < 0) {
4200119a:	20054c63          	bltz	a0,420013b2 <format_str_va+0x3a0>
                } else if (delim != 1 && format_str_parse_type(substr, delim, &type, &is_signed)) {
4200119e:	0ef50963          	beq	a0,a5,42001290 <format_str_va+0x27e>
    if (lower(substr[0]) == 'u' || lower(substr[0]) == 'i') {
420011a2:	38048ae3          	beqz	s1,42001d36 <format_str_va+0xd24>
420011a6:	0004c703          	lbu	a4,0(s1)
420011aa:	07500693          	li	a3,117
420011ae:	02076793          	or	a5,a4,32
420011b2:	5ed78a63          	beq	a5,a3,420017a6 <format_str_va+0x794>
420011b6:	06900693          	li	a3,105
420011ba:	7cd78e63          	beq	a5,a3,42001996 <format_str_va+0x984>
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
420011be:	4611                	li	a2,4
420011c0:	6ec50f63          	beq	a0,a2,420018be <format_str_va+0x8ac>
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
420011c4:	471d                	li	a4,7
420011c6:	00e508e3          	beq	a0,a4,420019d6 <format_str_va+0x9c4>
    if (length < 3)
420011ca:	4789                	li	a5,2
420011cc:	16a7fa63          	bgeu	a5,a0,42001340 <format_str_va+0x32e>
420011d0:	87a6                	mv	a5,s1
420011d2:	872a                	mv	a4,a0
420011d4:	4685                	li	a3,1
    if (length == 5 && lower(substr[0]) == 'l' && lower(substr[1]) == 'l' && lower(substr[2]) == 'o' &&
420011d6:	4615                	li	a2,5
420011d8:	32c71ae3          	bne	a4,a2,42001d0c <format_str_va+0xcfa>
420011dc:	2e0781e3          	beqz	a5,42001cbe <format_str_va+0xcac>
420011e0:	0007c703          	lbu	a4,0(a5)
420011e4:	06c00613          	li	a2,108
420011e8:	02076713          	or	a4,a4,32
420011ec:	1ac70ce3          	beq	a4,a2,42001ba4 <format_str_va+0xb92>
    } else if (length == 5 && lower(substr[0]) == 's' && lower(substr[1]) == 'h' && lower(substr[2]) == 'o' && lower(substr[3]) == 'r' && lower(substr[4]) == 't') {
420011f0:	07300613          	li	a2,115
420011f4:	14c71663          	bne	a4,a2,42001340 <format_str_va+0x32e>
420011f8:	577d                	li	a4,-1
420011fa:	2ee7f4e3          	bgeu	a5,a4,42001ce2 <format_str_va+0xcd0>
420011fe:	00178713          	add	a4,a5,1
42001202:	2c070fe3          	beqz	a4,42001ce0 <format_str_va+0xcce>
42001206:	0017c703          	lbu	a4,1(a5)
4200120a:	06800613          	li	a2,104
4200120e:	02076713          	or	a4,a4,32
42001212:	12c71763          	bne	a4,a2,42001340 <format_str_va+0x32e>
42001216:	5779                	li	a4,-2
42001218:	2ce7f3e3          	bgeu	a5,a4,42001cde <format_str_va+0xccc>
4200121c:	00278713          	add	a4,a5,2
42001220:	2a070ee3          	beqz	a4,42001cdc <format_str_va+0xcca>
42001224:	0027c703          	lbu	a4,2(a5)
42001228:	06f00613          	li	a2,111
4200122c:	02076713          	or	a4,a4,32
42001230:	10c71863          	bne	a4,a2,42001340 <format_str_va+0x32e>
42001234:	5775                	li	a4,-3
42001236:	2ae7f2e3          	bgeu	a5,a4,42001cda <format_str_va+0xcc8>
4200123a:	00378713          	add	a4,a5,3
4200123e:	28070de3          	beqz	a4,42001cd8 <format_str_va+0xcc6>
42001242:	0037c703          	lbu	a4,3(a5)
42001246:	07200613          	li	a2,114
4200124a:	02076713          	or	a4,a4,32
4200124e:	0ec71963          	bne	a4,a2,42001340 <format_str_va+0x32e>
42001252:	5771                	li	a4,-4
42001254:	28e7f1e3          	bgeu	a5,a4,42001cd6 <format_str_va+0xcc4>
42001258:	00478713          	add	a4,a5,4
4200125c:	26070ce3          	beqz	a4,42001cd4 <format_str_va+0xcc2>
42001260:	0047c783          	lbu	a5,4(a5)
42001264:	07400713          	li	a4,116
42001268:	0207e793          	or	a5,a5,32
4200126c:	0ce79a63          	bne	a5,a4,42001340 <format_str_va+0x32e>
        *type_out      = FMT_TYPE_SHORT;
42001270:	4785                	li	a5,1
42001272:	d43e                	sw	a5,40(sp)
                    substr += delim + 1;
42001274:	00150793          	add	a5,a0,1
            *is_signed_out = lower(substr[0]) == 'i';
42001278:	02d103a3          	sb	a3,39(sp)
                    substr += delim + 1;
4200127c:	00f48733          	add	a4,s1,a5
42001280:	5c07c763          	bltz	a5,4200184e <format_str_va+0x83c>
42001284:	5c976763          	bltu	a4,s1,42001852 <format_str_va+0x840>
42001288:	1dfd                	add	s11,s11,-1
4200128a:	8c3a                	mv	s8,a4
                    sublen -= delim + 1;
4200128c:	40ad8db3          	sub	s11,s11,a0
                if (!sublen)
42001290:	0a0d8863          	beqz	s11,42001340 <format_str_va+0x32e>
                lowercase = substr[0] & 0x20;
42001294:	2a0c02e3          	beqz	s8,42001d38 <format_str_va+0xd26>
42001298:	000c4483          	lbu	s1,0(s8)
                switch (lower(substr[0])) {
4200129c:	46d5                	li	a3,21
4200129e:	0204e793          	or	a5,s1,32
420012a2:	f9d78793          	add	a5,a5,-99
                lowercase = substr[0] & 0x20;
420012a6:	8095                	srl	s1,s1,0x5
                switch (lower(substr[0])) {
420012a8:	0ff7f793          	zext.b	a5,a5
                lowercase = substr[0] & 0x20;
420012ac:	8885                	and	s1,s1,1
                switch (lower(substr[0])) {
420012ae:	08f6e963          	bltu	a3,a5,42001340 <format_str_va+0x32e>
420012b2:	4732                	lw	a4,12(sp)
420012b4:	078a                	sll	a5,a5,0x2
420012b6:	97ba                	add	a5,a5,a4
420012b8:	439c                	lw	a5,0(a5)
420012ba:	8782                	jr	a5
            if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'c' && lower(msg[i + 3]) == 's') {
420012bc:	1006d463          	bgez	a3,420013c4 <format_str_va+0x3b2>
420012c0:	1099e463          	bltu	s3,s1,420013c8 <format_str_va+0x3b6>
420012c4:	26048de3          	beqz	s1,42001d3e <format_str_va+0xd2c>
420012c8:	0004c783          	lbu	a5,0(s1)
420012cc:	06300613          	li	a2,99
420012d0:	0207e793          	or	a5,a5,32
420012d4:	10c78463          	beq	a5,a2,420013dc <format_str_va+0x3ca>
            } else if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'l' && lower(msg[i + 3]) == 's') {
420012d8:	0e06df63          	bgez	a3,420013d6 <format_str_va+0x3c4>
420012dc:	0e99ef63          	bltu	s3,s1,420013da <format_str_va+0x3c8>
420012e0:	06c00613          	li	a2,108
420012e4:	e8c79de3          	bne	a5,a2,4200117e <format_str_va+0x16c>
420012e8:	017987b3          	add	a5,s3,s7
420012ec:	580bd363          	bgez	s7,42001872 <format_str_va+0x860>
420012f0:	58f9e363          	bltu	s3,a5,42001876 <format_str_va+0x864>
420012f4:	200783e3          	beqz	a5,42001cfa <format_str_va+0xce8>
420012f8:	0007c783          	lbu	a5,0(a5)
420012fc:	07300613          	li	a2,115
42001300:	0207e793          	or	a5,a5,32
42001304:	e6c79de3          	bne	a5,a2,4200117e <format_str_va+0x16c>
                mult       = FMT_MULT_ARR;
42001308:	4789                	li	a5,2
                type       = FMT_TYPE_CHAR;
4200130a:	d402                	sw	zero,40(sp)
                mult       = FMT_MULT_ARR;
4200130c:	d63e                	sw	a5,44(sp)
                is_signed  = false;
4200130e:	020103a3          	sb	zero,39(sp)
                if (!callback(cstr, length, cookie))
42001312:	004b2583          	lw	a1,4(s6)
42001316:	000b2503          	lw	a0,0(s6)
4200131a:	4612                	lw	a2,4(sp)
                size_t      length = va_arg(vararg, size_t);
4200131c:	0b21                	add	s6,s6,8
                if (!callback(cstr, length, cookie))
4200131e:	9902                	jalr	s2
42001320:	3a051c63          	bnez	a0,420016d8 <format_str_va+0x6c6>
42001324:	b369                	j	420010ae <format_str_va+0x9c>
        if (length == 2 && substr[1] == '8') {
42001326:	577d                	li	a4,-1
42001328:	18e4fee3          	bgeu	s1,a4,42001cc4 <format_str_va+0xcb2>
4200132c:	00148713          	add	a4,s1,1
42001330:	180709e3          	beqz	a4,42001cc2 <format_str_va+0xcb0>
42001334:	0014c683          	lbu	a3,1(s1)
42001338:	03800713          	li	a4,56
4200133c:	02e688e3          	beq	a3,a4,42001b6c <format_str_va+0xb5a>
42001340:	4c22                	lw	s8,8(sp)
    return callback(&msg[i], length - i, cookie);
42001342:	080cd763          	bgez	s9,420013d0 <format_str_va+0x3be>
42001346:	09a9e763          	bltu	s3,s10,420013d4 <format_str_va+0x3c2>
4200134a:	5426                	lw	s0,104(sp)
4200134c:	4612                	lw	a2,4(sp)
4200134e:	5496                	lw	s1,100(sp)
42001350:	49f6                	lw	s3,92(sp)
42001352:	4a66                	lw	s4,88(sp)
42001354:	4ad6                	lw	s5,84(sp)
42001356:	4b46                	lw	s6,80(sp)
42001358:	4bb6                	lw	s7,76(sp)
4200135a:	4c96                	lw	s9,68(sp)
4200135c:	5df2                	lw	s11,60(sp)
}
4200135e:	50b6                	lw	ra,108(sp)
    return callback(&msg[i], length - i, cookie);
42001360:	85e2                	mv	a1,s8
42001362:	856a                	mv	a0,s10
42001364:	4c26                	lw	s8,72(sp)
42001366:	4d06                	lw	s10,64(sp)
42001368:	87ca                	mv	a5,s2
4200136a:	5906                	lw	s2,96(sp)
}
4200136c:	6165                	add	sp,sp,112
    return callback(&msg[i], length - i, cookie);
4200136e:	8782                	jr	a5
            if (msg[i + 1] != '{' || fmt_end == -1) {
42001370:	dcf9f5e3          	bgeu	s3,a5,4200113a <format_str_va+0x128>
42001374:	9002                	ebreak
            ptrdiff_t fmt_end = mem_index(&msg[i], length - i, '}');
42001376:	dba9f3e3          	bgeu	s3,s10,4200111c <format_str_va+0x10a>
4200137a:	9002                	ebreak
                char const *substr = &msg[i + 2];
4200137c:	e099f5e3          	bgeu	s3,s1,42001186 <format_str_va+0x174>
42001380:	9002                	ebreak
            if (!callback(&msg[start], i - start, cookie))
42001382:	d1a9ffe3          	bgeu	s3,s10,420010a0 <format_str_va+0x8e>
42001386:	9002                	ebreak
42001388:	000ccd63          	bltz	s9,420013a2 <format_str_va+0x390>
4200138c:	013d6d63          	bltu	s10,s3,420013a6 <format_str_va+0x394>
42001390:	4612                	lw	a2,4(sp)
42001392:	419485b3          	sub	a1,s1,s9
42001396:	856a                	mv	a0,s10
42001398:	9902                	jalr	s2
4200139a:	d0050ae3          	beqz	a0,420010ae <format_str_va+0x9c>
4200139e:	8ca6                	mv	s9,s1
420013a0:	b175                	j	4200104c <format_str_va+0x3a>
420013a2:	ffa9f7e3          	bgeu	s3,s10,42001390 <format_str_va+0x37e>
420013a6:	9002                	ebreak
        } else if (msg[i] == '%' && i + 3 < length) {
420013a8:	000cd863          	bgez	s9,420013b8 <format_str_va+0x3a6>
420013ac:	d7a9f0e3          	bgeu	s3,s10,4200110c <format_str_va+0xfa>
420013b0:	9002                	ebreak
                    is_signed = true;
420013b2:	02f103a3          	sb	a5,39(sp)
420013b6:	bde9                	j	42001290 <format_str_va+0x27e>
        } else if (msg[i] == '%' && i + 3 < length) {
420013b8:	d53d7ae3          	bgeu	s10,s3,4200110c <format_str_va+0xfa>
420013bc:	9002                	ebreak
        if (msg[i] == '%' && i + 1 < length && msg[i + 1] == '%') {
420013be:	d337fbe3          	bgeu	a5,s3,420010f4 <format_str_va+0xe2>
420013c2:	9002                	ebreak
            if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'c' && lower(msg[i + 3]) == 's') {
420013c4:	f134f0e3          	bgeu	s1,s3,420012c4 <format_str_va+0x2b2>
420013c8:	9002                	ebreak
        } else if (msg[i] == '%' && i + 3 < length) {
420013ca:	d53d71e3          	bgeu	s10,s3,4200110c <format_str_va+0xfa>
420013ce:	9002                	ebreak
    return callback(&msg[i], length - i, cookie);
420013d0:	f73d7de3          	bgeu	s10,s3,4200134a <format_str_va+0x338>
420013d4:	9002                	ebreak
            } else if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'l' && lower(msg[i + 3]) == 's') {
420013d6:	f134f5e3          	bgeu	s1,s3,420012e0 <format_str_va+0x2ce>
420013da:	9002                	ebreak
            if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'c' && lower(msg[i + 3]) == 's') {
420013dc:	017987b3          	add	a5,s3,s7
420013e0:	480bd663          	bgez	s7,4200186c <format_str_va+0x85a>
420013e4:	48f9e663          	bltu	s3,a5,42001870 <format_str_va+0x85e>
420013e8:	0c0780e3          	beqz	a5,42001ca8 <format_str_va+0xc96>
420013ec:	0007c783          	lbu	a5,0(a5)
420013f0:	07300613          	li	a2,115
420013f4:	0207e793          	or	a5,a5,32
420013f8:	4ac78263          	beq	a5,a2,4200189c <format_str_va+0x88a>
            } else if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'l' && lower(msg[i + 3]) == 's') {
420013fc:	5806c463          	bltz	a3,42001984 <format_str_va+0x972>
42001400:	d734ffe3          	bgeu	s1,s3,4200117e <format_str_va+0x16c>
42001404:	9002                	ebreak
                    case 'q': spec = FMT_SPEC_OCTAL; break;
42001406:	4b89                	li	s7,2
                delim = mem_index(substr, sublen, ';');
42001408:	03b00613          	li	a2,59
4200140c:	85ee                	mv	a1,s11
4200140e:	8562                	mv	a0,s8
42001410:	561000ef          	jal	42002170 <mem_index>
                if (delim < 0 && sublen != 1) {
42001414:	0e054663          	bltz	a0,42001500 <format_str_va+0x4ee>
                    substr += delim + 1;
42001418:	00150693          	add	a3,a0,1
4200141c:	00dc07b3          	add	a5,s8,a3
42001420:	1406cb63          	bltz	a3,42001576 <format_str_va+0x564>
42001424:	1587eb63          	bltu	a5,s8,4200157a <format_str_va+0x568>
                    sublen -= delim + 1;
42001428:	1dfd                	add	s11,s11,-1
4200142a:	40ad8db3          	sub	s11,s11,a0
                    delim   = mem_index(substr, sublen, ';');
4200142e:	03b00613          	li	a2,59
42001432:	853e                	mv	a0,a5
42001434:	85ee                	mv	a1,s11
42001436:	c83e                	sw	a5,16(sp)
42001438:	539000ef          	jal	42002170 <mem_index>
                    if (delim >= 0 && format_str_parse_mult(substr, delim, &mult)) {
4200143c:	47c2                	lw	a5,16(sp)
                    delim   = mem_index(substr, sublen, ';');
4200143e:	8c2a                	mv	s8,a0
                    if (delim >= 0 && format_str_parse_mult(substr, delim, &mult)) {
42001440:	1070                	add	a2,sp,44
42001442:	24054b63          	bltz	a0,42001698 <format_str_va+0x686>
42001446:	85aa                	mv	a1,a0
42001448:	853e                	mv	a0,a5
4200144a:	3269                	jal	42000dd4 <format_str_parse_mult>
4200144c:	ee050ae3          	beqz	a0,42001340 <format_str_va+0x32e>
                        joiner     = &substr[delim + 1];
42001450:	47c2                	lw	a5,16(sp)
42001452:	001c0713          	add	a4,s8,1
42001456:	00e78833          	add	a6,a5,a4
4200145a:	12074163          	bltz	a4,4200157c <format_str_va+0x56a>
4200145e:	12f86163          	bltu	a6,a5,42001580 <format_str_va+0x56e>
                        joiner_len = sublen - delim - 1;
42001462:	fffd8693          	add	a3,s11,-1
42001466:	418686b3          	sub	a3,a3,s8
            if (mult == FMT_MULT_ARR && spec == FMT_SPEC_CHAR && type == FMT_TYPE_CHAR && !joiner) {
4200146a:	57b2                	lw	a5,44(sp)
4200146c:	4709                	li	a4,2
4200146e:	14e79063          	bne	a5,a4,420015ae <format_str_va+0x59c>
42001472:	478d                	li	a5,3
42001474:	50fb8b63          	beq	s7,a5,4200198a <format_str_va+0x978>
                size_t      length = va_arg(vararg, size_t);
42001478:	004b2883          	lw	a7,4(s6)
                void const *ptr    = va_arg(vararg, void const *);
4200147c:	000b2d83          	lw	s11,0(s6)
                size_t      length = va_arg(vararg, size_t);
42001480:	008b0793          	add	a5,s6,8
                for (size_t i = 0; i < length; i++) {
42001484:	54088763          	beqz	a7,420019d2 <format_str_va+0x9c0>
                            fmt_type_index(type, ptr, i),
42001488:	ca4e                	sw	s3,20(sp)
4200148a:	4992                	lw	s3,4(sp)
4200148c:	4b01                	li	s6,0
4200148e:	cc52                	sw	s4,24(sp)
42001490:	ce56                	sw	s5,28(sp)
42001492:	8c6e                	mv	s8,s11
42001494:	8ada                	mv	s5,s6
42001496:	8d6e                	mv	s10,s11
42001498:	8cee                	mv	s9,s11
4200149a:	c442                	sw	a6,8(sp)
4200149c:	c83e                	sw	a5,16(sp)
4200149e:	8a46                	mv	s4,a7
420014a0:	8b36                	mv	s6,a3
                    if (!format_str_output(
420014a2:	02714603          	lbu	a2,39(sp)
420014a6:	4785                	li	a5,1
420014a8:	5522                	lw	a0,40(sp)
420014aa:	0ac7e7e3          	bltu	a5,a2,42001d58 <format_str_va+0xd46>
420014ae:	8a05                	and	a2,a2,1
420014b0:	e559                	bnez	a0,4200153e <format_str_va+0x52c>
                            fmt_type_index(type, ptr, i),
420014b2:	015d87b3          	add	a5,s11,s5
420014b6:	080ac163          	bltz	s5,42001538 <format_str_va+0x526>
420014ba:	09b7e163          	bltu	a5,s11,4200153c <format_str_va+0x52a>
420014be:	7e078263          	beqz	a5,42001ca2 <format_str_va+0xc90>
                    if (!format_str_output(
420014c2:	0007c703          	lbu	a4,0(a5)
420014c6:	4781                	li	a5,0
420014c8:	88ce                	mv	a7,s3
420014ca:	884a                	mv	a6,s2
420014cc:	86a6                	mv	a3,s1
420014ce:	85de                	mv	a1,s7
420014d0:	325d                	jal	42000e76 <format_str_output>
420014d2:	bc050ee3          	beqz	a0,420010ae <format_str_va+0x9c>
                for (size_t i = 0; i < length; i++) {
420014d6:	0a85                	add	s5,s5,1
420014d8:	0c21                	add	s8,s8,8
420014da:	0c89                	add	s9,s9,2
420014dc:	0d11                	add	s10,s10,4
420014de:	4f5a0663          	beq	s4,s5,420019ca <format_str_va+0x9b8>
                    if (i && !callback(joiner, joiner_len, cookie)) {
420014e2:	4522                	lw	a0,8(sp)
420014e4:	864e                	mv	a2,s3
420014e6:	85da                	mv	a1,s6
420014e8:	9902                	jalr	s2
420014ea:	fd45                	bnez	a0,420014a2 <format_str_va+0x490>
420014ec:	b6c9                	j	420010ae <format_str_va+0x9c>
                delim = mem_index(substr, sublen, ';');
420014ee:	03b00613          	li	a2,59
420014f2:	85ee                	mv	a1,s11
420014f4:	8562                	mv	a0,s8
                    case 'c': spec = FMT_SPEC_CHAR; break;
420014f6:	4b8d                	li	s7,3
                delim = mem_index(substr, sublen, ';');
420014f8:	479000ef          	jal	42002170 <mem_index>
                if (delim < 0 && sublen != 1) {
420014fc:	f0055ee3          	bgez	a0,42001418 <format_str_va+0x406>
42001500:	4785                	li	a5,1
42001502:	e2fd9fe3          	bne	s11,a5,42001340 <format_str_va+0x32e>
                switch (type) {
42001506:	5da2                	lw	s11,40(sp)
                    mult = FMT_MULT_ONE;
42001508:	d602                	sw	zero,44(sp)
                switch (type) {
4200150a:	478d                	li	a5,3
                        if (is_signed)
4200150c:	02714603          	lbu	a2,39(sp)
                switch (type) {
42001510:	19b7ed63          	bltu	a5,s11,420016aa <format_str_va+0x698>
42001514:	4785                	li	a5,1
42001516:	27b7e663          	bltu	a5,s11,42001782 <format_str_va+0x770>
4200151a:	240d8763          	beqz	s11,42001768 <format_str_va+0x756>
                        if (is_signed)
4200151e:	02c7ede3          	bltu	a5,a2,42001d58 <format_str_va+0xd46>
                            value = (long long)(signed char)va_arg(vararg, int);
42001522:	000b2703          	lw	a4,0(s6)
                        if (is_signed)
42001526:	8a05                	and	a2,a2,1
                            value = (long long)(signed char)va_arg(vararg, int);
42001528:	0b11                	add	s6,s6,4
                            value = (long long)(short)va_arg(vararg, int);
4200152a:	0742                	sll	a4,a4,0x10
                        if (is_signed)
4200152c:	34060a63          	beqz	a2,42001880 <format_str_va+0x86e>
                            value = (long long)(short)va_arg(vararg, int);
42001530:	8741                	sra	a4,a4,0x10
42001532:	41f75793          	sra	a5,a4,0x1f
42001536:	aa41                	j	420016c6 <format_str_va+0x6b4>
                            fmt_type_index(type, ptr, i),
42001538:	f8fdf3e3          	bgeu	s11,a5,420014be <format_str_va+0x4ac>
4200153c:	9002                	ebreak
4200153e:	4785                	li	a5,1
42001540:	04f50163          	beq	a0,a5,42001582 <format_str_va+0x570>
42001544:	4789                	li	a5,2
42001546:	1cf50c63          	beq	a0,a5,4200171e <format_str_va+0x70c>
4200154a:	478d                	li	a5,3
4200154c:	3ef50963          	beq	a0,a5,4200193e <format_str_va+0x92c>
42001550:	003a9793          	sll	a5,s5,0x3
42001554:	00fd8733          	add	a4,s11,a5
42001558:	2e07de63          	bgez	a5,42001854 <format_str_va+0x842>
4200155c:	2eedee63          	bltu	s11,a4,42001858 <format_str_va+0x846>
42001560:	740c0363          	beqz	s8,42001ca6 <format_str_va+0xc94>
42001564:	007c7793          	and	a5,s8,7
42001568:	72079f63          	bnez	a5,42001ca6 <format_str_va+0xc94>
4200156c:	000c2703          	lw	a4,0(s8)
42001570:	004c2783          	lw	a5,4(s8)
42001574:	bf91                	j	420014c8 <format_str_va+0x4b6>
                    substr += delim + 1;
42001576:	eafc79e3          	bgeu	s8,a5,42001428 <format_str_va+0x416>
4200157a:	9002                	ebreak
                        joiner     = &substr[delim + 1];
4200157c:	ef07f3e3          	bgeu	a5,a6,42001462 <format_str_va+0x450>
42001580:	9002                	ebreak
42001582:	001a9793          	sll	a5,s5,0x1
                            fmt_type_index(type, ptr, i),
42001586:	00fd8733          	add	a4,s11,a5
4200158a:	0007cf63          	bltz	a5,420015a8 <format_str_va+0x596>
4200158e:	01b76f63          	bltu	a4,s11,420015ac <format_str_va+0x59a>
42001592:	7a0c8963          	beqz	s9,42001d44 <format_str_va+0xd32>
42001596:	001cf793          	and	a5,s9,1
4200159a:	7a079563          	bnez	a5,42001d44 <format_str_va+0xd32>
4200159e:	000c9703          	lh	a4,0(s9)
420015a2:	41f75793          	sra	a5,a4,0x1f
420015a6:	b70d                	j	420014c8 <format_str_va+0x4b6>
420015a8:	feedf5e3          	bgeu	s11,a4,42001592 <format_str_va+0x580>
420015ac:	9002                	ebreak
            } else if (mult == FMT_MULT_NUL && spec == FMT_SPEC_CHAR && type == FMT_TYPE_CHAR && !joiner) {
420015ae:	4705                	li	a4,1
                switch (type) {
420015b0:	5da2                	lw	s11,40(sp)
            } else if (mult == FMT_MULT_NUL && spec == FMT_SPEC_CHAR && type == FMT_TYPE_CHAR && !joiner) {
420015b2:	f4e79ce3          	bne	a5,a4,4200150a <format_str_va+0x4f8>
420015b6:	478d                	li	a5,3
420015b8:	2cfb8b63          	beq	s7,a5,4200188e <format_str_va+0x87c>
                for (size_t i = 0;; i++) {
420015bc:	4d01                	li	s10,0
                    long long value = fmt_type_index(type, ptr, i);
420015be:	ca4e                	sw	s3,20(sp)
420015c0:	cc52                	sw	s4,24(sp)
420015c2:	ce56                	sw	s5,28(sp)
420015c4:	8a6e                	mv	s4,s11
420015c6:	8aea                	mv	s5,s10
                void const *ptr = va_arg(vararg, void const *);
420015c8:	000b2c03          	lw	s8,0(s6)
                    long long value = fmt_type_index(type, ptr, i);
420015cc:	4992                	lw	s3,4(sp)
420015ce:	4c85                	li	s9,1
420015d0:	8db6                	mv	s11,a3
420015d2:	8d42                	mv	s10,a6
420015d4:	060a1063          	bnez	s4,42001634 <format_str_va+0x622>
420015d8:	015c07b3          	add	a5,s8,s5
420015dc:	080ac563          	bltz	s5,42001666 <format_str_va+0x654>
420015e0:	0987e563          	bltu	a5,s8,4200166a <format_str_va+0x658>
420015e4:	74078863          	beqz	a5,42001d34 <format_str_va+0xd22>
420015e8:	0007c703          	lbu	a4,0(a5)
420015ec:	4781                	li	a5,0
                    if (!value)
420015ee:	00f766b3          	or	a3,a4,a5
420015f2:	3c068763          	beqz	a3,420019c0 <format_str_va+0x9ae>
                    if (i && joiner && !callback(joiner, joiner_len, cookie)) {
420015f6:	000a8e63          	beqz	s5,42001612 <format_str_va+0x600>
420015fa:	000d0c63          	beqz	s10,42001612 <format_str_va+0x600>
420015fe:	c83e                	sw	a5,16(sp)
42001600:	c43a                	sw	a4,8(sp)
42001602:	864e                	mv	a2,s3
42001604:	85ee                	mv	a1,s11
42001606:	856a                	mv	a0,s10
42001608:	9902                	jalr	s2
4200160a:	4722                	lw	a4,8(sp)
4200160c:	47c2                	lw	a5,16(sp)
4200160e:	aa0500e3          	beqz	a0,420010ae <format_str_va+0x9c>
                    if (!format_str_output(type, spec, is_signed, lowercase, value, callback, cookie))
42001612:	02714603          	lbu	a2,39(sp)
42001616:	74cce163          	bltu	s9,a2,42001d58 <format_str_va+0xd46>
4200161a:	88ce                	mv	a7,s3
4200161c:	884a                	mv	a6,s2
4200161e:	86a6                	mv	a3,s1
42001620:	8a05                	and	a2,a2,1
42001622:	85de                	mv	a1,s7
42001624:	8552                	mv	a0,s4
42001626:	851ff0ef          	jal	42000e76 <format_str_output>
4200162a:	a80502e3          	beqz	a0,420010ae <format_str_va+0x9c>
                for (size_t i = 0;; i++) {
4200162e:	0a85                	add	s5,s5,1
                    long long value = fmt_type_index(type, ptr, i);
42001630:	fa0a04e3          	beqz	s4,420015d8 <format_str_va+0x5c6>
42001634:	039a0c63          	beq	s4,s9,4200166c <format_str_va+0x65a>
42001638:	4789                	li	a5,2
4200163a:	10fa0563          	beq	s4,a5,42001744 <format_str_va+0x732>
4200163e:	478d                	li	a5,3
42001640:	32fa0163          	beq	s4,a5,42001962 <format_str_va+0x950>
42001644:	003a9713          	sll	a4,s5,0x3
42001648:	00ec07b3          	add	a5,s8,a4
4200164c:	20075763          	bgez	a4,4200185a <format_str_va+0x848>
42001650:	20fc6763          	bltu	s8,a5,4200185e <format_str_va+0x84c>
42001654:	66078f63          	beqz	a5,42001cd2 <format_str_va+0xcc0>
42001658:	0077f713          	and	a4,a5,7
4200165c:	66071b63          	bnez	a4,42001cd2 <format_str_va+0xcc0>
42001660:	4398                	lw	a4,0(a5)
42001662:	43dc                	lw	a5,4(a5)
42001664:	b769                	j	420015ee <format_str_va+0x5dc>
42001666:	f6fc7fe3          	bgeu	s8,a5,420015e4 <format_str_va+0x5d2>
4200166a:	9002                	ebreak
4200166c:	001a9713          	sll	a4,s5,0x1
42001670:	00ec07b3          	add	a5,s8,a4
42001674:	00074f63          	bltz	a4,42001692 <format_str_va+0x680>
42001678:	0187ef63          	bltu	a5,s8,42001696 <format_str_va+0x684>
4200167c:	6c078363          	beqz	a5,42001d42 <format_str_va+0xd30>
42001680:	0017f713          	and	a4,a5,1
42001684:	6a071f63          	bnez	a4,42001d42 <format_str_va+0xd30>
42001688:	00079703          	lh	a4,0(a5)
4200168c:	41f75793          	sra	a5,a4,0x1f
42001690:	bfb9                	j	420015ee <format_str_va+0x5dc>
42001692:	fefc75e3          	bgeu	s8,a5,4200167c <format_str_va+0x66a>
42001696:	9002                	ebreak
                    } else if (delim < 0 && format_str_parse_mult(substr, sublen, &mult)) {
42001698:	85ee                	mv	a1,s11
4200169a:	853e                	mv	a0,a5
4200169c:	f38ff0ef          	jal	42000dd4 <format_str_parse_mult>
420016a0:	ca0500e3          	beqz	a0,42001340 <format_str_va+0x32e>
                        joiner_len = 0;
420016a4:	4681                	li	a3,0
                        joiner     = NULL;
420016a6:	4801                	li	a6,0
420016a8:	b3c9                	j	4200146a <format_str_va+0x458>
                switch (type) {
420016aa:	4791                	li	a5,4
420016ac:	0efd9663          	bne	s11,a5,42001798 <format_str_va+0x786>
                        if (is_signed)
420016b0:	4785                	li	a5,1
420016b2:	6ac7e363          	bltu	a5,a2,42001d58 <format_str_va+0xd46>
                            value = va_arg(vararg, long long);
420016b6:	007b0793          	add	a5,s6,7
420016ba:	9be1                	and	a5,a5,-8
420016bc:	4398                	lw	a4,0(a5)
420016be:	00878b13          	add	s6,a5,8
420016c2:	43dc                	lw	a5,4(a5)
                        if (is_signed)
420016c4:	8a05                	and	a2,a2,1
                if (!format_str_output(type, spec, is_signed, lowercase, value, callback, cookie))
420016c6:	4892                	lw	a7,4(sp)
420016c8:	884a                	mv	a6,s2
420016ca:	86a6                	mv	a3,s1
420016cc:	85de                	mv	a1,s7
420016ce:	856e                	mv	a0,s11
420016d0:	fa6ff0ef          	jal	42000e76 <format_str_output>
420016d4:	9c050de3          	beqz	a0,420010ae <format_str_va+0x9c>
            i = fmt_end + 1;
420016d8:	001a8c93          	add	s9,s5,1
420016dc:	655ccb63          	blt	s9,s5,42001d32 <format_str_va+0xd20>
    while (i < length) {
420016e0:	974ce6e3          	bltu	s9,s4,4200104c <format_str_va+0x3a>
420016e4:	5426                	lw	s0,104(sp)
420016e6:	5496                	lw	s1,100(sp)
420016e8:	5906                	lw	s2,96(sp)
420016ea:	49f6                	lw	s3,92(sp)
420016ec:	4a66                	lw	s4,88(sp)
420016ee:	4ad6                	lw	s5,84(sp)
420016f0:	4b46                	lw	s6,80(sp)
420016f2:	4bb6                	lw	s7,76(sp)
420016f4:	4c26                	lw	s8,72(sp)
420016f6:	4c96                	lw	s9,68(sp)
420016f8:	4d06                	lw	s10,64(sp)
420016fa:	5df2                	lw	s11,60(sp)
}
420016fc:	50b6                	lw	ra,108(sp)
    return true;
420016fe:	4505                	li	a0,1
}
42001700:	6165                	add	sp,sp,112
42001702:	8082                	ret
            if (!callback("%", 1, cookie))
42001704:	4612                	lw	a2,4(sp)
42001706:	42017537          	lui	a0,0x42017
4200170a:	4585                	li	a1,1
4200170c:	1a050513          	add	a0,a0,416 # 420171a0 <hextab+0x4d4>
42001710:	9902                	jalr	s2
42001712:	98050ee3          	beqz	a0,420010ae <format_str_va+0x9c>
42001716:	0c89                	add	s9,s9,2
    while (i < length) {
42001718:	934ceae3          	bltu	s9,s4,4200104c <format_str_va+0x3a>
4200171c:	b7e1                	j	420016e4 <format_str_va+0x6d2>
4200171e:	002a9793          	sll	a5,s5,0x2
                            fmt_type_index(type, ptr, i),
42001722:	00fd8733          	add	a4,s11,a5
42001726:	1207dd63          	bgez	a5,42001860 <format_str_va+0x84e>
4200172a:	12eded63          	bltu	s11,a4,42001864 <format_str_va+0x852>
4200172e:	600d0963          	beqz	s10,42001d40 <format_str_va+0xd2e>
42001732:	003d7793          	and	a5,s10,3
42001736:	60079563          	bnez	a5,42001d40 <format_str_va+0xd2e>
4200173a:	000d2703          	lw	a4,0(s10)
4200173e:	41f75793          	sra	a5,a4,0x1f
42001742:	b359                	j	420014c8 <format_str_va+0x4b6>
42001744:	002a9713          	sll	a4,s5,0x2
                    long long value = fmt_type_index(type, ptr, i);
42001748:	00ec07b3          	add	a5,s8,a4
4200174c:	10075d63          	bgez	a4,42001866 <format_str_va+0x854>
42001750:	10fc6d63          	bltu	s8,a5,4200186a <format_str_va+0x858>
42001754:	54078863          	beqz	a5,42001ca4 <format_str_va+0xc92>
42001758:	0037f713          	and	a4,a5,3
4200175c:	54071463          	bnez	a4,42001ca4 <format_str_va+0xc92>
42001760:	4398                	lw	a4,0(a5)
42001762:	41f75793          	sra	a5,a4,0x1f
42001766:	b561                	j	420015ee <format_str_va+0x5dc>
                        if (is_signed)
42001768:	5ec7e863          	bltu	a5,a2,42001d58 <format_str_va+0xd46>
4200176c:	8a05                	and	a2,a2,1
                            value = (long long)(signed char)va_arg(vararg, int);
4200176e:	000b2703          	lw	a4,0(s6)
42001772:	0b11                	add	s6,s6,4
                        if (is_signed)
42001774:	10060263          	beqz	a2,42001878 <format_str_va+0x866>
                            value = (long long)(signed char)va_arg(vararg, int);
42001778:	0762                	sll	a4,a4,0x18
4200177a:	8761                	sra	a4,a4,0x18
4200177c:	41f75793          	sra	a5,a4,0x1f
42001780:	b799                	j	420016c6 <format_str_va+0x6b4>
                        if (is_signed) // NOLINT
42001782:	5cc7eb63          	bltu	a5,a2,42001d58 <format_str_va+0xd46>
                            value = (long long)(signed char)va_arg(vararg, int);
42001786:	000b2703          	lw	a4,0(s6)
                        if (is_signed) // NOLINT
4200178a:	8a05                	and	a2,a2,1
                            value = (long long)(signed char)va_arg(vararg, int);
4200178c:	0b11                	add	s6,s6,4
                            value = va_arg(vararg, int);
4200178e:	41f75793          	sra	a5,a4,0x1f
                        if (is_signed) // NOLINT
42001792:	fa15                	bnez	a2,420016c6 <format_str_va+0x6b4>
                if (!format_str_output(type, spec, is_signed, lowercase, value, callback, cookie))
42001794:	4781                	li	a5,0
42001796:	bf05                	j	420016c6 <format_str_va+0x6b4>
42001798:	4785                	li	a5,1
4200179a:	5ac7ef63          	bltu	a5,a2,42001d58 <format_str_va+0xd46>
4200179e:	8a05                	and	a2,a2,1
420017a0:	4701                	li	a4,0
420017a2:	4781                	li	a5,0
420017a4:	b70d                	j	420016c6 <format_str_va+0x6b4>
        if (length == 2 && substr[1] == '8') {
420017a6:	4709                	li	a4,2
420017a8:	b6e50fe3          	beq	a0,a4,42001326 <format_str_va+0x314>
        } else if (length == 3 && substr[1] == '1' && substr[2] == '6') {
420017ac:	470d                	li	a4,3
420017ae:	2ee51563          	bne	a0,a4,42001a98 <format_str_va+0xa86>
420017b2:	577d                	li	a4,-1
420017b4:	50e4fe63          	bgeu	s1,a4,42001cd0 <format_str_va+0xcbe>
420017b8:	00148713          	add	a4,s1,1
420017bc:	50070963          	beqz	a4,42001cce <format_str_va+0xcbc>
420017c0:	0014c703          	lbu	a4,1(s1)
420017c4:	03100693          	li	a3,49
420017c8:	44d70c63          	beq	a4,a3,42001c20 <format_str_va+0xc0e>
        } else if (length == 3 && substr[1] == '3' && substr[2] == '2') {
420017cc:	03300693          	li	a3,51
420017d0:	36d71563          	bne	a4,a3,42001b3a <format_str_va+0xb28>
420017d4:	5779                	li	a4,-2
420017d6:	4ce4fb63          	bgeu	s1,a4,42001cac <format_str_va+0xc9a>
420017da:	00248713          	add	a4,s1,2
420017de:	4c070663          	beqz	a4,42001caa <format_str_va+0xc98>
420017e2:	0024c683          	lbu	a3,2(s1)
420017e6:	03200713          	li	a4,50
420017ea:	4ae68163          	beq	a3,a4,42001c8c <format_str_va+0xc7a>
    if (!is_signed) {
420017ee:	07500713          	li	a4,117
420017f2:	b4e787e3          	beq	a5,a4,42001340 <format_str_va+0x32e>
420017f6:	87a6                	mv	a5,s1
420017f8:	4685                	li	a3,1
    } else if (length == 3 && lower(substr[0]) == 'i' && lower(substr[1]) == 'n' && lower(substr[2]) == 't') {
420017fa:	52078763          	beqz	a5,42001d28 <format_str_va+0xd16>
420017fe:	0007c703          	lbu	a4,0(a5)
42001802:	06900613          	li	a2,105
42001806:	02076713          	or	a4,a4,32
4200180a:	b2c71be3          	bne	a4,a2,42001340 <format_str_va+0x32e>
4200180e:	577d                	li	a4,-1
42001810:	50e7fb63          	bgeu	a5,a4,42001d26 <format_str_va+0xd14>
42001814:	00178713          	add	a4,a5,1
42001818:	50070663          	beqz	a4,42001d24 <format_str_va+0xd12>
4200181c:	0017c703          	lbu	a4,1(a5)
42001820:	06e00613          	li	a2,110
42001824:	02076713          	or	a4,a4,32
42001828:	b0c71ce3          	bne	a4,a2,42001340 <format_str_va+0x32e>
4200182c:	5779                	li	a4,-2
4200182e:	4ee7fa63          	bgeu	a5,a4,42001d22 <format_str_va+0xd10>
42001832:	00278713          	add	a4,a5,2
42001836:	4e070563          	beqz	a4,42001d20 <format_str_va+0xd0e>
4200183a:	0027c783          	lbu	a5,2(a5)
4200183e:	07400713          	li	a4,116
42001842:	0207e793          	or	a5,a5,32
42001846:	a2e787e3          	beq	a5,a4,42001274 <format_str_va+0x262>
4200184a:	4c22                	lw	s8,8(sp)
4200184c:	bcdd                	j	42001342 <format_str_va+0x330>
                    substr += delim + 1;
4200184e:	a2e4fde3          	bgeu	s1,a4,42001288 <format_str_va+0x276>
42001852:	9002                	ebreak
                            fmt_type_index(type, ptr, i),
42001854:	d1b776e3          	bgeu	a4,s11,42001560 <format_str_va+0x54e>
42001858:	9002                	ebreak
                    long long value = fmt_type_index(type, ptr, i);
4200185a:	df87fde3          	bgeu	a5,s8,42001654 <format_str_va+0x642>
4200185e:	9002                	ebreak
                            fmt_type_index(type, ptr, i),
42001860:	edb777e3          	bgeu	a4,s11,4200172e <format_str_va+0x71c>
42001864:	9002                	ebreak
                    long long value = fmt_type_index(type, ptr, i);
42001866:	ef87f7e3          	bgeu	a5,s8,42001754 <format_str_va+0x742>
4200186a:	9002                	ebreak
            if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'c' && lower(msg[i + 3]) == 's') {
4200186c:	b737fee3          	bgeu	a5,s3,420013e8 <format_str_va+0x3d6>
42001870:	9002                	ebreak
            } else if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'l' && lower(msg[i + 3]) == 's') {
42001872:	a937f1e3          	bgeu	a5,s3,420012f4 <format_str_va+0x2e2>
42001876:	9002                	ebreak
                            value = (long long)(unsigned char)va_arg(vararg, unsigned int);
42001878:	0ff77713          	zext.b	a4,a4
4200187c:	4781                	li	a5,0
4200187e:	b5a1                	j	420016c6 <format_str_va+0x6b4>
                            value = (long long)(unsigned short)va_arg(vararg, unsigned int);
42001880:	8341                	srl	a4,a4,0x10
42001882:	4781                	li	a5,0
42001884:	b589                	j	420016c6 <format_str_va+0x6b4>
                switch (lower(substr[0])) {
42001886:	4b85                	li	s7,1
42001888:	b641                	j	42001408 <format_str_va+0x3f6>
                    case 'd': spec = FMT_SPEC_DEC; break;
4200188a:	4b81                	li	s7,0
4200188c:	beb5                	j	42001408 <format_str_va+0x3f6>
            } else if (mult == FMT_MULT_NUL && spec == FMT_SPEC_CHAR && type == FMT_TYPE_CHAR && !joiner) {
4200188e:	d20d97e3          	bnez	s11,420015bc <format_str_va+0x5aa>
42001892:	d20815e3          	bnez	a6,420015bc <format_str_va+0x5aa>
                char const *cstr = va_arg(vararg, void const *);
42001896:	000b2483          	lw	s1,0(s6)
4200189a:	a801                	j	420018aa <format_str_va+0x898>
4200189c:	000b2483          	lw	s1,0(s6)
                mult       = FMT_MULT_NUL;
420018a0:	4785                	li	a5,1
                type       = FMT_TYPE_CHAR;
420018a2:	d402                	sw	zero,40(sp)
                mult       = FMT_MULT_NUL;
420018a4:	d63e                	sw	a5,44(sp)
                is_signed  = false;
420018a6:	020103a3          	sb	zero,39(sp)
                if (!callback(cstr, cstr_length(cstr), cookie))
420018aa:	8526                	mv	a0,s1
420018ac:	217d                	jal	42001d5a <cstr_length>
420018ae:	4612                	lw	a2,4(sp)
420018b0:	85aa                	mv	a1,a0
420018b2:	8526                	mv	a0,s1
420018b4:	9902                	jalr	s2
420018b6:	fe050c63          	beqz	a0,420010ae <format_str_va+0x9c>
                void const *ptr = va_arg(vararg, void const *);
420018ba:	0b11                	add	s6,s6,4
420018bc:	bd31                	j	420016d8 <format_str_va+0x6c6>
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
420018be:	07300613          	li	a2,115
420018c2:	1ec78563          	beq	a5,a2,42001aac <format_str_va+0xa9a>
        substr++, length--;
420018c6:	87a6                	mv	a5,s1
420018c8:	4685                	li	a3,1
    } else if (length == 4 && lower(substr[0]) == 'l' && lower(substr[1]) == 'o' && lower(substr[2]) == 'n' && lower(substr[3]) == 'g') {
420018ca:	42078663          	beqz	a5,42001cf6 <format_str_va+0xce4>
420018ce:	0007c703          	lbu	a4,0(a5)
420018d2:	06c00613          	li	a2,108
420018d6:	02076713          	or	a4,a4,32
420018da:	1ec71a63          	bne	a4,a2,42001ace <format_str_va+0xabc>
420018de:	577d                	li	a4,-1
420018e0:	3ee7f663          	bgeu	a5,a4,42001ccc <format_str_va+0xcba>
420018e4:	00178713          	add	a4,a5,1
420018e8:	3e070163          	beqz	a4,42001cca <format_str_va+0xcb8>
420018ec:	0017c703          	lbu	a4,1(a5)
420018f0:	06f00613          	li	a2,111
420018f4:	02076713          	or	a4,a4,32
420018f8:	a4c714e3          	bne	a4,a2,42001340 <format_str_va+0x32e>
420018fc:	5779                	li	a4,-2
420018fe:	3ee7f663          	bgeu	a5,a4,42001cea <format_str_va+0xcd8>
42001902:	00278713          	add	a4,a5,2
42001906:	3e070163          	beqz	a4,42001ce8 <format_str_va+0xcd6>
4200190a:	0027c703          	lbu	a4,2(a5)
4200190e:	06e00613          	li	a2,110
42001912:	02076713          	or	a4,a4,32
42001916:	a2c715e3          	bne	a4,a2,42001340 <format_str_va+0x32e>
4200191a:	5775                	li	a4,-3
4200191c:	3ce7f563          	bgeu	a5,a4,42001ce6 <format_str_va+0xcd4>
42001920:	00378713          	add	a4,a5,3
42001924:	3c070063          	beqz	a4,42001ce4 <format_str_va+0xcd2>
42001928:	0037c783          	lbu	a5,3(a5)
4200192c:	06700713          	li	a4,103
42001930:	0207e793          	or	a5,a5,32
42001934:	a0e796e3          	bne	a5,a4,42001340 <format_str_va+0x32e>
        *type_out      = FMT_TYPE_LONG;
42001938:	478d                	li	a5,3
4200193a:	d43e                	sw	a5,40(sp)
        return true;
4200193c:	ba25                	j	42001274 <format_str_va+0x262>
4200193e:	002a9793          	sll	a5,s5,0x2
                            fmt_type_index(type, ptr, i),
42001942:	00fd8733          	add	a4,s11,a5
42001946:	0007cb63          	bltz	a5,4200195c <format_str_va+0x94a>
4200194a:	01b76b63          	bltu	a4,s11,42001960 <format_str_va+0x94e>
4200194e:	000d0663          	beqz	s10,4200195a <format_str_va+0x948>
42001952:	003d7793          	and	a5,s10,3
42001956:	de0782e3          	beqz	a5,4200173a <format_str_va+0x728>
4200195a:	9002                	ebreak
4200195c:	feedf9e3          	bgeu	s11,a4,4200194e <format_str_va+0x93c>
42001960:	9002                	ebreak
42001962:	002a9713          	sll	a4,s5,0x2
                    long long value = fmt_type_index(type, ptr, i);
42001966:	00ec07b3          	add	a5,s8,a4
4200196a:	00074a63          	bltz	a4,4200197e <format_str_va+0x96c>
4200196e:	0187ea63          	bltu	a5,s8,42001982 <format_str_va+0x970>
42001972:	c789                	beqz	a5,4200197c <format_str_va+0x96a>
42001974:	0037f713          	and	a4,a5,3
42001978:	de0704e3          	beqz	a4,42001760 <format_str_va+0x74e>
4200197c:	9002                	ebreak
4200197e:	fefc7ae3          	bgeu	s8,a5,42001972 <format_str_va+0x960>
42001982:	9002                	ebreak
            } else if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'l' && lower(msg[i + 3]) == 's') {
42001984:	fe99fd63          	bgeu	s3,s1,4200117e <format_str_va+0x16c>
42001988:	9002                	ebreak
            if (mult == FMT_MULT_ARR && spec == FMT_SPEC_CHAR && type == FMT_TYPE_CHAR && !joiner) {
4200198a:	57a2                	lw	a5,40(sp)
4200198c:	ae0796e3          	bnez	a5,42001478 <format_str_va+0x466>
42001990:	ae0814e3          	bnez	a6,42001478 <format_str_va+0x466>
42001994:	babd                	j	42001312 <format_str_va+0x300>
        if (length == 2 && substr[1] == '8') {
42001996:	4709                	li	a4,2
42001998:	1ee50e63          	beq	a0,a4,42001b94 <format_str_va+0xb82>
        } else if (length == 3 && substr[1] == '1' && substr[2] == '6') {
4200199c:	470d                	li	a4,3
4200199e:	e0e50ae3          	beq	a0,a4,420017b2 <format_str_va+0x7a0>
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
420019a2:	4711                	li	a4,4
420019a4:	f2e501e3          	beq	a0,a4,420018c6 <format_str_va+0x8b4>
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
420019a8:	471d                	li	a4,7
420019aa:	82e510e3          	bne	a0,a4,420011ca <format_str_va+0x1b8>
    if (!is_signed) {
420019ae:	07500713          	li	a4,117
420019b2:	4c22                	lw	s8,8(sp)
420019b4:	98e797e3          	bne	a5,a4,42001342 <format_str_va+0x330>
        substr++, length--;
420019b8:	57fd                	li	a5,-1
420019ba:	98f4e4e3          	bltu	s1,a5,42001342 <format_str_va+0x330>
420019be:	9002                	ebreak
                void const *ptr = va_arg(vararg, void const *);
420019c0:	49d2                	lw	s3,20(sp)
420019c2:	4a62                	lw	s4,24(sp)
420019c4:	4af2                	lw	s5,28(sp)
420019c6:	0b11                	add	s6,s6,4
420019c8:	bb01                	j	420016d8 <format_str_va+0x6c6>
420019ca:	47c2                	lw	a5,16(sp)
420019cc:	49d2                	lw	s3,20(sp)
420019ce:	4a62                	lw	s4,24(sp)
420019d0:	4af2                	lw	s5,28(sp)
                size_t      length = va_arg(vararg, size_t);
420019d2:	8b3e                	mv	s6,a5
420019d4:	b311                	j	420016d8 <format_str_va+0x6c6>
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
420019d6:	07000713          	li	a4,112
420019da:	96e793e3          	bne	a5,a4,42001340 <format_str_va+0x32e>
420019de:	57fd                	li	a5,-1
420019e0:	32f4ff63          	bgeu	s1,a5,42001d1e <format_str_va+0xd0c>
420019e4:	00148793          	add	a5,s1,1
420019e8:	2c078963          	beqz	a5,42001cba <format_str_va+0xca8>
420019ec:	0014c783          	lbu	a5,1(s1)
420019f0:	07400713          	li	a4,116
420019f4:	0207e793          	or	a5,a5,32
420019f8:	94e794e3          	bne	a5,a4,42001340 <format_str_va+0x32e>
420019fc:	57f9                	li	a5,-2
420019fe:	30f4f663          	bgeu	s1,a5,42001d0a <format_str_va+0xcf8>
42001a02:	00248793          	add	a5,s1,2
42001a06:	30078163          	beqz	a5,42001d08 <format_str_va+0xcf6>
42001a0a:	0024c783          	lbu	a5,2(s1)
42001a0e:	07200713          	li	a4,114
42001a12:	0207e793          	or	a5,a5,32
42001a16:	92e795e3          	bne	a5,a4,42001340 <format_str_va+0x32e>
42001a1a:	57f5                	li	a5,-3
42001a1c:	2ef4f563          	bgeu	s1,a5,42001d06 <format_str_va+0xcf4>
42001a20:	00348793          	add	a5,s1,3
42001a24:	2e078063          	beqz	a5,42001d04 <format_str_va+0xcf2>
42001a28:	0034c783          	lbu	a5,3(s1)
42001a2c:	06400713          	li	a4,100
42001a30:	0207e793          	or	a5,a5,32
42001a34:	90e796e3          	bne	a5,a4,42001340 <format_str_va+0x32e>
42001a38:	57f1                	li	a5,-4
42001a3a:	2cf4f463          	bgeu	s1,a5,42001d02 <format_str_va+0xcf0>
42001a3e:	00448793          	add	a5,s1,4
42001a42:	2a078f63          	beqz	a5,42001d00 <format_str_va+0xcee>
42001a46:	0044c783          	lbu	a5,4(s1)
42001a4a:	06900713          	li	a4,105
42001a4e:	0207e793          	or	a5,a5,32
42001a52:	8ee797e3          	bne	a5,a4,42001340 <format_str_va+0x32e>
42001a56:	57ed                	li	a5,-5
42001a58:	2af4f363          	bgeu	s1,a5,42001cfe <format_str_va+0xcec>
42001a5c:	00548793          	add	a5,s1,5
42001a60:	28078e63          	beqz	a5,42001cfc <format_str_va+0xcea>
42001a64:	0054c783          	lbu	a5,5(s1)
42001a68:	06600713          	li	a4,102
42001a6c:	0207e793          	or	a5,a5,32
42001a70:	8ce798e3          	bne	a5,a4,42001340 <format_str_va+0x32e>
42001a74:	5769                	li	a4,-6
42001a76:	22e4f563          	bgeu	s1,a4,42001ca0 <format_str_va+0xc8e>
42001a7a:	00648713          	add	a4,s1,6
42001a7e:	22070063          	beqz	a4,42001c9e <format_str_va+0xc8c>
42001a82:	0064c703          	lbu	a4,6(s1)
42001a86:	02076713          	or	a4,a4,32
42001a8a:	8af71be3          	bne	a4,a5,42001340 <format_str_va+0x32e>
        *type_out      = FMT_TYPE_SIZE;
42001a8e:	478d                	li	a5,3
42001a90:	d43e                	sw	a5,40(sp)
42001a92:	4685                	li	a3,1
42001a94:	fe0ff06f          	j	42001274 <format_str_va+0x262>
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
42001a98:	4711                	li	a4,4
42001a9a:	0ee51063          	bne	a0,a4,42001b7a <format_str_va+0xb68>
        substr++, length--;
42001a9e:	57fd                	li	a5,-1
42001aa0:	20f4fe63          	bgeu	s1,a5,42001cbc <format_str_va+0xcaa>
42001aa4:	00148793          	add	a5,s1,1
42001aa8:	4681                	li	a3,0
42001aaa:	bb81                	j	420017fa <format_str_va+0x7e8>
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
42001aac:	57fd                	li	a5,-1
42001aae:	24f4f063          	bgeu	s1,a5,42001cee <format_str_va+0xcdc>
42001ab2:	00148793          	add	a5,s1,1
42001ab6:	22078b63          	beqz	a5,42001cec <format_str_va+0xcda>
42001aba:	0014c783          	lbu	a5,1(s1)
42001abe:	0207e793          	or	a5,a5,32
42001ac2:	18d78363          	beq	a5,a3,42001c48 <format_str_va+0xc36>
    } else if (length == 4 && lower(substr[0]) == 'l' && lower(substr[1]) == 'o' && lower(substr[2]) == 'n' && lower(substr[3]) == 'g') {
42001ac6:	02076713          	or	a4,a4,32
42001aca:	87a6                	mv	a5,s1
42001acc:	4685                	li	a3,1
    } else if (length == 4 && lower(substr[0]) == 'c' && lower(substr[1]) == 'h' && lower(substr[2]) == 'a' && lower(substr[3]) == 'r') {
42001ace:	1e078563          	beqz	a5,42001cb8 <format_str_va+0xca6>
42001ad2:	06300613          	li	a2,99
42001ad6:	86c715e3          	bne	a4,a2,42001340 <format_str_va+0x32e>
42001ada:	577d                	li	a4,-1
42001adc:	1ce7fd63          	bgeu	a5,a4,42001cb6 <format_str_va+0xca4>
42001ae0:	00178713          	add	a4,a5,1
42001ae4:	1c070863          	beqz	a4,42001cb4 <format_str_va+0xca2>
42001ae8:	0017c703          	lbu	a4,1(a5)
42001aec:	06800613          	li	a2,104
42001af0:	02076713          	or	a4,a4,32
42001af4:	84c716e3          	bne	a4,a2,42001340 <format_str_va+0x32e>
42001af8:	5779                	li	a4,-2
42001afa:	1ae7fc63          	bgeu	a5,a4,42001cb2 <format_str_va+0xca0>
42001afe:	00278713          	add	a4,a5,2
42001b02:	1a070763          	beqz	a4,42001cb0 <format_str_va+0xc9e>
42001b06:	0027c703          	lbu	a4,2(a5)
42001b0a:	06100613          	li	a2,97
42001b0e:	02076713          	or	a4,a4,32
42001b12:	82c717e3          	bne	a4,a2,42001340 <format_str_va+0x32e>
42001b16:	5775                	li	a4,-3
42001b18:	18e7fb63          	bgeu	a5,a4,42001cae <format_str_va+0xc9c>
42001b1c:	00378713          	add	a4,a5,3
42001b20:	1c070a63          	beqz	a4,42001cf4 <format_str_va+0xce2>
42001b24:	0037c783          	lbu	a5,3(a5)
42001b28:	07200713          	li	a4,114
42001b2c:	0207e793          	or	a5,a5,32
42001b30:	80e798e3          	bne	a5,a4,42001340 <format_str_va+0x32e>
        *type_out      = FMT_TYPE_CHAR;
42001b34:	d402                	sw	zero,40(sp)
        return true;
42001b36:	f3eff06f          	j	42001274 <format_str_va+0x262>
        } else if (length == 3 && substr[1] == '6' && substr[2] == '4') {
42001b3a:	03600693          	li	a3,54
42001b3e:	cad718e3          	bne	a4,a3,420017ee <format_str_va+0x7dc>
42001b42:	5779                	li	a4,-2
42001b44:	18e4f263          	bgeu	s1,a4,42001cc8 <format_str_va+0xcb6>
42001b48:	00248713          	add	a4,s1,2
42001b4c:	16070d63          	beqz	a4,42001cc6 <format_str_va+0xcb4>
42001b50:	0024c683          	lbu	a3,2(s1)
42001b54:	03400713          	li	a4,52
42001b58:	c8e69be3          	bne	a3,a4,420017ee <format_str_va+0x7dc>
            *is_signed_out = lower(substr[0]) == 'i';
42001b5c:	f9778793          	add	a5,a5,-105
            *type_out      = FMT_TYPE_INT64;
42001b60:	4711                	li	a4,4
42001b62:	d43a                	sw	a4,40(sp)
            *is_signed_out = lower(substr[0]) == 'i';
42001b64:	0017b693          	seqz	a3,a5
            return true;
42001b68:	f0cff06f          	j	42001274 <format_str_va+0x262>
            *is_signed_out = lower(substr[0]) == 'i';
42001b6c:	f9778793          	add	a5,a5,-105
            *type_out      = FMT_TYPE_INT8;
42001b70:	d402                	sw	zero,40(sp)
            *is_signed_out = lower(substr[0]) == 'i';
42001b72:	0017b693          	seqz	a3,a5
            return true;
42001b76:	efeff06f          	j	42001274 <format_str_va+0x262>
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
42001b7a:	471d                	li	a4,7
42001b7c:	e2e509e3          	beq	a0,a4,420019ae <format_str_va+0x99c>
        substr++, length--;
42001b80:	577d                	li	a4,-1
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
42001b82:	00148793          	add	a5,s1,1
        substr++, length--;
42001b86:	16e4f963          	bgeu	s1,a4,42001cf8 <format_str_va+0xce6>
42001b8a:	fff50713          	add	a4,a0,-1
42001b8e:	4681                	li	a3,0
42001b90:	e46ff06f          	j	420011d6 <format_str_va+0x1c4>
        if (length == 2 && substr[1] == '8') {
42001b94:	577d                	li	a4,-1
42001b96:	12e4f563          	bgeu	s1,a4,42001cc0 <format_str_va+0xcae>
42001b9a:	00148713          	add	a4,s1,1
42001b9e:	f8071b63          	bnez	a4,42001334 <format_str_va+0x322>
42001ba2:	9002                	ebreak
    if (length == 5 && lower(substr[0]) == 'l' && lower(substr[1]) == 'l' && lower(substr[2]) == 'o' &&
42001ba4:	567d                	li	a2,-1
42001ba6:	1ac7f863          	bgeu	a5,a2,42001d56 <format_str_va+0xd44>
42001baa:	00178613          	add	a2,a5,1
42001bae:	1a060363          	beqz	a2,42001d54 <format_str_va+0xd42>
42001bb2:	0017c603          	lbu	a2,1(a5)
42001bb6:	02066613          	or	a2,a2,32
42001bba:	f8e61363          	bne	a2,a4,42001340 <format_str_va+0x32e>
42001bbe:	5779                	li	a4,-2
42001bc0:	18e7f963          	bgeu	a5,a4,42001d52 <format_str_va+0xd40>
42001bc4:	00278713          	add	a4,a5,2
42001bc8:	18070463          	beqz	a4,42001d50 <format_str_va+0xd3e>
42001bcc:	0027c703          	lbu	a4,2(a5)
42001bd0:	06f00613          	li	a2,111
42001bd4:	02076713          	or	a4,a4,32
42001bd8:	f6c71463          	bne	a4,a2,42001340 <format_str_va+0x32e>
        lower(substr[3]) == 'n' && lower(substr[4]) == 'g') {
42001bdc:	5775                	li	a4,-3
42001bde:	16e7f863          	bgeu	a5,a4,42001d4e <format_str_va+0xd3c>
42001be2:	00378713          	add	a4,a5,3
42001be6:	16070363          	beqz	a4,42001d4c <format_str_va+0xd3a>
42001bea:	0037c703          	lbu	a4,3(a5)
    if (length == 5 && lower(substr[0]) == 'l' && lower(substr[1]) == 'l' && lower(substr[2]) == 'o' &&
42001bee:	06e00613          	li	a2,110
42001bf2:	02076713          	or	a4,a4,32
42001bf6:	f4c71563          	bne	a4,a2,42001340 <format_str_va+0x32e>
        lower(substr[3]) == 'n' && lower(substr[4]) == 'g') {
42001bfa:	5771                	li	a4,-4
42001bfc:	14e7f763          	bgeu	a5,a4,42001d4a <format_str_va+0xd38>
42001c00:	00478713          	add	a4,a5,4
42001c04:	14070263          	beqz	a4,42001d48 <format_str_va+0xd36>
42001c08:	0047c783          	lbu	a5,4(a5)
42001c0c:	06700713          	li	a4,103
42001c10:	0207e793          	or	a5,a5,32
42001c14:	f2e79663          	bne	a5,a4,42001340 <format_str_va+0x32e>
        *type_out      = FMT_TYPE_LLONG;
42001c18:	4791                	li	a5,4
42001c1a:	d43e                	sw	a5,40(sp)
        return true;
42001c1c:	e58ff06f          	j	42001274 <format_str_va+0x262>
        } else if (length == 3 && substr[1] == '1' && substr[2] == '6') {
42001c20:	5779                	li	a4,-2
42001c22:	0ce4f863          	bgeu	s1,a4,42001cf2 <format_str_va+0xce0>
42001c26:	00248713          	add	a4,s1,2
42001c2a:	c379                	beqz	a4,42001cf0 <format_str_va+0xcde>
42001c2c:	0024c683          	lbu	a3,2(s1)
42001c30:	03600713          	li	a4,54
42001c34:	bae69de3          	bne	a3,a4,420017ee <format_str_va+0x7dc>
            *is_signed_out = lower(substr[0]) == 'i';
42001c38:	f9778793          	add	a5,a5,-105
            *type_out      = FMT_TYPE_INT16;
42001c3c:	4705                	li	a4,1
42001c3e:	d43a                	sw	a4,40(sp)
            *is_signed_out = lower(substr[0]) == 'i';
42001c40:	0017b693          	seqz	a3,a5
            return true;
42001c44:	e30ff06f          	j	42001274 <format_str_va+0x262>
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
42001c48:	57f9                	li	a5,-2
42001c4a:	0ef4f363          	bgeu	s1,a5,42001d30 <format_str_va+0xd1e>
42001c4e:	00248793          	add	a5,s1,2
42001c52:	cff1                	beqz	a5,42001d2e <format_str_va+0xd1c>
42001c54:	0024c783          	lbu	a5,2(s1)
42001c58:	07a00693          	li	a3,122
42001c5c:	0207e793          	or	a5,a5,32
42001c60:	e6d793e3          	bne	a5,a3,42001ac6 <format_str_va+0xab4>
        lower(substr[3]) == 'e') {
42001c64:	57f5                	li	a5,-3
42001c66:	0cf4f363          	bgeu	s1,a5,42001d2c <format_str_va+0xd1a>
42001c6a:	00348793          	add	a5,s1,3
42001c6e:	cfd5                	beqz	a5,42001d2a <format_str_va+0xd18>
42001c70:	0034c783          	lbu	a5,3(s1)
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
42001c74:	06500693          	li	a3,101
42001c78:	0207e793          	or	a5,a5,32
42001c7c:	e4d795e3          	bne	a5,a3,42001ac6 <format_str_va+0xab4>
        *type_out      = FMT_TYPE_SIZE;
42001c80:	478d                	li	a5,3
42001c82:	d43e                	sw	a5,40(sp)
42001c84:	4681                	li	a3,0
42001c86:	deeff06f          	j	42001274 <format_str_va+0x262>
            while (i < length && msg[i] != '%') i++;
42001c8a:	9002                	ebreak
            *is_signed_out = lower(substr[0]) == 'i';
42001c8c:	f9778793          	add	a5,a5,-105
            *type_out      = FMT_TYPE_INT32;
42001c90:	470d                	li	a4,3
42001c92:	d43a                	sw	a4,40(sp)
            *is_signed_out = lower(substr[0]) == 'i';
42001c94:	0017b693          	seqz	a3,a5
            return true;
42001c98:	ddcff06f          	j	42001274 <format_str_va+0x262>
        if (msg[i] == '%' && i + 1 < length && msg[i + 1] == '%') {
42001c9c:	9002                	ebreak
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
42001c9e:	9002                	ebreak
42001ca0:	9002                	ebreak
                            fmt_type_index(type, ptr, i),
42001ca2:	9002                	ebreak
                    long long value = fmt_type_index(type, ptr, i);
42001ca4:	9002                	ebreak
                            fmt_type_index(type, ptr, i),
42001ca6:	9002                	ebreak
            if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'c' && lower(msg[i + 3]) == 's') {
42001ca8:	9002                	ebreak
        } else if (length == 3 && substr[1] == '3' && substr[2] == '2') {
42001caa:	9002                	ebreak
42001cac:	9002                	ebreak
    } else if (length == 4 && lower(substr[0]) == 'c' && lower(substr[1]) == 'h' && lower(substr[2]) == 'a' && lower(substr[3]) == 'r') {
42001cae:	9002                	ebreak
42001cb0:	9002                	ebreak
42001cb2:	9002                	ebreak
42001cb4:	9002                	ebreak
42001cb6:	9002                	ebreak
42001cb8:	9002                	ebreak
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
42001cba:	9002                	ebreak
        substr++, length--;
42001cbc:	9002                	ebreak
    if (length == 5 && lower(substr[0]) == 'l' && lower(substr[1]) == 'l' && lower(substr[2]) == 'o' &&
42001cbe:	9002                	ebreak
        if (length == 2 && substr[1] == '8') {
42001cc0:	9002                	ebreak
42001cc2:	9002                	ebreak
42001cc4:	9002                	ebreak
        } else if (length == 3 && substr[1] == '6' && substr[2] == '4') {
42001cc6:	9002                	ebreak
42001cc8:	9002                	ebreak
    } else if (length == 4 && lower(substr[0]) == 'l' && lower(substr[1]) == 'o' && lower(substr[2]) == 'n' && lower(substr[3]) == 'g') {
42001cca:	9002                	ebreak
42001ccc:	9002                	ebreak
        } else if (length == 3 && substr[1] == '1' && substr[2] == '6') {
42001cce:	9002                	ebreak
42001cd0:	9002                	ebreak
                    long long value = fmt_type_index(type, ptr, i);
42001cd2:	9002                	ebreak
    } else if (length == 5 && lower(substr[0]) == 's' && lower(substr[1]) == 'h' && lower(substr[2]) == 'o' && lower(substr[3]) == 'r' && lower(substr[4]) == 't') {
42001cd4:	9002                	ebreak
42001cd6:	9002                	ebreak
42001cd8:	9002                	ebreak
42001cda:	9002                	ebreak
42001cdc:	9002                	ebreak
42001cde:	9002                	ebreak
42001ce0:	9002                	ebreak
42001ce2:	9002                	ebreak
    } else if (length == 4 && lower(substr[0]) == 'l' && lower(substr[1]) == 'o' && lower(substr[2]) == 'n' && lower(substr[3]) == 'g') {
42001ce4:	9002                	ebreak
42001ce6:	9002                	ebreak
42001ce8:	9002                	ebreak
42001cea:	9002                	ebreak
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
42001cec:	9002                	ebreak
42001cee:	9002                	ebreak
        } else if (length == 3 && substr[1] == '1' && substr[2] == '6') {
42001cf0:	9002                	ebreak
42001cf2:	9002                	ebreak
    } else if (length == 4 && lower(substr[0]) == 'c' && lower(substr[1]) == 'h' && lower(substr[2]) == 'a' && lower(substr[3]) == 'r') {
42001cf4:	9002                	ebreak
    } else if (length == 4 && lower(substr[0]) == 'l' && lower(substr[1]) == 'o' && lower(substr[2]) == 'n' && lower(substr[3]) == 'g') {
42001cf6:	9002                	ebreak
        substr++, length--;
42001cf8:	9002                	ebreak
            } else if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'l' && lower(msg[i + 3]) == 's') {
42001cfa:	9002                	ebreak
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
42001cfc:	9002                	ebreak
42001cfe:	9002                	ebreak
42001d00:	9002                	ebreak
42001d02:	9002                	ebreak
42001d04:	9002                	ebreak
42001d06:	9002                	ebreak
42001d08:	9002                	ebreak
42001d0a:	9002                	ebreak
    } else if (length == 4 && lower(substr[0]) == 'l' && lower(substr[1]) == 'o' && lower(substr[2]) == 'n' && lower(substr[3]) == 'g') {
42001d0c:	4611                	li	a2,4
42001d0e:	bac70ee3          	beq	a4,a2,420018ca <format_str_va+0x8b8>
    } else if (length == 3 && lower(substr[0]) == 'i' && lower(substr[1]) == 'n' && lower(substr[2]) == 't') {
42001d12:	460d                	li	a2,3
42001d14:	aec703e3          	beq	a4,a2,420017fa <format_str_va+0x7e8>
42001d18:	4c22                	lw	s8,8(sp)
42001d1a:	e28ff06f          	j	42001342 <format_str_va+0x330>
    } else if (length == 7 && lower(substr[0]) == 'p' && lower(substr[1]) == 't' && lower(substr[2]) == 'r' && lower(substr[3]) == 'd' && lower(substr[4]) == 'i' && lower(substr[5]) == 'f' && lower(substr[6]) == 'f') {
42001d1e:	9002                	ebreak
    } else if (length == 3 && lower(substr[0]) == 'i' && lower(substr[1]) == 'n' && lower(substr[2]) == 't') {
42001d20:	9002                	ebreak
42001d22:	9002                	ebreak
42001d24:	9002                	ebreak
42001d26:	9002                	ebreak
42001d28:	9002                	ebreak
        lower(substr[3]) == 'e') {
42001d2a:	9002                	ebreak
42001d2c:	9002                	ebreak
    if (length == 4 && lower(substr[0]) == 's' && lower(substr[1]) == 'i' && lower(substr[2]) == 'z' &&
42001d2e:	9002                	ebreak
42001d30:	9002                	ebreak
            i = fmt_end + 1;
42001d32:	9002                	ebreak
                    long long value = fmt_type_index(type, ptr, i);
42001d34:	9002                	ebreak
    if (lower(substr[0]) == 'u' || lower(substr[0]) == 'i') {
42001d36:	9002                	ebreak
                lowercase = substr[0] & 0x20;
42001d38:	9002                	ebreak
        if (msg[i] == '%' && i + 1 < length && msg[i + 1] == '%') {
42001d3a:	9002                	ebreak
            fmt_end += (ptrdiff_t)i;
42001d3c:	9002                	ebreak
            if ((size_t)fmt_end == i + 4 && lower(msg[i + 2]) == 'c' && lower(msg[i + 3]) == 's') {
42001d3e:	9002                	ebreak
                            fmt_type_index(type, ptr, i),
42001d40:	9002                	ebreak
                    long long value = fmt_type_index(type, ptr, i);
42001d42:	9002                	ebreak
                            fmt_type_index(type, ptr, i),
42001d44:	9002                	ebreak
            if (msg[i + 1] != '{' || fmt_end == -1) {
42001d46:	9002                	ebreak
        lower(substr[3]) == 'n' && lower(substr[4]) == 'g') {
42001d48:	9002                	ebreak
42001d4a:	9002                	ebreak
42001d4c:	9002                	ebreak
42001d4e:	9002                	ebreak
    if (length == 5 && lower(substr[0]) == 'l' && lower(substr[1]) == 'l' && lower(substr[2]) == 'o' &&
42001d50:	9002                	ebreak
42001d52:	9002                	ebreak
42001d54:	9002                	ebreak
42001d56:	9002                	ebreak
                    if (!format_str_output(
42001d58:	9002                	ebreak

42001d5a <cstr_length>:


// Compute the length of a C-string.
size_t cstr_length(char const *string) {
    char const *ptr = string;
    while (*ptr) ptr++;
42001d5a:	c115                	beqz	a0,42001d7e <cstr_length+0x24>
42001d5c:	00054783          	lbu	a5,0(a0)
42001d60:	cf89                	beqz	a5,42001d7a <cstr_length+0x20>
    char const *ptr = string;
42001d62:	87aa                	mv	a5,a0
    while (*ptr) ptr++;
42001d64:	56fd                	li	a3,-1
42001d66:	00d7fc63          	bgeu	a5,a3,42001d7e <cstr_length+0x24>
42001d6a:	0785                	add	a5,a5,1
42001d6c:	cb89                	beqz	a5,42001d7e <cstr_length+0x24>
42001d6e:	0007c703          	lbu	a4,0(a5)
42001d72:	fb75                	bnez	a4,42001d66 <cstr_length+0xc>
    return ptr - string;
42001d74:	40a78533          	sub	a0,a5,a0
42001d78:	8082                	ret
    while (*ptr) ptr++;
42001d7a:	4501                	li	a0,0
}
42001d7c:	8082                	ret
    while (*ptr) ptr++;
42001d7e:	9002                	ebreak

42001d80 <cstr_length_upto>:

// Compute the length of a C-string at most `max_length` characters long.
size_t cstr_length_upto(char const *string, size_t max_len) {
42001d80:	86aa                	mv	a3,a0
    for (size_t i = 0; i < max_len; i++) {
42001d82:	4781                	li	a5,0
size_t cstr_length_upto(char const *string, size_t max_len) {
42001d84:	852e                	mv	a0,a1
42001d86:	8736                	mv	a4,a3
    for (size_t i = 0; i < max_len; i++) {
42001d88:	02a78263          	beq	a5,a0,42001dac <cstr_length_upto+0x2c>
        if (!string[i])
42001d8c:	00f68633          	add	a2,a3,a5
42001d90:	0007cf63          	bltz	a5,42001dae <cstr_length_upto+0x2e>
42001d94:	00d66f63          	bltu	a2,a3,42001db2 <cstr_length_upto+0x32>
42001d98:	cf09                	beqz	a4,42001db2 <cstr_length_upto+0x32>
42001d9a:	00074603          	lbu	a2,0(a4)
42001d9e:	00178813          	add	a6,a5,1
42001da2:	0705                	add	a4,a4,1
42001da4:	ca01                	beqz	a2,42001db4 <cstr_length_upto+0x34>
    for (size_t i = 0; i < max_len; i++) {
42001da6:	87c2                	mv	a5,a6
42001da8:	fea792e3          	bne	a5,a0,42001d8c <cstr_length_upto+0xc>
42001dac:	8082                	ret
        if (!string[i])
42001dae:	fec6f5e3          	bgeu	a3,a2,42001d98 <cstr_length_upto+0x18>
42001db2:	9002                	ebreak
            return i;
42001db4:	853e                	mv	a0,a5
    }
    return max_len;
}
42001db6:	8082                	ret

42001db8 <cstr_index>:
// Returns -1 when not found.
ptrdiff_t cstr_index(char const *string, char value) {
    char const *ptr = string;

    // Find first index.
    while (*ptr) {
42001db8:	c50d                	beqz	a0,42001de2 <cstr_index+0x2a>
42001dba:	00054703          	lbu	a4,0(a0)
42001dbe:	cf09                	beqz	a4,42001dd8 <cstr_index+0x20>
    char const *ptr = string;
42001dc0:	87aa                	mv	a5,a0
        if (*ptr == value)
            return ptr - string;
        ptr++;
42001dc2:	56fd                	li	a3,-1
        if (*ptr == value)
42001dc4:	cf99                	beqz	a5,42001de2 <cstr_index+0x2a>
42001dc6:	00b70b63          	beq	a4,a1,42001ddc <cstr_index+0x24>
        ptr++;
42001dca:	00d7fc63          	bgeu	a5,a3,42001de2 <cstr_index+0x2a>
42001dce:	0785                	add	a5,a5,1
    while (*ptr) {
42001dd0:	cb89                	beqz	a5,42001de2 <cstr_index+0x2a>
42001dd2:	0007c703          	lbu	a4,0(a5)
42001dd6:	f77d                	bnez	a4,42001dc4 <cstr_index+0xc>
    }

    return -1;
42001dd8:	557d                	li	a0,-1
}
42001dda:	8082                	ret
            return ptr - string;
42001ddc:	40a78533          	sub	a0,a5,a0
42001de0:	8082                	ret
    while (*ptr) {
42001de2:	9002                	ebreak

42001de4 <cstr_last_index>:

// Find the last occurrance `value` in C-string `string`.
// Returns -1 when not found.
ptrdiff_t cstr_last_index(char const *string, char value) {
42001de4:	872a                	mv	a4,a0

// Find the last occurrance `value` in C-string `string` up to and excluding `last_index`.
// Returns -1 when not found.
ptrdiff_t cstr_last_index_upto(char const *string, char value, size_t last_index) {
    ptrdiff_t found = -1;
    for (size_t i = 0; string[i] && i < last_index; i++) {
42001de6:	c531                	beqz	a0,42001e32 <cstr_last_index+0x4e>
42001de8:	00054803          	lbu	a6,0(a0)
42001dec:	04080763          	beqz	a6,42001e3a <cstr_last_index+0x56>
42001df0:	86aa                	mv	a3,a0
42001df2:	4781                	li	a5,0
    ptrdiff_t found = -1;
42001df4:	557d                	li	a0,-1
    for (size_t i = 0; string[i] && i < last_index; i++) {
42001df6:	537d                	li	t1,-1
42001df8:	863e                	mv	a2,a5
        if (string[i] == value)
42001dfa:	00f708b3          	add	a7,a4,a5
42001dfe:	0785                	add	a5,a5,1
42001e00:	02064763          	bltz	a2,42001e2e <cstr_last_index+0x4a>
42001e04:	02e8e763          	bltu	a7,a4,42001e32 <cstr_last_index+0x4e>
42001e08:	c68d                	beqz	a3,42001e32 <cstr_last_index+0x4e>
42001e0a:	01059363          	bne	a1,a6,42001e10 <cstr_last_index+0x2c>
            found = (ptrdiff_t)i;
42001e0e:	8532                	mv	a0,a2
    for (size_t i = 0; string[i] && i < last_index; i++) {
42001e10:	00f70633          	add	a2,a4,a5
42001e14:	0207c063          	bltz	a5,42001e34 <cstr_last_index+0x50>
42001e18:	00e66d63          	bltu	a2,a4,42001e32 <cstr_last_index+0x4e>
42001e1c:	0685                	add	a3,a3,1
42001e1e:	ca91                	beqz	a3,42001e32 <cstr_last_index+0x4e>
42001e20:	0006c803          	lbu	a6,0(a3)
42001e24:	00080c63          	beqz	a6,42001e3c <cstr_last_index+0x58>
42001e28:	fc6798e3          	bne	a5,t1,42001df8 <cstr_last_index+0x14>
42001e2c:	8082                	ret
        if (string[i] == value)
42001e2e:	fd177de3          	bgeu	a4,a7,42001e08 <cstr_last_index+0x24>
    for (size_t i = 0; string[i] && i < last_index; i++) {
42001e32:	9002                	ebreak
42001e34:	fec774e3          	bgeu	a4,a2,42001e1c <cstr_last_index+0x38>
42001e38:	9002                	ebreak
    ptrdiff_t found = -1;
42001e3a:	557d                	li	a0,-1
}
42001e3c:	8082                	ret

42001e3e <cstr_index_from>:
    char const *ptr = string + first_index;
42001e3e:	00c507b3          	add	a5,a0,a2
42001e42:	02064963          	bltz	a2,42001e74 <cstr_index_from+0x36>
42001e46:	02a7e663          	bltu	a5,a0,42001e72 <cstr_index_from+0x34>
    for (size_t i = 0; i < first_index; i++) {
42001e4a:	872a                	mv	a4,a0
42001e4c:	4781                	li	a5,0
42001e4e:	02c78863          	beq	a5,a2,42001e7e <cstr_index_from+0x40>
        if (!string[i])
42001e52:	00f506b3          	add	a3,a0,a5
42001e56:	0007cc63          	bltz	a5,42001e6e <cstr_index_from+0x30>
42001e5a:	00a6ec63          	bltu	a3,a0,42001e72 <cstr_index_from+0x34>
42001e5e:	cb11                	beqz	a4,42001e72 <cstr_index_from+0x34>
42001e60:	00074683          	lbu	a3,0(a4)
42001e64:	0785                	add	a5,a5,1
42001e66:	0705                	add	a4,a4,1
42001e68:	f2fd                	bnez	a3,42001e4e <cstr_index_from+0x10>
            return -1;
42001e6a:	557d                	li	a0,-1
}
42001e6c:	8082                	ret
        if (!string[i])
42001e6e:	fed578e3          	bgeu	a0,a3,42001e5e <cstr_index_from+0x20>
    while (*ptr) {
42001e72:	9002                	ebreak
    char const *ptr = string + first_index;
42001e74:	fef56fe3          	bltu	a0,a5,42001e72 <cstr_index_from+0x34>
    for (size_t i = 0; i < first_index; i++) {
42001e78:	872a                	mv	a4,a0
42001e7a:	4781                	li	a5,0
42001e7c:	bfc9                	j	42001e4e <cstr_index_from+0x10>
    char const *ptr = string + first_index;
42001e7e:	97aa                	add	a5,a5,a0
    while (*ptr) {
42001e80:	dbed                	beqz	a5,42001e72 <cstr_index_from+0x34>
42001e82:	0007c703          	lbu	a4,0(a5)
42001e86:	d375                	beqz	a4,42001e6a <cstr_index_from+0x2c>
        ptr++;
42001e88:	56fd                	li	a3,-1
        if (*ptr == value)
42001e8a:	d7e5                	beqz	a5,42001e72 <cstr_index_from+0x34>
42001e8c:	00e58b63          	beq	a1,a4,42001ea2 <cstr_index_from+0x64>
        ptr++;
42001e90:	fed7f1e3          	bgeu	a5,a3,42001e72 <cstr_index_from+0x34>
42001e94:	0785                	add	a5,a5,1
    while (*ptr) {
42001e96:	dff1                	beqz	a5,42001e72 <cstr_index_from+0x34>
42001e98:	0007c703          	lbu	a4,0(a5)
42001e9c:	f77d                	bnez	a4,42001e8a <cstr_index_from+0x4c>
            return -1;
42001e9e:	557d                	li	a0,-1
}
42001ea0:	8082                	ret
            return ptr - string;
42001ea2:	40a78533          	sub	a0,a5,a0
42001ea6:	8082                	ret

42001ea8 <cstr_last_index_upto>:
ptrdiff_t cstr_last_index_upto(char const *string, char value, size_t last_index) {
42001ea8:	872a                	mv	a4,a0
    for (size_t i = 0; string[i] && i < last_index; i++) {
42001eaa:	c939                	beqz	a0,42001f00 <cstr_last_index_upto+0x58>
42001eac:	00054883          	lbu	a7,0(a0)
42001eb0:	04088c63          	beqz	a7,42001f08 <cstr_last_index_upto+0x60>
42001eb4:	ca31                	beqz	a2,42001f08 <cstr_last_index_upto+0x60>
42001eb6:	4e05                	li	t3,1
42001eb8:	962a                	add	a2,a2,a0
42001eba:	87aa                	mv	a5,a0
42001ebc:	4681                	li	a3,0
    ptrdiff_t found = -1;
42001ebe:	557d                	li	a0,-1
42001ec0:	40ee0e33          	sub	t3,t3,a4
42001ec4:	8836                	mv	a6,a3
        if (string[i] == value)
42001ec6:	00d70333          	add	t1,a4,a3
42001eca:	00fe06b3          	add	a3,t3,a5
42001ece:	02084763          	bltz	a6,42001efc <cstr_last_index_upto+0x54>
42001ed2:	02e36763          	bltu	t1,a4,42001f00 <cstr_last_index_upto+0x58>
42001ed6:	c78d                	beqz	a5,42001f00 <cstr_last_index_upto+0x58>
42001ed8:	01159363          	bne	a1,a7,42001ede <cstr_last_index_upto+0x36>
            found = (ptrdiff_t)i;
42001edc:	8542                	mv	a0,a6
    for (size_t i = 0; string[i] && i < last_index; i++) {
42001ede:	00d70833          	add	a6,a4,a3
42001ee2:	0206c063          	bltz	a3,42001f02 <cstr_last_index_upto+0x5a>
42001ee6:	00e86d63          	bltu	a6,a4,42001f00 <cstr_last_index_upto+0x58>
42001eea:	0785                	add	a5,a5,1
42001eec:	cb91                	beqz	a5,42001f00 <cstr_last_index_upto+0x58>
42001eee:	0007c883          	lbu	a7,0(a5)
42001ef2:	00088c63          	beqz	a7,42001f0a <cstr_last_index_upto+0x62>
42001ef6:	fcc797e3          	bne	a5,a2,42001ec4 <cstr_last_index_upto+0x1c>
42001efa:	8082                	ret
        if (string[i] == value)
42001efc:	fc677de3          	bgeu	a4,t1,42001ed6 <cstr_last_index_upto+0x2e>
    for (size_t i = 0; string[i] && i < last_index; i++) {
42001f00:	9002                	ebreak
42001f02:	ff0774e3          	bgeu	a4,a6,42001eea <cstr_last_index_upto+0x42>
42001f06:	9002                	ebreak
    ptrdiff_t found = -1;
42001f08:	557d                	li	a0,-1
    }
    return found;
}
42001f0a:	8082                	ret

42001f0c <cstr_equals>:


// Test the equality of two C-strings.
bool cstr_equals(char const *a, char const *b) {
    while (1) {
        if (*a != *b)
42001f0c:	cd0d                	beqz	a0,42001f46 <cstr_equals+0x3a>
42001f0e:	00054783          	lbu	a5,0(a0)
42001f12:	c995                	beqz	a1,42001f46 <cstr_equals+0x3a>
42001f14:	0005c703          	lbu	a4,0(a1)
42001f18:	02f71363          	bne	a4,a5,42001f3e <cstr_equals+0x32>
            return false;
        if (!*a)
            return true;
        a++, b++;
42001f1c:	577d                	li	a4,-1
        if (!*a)
42001f1e:	c505                	beqz	a0,42001f46 <cstr_equals+0x3a>
42001f20:	c38d                	beqz	a5,42001f42 <cstr_equals+0x36>
        a++, b++;
42001f22:	02e57263          	bgeu	a0,a4,42001f46 <cstr_equals+0x3a>
42001f26:	0505                	add	a0,a0,1
42001f28:	00e5ff63          	bgeu	a1,a4,42001f46 <cstr_equals+0x3a>
42001f2c:	0585                	add	a1,a1,1
        if (*a != *b)
42001f2e:	cd01                	beqz	a0,42001f46 <cstr_equals+0x3a>
42001f30:	00054783          	lbu	a5,0(a0)
42001f34:	c989                	beqz	a1,42001f46 <cstr_equals+0x3a>
42001f36:	0005c683          	lbu	a3,0(a1)
42001f3a:	fef682e3          	beq	a3,a5,42001f1e <cstr_equals+0x12>
            return false;
42001f3e:	4501                	li	a0,0
42001f40:	8082                	ret
            return true;
42001f42:	4505                	li	a0,1
    }
}
42001f44:	8082                	ret
        if (*a != *b)
42001f46:	9002                	ebreak

42001f48 <cstr_prefix_equals>:

// Test the of the first `length` characters equality of two C-strings.
bool cstr_prefix_equals(char const *a, char const *b, size_t length) {
    while (length--) {
42001f48:	c605                	beqz	a2,42001f70 <cstr_prefix_equals+0x28>
42001f4a:	962e                	add	a2,a2,a1
        if (*a != *b)
            return false;
        if (!*a)
            return true;
        a++, b++;
42001f4c:	56fd                	li	a3,-1
        if (*a != *b)
42001f4e:	c50d                	beqz	a0,42001f78 <cstr_prefix_equals+0x30>
42001f50:	00054703          	lbu	a4,0(a0)
42001f54:	c195                	beqz	a1,42001f78 <cstr_prefix_equals+0x30>
42001f56:	0005c783          	lbu	a5,0(a1)
42001f5a:	00e79d63          	bne	a5,a4,42001f74 <cstr_prefix_equals+0x2c>
        if (!*a)
42001f5e:	cb89                	beqz	a5,42001f70 <cstr_prefix_equals+0x28>
        a++, b++;
42001f60:	00d57c63          	bgeu	a0,a3,42001f78 <cstr_prefix_equals+0x30>
42001f64:	0505                	add	a0,a0,1
42001f66:	00d5f963          	bgeu	a1,a3,42001f78 <cstr_prefix_equals+0x30>
42001f6a:	0585                	add	a1,a1,1
    while (length--) {
42001f6c:	feb611e3          	bne	a2,a1,42001f4e <cstr_prefix_equals+0x6>
            return true;
42001f70:	4505                	li	a0,1
42001f72:	8082                	ret
            return false;
42001f74:	4501                	li	a0,0
    }
    return true;
}
42001f76:	8082                	ret
        a++, b++;
42001f78:	9002                	ebreak

42001f7a <cstr_equals_case>:


// ASCII character to lower case.
static inline char ascii_char_to_lower(char c) __attribute__((const));
static inline char ascii_char_to_lower(char c) {
    if (c >= 'A' && c <= 'Z') {
42001f7a:	4865                	li	a6,25
    while (1) {
        if (ascii_char_to_lower(*a) != ascii_char_to_lower(*b))
            return false;
        if (!*a)
            return true;
        a++, b++;
42001f7c:	58fd                	li	a7,-1
        if (ascii_char_to_lower(*a) != ascii_char_to_lower(*b))
42001f7e:	c529                	beqz	a0,42001fc8 <cstr_equals_case+0x4e>
42001f80:	00054783          	lbu	a5,0(a0)
42001f84:	fbf78713          	add	a4,a5,-65
42001f88:	0ff77713          	zext.b	a4,a4
        return c | 0x20;
    } else {
        return c;
42001f8c:	863e                	mv	a2,a5
    if (c >= 'A' && c <= 'Z') {
42001f8e:	00e86463          	bltu	a6,a4,42001f96 <cstr_equals_case+0x1c>
        return c | 0x20;
42001f92:	0207e613          	or	a2,a5,32
42001f96:	c98d                	beqz	a1,42001fc8 <cstr_equals_case+0x4e>
42001f98:	0005c703          	lbu	a4,0(a1)
    if (c >= 'A' && c <= 'Z') {
42001f9c:	fbf70693          	add	a3,a4,-65
42001fa0:	0ff6f693          	zext.b	a3,a3
42001fa4:	00d86463          	bltu	a6,a3,42001fac <cstr_equals_case+0x32>
        return c | 0x20;
42001fa8:	02076713          	or	a4,a4,32
42001fac:	00c71a63          	bne	a4,a2,42001fc0 <cstr_equals_case+0x46>
        if (!*a)
42001fb0:	cb91                	beqz	a5,42001fc4 <cstr_equals_case+0x4a>
        a++, b++;
42001fb2:	01157b63          	bgeu	a0,a7,42001fc8 <cstr_equals_case+0x4e>
42001fb6:	0505                	add	a0,a0,1
42001fb8:	0115f863          	bgeu	a1,a7,42001fc8 <cstr_equals_case+0x4e>
42001fbc:	0585                	add	a1,a1,1
        if (ascii_char_to_lower(*a) != ascii_char_to_lower(*b))
42001fbe:	b7c1                	j	42001f7e <cstr_equals_case+0x4>
            return false;
42001fc0:	4501                	li	a0,0
42001fc2:	8082                	ret
            return true;
42001fc4:	4505                	li	a0,1
    }
}
42001fc6:	8082                	ret
        a++, b++;
42001fc8:	9002                	ebreak

42001fca <cstr_prefix_equals_case>:

// Test the of the first `length` characters equality of two C-strings, case-insensitive.
bool cstr_prefix_equals_case(char const *a, char const *b, size_t length) {
    while (length--) {
42001fca:	c631                	beqz	a2,42002016 <cstr_prefix_equals_case+0x4c>
42001fcc:	962e                	add	a2,a2,a1
    if (c >= 'A' && c <= 'Z') {
42001fce:	48e5                	li	a7,25
        if (ascii_char_to_lower(*a) != ascii_char_to_lower(*b))
            return false;
        if (!*a)
            return true;
        a++, b++;
42001fd0:	537d                	li	t1,-1
        if (ascii_char_to_lower(*a) != ascii_char_to_lower(*b))
42001fd2:	c531                	beqz	a0,4200201e <cstr_prefix_equals_case+0x54>
42001fd4:	00054783          	lbu	a5,0(a0)
42001fd8:	fbf78713          	add	a4,a5,-65
42001fdc:	0ff77713          	zext.b	a4,a4
        return c;
42001fe0:	883e                	mv	a6,a5
    if (c >= 'A' && c <= 'Z') {
42001fe2:	00e8e463          	bltu	a7,a4,42001fea <cstr_prefix_equals_case+0x20>
        return c | 0x20;
42001fe6:	0207e813          	or	a6,a5,32
42001fea:	c995                	beqz	a1,4200201e <cstr_prefix_equals_case+0x54>
42001fec:	0005c683          	lbu	a3,0(a1)
    if (c >= 'A' && c <= 'Z') {
42001ff0:	fbf68713          	add	a4,a3,-65
42001ff4:	0ff77713          	zext.b	a4,a4
42001ff8:	00e8e463          	bltu	a7,a4,42002000 <cstr_prefix_equals_case+0x36>
        return c | 0x20;
42001ffc:	0206e693          	or	a3,a3,32
42002000:	01069d63          	bne	a3,a6,4200201a <cstr_prefix_equals_case+0x50>
        if (!*a)
42002004:	cb89                	beqz	a5,42002016 <cstr_prefix_equals_case+0x4c>
        a++, b++;
42002006:	00657c63          	bgeu	a0,t1,4200201e <cstr_prefix_equals_case+0x54>
4200200a:	0505                	add	a0,a0,1
4200200c:	0065f963          	bgeu	a1,t1,4200201e <cstr_prefix_equals_case+0x54>
42002010:	0585                	add	a1,a1,1
    while (length--) {
42002012:	fcb610e3          	bne	a2,a1,42001fd2 <cstr_prefix_equals_case+0x8>
            return true;
42002016:	4505                	li	a0,1
42002018:	8082                	ret
            return false;
4200201a:	4501                	li	a0,0
    }
    return true;
}
4200201c:	8082                	ret
        a++, b++;
4200201e:	9002                	ebreak

42002020 <cstr_copy>:

// Copy a NULL-terminated C-string from `src` into buffer `dest`.
// This may truncate characters, but not the NULL terminator, if `dest` does not fit `src` entirely.
size_t cstr_copy(char *dest, size_t size, char const *src) {
    char const *const orig = dest;
    while (size > 1) {
42002020:	4785                	li	a5,1
size_t cstr_copy(char *dest, size_t size, char const *src) {
42002022:	88aa                	mv	a7,a0
    while (size > 1) {
42002024:	02b7fb63          	bgeu	a5,a1,4200205a <cstr_copy+0x3a>
42002028:	87aa                	mv	a5,a0
        if (!*src)
            break;
        *dest = *src;
        dest++, src++;
4200202a:	56fd                	li	a3,-1
    while (size > 1) {
4200202c:	4805                	li	a6,1
        if (!*src)
4200202e:	ca15                	beqz	a2,42002062 <cstr_copy+0x42>
42002030:	00064703          	lbu	a4,0(a2)
42002034:	cf09                	beqz	a4,4200204e <cstr_copy+0x2e>
        *dest = *src;
42002036:	c795                	beqz	a5,42002062 <cstr_copy+0x42>
42002038:	00e78023          	sb	a4,0(a5)
        dest++, src++;
4200203c:	02d7f363          	bgeu	a5,a3,42002062 <cstr_copy+0x42>
42002040:	0785                	add	a5,a5,1
42002042:	02d67063          	bgeu	a2,a3,42002062 <cstr_copy+0x42>
        size--;
42002046:	15fd                	add	a1,a1,-1
        dest++, src++;
42002048:	0605                	add	a2,a2,1
    while (size > 1) {
4200204a:	ff0592e3          	bne	a1,a6,4200202e <cstr_copy+0xe>
    }
    if (size) {
        *dest = 0;
    }
    return dest - orig;
4200204e:	41178533          	sub	a0,a5,a7
        *dest = 0;
42002052:	cb81                	beqz	a5,42002062 <cstr_copy+0x42>
42002054:	00078023          	sb	zero,0(a5)
}
42002058:	8082                	ret
    if (size) {
4200205a:	4501                	li	a0,0
4200205c:	ddf5                	beqz	a1,42002058 <cstr_copy+0x38>
4200205e:	87c6                	mv	a5,a7
        *dest = 0;
42002060:	fbf5                	bnez	a5,42002054 <cstr_copy+0x34>
42002062:	9002                	ebreak

42002064 <cstr_concat>:
    while (*ptr) ptr++;
42002064:	c135                	beqz	a0,420020c8 <cstr_concat+0x64>
size_t cstr_concat(char *dest, size_t size, char const *src) {
42002066:	1141                	add	sp,sp,-16
42002068:	c606                	sw	ra,12(sp)
4200206a:	c422                	sw	s0,8(sp)
    while (*ptr) ptr++;
4200206c:	00054783          	lbu	a5,0(a0)
42002070:	c7b9                	beqz	a5,420020be <cstr_concat+0x5a>
    char const *ptr = string;
42002072:	87aa                	mv	a5,a0
    while (*ptr) ptr++;
42002074:	56fd                	li	a3,-1
42002076:	04d7f763          	bgeu	a5,a3,420020c4 <cstr_concat+0x60>
4200207a:	0785                	add	a5,a5,1
4200207c:	c7a9                	beqz	a5,420020c6 <cstr_concat+0x62>
4200207e:	0007c703          	lbu	a4,0(a5)
42002082:	fb75                	bnez	a4,42002076 <cstr_concat+0x12>
    return ptr - string;
42002084:	40a78433          	sub	s0,a5,a0
    if (dest_len < size - 1) {
42002088:	fff58713          	add	a4,a1,-1
4200208c:	00e46763          	bltu	s0,a4,4200209a <cstr_concat+0x36>
}
42002090:	40b2                	lw	ra,12(sp)
42002092:	8522                	mv	a0,s0
42002094:	4422                	lw	s0,8(sp)
42002096:	0141                	add	sp,sp,16
42002098:	8082                	ret
        return cstr_copy(dest + dest_len, size - dest_len, src) + dest_len;
4200209a:	00850733          	add	a4,a0,s0
4200209e:	00045d63          	bgez	s0,420020b8 <cstr_concat+0x54>
420020a2:	00e56d63          	bltu	a0,a4,420020bc <cstr_concat+0x58>
420020a6:	8d81                	sub	a1,a1,s0
420020a8:	853e                	mv	a0,a5
420020aa:	3f9d                	jal	42002020 <cstr_copy>
420020ac:	942a                	add	s0,s0,a0
}
420020ae:	40b2                	lw	ra,12(sp)
420020b0:	8522                	mv	a0,s0
420020b2:	4422                	lw	s0,8(sp)
420020b4:	0141                	add	sp,sp,16
420020b6:	8082                	ret
        return cstr_copy(dest + dest_len, size - dest_len, src) + dest_len;
420020b8:	fea777e3          	bgeu	a4,a0,420020a6 <cstr_concat+0x42>
420020bc:	9002                	ebreak
    char const *ptr = string;
420020be:	87aa                	mv	a5,a0
    while (*ptr) ptr++;
420020c0:	4401                	li	s0,0
420020c2:	b7d9                	j	42002088 <cstr_concat+0x24>
420020c4:	9002                	ebreak
420020c6:	9002                	ebreak
420020c8:	9002                	ebreak

420020ca <cstr_copy_packed>:

// Copy at most `length` bytes C-string `src` into buffer `dest`.
// WARNING: This may leave strings without NULL terminators if `dest` does not fit `src` entirely.
size_t cstr_copy_packed(char *dest, size_t size, char const *src) {
    char const *const orig = dest;
    while (size--) {
420020ca:	c985                	beqz	a1,420020fa <cstr_copy_packed+0x30>
420020cc:	95b2                	add	a1,a1,a2
420020ce:	87aa                	mv	a5,a0
        *dest = *src;
        if (!*src)
            return dest - orig;
        dest++, src++;
420020d0:	56fd                	li	a3,-1
        *dest = *src;
420020d2:	c615                	beqz	a2,420020fe <cstr_copy_packed+0x34>
420020d4:	00064703          	lbu	a4,0(a2)
420020d8:	c39d                	beqz	a5,420020fe <cstr_copy_packed+0x34>
420020da:	00e78023          	sb	a4,0(a5)
        if (!*src)
420020de:	00064703          	lbu	a4,0(a2)
420020e2:	cb09                	beqz	a4,420020f4 <cstr_copy_packed+0x2a>
        dest++, src++;
420020e4:	00d7fd63          	bgeu	a5,a3,420020fe <cstr_copy_packed+0x34>
420020e8:	0785                	add	a5,a5,1
420020ea:	00d67a63          	bgeu	a2,a3,420020fe <cstr_copy_packed+0x34>
420020ee:	0605                	add	a2,a2,1
    while (size--) {
420020f0:	fec591e3          	bne	a1,a2,420020d2 <cstr_copy_packed+0x8>
    }
    return dest - orig;
420020f4:	40a78533          	sub	a0,a5,a0
420020f8:	8082                	ret
    while (size--) {
420020fa:	4501                	li	a0,0
}
420020fc:	8082                	ret
        dest++, src++;
420020fe:	9002                	ebreak

42002100 <cstr_concat_packed>:
size_t cstr_concat_packed(char *dest, size_t size, char const *src) {
42002100:	1141                	add	sp,sp,-16
42002102:	872a                	mv	a4,a0
42002104:	c422                	sw	s0,8(sp)
42002106:	c606                	sw	ra,12(sp)
42002108:	852e                	mv	a0,a1
    for (size_t i = 0; i < max_len; i++) {
4200210a:	4401                	li	s0,0
4200210c:	87ba                	mv	a5,a4
4200210e:	02850363          	beq	a0,s0,42002134 <cstr_concat_packed+0x34>
        if (!string[i])
42002112:	008706b3          	add	a3,a4,s0
42002116:	02044363          	bltz	s0,4200213c <cstr_concat_packed+0x3c>
4200211a:	02e6e363          	bltu	a3,a4,42002140 <cstr_concat_packed+0x40>
4200211e:	c38d                	beqz	a5,42002140 <cstr_concat_packed+0x40>
42002120:	0007c803          	lbu	a6,0(a5)
42002124:	00140893          	add	a7,s0,1
42002128:	0785                	add	a5,a5,1
4200212a:	00080c63          	beqz	a6,42002142 <cstr_concat_packed+0x42>
    for (size_t i = 0; i < max_len; i++) {
4200212e:	8446                	mv	s0,a7
42002130:	fe8511e3          	bne	a0,s0,42002112 <cstr_concat_packed+0x12>
}
42002134:	40b2                	lw	ra,12(sp)
42002136:	4422                	lw	s0,8(sp)
42002138:	0141                	add	sp,sp,16
4200213a:	8082                	ret
        if (!string[i])
4200213c:	fed771e3          	bgeu	a4,a3,4200211e <cstr_concat_packed+0x1e>
        return cstr_copy_packed(dest + dest_len, size - dest_len, src) + dest_len;
42002140:	9002                	ebreak
    if (dest_len < size) {
42002142:	00a46763          	bltu	s0,a0,42002150 <cstr_concat_packed+0x50>
}
42002146:	40b2                	lw	ra,12(sp)
    return dest_len;
42002148:	8522                	mv	a0,s0
}
4200214a:	4422                	lw	s0,8(sp)
4200214c:	0141                	add	sp,sp,16
4200214e:	8082                	ret
        return cstr_copy_packed(dest + dest_len, size - dest_len, src) + dest_len;
42002150:	00045d63          	bgez	s0,4200216a <cstr_concat_packed+0x6a>
42002154:	fed766e3          	bltu	a4,a3,42002140 <cstr_concat_packed+0x40>
42002158:	408505b3          	sub	a1,a0,s0
4200215c:	8536                	mv	a0,a3
4200215e:	37b5                	jal	420020ca <cstr_copy_packed>
}
42002160:	40b2                	lw	ra,12(sp)
        return cstr_copy_packed(dest + dest_len, size - dest_len, src) + dest_len;
42002162:	9522                	add	a0,a0,s0
}
42002164:	4422                	lw	s0,8(sp)
42002166:	0141                	add	sp,sp,16
42002168:	8082                	ret
        return cstr_copy_packed(dest + dest_len, size - dest_len, src) + dest_len;
4200216a:	fee6f7e3          	bgeu	a3,a4,42002158 <cstr_concat_packed+0x58>
4200216e:	9002                	ebreak

42002170 <mem_index>:

// Find the first occurrance of byte `value` in memory `memory`.
// Returns -1 when not found.
ptrdiff_t mem_index(void const *memory, size_t size, uint8_t value) {
    uint8_t const *ptr = memory;
    for (size_t i = 0; i < size; i++) {
42002170:	4781                	li	a5,0
42002172:	872a                	mv	a4,a0
42002174:	02b78363          	beq	a5,a1,4200219a <mem_index+0x2a>
        if (ptr[i] == value)
42002178:	00f506b3          	add	a3,a0,a5
4200217c:	0207c163          	bltz	a5,4200219e <mem_index+0x2e>
42002180:	02a6e163          	bltu	a3,a0,420021a2 <mem_index+0x32>
42002184:	cf19                	beqz	a4,420021a2 <mem_index+0x32>
42002186:	00074683          	lbu	a3,0(a4)
4200218a:	00178813          	add	a6,a5,1
4200218e:	0705                	add	a4,a4,1
42002190:	00c68a63          	beq	a3,a2,420021a4 <mem_index+0x34>
    for (size_t i = 0; i < size; i++) {
42002194:	87c2                	mv	a5,a6
42002196:	feb791e3          	bne	a5,a1,42002178 <mem_index+0x8>
            return (ptrdiff_t)i;
    }
    return -1;
4200219a:	557d                	li	a0,-1
}
4200219c:	8082                	ret
        if (ptr[i] == value)
4200219e:	fed573e3          	bgeu	a0,a3,42002184 <mem_index+0x14>
420021a2:	9002                	ebreak
            return (ptrdiff_t)i;
420021a4:	853e                	mv	a0,a5
420021a6:	8082                	ret

420021a8 <mem_last_index>:

// Find the first occurrance of byte `value` in memory `memory`.
// Returns -1 when not found.
ptrdiff_t mem_last_index(void const *memory, size_t size, uint8_t value) {
    uint8_t const *ptr = memory;
    for (size_t i = size; i-- > 0;) {
420021a8:	15fd                	add	a1,a1,-1
420021aa:	00b507b3          	add	a5,a0,a1
420021ae:	fff50693          	add	a3,a0,-1
420021b2:	02d78163          	beq	a5,a3,420021d4 <mem_last_index+0x2c>
        if (ptr[i] == value)
420021b6:	00b50733          	add	a4,a0,a1
420021ba:	0005cf63          	bltz	a1,420021d8 <mem_last_index+0x30>
420021be:	00a76f63          	bltu	a4,a0,420021dc <mem_last_index+0x34>
420021c2:	cf89                	beqz	a5,420021dc <mem_last_index+0x34>
420021c4:	0007c703          	lbu	a4,0(a5)
420021c8:	17fd                	add	a5,a5,-1
420021ca:	00c70a63          	beq	a4,a2,420021de <mem_last_index+0x36>
420021ce:	15fd                	add	a1,a1,-1
    for (size_t i = size; i-- > 0;) {
420021d0:	fed793e3          	bne	a5,a3,420021b6 <mem_last_index+0xe>
            return (ptrdiff_t)i;
    }
    return -1;
420021d4:	557d                	li	a0,-1
}
420021d6:	8082                	ret
        if (ptr[i] == value)
420021d8:	fee575e3          	bgeu	a0,a4,420021c2 <mem_last_index+0x1a>
420021dc:	9002                	ebreak
            return (ptrdiff_t)i;
420021de:	852e                	mv	a0,a1
420021e0:	8082                	ret

420021e2 <mem_equals>:
        }                                                                                                              \
    }

// Test the equality of two memory areas.
bool mem_equals(void const *a, void const *b, size_t size) {
    size_t align_detector = (size_t)a | (size_t)b | (size_t)size;
420021e2:	00c5e6b3          	or	a3,a1,a2
420021e6:	00a6e833          	or	a6,a3,a0

    // Optimise for alignment.
    if (align_detector & 1) {
420021ea:	00187693          	and	a3,a6,1
    size_t align_detector = (size_t)a | (size_t)b | (size_t)size;
420021ee:	87aa                	mv	a5,a0
420021f0:	872e                	mv	a4,a1
    if (align_detector & 1) {
420021f2:	c6b9                	beqz	a3,42002240 <mem_equals+0x5e>
        MEM_EQUALS_IMPL(uint8_t, 1, a, b, size)
420021f4:	4681                	li	a3,0
420021f6:	02c68d63          	beq	a3,a2,42002230 <mem_equals+0x4e>
420021fa:	00d50833          	add	a6,a0,a3
420021fe:	0206ce63          	bltz	a3,4200223a <mem_equals+0x58>
42002202:	02a86b63          	bltu	a6,a0,42002238 <mem_equals+0x56>
42002206:	cb8d                	beqz	a5,42002238 <mem_equals+0x56>
42002208:	0007c883          	lbu	a7,0(a5)
4200220c:	00168313          	add	t1,a3,1
42002210:	00d58833          	add	a6,a1,a3
42002214:	0206c063          	bltz	a3,42002234 <mem_equals+0x52>
42002218:	02b86063          	bltu	a6,a1,42002238 <mem_equals+0x56>
4200221c:	cf11                	beqz	a4,42002238 <mem_equals+0x56>
4200221e:	00074683          	lbu	a3,0(a4)
42002222:	0785                	add	a5,a5,1
42002224:	0705                	add	a4,a4,1
42002226:	0d169a63          	bne	a3,a7,420022fa <mem_equals+0x118>
4200222a:	869a                	mv	a3,t1
4200222c:	fcc697e3          	bne	a3,a2,420021fa <mem_equals+0x18>
        MEM_EQUALS_IMPL(uint32_t, 4, a, b, size)
    } else {
        MEM_EQUALS_IMPL(uint64_t, 8, a, b, size)
    }

    return true;
42002230:	4505                	li	a0,1
42002232:	8082                	ret
        MEM_EQUALS_IMPL(uint8_t, 1, a, b, size)
42002234:	ff05f4e3          	bgeu	a1,a6,4200221c <mem_equals+0x3a>
        MEM_EQUALS_IMPL(uint64_t, 8, a, b, size)
42002238:	9002                	ebreak
        MEM_EQUALS_IMPL(uint8_t, 1, a, b, size)
4200223a:	fd0576e3          	bgeu	a0,a6,42002206 <mem_equals+0x24>
        MEM_EQUALS_IMPL(uint64_t, 8, a, b, size)
4200223e:	9002                	ebreak
    } else if (align_detector & 2) {
42002240:	00287893          	and	a7,a6,2
42002244:	04088d63          	beqz	a7,4200229e <mem_equals+0xbc>
        MEM_EQUALS_IMPL(uint16_t, 2, a, b, size)
42002248:	8205                	srl	a2,a2,0x1
4200224a:	d27d                	beqz	a2,42002230 <mem_equals+0x4e>
4200224c:	0606                	sll	a2,a2,0x1
4200224e:	00d50833          	add	a6,a0,a3
42002252:	0406c363          	bltz	a3,42002298 <mem_equals+0xb6>
42002256:	fea861e3          	bltu	a6,a0,42002238 <mem_equals+0x56>
4200225a:	dff9                	beqz	a5,42002238 <mem_equals+0x56>
4200225c:	0017f813          	and	a6,a5,1
42002260:	fc081ce3          	bnez	a6,42002238 <mem_equals+0x56>
42002264:	0007d883          	lhu	a7,0(a5)
42002268:	00d58833          	add	a6,a1,a3
4200226c:	0806c463          	bltz	a3,420022f4 <mem_equals+0x112>
42002270:	fcb864e3          	bltu	a6,a1,42002238 <mem_equals+0x56>
42002274:	d371                	beqz	a4,42002238 <mem_equals+0x56>
42002276:	00177813          	and	a6,a4,1
4200227a:	fa081fe3          	bnez	a6,42002238 <mem_equals+0x56>
4200227e:	00075803          	lhu	a6,0(a4)
42002282:	07181c63          	bne	a6,a7,420022fa <mem_equals+0x118>
42002286:	0689                	add	a3,a3,2
42002288:	0789                	add	a5,a5,2
4200228a:	0709                	add	a4,a4,2
4200228c:	fac682e3          	beq	a3,a2,42002230 <mem_equals+0x4e>
42002290:	00d50833          	add	a6,a0,a3
42002294:	fc06d1e3          	bgez	a3,42002256 <mem_equals+0x74>
42002298:	fd0571e3          	bgeu	a0,a6,4200225a <mem_equals+0x78>
        MEM_EQUALS_IMPL(uint64_t, 8, a, b, size)
4200229c:	9002                	ebreak
    } else if (align_detector & 4) {
4200229e:	00487693          	and	a3,a6,4
420022a2:	ceb1                	beqz	a3,420022fe <mem_equals+0x11c>
        MEM_EQUALS_IMPL(uint32_t, 4, a, b, size)
420022a4:	8209                	srl	a2,a2,0x2
420022a6:	d649                	beqz	a2,42002230 <mem_equals+0x4e>
420022a8:	060a                	sll	a2,a2,0x2
420022aa:	011506b3          	add	a3,a0,a7
420022ae:	0408c063          	bltz	a7,420022ee <mem_equals+0x10c>
420022b2:	f8a6e3e3          	bltu	a3,a0,42002238 <mem_equals+0x56>
420022b6:	d3c9                	beqz	a5,42002238 <mem_equals+0x56>
420022b8:	0037f693          	and	a3,a5,3
420022bc:	feb5                	bnez	a3,42002238 <mem_equals+0x56>
420022be:	0007a803          	lw	a6,0(a5)
420022c2:	011586b3          	add	a3,a1,a7
420022c6:	0808cd63          	bltz	a7,42002360 <mem_equals+0x17e>
420022ca:	f6b6e7e3          	bltu	a3,a1,42002238 <mem_equals+0x56>
420022ce:	d72d                	beqz	a4,42002238 <mem_equals+0x56>
420022d0:	00377693          	and	a3,a4,3
420022d4:	f2b5                	bnez	a3,42002238 <mem_equals+0x56>
420022d6:	4314                	lw	a3,0(a4)
420022d8:	02d81163          	bne	a6,a3,420022fa <mem_equals+0x118>
420022dc:	0891                	add	a7,a7,4
420022de:	0791                	add	a5,a5,4
420022e0:	0711                	add	a4,a4,4
420022e2:	f4c887e3          	beq	a7,a2,42002230 <mem_equals+0x4e>
420022e6:	011506b3          	add	a3,a0,a7
420022ea:	fc08d4e3          	bgez	a7,420022b2 <mem_equals+0xd0>
420022ee:	fcd574e3          	bgeu	a0,a3,420022b6 <mem_equals+0xd4>
        MEM_EQUALS_IMPL(uint64_t, 8, a, b, size)
420022f2:	9002                	ebreak
        MEM_EQUALS_IMPL(uint16_t, 2, a, b, size)
420022f4:	f905f0e3          	bgeu	a1,a6,42002274 <mem_equals+0x92>
        MEM_EQUALS_IMPL(uint64_t, 8, a, b, size)
420022f8:	9002                	ebreak
        MEM_EQUALS_IMPL(uint8_t, 1, a, b, size)
420022fa:	4501                	li	a0,0
}
420022fc:	8082                	ret
        MEM_EQUALS_IMPL(uint64_t, 8, a, b, size)
420022fe:	820d                	srl	a2,a2,0x3
42002300:	da05                	beqz	a2,42002230 <mem_equals+0x4e>
42002302:	060e                	sll	a2,a2,0x3
42002304:	00d50833          	add	a6,a0,a3
42002308:	0406c963          	bltz	a3,4200235a <mem_equals+0x178>
4200230c:	f2a866e3          	bltu	a6,a0,42002238 <mem_equals+0x56>
42002310:	d785                	beqz	a5,42002238 <mem_equals+0x56>
42002312:	0077f813          	and	a6,a5,7
42002316:	f20811e3          	bnez	a6,42002238 <mem_equals+0x56>
4200231a:	0007a883          	lw	a7,0(a5)
4200231e:	0047a303          	lw	t1,4(a5)
42002322:	00d58833          	add	a6,a1,a3
42002326:	0406c063          	bltz	a3,42002366 <mem_equals+0x184>
4200232a:	f0b867e3          	bltu	a6,a1,42002238 <mem_equals+0x56>
4200232e:	d709                	beqz	a4,42002238 <mem_equals+0x56>
42002330:	00777813          	and	a6,a4,7
42002334:	f00812e3          	bnez	a6,42002238 <mem_equals+0x56>
42002338:	00072803          	lw	a6,0(a4)
4200233c:	fb181fe3          	bne	a6,a7,420022fa <mem_equals+0x118>
42002340:	00472803          	lw	a6,4(a4)
42002344:	fa681be3          	bne	a6,t1,420022fa <mem_equals+0x118>
42002348:	06a1                	add	a3,a3,8
4200234a:	07a1                	add	a5,a5,8
4200234c:	0721                	add	a4,a4,8
4200234e:	eec681e3          	beq	a3,a2,42002230 <mem_equals+0x4e>
42002352:	00d50833          	add	a6,a0,a3
42002356:	fa06dbe3          	bgez	a3,4200230c <mem_equals+0x12a>
4200235a:	fb057be3          	bgeu	a0,a6,42002310 <mem_equals+0x12e>
4200235e:	9002                	ebreak
        MEM_EQUALS_IMPL(uint32_t, 4, a, b, size)
42002360:	f6d5f7e3          	bgeu	a1,a3,420022ce <mem_equals+0xec>
        MEM_EQUALS_IMPL(uint64_t, 8, a, b, size)
42002364:	9002                	ebreak
42002366:	fd05f4e3          	bgeu	a1,a6,4200232e <mem_equals+0x14c>
4200236a:	9002                	ebreak

4200236c <mem_copy>:
    }

// Copy the contents of memory area `src` to memory area `dest`.
// Correct copying is gauranteed even if `src` and `dest` are overlapping regions.
void mem_copy(void *dest, void const *src, size_t size) {
    size_t align_detector = (size_t)dest | (size_t)src | (size_t)size;
4200236c:	00c5e6b3          	or	a3,a1,a2
42002370:	00a6e833          	or	a6,a3,a0

    // Optimise for alignment.
    if (align_detector & 1) {
42002374:	00187693          	and	a3,a6,1
    size_t align_detector = (size_t)dest | (size_t)src | (size_t)size;
42002378:	872a                	mv	a4,a0
4200237a:	87ae                	mv	a5,a1
    if (align_detector & 1) {
4200237c:	ce9d                	beqz	a3,420023ba <mem_copy+0x4e>
        MEM_COPY_IMPL(uint8_t, 1, dest, src, size)
4200237e:	0cb57d63          	bgeu	a0,a1,42002458 <mem_copy+0xec>
42002382:	12060463          	beqz	a2,420024aa <mem_copy+0x13e>
42002386:	4681                	li	a3,0
42002388:	00d58833          	add	a6,a1,a3
4200238c:	1206c363          	bltz	a3,420024b2 <mem_copy+0x146>
42002390:	10b86a63          	bltu	a6,a1,420024a4 <mem_copy+0x138>
42002394:	00d50833          	add	a6,a0,a3
42002398:	1006ca63          	bltz	a3,420024ac <mem_copy+0x140>
4200239c:	10a86463          	bltu	a6,a0,420024a4 <mem_copy+0x138>
420023a0:	10078263          	beqz	a5,420024a4 <mem_copy+0x138>
420023a4:	0007c803          	lbu	a6,0(a5)
420023a8:	0685                	add	a3,a3,1
420023aa:	cf6d                	beqz	a4,420024a4 <mem_copy+0x138>
420023ac:	01070023          	sb	a6,0(a4)
420023b0:	0785                	add	a5,a5,1
420023b2:	0705                	add	a4,a4,1
420023b4:	fcd61ae3          	bne	a2,a3,42002388 <mem_copy+0x1c>
420023b8:	8082                	ret
    } else if (align_detector & 2) {
420023ba:	00287893          	and	a7,a6,2
420023be:	04088863          	beqz	a7,4200240e <mem_copy+0xa2>
        MEM_COPY_IMPL(uint16_t, 2, dest, src, size)
420023c2:	8205                	srl	a2,a2,0x1
420023c4:	0eb56a63          	bltu	a0,a1,420024b8 <mem_copy+0x14c>
420023c8:	0ea5f163          	bgeu	a1,a0,420024aa <mem_copy+0x13e>
420023cc:	fff60793          	add	a5,a2,-1
420023d0:	ce69                	beqz	a2,420024aa <mem_copy+0x13e>
420023d2:	0786                	sll	a5,a5,0x1
420023d4:	5879                	li	a6,-2
420023d6:	00f586b3          	add	a3,a1,a5
420023da:	1807cc63          	bltz	a5,42002572 <mem_copy+0x206>
420023de:	0cb6e363          	bltu	a3,a1,420024a4 <mem_copy+0x138>
420023e2:	00f50733          	add	a4,a0,a5
420023e6:	1807c363          	bltz	a5,4200256c <mem_copy+0x200>
420023ea:	0aa76d63          	bltu	a4,a0,420024a4 <mem_copy+0x138>
420023ee:	cadd                	beqz	a3,420024a4 <mem_copy+0x138>
420023f0:	0016f613          	and	a2,a3,1
420023f4:	ea45                	bnez	a2,420024a4 <mem_copy+0x138>
420023f6:	0006d683          	lhu	a3,0(a3)
420023fa:	c74d                	beqz	a4,420024a4 <mem_copy+0x138>
420023fc:	00177613          	and	a2,a4,1
42002400:	e255                	bnez	a2,420024a4 <mem_copy+0x138>
42002402:	00d71023          	sh	a3,0(a4)
42002406:	17f9                	add	a5,a5,-2
42002408:	fd0797e3          	bne	a5,a6,420023d6 <mem_copy+0x6a>
4200240c:	8082                	ret
    } else if (align_detector & 4) {
4200240e:	00487693          	and	a3,a6,4
42002412:	c6ed                	beqz	a3,420024fc <mem_copy+0x190>
        MEM_COPY_IMPL(uint32_t, 4, dest, src, size)
42002414:	8209                	srl	a2,a2,0x2
42002416:	16b57763          	bgeu	a0,a1,42002584 <mem_copy+0x218>
4200241a:	ca41                	beqz	a2,420024aa <mem_copy+0x13e>
4200241c:	060a                	sll	a2,a2,0x2
4200241e:	011586b3          	add	a3,a1,a7
42002422:	1408cb63          	bltz	a7,42002578 <mem_copy+0x20c>
42002426:	06b6ef63          	bltu	a3,a1,420024a4 <mem_copy+0x138>
4200242a:	011506b3          	add	a3,a0,a7
4200242e:	1208c963          	bltz	a7,42002560 <mem_copy+0x1f4>
42002432:	06a6e963          	bltu	a3,a0,420024a4 <mem_copy+0x138>
42002436:	c7bd                	beqz	a5,420024a4 <mem_copy+0x138>
42002438:	0037f693          	and	a3,a5,3
4200243c:	e6a5                	bnez	a3,420024a4 <mem_copy+0x138>
4200243e:	4394                	lw	a3,0(a5)
42002440:	c335                	beqz	a4,420024a4 <mem_copy+0x138>
42002442:	00377813          	and	a6,a4,3
42002446:	04081f63          	bnez	a6,420024a4 <mem_copy+0x138>
4200244a:	c314                	sw	a3,0(a4)
4200244c:	0891                	add	a7,a7,4
4200244e:	0791                	add	a5,a5,4
42002450:	0711                	add	a4,a4,4
42002452:	fcc896e3          	bne	a7,a2,4200241e <mem_copy+0xb2>
42002456:	8082                	ret
        MEM_COPY_IMPL(uint8_t, 1, dest, src, size)
42002458:	04a5f963          	bgeu	a1,a0,420024aa <mem_copy+0x13e>
4200245c:	fff60793          	add	a5,a2,-1
42002460:	c629                	beqz	a2,420024aa <mem_copy+0x13e>
42002462:	00f58633          	add	a2,a1,a5
42002466:	86b2                	mv	a3,a2
42002468:	00f50733          	add	a4,a0,a5
4200246c:	587d                	li	a6,-1
4200246e:	0207c963          	bltz	a5,420024a0 <mem_copy+0x134>
42002472:	02b66963          	bltu	a2,a1,420024a4 <mem_copy+0x138>
42002476:	00f50633          	add	a2,a0,a5
4200247a:	0e07c063          	bltz	a5,4200255a <mem_copy+0x1ee>
4200247e:	02a66363          	bltu	a2,a0,420024a4 <mem_copy+0x138>
42002482:	c28d                	beqz	a3,420024a4 <mem_copy+0x138>
42002484:	0006c603          	lbu	a2,0(a3)
42002488:	cf11                	beqz	a4,420024a4 <mem_copy+0x138>
4200248a:	00c70023          	sb	a2,0(a4)
4200248e:	17fd                	add	a5,a5,-1
42002490:	16fd                	add	a3,a3,-1
42002492:	177d                	add	a4,a4,-1
42002494:	01078b63          	beq	a5,a6,420024aa <mem_copy+0x13e>
42002498:	00f58633          	add	a2,a1,a5
4200249c:	fc07dbe3          	bgez	a5,42002472 <mem_copy+0x106>
420024a0:	fcc5fbe3          	bgeu	a1,a2,42002476 <mem_copy+0x10a>
    } else {
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
420024a4:	9002                	ebreak
420024a6:	12a5e463          	bltu	a1,a0,420025ce <mem_copy+0x262>
    }
}
420024aa:	8082                	ret
        MEM_COPY_IMPL(uint8_t, 1, dest, src, size)
420024ac:	ef057ae3          	bgeu	a0,a6,420023a0 <mem_copy+0x34>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
420024b0:	9002                	ebreak
        MEM_COPY_IMPL(uint8_t, 1, dest, src, size)
420024b2:	ef05f1e3          	bgeu	a1,a6,42002394 <mem_copy+0x28>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
420024b6:	9002                	ebreak
        MEM_COPY_IMPL(uint16_t, 2, dest, src, size)
420024b8:	da6d                	beqz	a2,420024aa <mem_copy+0x13e>
420024ba:	0606                	sll	a2,a2,0x1
420024bc:	00d58833          	add	a6,a1,a3
420024c0:	0806ca63          	bltz	a3,42002554 <mem_copy+0x1e8>
420024c4:	feb860e3          	bltu	a6,a1,420024a4 <mem_copy+0x138>
420024c8:	00d50833          	add	a6,a0,a3
420024cc:	0806c163          	bltz	a3,4200254e <mem_copy+0x1e2>
420024d0:	fca86ae3          	bltu	a6,a0,420024a4 <mem_copy+0x138>
420024d4:	dbe1                	beqz	a5,420024a4 <mem_copy+0x138>
420024d6:	0017f813          	and	a6,a5,1
420024da:	fc0815e3          	bnez	a6,420024a4 <mem_copy+0x138>
420024de:	0007d803          	lhu	a6,0(a5)
420024e2:	d369                	beqz	a4,420024a4 <mem_copy+0x138>
420024e4:	00177893          	and	a7,a4,1
420024e8:	fa089ee3          	bnez	a7,420024a4 <mem_copy+0x138>
420024ec:	01071023          	sh	a6,0(a4)
420024f0:	0689                	add	a3,a3,2
420024f2:	0789                	add	a5,a5,2
420024f4:	0709                	add	a4,a4,2
420024f6:	fcc693e3          	bne	a3,a2,420024bc <mem_copy+0x150>
420024fa:	8082                	ret
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
420024fc:	820d                	srl	a2,a2,0x3
420024fe:	fab574e3          	bgeu	a0,a1,420024a6 <mem_copy+0x13a>
42002502:	d645                	beqz	a2,420024aa <mem_copy+0x13e>
42002504:	060e                	sll	a2,a2,0x3
42002506:	00d58833          	add	a6,a1,a3
4200250a:	0606ca63          	bltz	a3,4200257e <mem_copy+0x212>
4200250e:	f8b86be3          	bltu	a6,a1,420024a4 <mem_copy+0x138>
42002512:	00d50833          	add	a6,a0,a3
42002516:	0406c863          	bltz	a3,42002566 <mem_copy+0x1fa>
4200251a:	f8a865e3          	bltu	a6,a0,420024a4 <mem_copy+0x138>
4200251e:	d3d9                	beqz	a5,420024a4 <mem_copy+0x138>
42002520:	0077f813          	and	a6,a5,7
42002524:	f80810e3          	bnez	a6,420024a4 <mem_copy+0x138>
42002528:	0007a803          	lw	a6,0(a5)
4200252c:	0047a883          	lw	a7,4(a5)
42002530:	db35                	beqz	a4,420024a4 <mem_copy+0x138>
42002532:	00777313          	and	t1,a4,7
42002536:	f60317e3          	bnez	t1,420024a4 <mem_copy+0x138>
4200253a:	01072023          	sw	a6,0(a4)
4200253e:	01172223          	sw	a7,4(a4)
42002542:	06a1                	add	a3,a3,8
42002544:	07a1                	add	a5,a5,8
42002546:	0721                	add	a4,a4,8
42002548:	fac69fe3          	bne	a3,a2,42002506 <mem_copy+0x19a>
4200254c:	8082                	ret
        MEM_COPY_IMPL(uint16_t, 2, dest, src, size)
4200254e:	f90573e3          	bgeu	a0,a6,420024d4 <mem_copy+0x168>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
42002552:	9002                	ebreak
        MEM_COPY_IMPL(uint16_t, 2, dest, src, size)
42002554:	f705fae3          	bgeu	a1,a6,420024c8 <mem_copy+0x15c>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
42002558:	9002                	ebreak
        MEM_COPY_IMPL(uint8_t, 1, dest, src, size)
4200255a:	f2c574e3          	bgeu	a0,a2,42002482 <mem_copy+0x116>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
4200255e:	9002                	ebreak
        MEM_COPY_IMPL(uint32_t, 4, dest, src, size)
42002560:	ecd57be3          	bgeu	a0,a3,42002436 <mem_copy+0xca>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
42002564:	9002                	ebreak
42002566:	fb057ce3          	bgeu	a0,a6,4200251e <mem_copy+0x1b2>
4200256a:	9002                	ebreak
        MEM_COPY_IMPL(uint16_t, 2, dest, src, size)
4200256c:	e8e571e3          	bgeu	a0,a4,420023ee <mem_copy+0x82>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
42002570:	9002                	ebreak
        MEM_COPY_IMPL(uint16_t, 2, dest, src, size)
42002572:	e6d5f8e3          	bgeu	a1,a3,420023e2 <mem_copy+0x76>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
42002576:	9002                	ebreak
        MEM_COPY_IMPL(uint32_t, 4, dest, src, size)
42002578:	ead5f9e3          	bgeu	a1,a3,4200242a <mem_copy+0xbe>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
4200257c:	9002                	ebreak
4200257e:	f905fae3          	bgeu	a1,a6,42002512 <mem_copy+0x1a6>
42002582:	9002                	ebreak
        MEM_COPY_IMPL(uint32_t, 4, dest, src, size)
42002584:	f2a5f3e3          	bgeu	a1,a0,420024aa <mem_copy+0x13e>
42002588:	fff60793          	add	a5,a2,-1
4200258c:	de19                	beqz	a2,420024aa <mem_copy+0x13e>
4200258e:	078a                	sll	a5,a5,0x2
42002590:	5871                	li	a6,-4
42002592:	00f586b3          	add	a3,a1,a5
42002596:	0a07c163          	bltz	a5,42002638 <mem_copy+0x2cc>
4200259a:	f0b6e5e3          	bltu	a3,a1,420024a4 <mem_copy+0x138>
4200259e:	00f50733          	add	a4,a0,a5
420025a2:	0807c863          	bltz	a5,42002632 <mem_copy+0x2c6>
420025a6:	eea76fe3          	bltu	a4,a0,420024a4 <mem_copy+0x138>
420025aa:	ee068de3          	beqz	a3,420024a4 <mem_copy+0x138>
420025ae:	0036f613          	and	a2,a3,3
420025b2:	ee0619e3          	bnez	a2,420024a4 <mem_copy+0x138>
420025b6:	4294                	lw	a3,0(a3)
420025b8:	ee0706e3          	beqz	a4,420024a4 <mem_copy+0x138>
420025bc:	00377613          	and	a2,a4,3
420025c0:	ee0612e3          	bnez	a2,420024a4 <mem_copy+0x138>
420025c4:	c314                	sw	a3,0(a4)
420025c6:	17f1                	add	a5,a5,-4
420025c8:	fd0795e3          	bne	a5,a6,42002592 <mem_copy+0x226>
420025cc:	8082                	ret
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
420025ce:	fff60793          	add	a5,a2,-1
420025d2:	ec060ce3          	beqz	a2,420024aa <mem_copy+0x13e>
420025d6:	078e                	sll	a5,a5,0x3
420025d8:	58e1                	li	a7,-8
420025da:	00f586b3          	add	a3,a1,a5
420025de:	0407c163          	bltz	a5,42002620 <mem_copy+0x2b4>
420025e2:	ecb6e1e3          	bltu	a3,a1,420024a4 <mem_copy+0x138>
420025e6:	00f50733          	add	a4,a0,a5
420025ea:	0407c163          	bltz	a5,4200262c <mem_copy+0x2c0>
420025ee:	eaa76be3          	bltu	a4,a0,420024a4 <mem_copy+0x138>
420025f2:	ea0689e3          	beqz	a3,420024a4 <mem_copy+0x138>
420025f6:	0076f613          	and	a2,a3,7
420025fa:	ea0615e3          	bnez	a2,420024a4 <mem_copy+0x138>
420025fe:	4290                	lw	a2,0(a3)
42002600:	42d4                	lw	a3,4(a3)
42002602:	ea0701e3          	beqz	a4,420024a4 <mem_copy+0x138>
42002606:	00777813          	and	a6,a4,7
4200260a:	e8081de3          	bnez	a6,420024a4 <mem_copy+0x138>
4200260e:	c310                	sw	a2,0(a4)
42002610:	c354                	sw	a3,4(a4)
42002612:	17e1                	add	a5,a5,-8
42002614:	e9178be3          	beq	a5,a7,420024aa <mem_copy+0x13e>
42002618:	00f586b3          	add	a3,a1,a5
4200261c:	fc07d3e3          	bgez	a5,420025e2 <mem_copy+0x276>
42002620:	e8d5e2e3          	bltu	a1,a3,420024a4 <mem_copy+0x138>
42002624:	00f50733          	add	a4,a0,a5
42002628:	fc07d3e3          	bgez	a5,420025ee <mem_copy+0x282>
4200262c:	fce573e3          	bgeu	a0,a4,420025f2 <mem_copy+0x286>
42002630:	9002                	ebreak
        MEM_COPY_IMPL(uint32_t, 4, dest, src, size)
42002632:	f6e57ce3          	bgeu	a0,a4,420025aa <mem_copy+0x23e>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
42002636:	9002                	ebreak
        MEM_COPY_IMPL(uint32_t, 4, dest, src, size)
42002638:	f6d5f3e3          	bgeu	a1,a3,4200259e <mem_copy+0x232>
        MEM_COPY_IMPL(uint64_t, 8, dest, src, size)
4200263c:	9002                	ebreak

4200263e <mem_swap>:
    }

// Swap the contents of memory areas `a` and `b`.
// For correct copying, `a` and `b` must not overlap.
void mem_swap(void *a, void *b, size_t size) {
    size_t align_detector = (size_t)a | (size_t)b | (size_t)size;
4200263e:	00c5e6b3          	or	a3,a1,a2
42002642:	00a6e833          	or	a6,a3,a0

    // Optimise for alignment.
    if (align_detector & 1) {
42002646:	00187693          	and	a3,a6,1
    size_t align_detector = (size_t)a | (size_t)b | (size_t)size;
4200264a:	872a                	mv	a4,a0
4200264c:	87ae                	mv	a5,a1
    if (align_detector & 1) {
4200264e:	cec1                	beqz	a3,420026e6 <mem_swap+0xa8>
        MEM_SWAP_IMPL(uint8_t, 1, a, b, size)
42002650:	ca51                	beqz	a2,420026e4 <mem_swap+0xa6>
42002652:	4681                	li	a3,0
42002654:	00d508b3          	add	a7,a0,a3
42002658:	0406c763          	bltz	a3,420026a6 <mem_swap+0x68>
4200265c:	04a8e763          	bltu	a7,a0,420026aa <mem_swap+0x6c>
42002660:	c729                	beqz	a4,420026aa <mem_swap+0x6c>
42002662:	00074e03          	lbu	t3,0(a4)
42002666:	00168313          	add	t1,a3,1
4200266a:	00d58833          	add	a6,a1,a3
4200266e:	1406c363          	bltz	a3,420027b4 <mem_swap+0x176>
42002672:	02b86c63          	bltu	a6,a1,420026aa <mem_swap+0x6c>
42002676:	1206cc63          	bltz	a3,420027ae <mem_swap+0x170>
4200267a:	02a8e863          	bltu	a7,a0,420026aa <mem_swap+0x6c>
4200267e:	c795                	beqz	a5,420026aa <mem_swap+0x6c>
42002680:	0007c883          	lbu	a7,0(a5)
42002684:	01170023          	sb	a7,0(a4)
42002688:	1206c963          	bltz	a3,420027ba <mem_swap+0x17c>
4200268c:	00b86f63          	bltu	a6,a1,420026aa <mem_swap+0x6c>
42002690:	01c78023          	sb	t3,0(a5)
42002694:	0705                	add	a4,a4,1
42002696:	0785                	add	a5,a5,1
42002698:	12660963          	beq	a2,t1,420027ca <mem_swap+0x18c>
4200269c:	869a                	mv	a3,t1
4200269e:	00d508b3          	add	a7,a0,a3
420026a2:	fa06dde3          	bgez	a3,4200265c <mem_swap+0x1e>
420026a6:	fb157de3          	bgeu	a0,a7,42002660 <mem_swap+0x22>
    } else if (align_detector & 2) {
        MEM_SWAP_IMPL(uint16_t, 2, a, b, size)
    } else if (align_detector & 4) {
        MEM_SWAP_IMPL(uint32_t, 4, a, b, size)
    } else {
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
420026aa:	9002                	ebreak
420026ac:	ff056fe3          	bltu	a0,a6,420026aa <mem_swap+0x6c>
420026b0:	dfed                	beqz	a5,420026aa <mem_swap+0x6c>
420026b2:	0077f813          	and	a6,a5,7
420026b6:	fe081ae3          	bnez	a6,420026aa <mem_swap+0x6c>
420026ba:	0007a803          	lw	a6,0(a5)
420026be:	0047a883          	lw	a7,4(a5)
420026c2:	01072023          	sw	a6,0(a4)
420026c6:	01172223          	sw	a7,4(a4)
420026ca:	1606cb63          	bltz	a3,42002840 <mem_swap+0x202>
420026ce:	fcb36ee3          	bltu	t1,a1,420026aa <mem_swap+0x6c>
420026d2:	01c7a023          	sw	t3,0(a5)
420026d6:	01d7a223          	sw	t4,4(a5)
420026da:	06a1                	add	a3,a3,8
420026dc:	0721                	add	a4,a4,8
420026de:	07a1                	add	a5,a5,8
420026e0:	10c69663          	bne	a3,a2,420027ec <mem_swap+0x1ae>
    }
}
420026e4:	8082                	ret
    } else if (align_detector & 2) {
420026e6:	00287893          	and	a7,a6,2
420026ea:	06088163          	beqz	a7,4200274c <mem_swap+0x10e>
        MEM_SWAP_IMPL(uint16_t, 2, a, b, size)
420026ee:	8205                	srl	a2,a2,0x1
420026f0:	da75                	beqz	a2,420026e4 <mem_swap+0xa6>
420026f2:	0606                	sll	a2,a2,0x1
420026f4:	00d508b3          	add	a7,a0,a3
420026f8:	0c06cd63          	bltz	a3,420027d2 <mem_swap+0x194>
420026fc:	faa8e7e3          	bltu	a7,a0,420026aa <mem_swap+0x6c>
42002700:	d74d                	beqz	a4,420026aa <mem_swap+0x6c>
42002702:	00177813          	and	a6,a4,1
42002706:	fa0812e3          	bnez	a6,420026aa <mem_swap+0x6c>
4200270a:	00075303          	lhu	t1,0(a4)
4200270e:	00d58833          	add	a6,a1,a3
42002712:	0c06c663          	bltz	a3,420027de <mem_swap+0x1a0>
42002716:	f8b86ae3          	bltu	a6,a1,420026aa <mem_swap+0x6c>
4200271a:	0a06cf63          	bltz	a3,420027d8 <mem_swap+0x19a>
4200271e:	f8a8e6e3          	bltu	a7,a0,420026aa <mem_swap+0x6c>
42002722:	d7c1                	beqz	a5,420026aa <mem_swap+0x6c>
42002724:	0017f893          	and	a7,a5,1
42002728:	f80891e3          	bnez	a7,420026aa <mem_swap+0x6c>
4200272c:	0007d883          	lhu	a7,0(a5)
42002730:	01171023          	sh	a7,0(a4)
42002734:	0806cc63          	bltz	a3,420027cc <mem_swap+0x18e>
42002738:	f6b869e3          	bltu	a6,a1,420026aa <mem_swap+0x6c>
4200273c:	00679023          	sh	t1,0(a5)
42002740:	0689                	add	a3,a3,2
42002742:	0709                	add	a4,a4,2
42002744:	0789                	add	a5,a5,2
42002746:	fac697e3          	bne	a3,a2,420026f4 <mem_swap+0xb6>
4200274a:	8082                	ret
    } else if (align_detector & 4) {
4200274c:	00487693          	and	a3,a6,4
42002750:	cad1                	beqz	a3,420027e4 <mem_swap+0x1a6>
        MEM_SWAP_IMPL(uint32_t, 4, a, b, size)
42002752:	8209                	srl	a2,a2,0x2
42002754:	da41                	beqz	a2,420026e4 <mem_swap+0xa6>
42002756:	060a                	sll	a2,a2,0x2
42002758:	01150833          	add	a6,a0,a7
4200275c:	0c08c963          	bltz	a7,4200282e <mem_swap+0x1f0>
42002760:	f4a865e3          	bltu	a6,a0,420026aa <mem_swap+0x6c>
42002764:	d339                	beqz	a4,420026aa <mem_swap+0x6c>
42002766:	00377693          	and	a3,a4,3
4200276a:	f2a1                	bnez	a3,420026aa <mem_swap+0x6c>
4200276c:	00072303          	lw	t1,0(a4)
42002770:	011586b3          	add	a3,a1,a7
42002774:	0a08ca63          	bltz	a7,42002828 <mem_swap+0x1ea>
42002778:	f2b6e9e3          	bltu	a3,a1,420026aa <mem_swap+0x6c>
4200277c:	0a08c363          	bltz	a7,42002822 <mem_swap+0x1e4>
42002780:	f2a865e3          	bltu	a6,a0,420026aa <mem_swap+0x6c>
42002784:	d39d                	beqz	a5,420026aa <mem_swap+0x6c>
42002786:	0037f813          	and	a6,a5,3
4200278a:	f20810e3          	bnez	a6,420026aa <mem_swap+0x6c>
4200278e:	0007a803          	lw	a6,0(a5)
42002792:	01072023          	sw	a6,0(a4)
42002796:	0a08c863          	bltz	a7,42002846 <mem_swap+0x208>
4200279a:	f0b6e8e3          	bltu	a3,a1,420026aa <mem_swap+0x6c>
4200279e:	0067a023          	sw	t1,0(a5)
420027a2:	0891                	add	a7,a7,4
420027a4:	0711                	add	a4,a4,4
420027a6:	0791                	add	a5,a5,4
420027a8:	fac898e3          	bne	a7,a2,42002758 <mem_swap+0x11a>
420027ac:	8082                	ret
        MEM_SWAP_IMPL(uint8_t, 1, a, b, size)
420027ae:	ed1578e3          	bgeu	a0,a7,4200267e <mem_swap+0x40>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
420027b2:	9002                	ebreak
        MEM_SWAP_IMPL(uint8_t, 1, a, b, size)
420027b4:	ed05f1e3          	bgeu	a1,a6,42002676 <mem_swap+0x38>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
420027b8:	9002                	ebreak
        MEM_SWAP_IMPL(uint8_t, 1, a, b, size)
420027ba:	ef05e8e3          	bltu	a1,a6,420026aa <mem_swap+0x6c>
420027be:	01c78023          	sb	t3,0(a5)
420027c2:	0705                	add	a4,a4,1
420027c4:	0785                	add	a5,a5,1
420027c6:	ec661be3          	bne	a2,t1,4200269c <mem_swap+0x5e>
420027ca:	8082                	ret
        MEM_SWAP_IMPL(uint16_t, 2, a, b, size)
420027cc:	f705f8e3          	bgeu	a1,a6,4200273c <mem_swap+0xfe>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
420027d0:	9002                	ebreak
        MEM_SWAP_IMPL(uint16_t, 2, a, b, size)
420027d2:	f31577e3          	bgeu	a0,a7,42002700 <mem_swap+0xc2>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
420027d6:	9002                	ebreak
        MEM_SWAP_IMPL(uint16_t, 2, a, b, size)
420027d8:	f51575e3          	bgeu	a0,a7,42002722 <mem_swap+0xe4>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
420027dc:	9002                	ebreak
        MEM_SWAP_IMPL(uint16_t, 2, a, b, size)
420027de:	f305fee3          	bgeu	a1,a6,4200271a <mem_swap+0xdc>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
420027e2:	9002                	ebreak
420027e4:	820d                	srl	a2,a2,0x3
420027e6:	ee060fe3          	beqz	a2,420026e4 <mem_swap+0xa6>
420027ea:	060e                	sll	a2,a2,0x3
420027ec:	00d50833          	add	a6,a0,a3
420027f0:	0406c563          	bltz	a3,4200283a <mem_swap+0x1fc>
420027f4:	eaa86be3          	bltu	a6,a0,420026aa <mem_swap+0x6c>
420027f8:	ea0709e3          	beqz	a4,420026aa <mem_swap+0x6c>
420027fc:	00777893          	and	a7,a4,7
42002800:	ea0895e3          	bnez	a7,420026aa <mem_swap+0x6c>
42002804:	00072e03          	lw	t3,0(a4)
42002808:	00472e83          	lw	t4,4(a4)
4200280c:	00d58333          	add	t1,a1,a3
42002810:	0206c263          	bltz	a3,42002834 <mem_swap+0x1f6>
42002814:	e8b36be3          	bltu	t1,a1,420026aa <mem_swap+0x6c>
42002818:	e806cae3          	bltz	a3,420026ac <mem_swap+0x6e>
4200281c:	e8a87ae3          	bgeu	a6,a0,420026b0 <mem_swap+0x72>
42002820:	9002                	ebreak
        MEM_SWAP_IMPL(uint32_t, 4, a, b, size)
42002822:	f70571e3          	bgeu	a0,a6,42002784 <mem_swap+0x146>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
42002826:	9002                	ebreak
        MEM_SWAP_IMPL(uint32_t, 4, a, b, size)
42002828:	f4d5fae3          	bgeu	a1,a3,4200277c <mem_swap+0x13e>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
4200282c:	9002                	ebreak
        MEM_SWAP_IMPL(uint32_t, 4, a, b, size)
4200282e:	f3057be3          	bgeu	a0,a6,42002764 <mem_swap+0x126>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
42002832:	9002                	ebreak
42002834:	fe65f2e3          	bgeu	a1,t1,42002818 <mem_swap+0x1da>
42002838:	9002                	ebreak
4200283a:	fb057fe3          	bgeu	a0,a6,420027f8 <mem_swap+0x1ba>
4200283e:	9002                	ebreak
42002840:	e865f9e3          	bgeu	a1,t1,420026d2 <mem_swap+0x94>
42002844:	9002                	ebreak
        MEM_SWAP_IMPL(uint32_t, 4, a, b, size)
42002846:	f4d5fce3          	bgeu	a1,a3,4200279e <mem_swap+0x160>
        MEM_SWAP_IMPL(uint64_t, 8, a, b, size)
4200284a:	9002                	ebreak

4200284c <mem_set>:
        }                                                                                                              \
    }

// Set the contents of memory area `dest` to the constant byte `value`.
void mem_set(void *dest, uint8_t value, size_t size) {
    size_t align_detector = (size_t)dest | (size_t)size;
4200284c:	00c566b3          	or	a3,a0,a2

    // Optimise for alignment.
    if (align_detector & 1) {
42002850:	0016f713          	and	a4,a3,1
    size_t align_detector = (size_t)dest | (size_t)size;
42002854:	87aa                	mv	a5,a0
    if (align_detector & 1) {
42002856:	c331                	beqz	a4,4200289a <mem_set+0x4e>
        MEM_SET_IMPL(uint8_t, 1, dest, value, size)
42002858:	4701                	li	a4,0
4200285a:	ce05                	beqz	a2,42002892 <mem_set+0x46>
4200285c:	00e506b3          	add	a3,a0,a4
42002860:	02074a63          	bltz	a4,42002894 <mem_set+0x48>
42002864:	02a6ea63          	bltu	a3,a0,42002898 <mem_set+0x4c>
42002868:	cb85                	beqz	a5,42002898 <mem_set+0x4c>
4200286a:	00b78023          	sb	a1,0(a5)
4200286e:	0705                	add	a4,a4,1
42002870:	0785                	add	a5,a5,1
42002872:	fee615e3          	bne	a2,a4,4200285c <mem_set+0x10>
42002876:	8082                	ret
    } else if (align_detector & 2) {
        MEM_SET_IMPL(uint16_t, 2, dest, value, size)
    } else if (align_detector & 4) {
        MEM_SET_IMPL(uint32_t, 4, dest, value, size)
    } else {
        MEM_SET_IMPL(uint64_t, 8, dest, value, size)
42002878:	02d56063          	bltu	a0,a3,42002898 <mem_set+0x4c>
4200287c:	cf91                	beqz	a5,42002898 <mem_set+0x4c>
4200287e:	0077f693          	and	a3,a5,7
42002882:	ea99                	bnez	a3,42002898 <mem_set+0x4c>
42002884:	c38c                	sw	a1,0(a5)
42002886:	0007a223          	sw	zero,4(a5)
4200288a:	0721                	add	a4,a4,8
4200288c:	07a1                	add	a5,a5,8
4200288e:	06c71a63          	bne	a4,a2,42002902 <mem_set+0xb6>
    }
}
42002892:	8082                	ret
        MEM_SET_IMPL(uint8_t, 1, dest, value, size)
42002894:	fcd57ae3          	bgeu	a0,a3,42002868 <mem_set+0x1c>
        MEM_SET_IMPL(uint64_t, 8, dest, value, size)
42002898:	9002                	ebreak
    } else if (align_detector & 2) {
4200289a:	0026f813          	and	a6,a3,2
4200289e:	02080663          	beqz	a6,420028ca <mem_set+0x7e>
        MEM_SET_IMPL(uint16_t, 2, dest, value, size)
420028a2:	8205                	srl	a2,a2,0x1
420028a4:	d67d                	beqz	a2,42002892 <mem_set+0x46>
420028a6:	0606                	sll	a2,a2,0x1
420028a8:	00e506b3          	add	a3,a0,a4
420028ac:	04074563          	bltz	a4,420028f6 <mem_set+0xaa>
420028b0:	fea6e4e3          	bltu	a3,a0,42002898 <mem_set+0x4c>
420028b4:	d3f5                	beqz	a5,42002898 <mem_set+0x4c>
420028b6:	0017f693          	and	a3,a5,1
420028ba:	fef9                	bnez	a3,42002898 <mem_set+0x4c>
420028bc:	00b79023          	sh	a1,0(a5)
420028c0:	0709                	add	a4,a4,2
420028c2:	0789                	add	a5,a5,2
420028c4:	fee612e3          	bne	a2,a4,420028a8 <mem_set+0x5c>
420028c8:	8082                	ret
    } else if (align_detector & 4) {
420028ca:	0046f713          	and	a4,a3,4
420028ce:	c71d                	beqz	a4,420028fc <mem_set+0xb0>
        MEM_SET_IMPL(uint32_t, 4, dest, value, size)
420028d0:	8209                	srl	a2,a2,0x2
420028d2:	d261                	beqz	a2,42002892 <mem_set+0x46>
420028d4:	060a                	sll	a2,a2,0x2
420028d6:	01050733          	add	a4,a0,a6
420028da:	02084b63          	bltz	a6,42002910 <mem_set+0xc4>
420028de:	faa76de3          	bltu	a4,a0,42002898 <mem_set+0x4c>
420028e2:	dbdd                	beqz	a5,42002898 <mem_set+0x4c>
420028e4:	0037f713          	and	a4,a5,3
420028e8:	fb45                	bnez	a4,42002898 <mem_set+0x4c>
420028ea:	c38c                	sw	a1,0(a5)
420028ec:	0811                	add	a6,a6,4
420028ee:	0791                	add	a5,a5,4
420028f0:	fec813e3          	bne	a6,a2,420028d6 <mem_set+0x8a>
420028f4:	8082                	ret
        MEM_SET_IMPL(uint16_t, 2, dest, value, size)
420028f6:	fad57fe3          	bgeu	a0,a3,420028b4 <mem_set+0x68>
        MEM_SET_IMPL(uint64_t, 8, dest, value, size)
420028fa:	9002                	ebreak
420028fc:	820d                	srl	a2,a2,0x3
420028fe:	da51                	beqz	a2,42002892 <mem_set+0x46>
42002900:	060e                	sll	a2,a2,0x3
42002902:	00e506b3          	add	a3,a0,a4
42002906:	f60749e3          	bltz	a4,42002878 <mem_set+0x2c>
4200290a:	f6a6f9e3          	bgeu	a3,a0,4200287c <mem_set+0x30>
4200290e:	9002                	ebreak
        MEM_SET_IMPL(uint32_t, 4, dest, value, size)
42002910:	fce579e3          	bgeu	a0,a4,420028e2 <mem_set+0x96>
        MEM_SET_IMPL(uint64_t, 8, dest, value, size)
42002914:	9002                	ebreak

42002916 <memset>:



// Function call emitted by the compiler.
void *memset(void *dst, int byte, size_t len) {
42002916:	1141                	add	sp,sp,-16
    mem_set(dst, (uint8_t)byte, len);
42002918:	0ff5f593          	zext.b	a1,a1
void *memset(void *dst, int byte, size_t len) {
4200291c:	c422                	sw	s0,8(sp)
4200291e:	c606                	sw	ra,12(sp)
42002920:	842a                	mv	s0,a0
    mem_set(dst, (uint8_t)byte, len);
42002922:	372d                	jal	4200284c <mem_set>
    return dst;
}
42002924:	40b2                	lw	ra,12(sp)
42002926:	8522                	mv	a0,s0
42002928:	4422                	lw	s0,8(sp)
4200292a:	0141                	add	sp,sp,16
4200292c:	8082                	ret

4200292e <memcpy>:

// Function call emitted by the compiler.
void *memcpy(void *dst, void const *src, size_t len) {
4200292e:	1141                	add	sp,sp,-16
42002930:	c422                	sw	s0,8(sp)
42002932:	c606                	sw	ra,12(sp)
42002934:	842a                	mv	s0,a0
    mem_copy(dst, src, len);
42002936:	3c1d                	jal	4200236c <mem_copy>
    return dst;
}
42002938:	40b2                	lw	ra,12(sp)
4200293a:	8522                	mv	a0,s0
4200293c:	4422                	lw	s0,8(sp)
4200293e:	0141                	add	sp,sp,16
42002940:	8082                	ret

42002942 <memmove>:

// Function call emitted by the compiler.
void *memmove(void *dst, void const *src, size_t len) {
42002942:	1141                	add	sp,sp,-16
42002944:	c422                	sw	s0,8(sp)
42002946:	c606                	sw	ra,12(sp)
42002948:	842a                	mv	s0,a0
4200294a:	340d                	jal	4200236c <mem_copy>
4200294c:	40b2                	lw	ra,12(sp)
4200294e:	8522                	mv	a0,s0
42002950:	4422                	lw	s0,8(sp)
42002952:	0141                	add	sp,sp,16
42002954:	8082                	ret

42002956 <memcmp>:
    mem_copy(dst, src, len);
    return dst;
}

// Function call emitted by the compiler.
int memcmp(void const *a, void const *b, size_t len) {
42002956:	1141                	add	sp,sp,-16
42002958:	c606                	sw	ra,12(sp)
    // This is not strictly correct according to the `memcmp` spec,
    // but it will work for equality tests.
    return !mem_equals(a, b, len);
4200295a:	889ff0ef          	jal	420021e2 <mem_equals>
}
4200295e:	40b2                	lw	ra,12(sp)
    return !mem_equals(a, b, len);
42002960:	00154513          	xor	a0,a0,1
}
42002964:	0ff57513          	zext.b	a0,a0
42002968:	0141                	add	sp,sp,16
4200296a:	8082                	ret

4200296c <__udivmodsi4>:
            return -res.remainder;                                                                                     \
        else                                                                                                           \
            return res.remainder;                                                                                      \
    }

DIVMOD_FUNCS(si_t, si)
4200296c:	86aa                	mv	a3,a0
4200296e:	c5a9                	beqz	a1,420029b8 <__udivmodsi4+0x4c>
DIVMOD_IMPL(si_t, si)
42002970:	4781                	li	a5,0
42002972:	0005c663          	bltz	a1,4200297e <__udivmodsi4+0x12>
42002976:	0586                	sll	a1,a1,0x1
42002978:	0785                	add	a5,a5,1
4200297a:	fe05dee3          	bgez	a1,42002976 <__udivmodsi4+0xa>
4200297e:	4501                	li	a0,0
42002980:	03f00e13          	li	t3,63
42002984:	4305                	li	t1,1
42002986:	58fd                	li	a7,-1
42002988:	00b6ee63          	bltu	a3,a1,420029a4 <__udivmodsi4+0x38>
4200298c:	02fe6b63          	bltu	t3,a5,420029c2 <__udivmodsi4+0x56>
42002990:	fe078813          	add	a6,a5,-32
42002994:	41f85813          	sra	a6,a6,0x1f
42002998:	00f31733          	sll	a4,t1,a5
4200299c:	01077733          	and	a4,a4,a6
420029a0:	8d59                	or	a0,a0,a4
420029a2:	8e8d                	sub	a3,a3,a1
420029a4:	17fd                	add	a5,a5,-1
420029a6:	8185                	srl	a1,a1,0x1
420029a8:	ff1790e3          	bne	a5,a7,42002988 <__udivmodsi4+0x1c>
DIVMOD_FUNCS(si_t, si)
420029ac:	ca19                	beqz	a2,420029c2 <__udivmodsi4+0x56>
420029ae:	00367793          	and	a5,a2,3
420029b2:	eb81                	bnez	a5,420029c2 <__udivmodsi4+0x56>
420029b4:	c214                	sw	a3,0(a2)
420029b6:	8082                	ret
420029b8:	c609                	beqz	a2,420029c2 <__udivmodsi4+0x56>
420029ba:	00367793          	and	a5,a2,3
420029be:	557d                	li	a0,-1
420029c0:	dbf5                	beqz	a5,420029b4 <__udivmodsi4+0x48>
420029c2:	9002                	ebreak

420029c4 <__udivsi3>:
420029c4:	86aa                	mv	a3,a0
420029c6:	cd95                	beqz	a1,42002a02 <__udivsi3+0x3e>
DIVMOD_IMPL(si_t, si)
420029c8:	4781                	li	a5,0
420029ca:	0005c663          	bltz	a1,420029d6 <__udivsi3+0x12>
420029ce:	0586                	sll	a1,a1,0x1
420029d0:	0785                	add	a5,a5,1
420029d2:	fe05dee3          	bgez	a1,420029ce <__udivsi3+0xa>
420029d6:	4501                	li	a0,0
420029d8:	03f00313          	li	t1,63
420029dc:	4885                	li	a7,1
420029de:	587d                	li	a6,-1
420029e0:	00b6ec63          	bltu	a3,a1,420029f8 <__udivsi3+0x34>
420029e4:	02f36163          	bltu	t1,a5,42002a06 <__udivsi3+0x42>
420029e8:	fe078613          	add	a2,a5,-32
420029ec:	867d                	sra	a2,a2,0x1f
420029ee:	00f89733          	sll	a4,a7,a5
420029f2:	8f71                	and	a4,a4,a2
420029f4:	8d59                	or	a0,a0,a4
420029f6:	8e8d                	sub	a3,a3,a1
420029f8:	17fd                	add	a5,a5,-1
420029fa:	8185                	srl	a1,a1,0x1
420029fc:	ff0792e3          	bne	a5,a6,420029e0 <__udivsi3+0x1c>
42002a00:	8082                	ret
DIVMOD_FUNCS(si_t, si)
42002a02:	557d                	li	a0,-1
42002a04:	8082                	ret
DIVMOD_IMPL(si_t, si)
42002a06:	9002                	ebreak

42002a08 <__umodsi3>:
DIVMOD_FUNCS(si_t, si)
42002a08:	e191                	bnez	a1,42002a0c <__umodsi3+0x4>
42002a0a:	8082                	ret
DIVMOD_IMPL(si_t, si)
42002a0c:	4781                	li	a5,0
42002a0e:	0005c663          	bltz	a1,42002a1a <__umodsi3+0x12>
42002a12:	0586                	sll	a1,a1,0x1
42002a14:	0785                	add	a5,a5,1
42002a16:	fe05dee3          	bgez	a1,42002a12 <__umodsi3+0xa>
42002a1a:	03f00693          	li	a3,63
42002a1e:	577d                	li	a4,-1
42002a20:	00b56563          	bltu	a0,a1,42002a2a <__umodsi3+0x22>
42002a24:	00f6e863          	bltu	a3,a5,42002a34 <__umodsi3+0x2c>
42002a28:	8d0d                	sub	a0,a0,a1
42002a2a:	17fd                	add	a5,a5,-1
42002a2c:	8185                	srl	a1,a1,0x1
42002a2e:	fee799e3          	bne	a5,a4,42002a20 <__umodsi3+0x18>
DIVMOD_FUNCS(si_t, si)
42002a32:	8082                	ret
DIVMOD_IMPL(si_t, si)
42002a34:	9002                	ebreak

42002a36 <__divmodsi4>:
DIVMOD_FUNCS(si_t, si)
42002a36:	8eaa                	mv	t4,a0
42002a38:	c5bd                	beqz	a1,42002aa6 <__divmodsi4+0x70>
42002a3a:	00a5cfb3          	xor	t6,a1,a0
42002a3e:	882a                	mv	a6,a0
42002a40:	87ae                	mv	a5,a1
DIVMOD_IMPL(si_t, si)
42002a42:	4701                	li	a4,0
42002a44:	0005c663          	bltz	a1,42002a50 <__divmodsi4+0x1a>
42002a48:	0786                	sll	a5,a5,0x1
42002a4a:	0705                	add	a4,a4,1
42002a4c:	fe07dee3          	bgez	a5,42002a48 <__divmodsi4+0x12>
42002a50:	4301                	li	t1,0
42002a52:	03f00f13          	li	t5,63
42002a56:	4505                	li	a0,1
42002a58:	5e7d                	li	t3,-1
42002a5a:	02f86063          	bltu	a6,a5,42002a7a <__divmodsi4+0x44>
42002a5e:	04ef6963          	bltu	t5,a4,42002ab0 <__divmodsi4+0x7a>
42002a62:	fe070893          	add	a7,a4,-32
42002a66:	41f8d893          	sra	a7,a7,0x1f
42002a6a:	00e516b3          	sll	a3,a0,a4
42002a6e:	0116f6b3          	and	a3,a3,a7
42002a72:	00d36333          	or	t1,t1,a3
42002a76:	40f80833          	sub	a6,a6,a5
42002a7a:	177d                	add	a4,a4,-1
42002a7c:	8385                	srl	a5,a5,0x1
42002a7e:	fdc71ee3          	bne	a4,t3,42002a5a <__divmodsi4+0x24>
DIVMOD_FUNCS(si_t, si)
42002a82:	02bed063          	bge	t4,a1,42002aa2 <__divmodsi4+0x6c>
42002a86:	41000eb3          	neg	t4,a6
42002a8a:	c21d                	beqz	a2,42002ab0 <__divmodsi4+0x7a>
42002a8c:	00367793          	and	a5,a2,3
42002a90:	e385                	bnez	a5,42002ab0 <__divmodsi4+0x7a>
42002a92:	851a                	mv	a0,t1
42002a94:	000fd463          	bgez	t6,42002a9c <__divmodsi4+0x66>
42002a98:	40600533          	neg	a0,t1
42002a9c:	01d62023          	sw	t4,0(a2)
42002aa0:	8082                	ret
42002aa2:	8ec2                	mv	t4,a6
42002aa4:	b7dd                	j	42002a8a <__divmodsi4+0x54>
42002aa6:	c609                	beqz	a2,42002ab0 <__divmodsi4+0x7a>
42002aa8:	00367793          	and	a5,a2,3
42002aac:	557d                	li	a0,-1
42002aae:	d7fd                	beqz	a5,42002a9c <__divmodsi4+0x66>
42002ab0:	9002                	ebreak

42002ab2 <__divsi3>:
42002ab2:	872a                	mv	a4,a0
42002ab4:	c5c1                	beqz	a1,42002b3c <__divsi3+0x8a>
42002ab6:	00a5ce33          	xor	t3,a1,a0
42002aba:	04054e63          	bltz	a0,42002b16 <__divsi3+0x64>
42002abe:	0405c263          	bltz	a1,42002b02 <__divsi3+0x50>
DIVMOD_IMPL(si_t, si)
42002ac2:	4781                	li	a5,0
42002ac4:	0586                	sll	a1,a1,0x1
42002ac6:	0785                	add	a5,a5,1
42002ac8:	fe05dee3          	bgez	a1,42002ac4 <__divsi3+0x12>
42002acc:	4501                	li	a0,0
42002ace:	03f00313          	li	t1,63
42002ad2:	4885                	li	a7,1
42002ad4:	587d                	li	a6,-1
42002ad6:	00b76c63          	bltu	a4,a1,42002aee <__divsi3+0x3c>
42002ada:	06f36363          	bltu	t1,a5,42002b40 <__divsi3+0x8e>
42002ade:	fe078613          	add	a2,a5,-32
42002ae2:	867d                	sra	a2,a2,0x1f
42002ae4:	00f896b3          	sll	a3,a7,a5
42002ae8:	8ef1                	and	a3,a3,a2
42002aea:	8d55                	or	a0,a0,a3
42002aec:	8f0d                	sub	a4,a4,a1
42002aee:	17fd                	add	a5,a5,-1
42002af0:	8185                	srl	a1,a1,0x1
42002af2:	ff0792e3          	bne	a5,a6,42002ad6 <__divsi3+0x24>
DIVMOD_FUNCS(si_t, si)
42002af6:	000e4363          	bltz	t3,42002afc <__divsi3+0x4a>
42002afa:	8082                	ret
42002afc:	40a00533          	neg	a0,a0
42002b00:	8082                	ret
42002b02:	800006b7          	lui	a3,0x80000
42002b06:	40b007b3          	neg	a5,a1
42002b0a:	02d58b63          	beq	a1,a3,42002b40 <__divsi3+0x8e>
DIVMOD_IMPL(si_t, si)
42002b0e:	0007ce63          	bltz	a5,42002b2a <__divsi3+0x78>
DIVMOD_FUNCS(si_t, si)
42002b12:	85be                	mv	a1,a5
42002b14:	b77d                	j	42002ac2 <__divsi3+0x10>
42002b16:	800006b7          	lui	a3,0x80000
42002b1a:	40a007b3          	neg	a5,a0
42002b1e:	02d50163          	beq	a0,a3,42002b40 <__divsi3+0x8e>
42002b22:	873e                	mv	a4,a5
42002b24:	f805dfe3          	bgez	a1,42002ac2 <__divsi3+0x10>
42002b28:	bfe9                	j	42002b02 <__divsi3+0x50>
DIVMOD_IMPL(si_t, si)
42002b2a:	4781                	li	a5,0
42002b2c:	800005b7          	lui	a1,0x80000
42002b30:	4501                	li	a0,0
42002b32:	03f00313          	li	t1,63
42002b36:	4885                	li	a7,1
42002b38:	587d                	li	a6,-1
42002b3a:	bf71                	j	42002ad6 <__divsi3+0x24>
DIVMOD_FUNCS(si_t, si)
42002b3c:	557d                	li	a0,-1
42002b3e:	8082                	ret
DIVMOD_IMPL(si_t, si)
42002b40:	9002                	ebreak

42002b42 <__modsi3>:
DIVMOD_FUNCS(si_t, si)
42002b42:	862a                	mv	a2,a0
42002b44:	c995                	beqz	a1,42002b78 <__modsi3+0x36>
42002b46:	872a                	mv	a4,a0
42002b48:	04054663          	bltz	a0,42002b94 <__modsi3+0x52>
42002b4c:	0205ca63          	bltz	a1,42002b80 <__modsi3+0x3e>
DIVMOD_IMPL(si_t, si)
42002b50:	4781                	li	a5,0
42002b52:	0586                	sll	a1,a1,0x1
42002b54:	0785                	add	a5,a5,1
42002b56:	fe05dee3          	bgez	a1,42002b52 <__modsi3+0x10>
42002b5a:	03f00513          	li	a0,63
42002b5e:	56fd                	li	a3,-1
42002b60:	00b76563          	bltu	a4,a1,42002b6a <__modsi3+0x28>
42002b64:	02f56e63          	bltu	a0,a5,42002ba0 <__modsi3+0x5e>
42002b68:	8f0d                	sub	a4,a4,a1
42002b6a:	17fd                	add	a5,a5,-1
42002b6c:	8185                	srl	a1,a1,0x1
42002b6e:	fed799e3          	bne	a5,a3,42002b60 <__modsi3+0x1e>
DIVMOD_FUNCS(si_t, si)
42002b72:	853a                	mv	a0,a4
42002b74:	00064363          	bltz	a2,42002b7a <__modsi3+0x38>
42002b78:	8082                	ret
42002b7a:	40e00533          	neg	a0,a4
42002b7e:	8082                	ret
42002b80:	800006b7          	lui	a3,0x80000
42002b84:	40b007b3          	neg	a5,a1
42002b88:	00d58c63          	beq	a1,a3,42002ba0 <__modsi3+0x5e>
DIVMOD_IMPL(si_t, si)
42002b8c:	0007cb63          	bltz	a5,42002ba2 <__modsi3+0x60>
DIVMOD_FUNCS(si_t, si)
42002b90:	85be                	mv	a1,a5
42002b92:	bf7d                	j	42002b50 <__modsi3+0xe>
42002b94:	800007b7          	lui	a5,0x80000
42002b98:	40a00733          	neg	a4,a0
42002b9c:	faf518e3          	bne	a0,a5,42002b4c <__modsi3+0xa>
DIVMOD_IMPL(si_t, si)
42002ba0:	9002                	ebreak
42002ba2:	4781                	li	a5,0
42002ba4:	800005b7          	lui	a1,0x80000
42002ba8:	bf4d                	j	42002b5a <__modsi3+0x18>

42002baa <__udivmoddi4>:
DIVMOD_FUNCS(di_t, di)
42002baa:	00d667b3          	or	a5,a2,a3
42002bae:	8e36                	mv	t3,a3
42002bb0:	88aa                	mv	a7,a0
42002bb2:	882e                	mv	a6,a1
42002bb4:	c7d1                	beqz	a5,42002c40 <__udivmoddi4+0x96>
DIVMOD_IMPL(di_t, di)
42002bb6:	4781                	li	a5,0
42002bb8:	0006cc63          	bltz	a3,42002bd0 <__udivmoddi4+0x26>
42002bbc:	01f65693          	srl	a3,a2,0x1f
42002bc0:	001e1593          	sll	a1,t3,0x1
42002bc4:	00b6ee33          	or	t3,a3,a1
42002bc8:	0606                	sll	a2,a2,0x1
42002bca:	0785                	add	a5,a5,1 # 80000001 <__stop_free_lpsram+0x2fffc001>
42002bcc:	fe05d8e3          	bgez	a1,42002bbc <__udivmoddi4+0x12>
42002bd0:	4501                	li	a0,0
42002bd2:	4581                	li	a1,0
42002bd4:	03f00293          	li	t0,63
42002bd8:	4385                	li	t2,1
42002bda:	5efd                	li	t4,-1
42002bdc:	03c86c63          	bltu	a6,t3,42002c14 <__udivmoddi4+0x6a>
42002be0:	010e1463          	bne	t3,a6,42002be8 <__udivmoddi4+0x3e>
42002be4:	02c8e863          	bltu	a7,a2,42002c14 <__udivmoddi4+0x6a>
42002be8:	06f2e263          	bltu	t0,a5,42002c4c <__udivmoddi4+0xa2>
42002bec:	fe078313          	add	t1,a5,-32
42002bf0:	04034463          	bltz	t1,42002c38 <__udivmoddi4+0x8e>
42002bf4:	00639333          	sll	t1,t2,t1
42002bf8:	4f81                	li	t6,0
42002bfa:	40c886b3          	sub	a3,a7,a2
42002bfe:	00d8bf33          	sltu	t5,a7,a3
42002c02:	41c80833          	sub	a6,a6,t3
42002c06:	01f56533          	or	a0,a0,t6
42002c0a:	0065e5b3          	or	a1,a1,t1
42002c0e:	88b6                	mv	a7,a3
42002c10:	41e80833          	sub	a6,a6,t5
42002c14:	01fe1693          	sll	a3,t3,0x1f
42002c18:	8205                	srl	a2,a2,0x1
42002c1a:	17fd                	add	a5,a5,-1
42002c1c:	8e55                	or	a2,a2,a3
42002c1e:	001e5e13          	srl	t3,t3,0x1
42002c22:	fbd79de3          	bne	a5,t4,42002bdc <__udivmoddi4+0x32>
DIVMOD_FUNCS(di_t, di)
42002c26:	c31d                	beqz	a4,42002c4c <__udivmoddi4+0xa2>
42002c28:	00777793          	and	a5,a4,7
42002c2c:	e385                	bnez	a5,42002c4c <__udivmoddi4+0xa2>
42002c2e:	01172023          	sw	a7,0(a4)
42002c32:	01072223          	sw	a6,4(a4)
42002c36:	8082                	ret
DIVMOD_IMPL(di_t, di)
42002c38:	4301                	li	t1,0
42002c3a:	00f39fb3          	sll	t6,t2,a5
42002c3e:	bf75                	j	42002bfa <__udivmoddi4+0x50>
DIVMOD_FUNCS(di_t, di)
42002c40:	c711                	beqz	a4,42002c4c <__udivmoddi4+0xa2>
42002c42:	00777793          	and	a5,a4,7
42002c46:	557d                	li	a0,-1
42002c48:	55fd                	li	a1,-1
42002c4a:	d3f5                	beqz	a5,42002c2e <__udivmoddi4+0x84>
42002c4c:	9002                	ebreak

42002c4e <__udivdi3>:
42002c4e:	00d667b3          	or	a5,a2,a3
42002c52:	88aa                	mv	a7,a0
42002c54:	872e                	mv	a4,a1
42002c56:	cfad                	beqz	a5,42002cd0 <__udivdi3+0x82>
DIVMOD_IMPL(di_t, di)
42002c58:	4781                	li	a5,0
42002c5a:	0006cc63          	bltz	a3,42002c72 <__udivdi3+0x24>
42002c5e:	01f65593          	srl	a1,a2,0x1f
42002c62:	00169813          	sll	a6,a3,0x1
42002c66:	0105e6b3          	or	a3,a1,a6
42002c6a:	0606                	sll	a2,a2,0x1
42002c6c:	0785                	add	a5,a5,1
42002c6e:	fe0858e3          	bgez	a6,42002c5e <__udivdi3+0x10>
42002c72:	4501                	li	a0,0
42002c74:	4581                	li	a1,0
42002c76:	03f00f93          	li	t6,63
42002c7a:	4285                	li	t0,1
42002c7c:	5e7d                	li	t3,-1
42002c7e:	02d76b63          	bltu	a4,a3,42002cb4 <__udivdi3+0x66>
42002c82:	00e69463          	bne	a3,a4,42002c8a <__udivdi3+0x3c>
42002c86:	02c8e763          	bltu	a7,a2,42002cb4 <__udivdi3+0x66>
42002c8a:	04ffe663          	bltu	t6,a5,42002cd6 <__udivdi3+0x88>
42002c8e:	fe078813          	add	a6,a5,-32
42002c92:	02084b63          	bltz	a6,42002cc8 <__udivdi3+0x7a>
42002c96:	01029833          	sll	a6,t0,a6
42002c9a:	4f01                	li	t5,0
42002c9c:	40c88333          	sub	t1,a7,a2
42002ca0:	0068beb3          	sltu	t4,a7,t1
42002ca4:	8f15                	sub	a4,a4,a3
42002ca6:	01e56533          	or	a0,a0,t5
42002caa:	0105e5b3          	or	a1,a1,a6
42002cae:	889a                	mv	a7,t1
42002cb0:	41d70733          	sub	a4,a4,t4
42002cb4:	01f69813          	sll	a6,a3,0x1f
42002cb8:	8205                	srl	a2,a2,0x1
42002cba:	17fd                	add	a5,a5,-1
42002cbc:	00c86633          	or	a2,a6,a2
42002cc0:	8285                	srl	a3,a3,0x1
42002cc2:	fbc79ee3          	bne	a5,t3,42002c7e <__udivdi3+0x30>
42002cc6:	8082                	ret
42002cc8:	4801                	li	a6,0
42002cca:	00f29f33          	sll	t5,t0,a5
42002cce:	b7f9                	j	42002c9c <__udivdi3+0x4e>
DIVMOD_FUNCS(di_t, di)
42002cd0:	557d                	li	a0,-1
42002cd2:	55fd                	li	a1,-1
42002cd4:	8082                	ret
DIVMOD_IMPL(di_t, di)
42002cd6:	9002                	ebreak

42002cd8 <__umoddi3>:
DIVMOD_FUNCS(di_t, di)
42002cd8:	00d667b3          	or	a5,a2,a3
42002cdc:	e391                	bnez	a5,42002ce0 <__umoddi3+0x8>
42002cde:	8082                	ret
DIVMOD_IMPL(di_t, di)
42002ce0:	4781                	li	a5,0
42002ce2:	0006cc63          	bltz	a3,42002cfa <__umoddi3+0x22>
42002ce6:	01f65713          	srl	a4,a2,0x1f
42002cea:	00169813          	sll	a6,a3,0x1
42002cee:	010766b3          	or	a3,a4,a6
42002cf2:	0606                	sll	a2,a2,0x1
42002cf4:	0785                	add	a5,a5,1
42002cf6:	fe0858e3          	bgez	a6,42002ce6 <__umoddi3+0xe>
42002cfa:	03f00313          	li	t1,63
42002cfe:	587d                	li	a6,-1
42002d00:	02d5e063          	bltu	a1,a3,42002d20 <__umoddi3+0x48>
42002d04:	00b69463          	bne	a3,a1,42002d0c <__umoddi3+0x34>
42002d08:	00c56c63          	bltu	a0,a2,42002d20 <__umoddi3+0x48>
42002d0c:	02f36363          	bltu	t1,a5,42002d32 <__umoddi3+0x5a>
42002d10:	40c50733          	sub	a4,a0,a2
42002d14:	00e538b3          	sltu	a7,a0,a4
42002d18:	8d95                	sub	a1,a1,a3
42002d1a:	853a                	mv	a0,a4
42002d1c:	411585b3          	sub	a1,a1,a7
42002d20:	01f69713          	sll	a4,a3,0x1f
42002d24:	8205                	srl	a2,a2,0x1
42002d26:	17fd                	add	a5,a5,-1
42002d28:	8e59                	or	a2,a2,a4
42002d2a:	8285                	srl	a3,a3,0x1
42002d2c:	fd079ae3          	bne	a5,a6,42002d00 <__umoddi3+0x28>
DIVMOD_FUNCS(di_t, di)
42002d30:	8082                	ret
DIVMOD_IMPL(di_t, di)
42002d32:	9002                	ebreak

42002d34 <__divmoddi4>:
DIVMOD_FUNCS(di_t, di)
42002d34:	1101                	add	sp,sp,-32
42002d36:	cc26                	sw	s1,24(sp)
42002d38:	00d667b3          	or	a5,a2,a3
42002d3c:	84aa                	mv	s1,a0
42002d3e:	82ae                	mv	t0,a1
42002d40:	cbed                	beqz	a5,42002e32 <__divmoddi4+0xfe>
42002d42:	c84e                	sw	s3,16(sp)
42002d44:	ce22                	sw	s0,28(sp)
42002d46:	ca4a                	sw	s2,20(sp)
42002d48:	c652                	sw	s4,12(sp)
42002d4a:	00b6c9b3          	xor	s3,a3,a1
42002d4e:	8f2a                	mv	t5,a0
42002d50:	8e2e                	mv	t3,a1
42002d52:	87b2                	mv	a5,a2
42002d54:	8836                	mv	a6,a3
DIVMOD_IMPL(di_t, di)
42002d56:	4881                	li	a7,0
42002d58:	0006cc63          	bltz	a3,42002d70 <__divmoddi4+0x3c>
42002d5c:	01f7d313          	srl	t1,a5,0x1f
42002d60:	00181e93          	sll	t4,a6,0x1
42002d64:	01d36833          	or	a6,t1,t4
42002d68:	0786                	sll	a5,a5,0x1
42002d6a:	0885                	add	a7,a7,1
42002d6c:	fe0ed8e3          	bgez	t4,42002d5c <__divmoddi4+0x28>
42002d70:	4501                	li	a0,0
42002d72:	4581                	li	a1,0
42002d74:	03f00913          	li	s2,63
42002d78:	4a05                	li	s4,1
42002d7a:	5ffd                	li	t6,-1
42002d7c:	030e6b63          	bltu	t3,a6,42002db2 <__divmoddi4+0x7e>
42002d80:	01c81463          	bne	a6,t3,42002d88 <__divmoddi4+0x54>
42002d84:	02ff6763          	bltu	t5,a5,42002db2 <__divmoddi4+0x7e>
42002d88:	0d196063          	bltu	s2,a7,42002e48 <__divmoddi4+0x114>
42002d8c:	fe088313          	add	t1,a7,-32
42002d90:	06034763          	bltz	t1,42002dfe <__divmoddi4+0xca>
42002d94:	006a1333          	sll	t1,s4,t1
42002d98:	4401                	li	s0,0
42002d9a:	40ff0eb3          	sub	t4,t5,a5
42002d9e:	01df33b3          	sltu	t2,t5,t4
42002da2:	410e0e33          	sub	t3,t3,a6
42002da6:	8d41                	or	a0,a0,s0
42002da8:	0065e5b3          	or	a1,a1,t1
42002dac:	8f76                	mv	t5,t4
42002dae:	407e0e33          	sub	t3,t3,t2
42002db2:	01f81313          	sll	t1,a6,0x1f
42002db6:	8385                	srl	a5,a5,0x1
42002db8:	18fd                	add	a7,a7,-1
42002dba:	00f367b3          	or	a5,t1,a5
42002dbe:	00185813          	srl	a6,a6,0x1
42002dc2:	fbf89de3          	bne	a7,t6,42002d7c <__divmoddi4+0x48>
DIVMOD_FUNCS(di_t, di)
42002dc6:	04d2d063          	bge	t0,a3,42002e06 <__divmoddi4+0xd2>
42002dca:	01e037b3          	snez	a5,t5
42002dce:	41c00e33          	neg	t3,t3
42002dd2:	40fe0e33          	sub	t3,t3,a5
42002dd6:	41e00f33          	neg	t5,t5
42002dda:	84fa                	mv	s1,t5
42002ddc:	82f2                	mv	t0,t3
42002dde:	c72d                	beqz	a4,42002e48 <__divmoddi4+0x114>
42002de0:	00777793          	and	a5,a4,7
42002de4:	e3b5                	bnez	a5,42002e48 <__divmoddi4+0x114>
42002de6:	0209c563          	bltz	s3,42002e10 <__divmoddi4+0xdc>
42002dea:	4472                	lw	s0,28(sp)
42002dec:	4952                	lw	s2,20(sp)
42002dee:	49c2                	lw	s3,16(sp)
42002df0:	4a32                	lw	s4,12(sp)
42002df2:	c304                	sw	s1,0(a4)
42002df4:	00572223          	sw	t0,4(a4)
42002df8:	44e2                	lw	s1,24(sp)
42002dfa:	6105                	add	sp,sp,32
42002dfc:	8082                	ret
DIVMOD_IMPL(di_t, di)
42002dfe:	4301                	li	t1,0
42002e00:	011a1433          	sll	s0,s4,a7
42002e04:	bf59                	j	42002d9a <__divmoddi4+0x66>
DIVMOD_FUNCS(di_t, di)
42002e06:	fc569ae3          	bne	a3,t0,42002dda <__divmoddi4+0xa6>
42002e0a:	fcc4f8e3          	bgeu	s1,a2,42002dda <__divmoddi4+0xa6>
42002e0e:	bf75                	j	42002dca <__divmoddi4+0x96>
42002e10:	4472                	lw	s0,28(sp)
42002e12:	00a037b3          	snez	a5,a0
42002e16:	c304                	sw	s1,0(a4)
42002e18:	40b005b3          	neg	a1,a1
42002e1c:	00572223          	sw	t0,4(a4)
42002e20:	4952                	lw	s2,20(sp)
42002e22:	49c2                	lw	s3,16(sp)
42002e24:	4a32                	lw	s4,12(sp)
42002e26:	44e2                	lw	s1,24(sp)
42002e28:	8d9d                	sub	a1,a1,a5
42002e2a:	40a00533          	neg	a0,a0
42002e2e:	6105                	add	sp,sp,32
42002e30:	8082                	ret
42002e32:	c711                	beqz	a4,42002e3e <__divmoddi4+0x10a>
42002e34:	00777793          	and	a5,a4,7
42002e38:	557d                	li	a0,-1
42002e3a:	55fd                	li	a1,-1
42002e3c:	dbdd                	beqz	a5,42002df2 <__divmoddi4+0xbe>
42002e3e:	ce22                	sw	s0,28(sp)
42002e40:	ca4a                	sw	s2,20(sp)
42002e42:	c84e                	sw	s3,16(sp)
42002e44:	c652                	sw	s4,12(sp)
42002e46:	9002                	ebreak
42002e48:	9002                	ebreak

42002e4a <__divdi3>:
42002e4a:	00d667b3          	or	a5,a2,a3
42002e4e:	8f2a                	mv	t5,a0
42002e50:	872e                	mv	a4,a1
42002e52:	c3ed                	beqz	a5,42002f34 <__divdi3+0xea>
42002e54:	00b6c2b3          	xor	t0,a3,a1
42002e58:	0a05c563          	bltz	a1,42002f02 <__divdi3+0xb8>
42002e5c:	0806c663          	bltz	a3,42002ee8 <__divdi3+0x9e>
DIVMOD_IMPL(di_t, di)
42002e60:	4781                	li	a5,0
42002e62:	01f65593          	srl	a1,a2,0x1f
42002e66:	00169813          	sll	a6,a3,0x1
42002e6a:	0105e6b3          	or	a3,a1,a6
42002e6e:	0606                	sll	a2,a2,0x1
42002e70:	0785                	add	a5,a5,1
42002e72:	fe0858e3          	bgez	a6,42002e62 <__divdi3+0x18>
42002e76:	4501                	li	a0,0
42002e78:	4581                	li	a1,0
42002e7a:	03f00f93          	li	t6,63
42002e7e:	4385                	li	t2,1
42002e80:	537d                	li	t1,-1
42002e82:	02d76b63          	bltu	a4,a3,42002eb8 <__divdi3+0x6e>
42002e86:	00e69463          	bne	a3,a4,42002e8e <__divdi3+0x44>
42002e8a:	02cf6763          	bltu	t5,a2,42002eb8 <__divdi3+0x6e>
42002e8e:	0affea63          	bltu	t6,a5,42002f42 <__divdi3+0xf8>
42002e92:	fe078813          	add	a6,a5,-32
42002e96:	02084d63          	bltz	a6,42002ed0 <__divdi3+0x86>
42002e9a:	01039833          	sll	a6,t2,a6
42002e9e:	4e81                	li	t4,0
42002ea0:	40cf08b3          	sub	a7,t5,a2
42002ea4:	011f3e33          	sltu	t3,t5,a7
42002ea8:	8f15                	sub	a4,a4,a3
42002eaa:	01d56533          	or	a0,a0,t4
42002eae:	0105e5b3          	or	a1,a1,a6
42002eb2:	8f46                	mv	t5,a7
42002eb4:	41c70733          	sub	a4,a4,t3
42002eb8:	01f69813          	sll	a6,a3,0x1f
42002ebc:	8205                	srl	a2,a2,0x1
42002ebe:	17fd                	add	a5,a5,-1
42002ec0:	00c86633          	or	a2,a6,a2
42002ec4:	8285                	srl	a3,a3,0x1
42002ec6:	fa679ee3          	bne	a5,t1,42002e82 <__divdi3+0x38>
DIVMOD_FUNCS(di_t, di)
42002eca:	0002c763          	bltz	t0,42002ed8 <__divdi3+0x8e>
42002ece:	8082                	ret
DIVMOD_IMPL(di_t, di)
42002ed0:	4801                	li	a6,0
42002ed2:	00f39eb3          	sll	t4,t2,a5
42002ed6:	b7e9                	j	42002ea0 <__divdi3+0x56>
DIVMOD_FUNCS(di_t, di)
42002ed8:	00a037b3          	snez	a5,a0
42002edc:	40b005b3          	neg	a1,a1
42002ee0:	8d9d                	sub	a1,a1,a5
42002ee2:	40a00533          	neg	a0,a0
42002ee6:	8082                	ret
42002ee8:	00c035b3          	snez	a1,a2
42002eec:	40d007b3          	neg	a5,a3
42002ef0:	40c00533          	neg	a0,a2
42002ef4:	8f8d                	sub	a5,a5,a1
42002ef6:	c231                	beqz	a2,42002f3a <__divdi3+0xf0>
DIVMOD_IMPL(di_t, di)
42002ef8:	0207c363          	bltz	a5,42002f1e <__divdi3+0xd4>
DIVMOD_FUNCS(di_t, di)
42002efc:	862a                	mv	a2,a0
42002efe:	86be                	mv	a3,a5
42002f00:	b785                	j	42002e60 <__divdi3+0x16>
42002f02:	40b007b3          	neg	a5,a1
42002f06:	00a03533          	snez	a0,a0
42002f0a:	41e005b3          	neg	a1,t5
42002f0e:	8f89                	sub	a5,a5,a0
42002f10:	020f0a63          	beqz	t5,42002f44 <__divdi3+0xfa>
42002f14:	8f2e                	mv	t5,a1
42002f16:	873e                	mv	a4,a5
42002f18:	f406d4e3          	bgez	a3,42002e60 <__divdi3+0x16>
42002f1c:	b7f1                	j	42002ee8 <__divdi3+0x9e>
DIVMOD_IMPL(di_t, di)
42002f1e:	4781                	li	a5,0
42002f20:	4601                	li	a2,0
42002f22:	800006b7          	lui	a3,0x80000
42002f26:	4501                	li	a0,0
42002f28:	4581                	li	a1,0
42002f2a:	03f00f93          	li	t6,63
42002f2e:	4385                	li	t2,1
42002f30:	537d                	li	t1,-1
42002f32:	bf81                	j	42002e82 <__divdi3+0x38>
DIVMOD_FUNCS(di_t, di)
42002f34:	557d                	li	a0,-1
42002f36:	55fd                	li	a1,-1
42002f38:	8082                	ret
42002f3a:	80000637          	lui	a2,0x80000
42002f3e:	fac69de3          	bne	a3,a2,42002ef8 <__divdi3+0xae>
DIVMOD_IMPL(di_t, di)
42002f42:	9002                	ebreak
DIVMOD_FUNCS(di_t, di)
42002f44:	80000537          	lui	a0,0x80000
42002f48:	fca716e3          	bne	a4,a0,42002f14 <__divdi3+0xca>
DIVMOD_IMPL(di_t, di)
42002f4c:	9002                	ebreak

42002f4e <__moddi3>:
DIVMOD_FUNCS(di_t, di)
42002f4e:	00d667b3          	or	a5,a2,a3
42002f52:	872a                	mv	a4,a0
42002f54:	88ae                	mv	a7,a1
42002f56:	cfa9                	beqz	a5,42002fb0 <__moddi3+0x62>
42002f58:	0805c263          	bltz	a1,42002fdc <__moddi3+0x8e>
42002f5c:	0606c363          	bltz	a3,42002fc2 <__moddi3+0x74>
DIVMOD_IMPL(di_t, di)
42002f60:	4781                	li	a5,0
42002f62:	01f65713          	srl	a4,a2,0x1f
42002f66:	00169813          	sll	a6,a3,0x1
42002f6a:	010766b3          	or	a3,a4,a6
42002f6e:	0606                	sll	a2,a2,0x1
42002f70:	0785                	add	a5,a5,1
42002f72:	fe0858e3          	bgez	a6,42002f62 <__moddi3+0x14>
42002f76:	03f00e13          	li	t3,63
42002f7a:	587d                	li	a6,-1
42002f7c:	02d5e063          	bltu	a1,a3,42002f9c <__moddi3+0x4e>
42002f80:	00b69463          	bne	a3,a1,42002f88 <__moddi3+0x3a>
42002f84:	00c56c63          	bltu	a0,a2,42002f9c <__moddi3+0x4e>
42002f88:	06fe6763          	bltu	t3,a5,42002ff6 <__moddi3+0xa8>
42002f8c:	40c50733          	sub	a4,a0,a2
42002f90:	00e53333          	sltu	t1,a0,a4
42002f94:	8d95                	sub	a1,a1,a3
42002f96:	853a                	mv	a0,a4
42002f98:	406585b3          	sub	a1,a1,t1
42002f9c:	01f69713          	sll	a4,a3,0x1f
42002fa0:	8205                	srl	a2,a2,0x1
42002fa2:	17fd                	add	a5,a5,-1
42002fa4:	8e59                	or	a2,a2,a4
42002fa6:	8285                	srl	a3,a3,0x1
42002fa8:	fd079ae3          	bne	a5,a6,42002f7c <__moddi3+0x2e>
DIVMOD_FUNCS(di_t, di)
42002fac:	0008c363          	bltz	a7,42002fb2 <__moddi3+0x64>
42002fb0:	8082                	ret
42002fb2:	00a037b3          	snez	a5,a0
42002fb6:	40b005b3          	neg	a1,a1
42002fba:	8d9d                	sub	a1,a1,a5
42002fbc:	40a00533          	neg	a0,a0
42002fc0:	8082                	ret
42002fc2:	00c03733          	snez	a4,a2
42002fc6:	40d007b3          	neg	a5,a3
42002fca:	40c00833          	neg	a6,a2
42002fce:	8f99                	sub	a5,a5,a4
42002fd0:	ca0d                	beqz	a2,42003002 <__moddi3+0xb4>
DIVMOD_IMPL(di_t, di)
42002fd2:	0207c363          	bltz	a5,42002ff8 <__moddi3+0xaa>
DIVMOD_FUNCS(di_t, di)
42002fd6:	8642                	mv	a2,a6
42002fd8:	86be                	mv	a3,a5
42002fda:	b759                	j	42002f60 <__moddi3+0x12>
42002fdc:	00a035b3          	snez	a1,a0
42002fe0:	411007b3          	neg	a5,a7
42002fe4:	40a00533          	neg	a0,a0
42002fe8:	40b785b3          	sub	a1,a5,a1
42002fec:	fb25                	bnez	a4,42002f5c <__moddi3+0xe>
42002fee:	800007b7          	lui	a5,0x80000
42002ff2:	f6f895e3          	bne	a7,a5,42002f5c <__moddi3+0xe>
DIVMOD_IMPL(di_t, di)
42002ff6:	9002                	ebreak
42002ff8:	4781                	li	a5,0
42002ffa:	4601                	li	a2,0
42002ffc:	800006b7          	lui	a3,0x80000
42003000:	bf9d                	j	42002f76 <__moddi3+0x28>
DIVMOD_FUNCS(di_t, di)
42003002:	80000737          	lui	a4,0x80000
42003006:	fee688e3          	beq	a3,a4,42002ff6 <__moddi3+0xa8>
DIVMOD_IMPL(di_t, di)
4200300a:	fc07d6e3          	bgez	a5,42002fd6 <__moddi3+0x88>
4200300e:	b7ed                	j	42002ff8 <__moddi3+0xaa>

42003010 <__ashlsi3>:
#define FAKE_OPER(type, name, oper)                                                                                    \
    type name(type a, type b) {                                                                                        \
        return a oper(b & (sizeof(type) * 8 - 1));                                                                     \
    }

FAKE_OPER(si_t, __ashlsi3, <<)
42003010:	89fd                	and	a1,a1,31
42003012:	47fd                	li	a5,31
42003014:	8f8d                	sub	a5,a5,a1
42003016:	00f557b3          	srl	a5,a0,a5
4200301a:	e781                	bnez	a5,42003022 <__ashlsi3+0x12>
4200301c:	00b51533          	sll	a0,a0,a1
42003020:	8082                	ret
42003022:	9002                	ebreak

42003024 <__ashrsi3>:
FAKE_OPER(si_t, __ashrsi3, >>)
42003024:	40b55533          	sra	a0,a0,a1
42003028:	8082                	ret

4200302a <__lshrsi3>:
FAKE_OPER(si_t, __lshrsi3, >>)
4200302a:	40b55533          	sra	a0,a0,a1
4200302e:	8082                	ret

42003030 <__ashldi3>:
FAKE_OPER(di_t, __ashldi3, <<)
42003030:	03f67613          	and	a2,a2,63
42003034:	03f00713          	li	a4,63
42003038:	8f11                	sub	a4,a4,a2
4200303a:	fe070793          	add	a5,a4,-32 # 7fffffe0 <__stop_free_lpsram+0x2fffbfe0>
4200303e:	0007cf63          	bltz	a5,4200305c <__ashldi3+0x2c>
42003042:	00f5d7b3          	srl	a5,a1,a5
42003046:	4701                	li	a4,0
42003048:	8fd9                	or	a5,a5,a4
4200304a:	e3a9                	bnez	a5,4200308c <__ashldi3+0x5c>
4200304c:	fe060793          	add	a5,a2,-32 # 7fffffe0 <__stop_free_lpsram+0x2fffbfe0>
42003050:	0207c263          	bltz	a5,42003074 <__ashldi3+0x44>
42003054:	00f515b3          	sll	a1,a0,a5
42003058:	4501                	li	a0,0
4200305a:	8082                	ret
4200305c:	47fd                	li	a5,31
4200305e:	8f99                	sub	a5,a5,a4
42003060:	00159693          	sll	a3,a1,0x1
42003064:	00f696b3          	sll	a3,a3,a5
42003068:	00e557b3          	srl	a5,a0,a4
4200306c:	8fd5                	or	a5,a5,a3
4200306e:	00e5d733          	srl	a4,a1,a4
42003072:	bfd9                	j	42003048 <__ashldi3+0x18>
42003074:	477d                	li	a4,31
42003076:	00155793          	srl	a5,a0,0x1
4200307a:	8f11                	sub	a4,a4,a2
4200307c:	00e7d7b3          	srl	a5,a5,a4
42003080:	00c595b3          	sll	a1,a1,a2
42003084:	8ddd                	or	a1,a1,a5
42003086:	00c51533          	sll	a0,a0,a2
4200308a:	8082                	ret
4200308c:	9002                	ebreak

4200308e <__ashrdi3>:
FAKE_OPER(di_t, __ashrdi3, >>)
4200308e:	03f67613          	and	a2,a2,63
42003092:	fe060793          	add	a5,a2,-32
42003096:	0007c663          	bltz	a5,420030a2 <__ashrdi3+0x14>
4200309a:	40f5d533          	sra	a0,a1,a5
4200309e:	85fd                	sra	a1,a1,0x1f
420030a0:	8082                	ret
420030a2:	477d                	li	a4,31
420030a4:	00159793          	sll	a5,a1,0x1
420030a8:	8f11                	sub	a4,a4,a2
420030aa:	00e797b3          	sll	a5,a5,a4
420030ae:	00c55533          	srl	a0,a0,a2
420030b2:	8d5d                	or	a0,a0,a5
420030b4:	40c5d5b3          	sra	a1,a1,a2
420030b8:	8082                	ret

420030ba <__lshrdi3>:
FAKE_OPER(di_t, __lshrdi3, >>)
420030ba:	03f67613          	and	a2,a2,63
420030be:	fe060793          	add	a5,a2,-32
420030c2:	0007c663          	bltz	a5,420030ce <__lshrdi3+0x14>
420030c6:	40f5d533          	sra	a0,a1,a5
420030ca:	85fd                	sra	a1,a1,0x1f
420030cc:	8082                	ret
420030ce:	477d                	li	a4,31
420030d0:	00159793          	sll	a5,a1,0x1
420030d4:	8f11                	sub	a4,a4,a2
420030d6:	00e797b3          	sll	a5,a5,a4
420030da:	00c55533          	srl	a0,a0,a2
420030de:	8d5d                	or	a0,a0,a5
420030e0:	40c5d5b3          	sra	a1,a1,a2
420030e4:	8082                	ret

420030e6 <__mulsi3>:
FAKE_OPER(ti_t, __ashrti3, >>)
FAKE_OPER(ti_t, __lshrti3, >>)
#endif

// Explicit implementation of integer multiply for the larger versions to rely upon if required.
int __mulsi3(int a, int b) {
420030e6:	87aa                	mv	a5,a0
420030e8:	02000693          	li	a3,32
    int res = 0;
420030ec:	4501                	li	a0,0
    for (unsigned int i = 0; i < sizeof(int) * 8; i++) {
        if (b & 1) {
420030ee:	0015f713          	and	a4,a1,1
420030f2:	cb11                	beqz	a4,42003106 <__mulsi3+0x20>
            res += a;
420030f4:	00a78733          	add	a4,a5,a0
420030f8:	00f72633          	slt	a2,a4,a5
420030fc:	00052513          	slti	a0,a0,0
42003100:	00c51b63          	bne	a0,a2,42003116 <__mulsi3+0x30>
42003104:	853a                	mv	a0,a4
        }
        b >>= 1;
        a <<= 1;
42003106:	01e7d713          	srl	a4,a5,0x1e
        b >>= 1;
4200310a:	8585                	sra	a1,a1,0x1
        a <<= 1;
4200310c:	e709                	bnez	a4,42003116 <__mulsi3+0x30>
    for (unsigned int i = 0; i < sizeof(int) * 8; i++) {
4200310e:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
        a <<= 1;
42003110:	0786                	sll	a5,a5,0x1
    for (unsigned int i = 0; i < sizeof(int) * 8; i++) {
42003112:	fef1                	bnez	a3,420030ee <__mulsi3+0x8>
    }
    return res;
}
42003114:	8082                	ret
        a <<= 1;
42003116:	9002                	ebreak

42003118 <__muldi3>:

FAKE_OPER(di_t, __muldi3, *)
42003118:	41f55793          	sra	a5,a0,0x1f
4200311c:	03f67613          	and	a2,a2,63
42003120:	00b79763          	bne	a5,a1,4200312e <__muldi3+0x16>
42003124:	02a615b3          	mulh	a1,a2,a0
42003128:	02a60533          	mul	a0,a2,a0
4200312c:	8082                	ret
4200312e:	02a60733          	mul	a4,a2,a0
42003132:	02a637b3          	mulhu	a5,a2,a0
42003136:	02b606b3          	mul	a3,a2,a1
4200313a:	02b63533          	mulhu	a0,a2,a1
4200313e:	0005d363          	bgez	a1,42003144 <__muldi3+0x2c>
42003142:	8d11                	sub	a0,a0,a2
42003144:	00f685b3          	add	a1,a3,a5
42003148:	00d5b6b3          	sltu	a3,a1,a3
4200314c:	96aa                	add	a3,a3,a0
4200314e:	41f5d793          	sra	a5,a1,0x1f
42003152:	00d79463          	bne	a5,a3,4200315a <__muldi3+0x42>
42003156:	853a                	mv	a0,a4
42003158:	8082                	ret
4200315a:	9002                	ebreak

4200315c <putccb>:
    mutex_release(NULL, &log_mtx);
}

static bool putccb(char const *msg, size_t len, void *cookie) {
    (void)cookie;
    for (size_t i = 0; i < len; i++) {
4200315c:	c5a9                	beqz	a1,420031a6 <putccb+0x4a>
static bool putccb(char const *msg, size_t len, void *cookie) {
4200315e:	1101                	add	sp,sp,-32
42003160:	cc22                	sw	s0,24(sp)
42003162:	ca26                	sw	s1,20(sp)
42003164:	c84a                	sw	s2,16(sp)
42003166:	c64e                	sw	s3,12(sp)
42003168:	ce06                	sw	ra,28(sp)
4200316a:	89ae                	mv	s3,a1
4200316c:	892a                	mv	s2,a0
4200316e:	84aa                	mv	s1,a0
    for (size_t i = 0; i < len; i++) {
42003170:	4401                	li	s0,0
        rawputc(msg[i]);
42003172:	008907b3          	add	a5,s2,s0
42003176:	02044563          	bltz	s0,420031a0 <putccb+0x44>
4200317a:	0327e563          	bltu	a5,s2,420031a4 <putccb+0x48>
4200317e:	c495                	beqz	s1,420031aa <putccb+0x4e>
42003180:	0004c503          	lbu	a0,0(s1)
42003184:	0405                	add	s0,s0,1
    for (size_t i = 0; i < len; i++) {
42003186:	0485                	add	s1,s1,1
        rawputc(msg[i]);
42003188:	7e10c0ef          	jal	42010168 <rawputc>
    for (size_t i = 0; i < len; i++) {
4200318c:	fe8993e3          	bne	s3,s0,42003172 <putccb+0x16>
    }
    return true;
}
42003190:	40f2                	lw	ra,28(sp)
42003192:	4462                	lw	s0,24(sp)
42003194:	44d2                	lw	s1,20(sp)
42003196:	4942                	lw	s2,16(sp)
42003198:	49b2                	lw	s3,12(sp)
4200319a:	4505                	li	a0,1
4200319c:	6105                	add	sp,sp,32
4200319e:	8082                	ret
        rawputc(msg[i]);
420031a0:	fcf97fe3          	bgeu	s2,a5,4200317e <putccb+0x22>
420031a4:	9002                	ebreak
}
420031a6:	4505                	li	a0,1
420031a8:	8082                	ret
        rawputc(msg[i]);
420031aa:	9002                	ebreak

420031ac <logk_prefix>:
void logk_prefix(log_level_t level) {
420031ac:	1141                	add	sp,sp,-16
420031ae:	c606                	sw	ra,12(sp)
    if (isvalidlevel(level))
420031b0:	4791                	li	a5,4
420031b2:	02a7f063          	bgeu	a5,a0,420031d2 <logk_prefix+0x26>
    rawprintuptime();
420031b6:	2940d0ef          	jal	4201044a <rawprintuptime>
    rawputc(' ');
420031ba:	02000513          	li	a0,32
420031be:	7ab0c0ef          	jal	42010168 <rawputc>
}
420031c2:	40b2                	lw	ra,12(sp)
        rawprint("      ");
420031c4:	42017537          	lui	a0,0x42017
420031c8:	1a450513          	add	a0,a0,420 # 420171a4 <hextab+0x4d8>
}
420031cc:	0141                	add	sp,sp,16
        rawprint("      ");
420031ce:	0b00d06f          	j	4201027e <rawprint>
420031d2:	c422                	sw	s0,8(sp)
420031d4:	c226                	sw	s1,4(sp)
420031d6:	c04a                	sw	s2,0(sp)
        rawprint(colcode[level]);
420031d8:	4715                	li	a4,5
420031da:	842a                	mv	s0,a0
420031dc:	06e57763          	bgeu	a0,a4,4200324a <logk_prefix+0x9e>
420031e0:	00251913          	sll	s2,a0,0x2
420031e4:	420174b7          	lui	s1,0x42017
420031e8:	a8c48493          	add	s1,s1,-1396 # 42016a8c <colcode>
420031ec:	97ca                	add	a5,a5,s2
420031ee:	4751                	li	a4,20
420031f0:	012486b3          	add	a3,s1,s2
420031f4:	04f76863          	bltu	a4,a5,42003244 <logk_prefix+0x98>
420031f8:	012487b3          	add	a5,s1,s2
420031fc:	0497e763          	bltu	a5,s1,4200324a <logk_prefix+0x9e>
42003200:	4388                	lw	a0,0(a5)
42003202:	07c0d0ef          	jal	4201027e <rawprint>
    rawprintuptime();
42003206:	2440d0ef          	jal	4201044a <rawprintuptime>
    rawputc(' ');
4200320a:	02000513          	li	a0,32
4200320e:	75b0c0ef          	jal	42010168 <rawputc>
        rawprint(prefix[level]);
42003212:	4795                	li	a5,5
42003214:	02f47b63          	bgeu	s0,a5,4200324a <logk_prefix+0x9e>
42003218:	01448793          	add	a5,s1,20
4200321c:	00490713          	add	a4,s2,4
42003220:	46d1                	li	a3,20
42003222:	01278633          	add	a2,a5,s2
42003226:	02e6e363          	bltu	a3,a4,4200324c <logk_prefix+0xa0>
4200322a:	01278733          	add	a4,a5,s2
4200322e:	00f76e63          	bltu	a4,a5,4200324a <logk_prefix+0x9e>
42003232:	94ca                	add	s1,s1,s2
42003234:	4422                	lw	s0,8(sp)
42003236:	48c8                	lw	a0,20(s1)
42003238:	4902                	lw	s2,0(sp)
4200323a:	4492                	lw	s1,4(sp)
}
4200323c:	40b2                	lw	ra,12(sp)
4200323e:	0141                	add	sp,sp,16
        rawprint(prefix[level]);
42003240:	03e0d06f          	j	4201027e <rawprint>
        rawprint(colcode[level]);
42003244:	97b6                	add	a5,a5,a3
42003246:	fad7e9e3          	bltu	a5,a3,420031f8 <logk_prefix+0x4c>
        rawprint(prefix[level]);
4200324a:	9002                	ebreak
4200324c:	9732                	add	a4,a4,a2
4200324e:	fcc76ee3          	bltu	a4,a2,4200322a <logk_prefix+0x7e>
42003252:	bfe5                	j	4200324a <logk_prefix+0x9e>

42003254 <logk>:
void logk(log_level_t level, char const *msg) {
42003254:	1141                	add	sp,sp,-16
42003256:	c04a                	sw	s2,0(sp)
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
42003258:	800006b7          	lui	a3,0x80000
void logk(log_level_t level, char const *msg) {
4200325c:	c422                	sw	s0,8(sp)
4200325e:	c226                	sw	s1,4(sp)
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
42003260:	567d                	li	a2,-1
42003262:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
void logk(log_level_t level, char const *msg) {
42003264:	84aa                	mv	s1,a0
42003266:	842e                	mv	s0,a1
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
42003268:	4501                	li	a0,0
4200326a:	0b818593          	add	a1,gp,184 # 408000b8 <log_mtx>
void logk(log_level_t level, char const *msg) {
4200326e:	c606                	sw	ra,12(sp)
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
42003270:	2109                	jal	42003672 <mutex_acquire>
    logk_prefix(level);
42003272:	8526                	mv	a0,s1
42003274:	3f25                	jal	420031ac <logk_prefix>
    rawprint(msg);
42003276:	8522                	mv	a0,s0
42003278:	0060d0ef          	jal	4201027e <rawprint>
    rawprint(term);
4200327c:	42017537          	lui	a0,0x42017
42003280:	1ac50513          	add	a0,a0,428 # 420171ac <hextab+0x4e0>
42003284:	7fb0c0ef          	jal	4201027e <rawprint>
}
42003288:	4422                	lw	s0,8(sp)
4200328a:	40b2                	lw	ra,12(sp)
4200328c:	4492                	lw	s1,4(sp)
    mutex_release(NULL, &log_mtx);
4200328e:	0b818593          	add	a1,gp,184 # 408000b8 <log_mtx>
}
42003292:	4902                	lw	s2,0(sp)
    mutex_release(NULL, &log_mtx);
42003294:	4501                	li	a0,0
}
42003296:	0141                	add	sp,sp,16
    mutex_release(NULL, &log_mtx);
42003298:	a3b5                	j	42003804 <mutex_release>

4200329a <logkf>:

// Print a formatted message.
void logkf(log_level_t level, char const *msg, ...) {
4200329a:	7139                	add	sp,sp,-64
4200329c:	c84a                	sw	s2,16(sp)
4200329e:	d636                	sw	a3,44(sp)
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
420032a0:	800006b7          	lui	a3,0x80000
void logkf(log_level_t level, char const *msg, ...) {
420032a4:	cc22                	sw	s0,24(sp)
420032a6:	ca26                	sw	s1,20(sp)
420032a8:	842e                	mv	s0,a1
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
420032aa:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
420032ac:	0b818593          	add	a1,gp,184 # 408000b8 <log_mtx>
void logkf(log_level_t level, char const *msg, ...) {
420032b0:	84aa                	mv	s1,a0
420032b2:	d432                	sw	a2,40(sp)
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
420032b4:	4501                	li	a0,0
420032b6:	567d                	li	a2,-1
void logkf(log_level_t level, char const *msg, ...) {
420032b8:	ce06                	sw	ra,28(sp)
420032ba:	da3e                	sw	a5,52(sp)
420032bc:	dc42                	sw	a6,56(sp)
420032be:	de46                	sw	a7,60(sp)
420032c0:	d83a                	sw	a4,48(sp)
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
420032c2:	2e45                	jal	42003672 <mutex_acquire>
    logk_prefix(level);
420032c4:	8526                	mv	a0,s1
420032c6:	35dd                	jal	420031ac <logk_prefix>
    va_list vararg;
    va_start(vararg, msg);
420032c8:	1024                	add	s1,sp,40
    format_str_va(msg, cstr_length(msg), putccb, NULL, vararg);
420032ca:	8522                	mv	a0,s0
    va_start(vararg, msg);
420032cc:	c626                	sw	s1,12(sp)
    format_str_va(msg, cstr_length(msg), putccb, NULL, vararg);
420032ce:	a8dfe0ef          	jal	42001d5a <cstr_length>
420032d2:	42003637          	lui	a2,0x42003
420032d6:	85aa                	mv	a1,a0
420032d8:	8726                	mv	a4,s1
420032da:	4681                	li	a3,0
420032dc:	15c60613          	add	a2,a2,348 # 4200315c <putccb>
420032e0:	8522                	mv	a0,s0
420032e2:	d31fd0ef          	jal	42001012 <format_str_va>
    va_end(vararg);
    rawprint(term);
420032e6:	42017537          	lui	a0,0x42017
420032ea:	1ac50513          	add	a0,a0,428 # 420171ac <hextab+0x4e0>
420032ee:	7910c0ef          	jal	4201027e <rawprint>
    mutex_release(NULL, &log_mtx);
420032f2:	0b818593          	add	a1,gp,184 # 408000b8 <log_mtx>
420032f6:	4501                	li	a0,0
420032f8:	2331                	jal	42003804 <mutex_release>
}
420032fa:	40f2                	lw	ra,28(sp)
420032fc:	4462                	lw	s0,24(sp)
420032fe:	44d2                	lw	s1,20(sp)
42003300:	4942                	lw	s2,16(sp)
42003302:	6121                	add	sp,sp,64
42003304:	8082                	ret

42003306 <logk_hexdump_vaddr>:
}

#define LOGK_HEXDUMP_COLS   16
#define LOGK_HEXDUMP_GROUPS 4
// Print a hexdump, override the address shown (usually for debug purposes).
void logk_hexdump_vaddr(log_level_t level, char const *msg, void const *data, size_t size, size_t vaddr) {
42003306:	715d                	add	sp,sp,-80
42003308:	d06a                	sw	s10,32(sp)
4200330a:	8d36                	mv	s10,a3
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
4200330c:	800006b7          	lui	a3,0x80000
42003310:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
void logk_hexdump_vaddr(log_level_t level, char const *msg, void const *data, size_t size, size_t vaddr) {
42003312:	c4a2                	sw	s0,72(sp)
42003314:	c2a6                	sw	s1,68(sp)
42003316:	c0ca                	sw	s2,64(sp)
42003318:	84ae                	mv	s1,a1
4200331a:	892a                	mv	s2,a0
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
4200331c:	0b818593          	add	a1,gp,184 # 408000b8 <log_mtx>
void logk_hexdump_vaddr(log_level_t level, char const *msg, void const *data, size_t size, size_t vaddr) {
42003320:	8432                	mv	s0,a2
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
42003322:	4501                	li	a0,0
42003324:	567d                	li	a2,-1
void logk_hexdump_vaddr(log_level_t level, char const *msg, void const *data, size_t size, size_t vaddr) {
42003326:	c686                	sw	ra,76(sp)
42003328:	c63a                	sw	a4,12(sp)
4200332a:	c46a                	sw	s10,8(sp)
    mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
4200332c:	2699                	jal	42003672 <mutex_acquire>
    logk_prefix(level);
4200332e:	854a                	mv	a0,s2
42003330:	3db5                	jal	420031ac <logk_prefix>
    rawprint(msg);
42003332:	8526                	mv	a0,s1
42003334:	74b0c0ef          	jal	4201027e <rawprint>
    rawputc('\r');
42003338:	4535                	li	a0,13
4200333a:	62f0c0ef          	jal	42010168 <rawputc>
    rawputc('\n');
4200333e:	4529                	li	a0,10
42003340:	6290c0ef          	jal	42010168 <rawputc>

    uint8_t const *ptr = data;
    for (size_t y = 0; y * LOGK_HEXDUMP_COLS < size; y++) {
42003344:	0e0d0a63          	beqz	s10,42003438 <logk_hexdump_vaddr+0x132>
42003348:	47a2                	lw	a5,8(sp)
4200334a:	de4e                	sw	s3,60(sp)
4200334c:	dc52                	sw	s4,56(sp)
4200334e:	da56                	sw	s5,52(sp)
42003350:	d85a                	sw	s6,48(sp)
42003352:	d65e                	sw	s7,44(sp)
42003354:	d462                	sw	s8,40(sp)
42003356:	d266                	sw	s9,36(sp)
42003358:	ce6e                	sw	s11,28(sp)
4200335a:	8ca2                	mv	s9,s0
4200335c:	89be                	mv	s3,a5
4200335e:	4a41                	li	s4,16
42003360:	4901                	li	s2,0
42003362:	fff78b13          	add	s6,a5,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
        }
        rawputc(' ');
        rawputc(' ');
        for (x = 0; y * LOGK_HEXDUMP_COLS + x < size && x < LOGK_HEXDUMP_COLS; x++) {
            char c = (char)ptr[y * LOGK_HEXDUMP_COLS + x];
            if (c >= 0x20 && c <= 0x7e) {
42003366:	05e00a93          	li	s5,94
        for (; x < LOGK_HEXDUMP_GROUPS; x++) {
4200336a:	4c11                	li	s8,4
        for (x = 0; y * LOGK_HEXDUMP_COLS + x < size && x < LOGK_HEXDUMP_COLS; x++) {
4200336c:	4bc1                	li	s7,16
        rawprinthex((size_t)vaddr + y * LOGK_HEXDUMP_COLS, sizeof(size_t) * 2);
4200336e:	47b2                	lw	a5,12(sp)
42003370:	4621                	li	a2,8
42003372:	4581                	li	a1,0
42003374:	01278533          	add	a0,a5,s2
42003378:	76d0c0ef          	jal	420102e4 <rawprinthex>
        rawputc(':');
4200337c:	03a00513          	li	a0,58
42003380:	5e90c0ef          	jal	42010168 <rawputc>
        for (x = 0; y * LOGK_HEXDUMP_COLS + x < size && x < LOGK_HEXDUMP_COLS; x++) {
42003384:	47a2                	lw	a5,8(sp)
42003386:	0ef97463          	bgeu	s2,a5,4200346e <logk_hexdump_vaddr+0x168>
4200338a:	84e6                	mv	s1,s9
4200338c:	4d81                	li	s11,0
            if ((x % LOGK_HEXDUMP_GROUPS) == 0) {
4200338e:	003df713          	and	a4,s11,3
42003392:	01b90d33          	add	s10,s2,s11
42003396:	c779                	beqz	a4,42003464 <logk_hexdump_vaddr+0x15e>
            rawputc(' ');
42003398:	02000513          	li	a0,32
4200339c:	5cd0c0ef          	jal	42010168 <rawputc>
            rawprinthex(ptr[y * LOGK_HEXDUMP_COLS + x], 2);
420033a0:	01a40733          	add	a4,s0,s10
420033a4:	0a0d4d63          	bltz	s10,4200345e <logk_hexdump_vaddr+0x158>
420033a8:	0a876a63          	bltu	a4,s0,4200345c <logk_hexdump_vaddr+0x156>
420033ac:	c8c5                	beqz	s1,4200345c <logk_hexdump_vaddr+0x156>
420033ae:	0004c503          	lbu	a0,0(s1)
420033b2:	4609                	li	a2,2
420033b4:	4581                	li	a1,0
        for (x = 0; y * LOGK_HEXDUMP_COLS + x < size && x < LOGK_HEXDUMP_COLS; x++) {
420033b6:	0d85                	add	s11,s11,1
            rawprinthex(ptr[y * LOGK_HEXDUMP_COLS + x], 2);
420033b8:	72d0c0ef          	jal	420102e4 <rawprinthex>
        for (x = 0; y * LOGK_HEXDUMP_COLS + x < size && x < LOGK_HEXDUMP_COLS; x++) {
420033bc:	0f3d8963          	beq	s11,s3,420034ae <logk_hexdump_vaddr+0x1a8>
420033c0:	0485                	add	s1,s1,1
420033c2:	fd7d96e3          	bne	s11,s7,4200338e <logk_hexdump_vaddr+0x88>
        rawputc(' ');
420033c6:	02000513          	li	a0,32
420033ca:	59f0c0ef          	jal	42010168 <rawputc>
        rawputc(' ');
420033ce:	02000513          	li	a0,32
420033d2:	5970c0ef          	jal	42010168 <rawputc>
                rawputc(' ');
420033d6:	8de6                	mv	s11,s9
420033d8:	84ca                	mv	s1,s2
            char c = (char)ptr[y * LOGK_HEXDUMP_COLS + x];
420033da:	00940733          	add	a4,s0,s1
420033de:	0604cd63          	bltz	s1,42003458 <logk_hexdump_vaddr+0x152>
420033e2:	06876d63          	bltu	a4,s0,4200345c <logk_hexdump_vaddr+0x156>
420033e6:	060d8b63          	beqz	s11,4200345c <logk_hexdump_vaddr+0x156>
420033ea:	000dc503          	lbu	a0,0(s11)
            if (c >= 0x20 && c <= 0x7e) {
420033ee:	fe050713          	add	a4,a0,-32
420033f2:	0ff77713          	zext.b	a4,a4
420033f6:	00eaf463          	bgeu	s5,a4,420033fe <logk_hexdump_vaddr+0xf8>
                rawputc(c);
            } else {
                rawputc('.');
420033fa:	02e00513          	li	a0,46
420033fe:	56b0c0ef          	jal	42010168 <rawputc>
        for (x = 0; y * LOGK_HEXDUMP_COLS + x < size && x < LOGK_HEXDUMP_COLS; x++) {
42003402:	01648663          	beq	s1,s6,4200340e <logk_hexdump_vaddr+0x108>
42003406:	0485                	add	s1,s1,1
42003408:	0d85                	add	s11,s11,1
4200340a:	fd4498e3          	bne	s1,s4,420033da <logk_hexdump_vaddr+0xd4>
            }
        }
        rawputc('\r');
4200340e:	4535                	li	a0,13
42003410:	5590c0ef          	jal	42010168 <rawputc>
        rawputc('\n');
42003414:	4529                	li	a0,10
42003416:	5530c0ef          	jal	42010168 <rawputc>
    for (size_t y = 0; y * LOGK_HEXDUMP_COLS < size; y++) {
4200341a:	47a2                	lw	a5,8(sp)
4200341c:	0941                	add	s2,s2,16
4200341e:	0a41                	add	s4,s4,16
42003420:	0cc1                	add	s9,s9,16
42003422:	19c1                	add	s3,s3,-16
42003424:	f4f965e3          	bltu	s2,a5,4200336e <logk_hexdump_vaddr+0x68>
42003428:	59f2                	lw	s3,60(sp)
4200342a:	5a62                	lw	s4,56(sp)
4200342c:	5ad2                	lw	s5,52(sp)
4200342e:	5b42                	lw	s6,48(sp)
42003430:	5bb2                	lw	s7,44(sp)
42003432:	5c22                	lw	s8,40(sp)
42003434:	5c92                	lw	s9,36(sp)
42003436:	4df2                	lw	s11,28(sp)
    }
    rawprint("\033[0m");
42003438:	42017537          	lui	a0,0x42017
4200343c:	1b450513          	add	a0,a0,436 # 420171b4 <hextab+0x4e8>
42003440:	63f0c0ef          	jal	4201027e <rawprint>
    mutex_release(NULL, &log_mtx);
}
42003444:	4426                	lw	s0,72(sp)
42003446:	40b6                	lw	ra,76(sp)
42003448:	4496                	lw	s1,68(sp)
4200344a:	4906                	lw	s2,64(sp)
4200344c:	5d02                	lw	s10,32(sp)
    mutex_release(NULL, &log_mtx);
4200344e:	0b818593          	add	a1,gp,184 # 408000b8 <log_mtx>
42003452:	4501                	li	a0,0
}
42003454:	6161                	add	sp,sp,80
    mutex_release(NULL, &log_mtx);
42003456:	a67d                	j	42003804 <mutex_release>
            char c = (char)ptr[y * LOGK_HEXDUMP_COLS + x];
42003458:	f8e477e3          	bgeu	s0,a4,420033e6 <logk_hexdump_vaddr+0xe0>
4200345c:	9002                	ebreak
            rawprinthex(ptr[y * LOGK_HEXDUMP_COLS + x], 2);
4200345e:	f4e477e3          	bgeu	s0,a4,420033ac <logk_hexdump_vaddr+0xa6>
            char c = (char)ptr[y * LOGK_HEXDUMP_COLS + x];
42003462:	9002                	ebreak
                rawputc(' ');
42003464:	02000513          	li	a0,32
42003468:	5010c0ef          	jal	42010168 <rawputc>
4200346c:	b735                	j	42003398 <logk_hexdump_vaddr+0x92>
                rawputc(' ');
4200346e:	02000513          	li	a0,32
42003472:	4f70c0ef          	jal	42010168 <rawputc>
42003476:	4481                	li	s1,0
            rawputc(' ');
42003478:	02000513          	li	a0,32
4200347c:	4ed0c0ef          	jal	42010168 <rawputc>
            rawputc(' ');
42003480:	02000513          	li	a0,32
42003484:	4e50c0ef          	jal	42010168 <rawputc>
            rawputc(' ');
42003488:	02000513          	li	a0,32
        for (; x < LOGK_HEXDUMP_GROUPS; x++) {
4200348c:	0485                	add	s1,s1,1
            rawputc(' ');
4200348e:	4db0c0ef          	jal	42010168 <rawputc>
        for (; x < LOGK_HEXDUMP_GROUPS; x++) {
42003492:	ff8493e3          	bne	s1,s8,42003478 <logk_hexdump_vaddr+0x172>
        rawputc(' ');
42003496:	02000513          	li	a0,32
4200349a:	4cf0c0ef          	jal	42010168 <rawputc>
        rawputc(' ');
4200349e:	02000513          	li	a0,32
420034a2:	4c70c0ef          	jal	42010168 <rawputc>
        for (x = 0; y * LOGK_HEXDUMP_COLS + x < size && x < LOGK_HEXDUMP_COLS; x++) {
420034a6:	47a2                	lw	a5,8(sp)
420034a8:	f2f967e3          	bltu	s2,a5,420033d6 <logk_hexdump_vaddr+0xd0>
420034ac:	b78d                	j	4200340e <logk_hexdump_vaddr+0x108>
        for (; x < LOGK_HEXDUMP_GROUPS; x++) {
420034ae:	478d                	li	a5,3
420034b0:	84ce                	mv	s1,s3
420034b2:	fd37f3e3          	bgeu	a5,s3,42003478 <logk_hexdump_vaddr+0x172>
420034b6:	bf01                	j	420033c6 <logk_hexdump_vaddr+0xc0>

420034b8 <logk_hexdump>:
void logk_hexdump(log_level_t level, char const *msg, void const *data, size_t size) {
420034b8:	8732                	mv	a4,a2
    logk_hexdump_vaddr(level, msg, data, size, (size_t)data);
420034ba:	b5b1                	j	42003306 <logk_hexdump_vaddr>

420034bc <mutex_init>:



// Initialise a mutex for unshared use.
void mutex_init(badge_err_t *ec, mutex_t *mutex) {
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) == MUTEX_MAGIC) {
420034bc:	cdc1                	beqz	a1,42003554 <mutex_init+0x98>
420034be:	0035f793          	and	a5,a1,3
420034c2:	ebc9                	bnez	a5,42003554 <mutex_init+0x98>
void mutex_init(badge_err_t *ec, mutex_t *mutex) {
420034c4:	1141                	add	sp,sp,-16
420034c6:	c422                	sw	s0,8(sp)
420034c8:	c606                	sw	ra,12(sp)
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) == MUTEX_MAGIC) {
420034ca:	4198                	lw	a4,0(a1)
420034cc:	842a                	mv	s0,a0
420034ce:	0ff0000f          	fence
420034d2:	cafec7b7          	lui	a5,0xcafec
420034d6:	abe78793          	add	a5,a5,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
420034da:	04f70463          	beq	a4,a5,42003522 <mutex_init+0x66>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
        return;
    }
    mutex->magic     = MUTEX_MAGIC;
420034de:	0f50000f          	fence	iorw,ow
420034e2:	0cf5a02f          	amoswap.w.aq	zero,a5,(a1)
    mutex->is_shared = false;
420034e6:	57f1                	li	a5,-4
420034e8:	06f5f763          	bgeu	a1,a5,42003556 <mutex_init+0x9a>
420034ec:	00058223          	sb	zero,4(a1) # 80000004 <__stop_free_lpsram+0x2fffc004>
    atomic_store(&mutex->shares, 0);
420034f0:	5761                	li	a4,-8
420034f2:	06e5f363          	bgeu	a1,a4,42003558 <mutex_init+0x9c>
420034f6:	00858713          	add	a4,a1,8
420034fa:	0f50000f          	fence	iorw,ow
420034fe:	0c07202f          	amoswap.w.aq	zero,zero,(a4)
    atomic_thread_fence(memory_order_release);
42003502:	0ff0000f          	fence
    badge_err_set_ok(ec);
42003506:	c911                	beqz	a0,4200351a <mutex_init+0x5e>
42003508:	00357713          	and	a4,a0,3
4200350c:	e739                	bnez	a4,4200355a <mutex_init+0x9e>
4200350e:	04f57763          	bgeu	a0,a5,4200355c <mutex_init+0xa0>
42003512:	00052223          	sw	zero,4(a0)
42003516:	00052023          	sw	zero,0(a0)
}
4200351a:	40b2                	lw	ra,12(sp)
4200351c:	4422                	lw	s0,8(sp)
4200351e:	0141                	add	sp,sp,16
42003520:	8082                	ret
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003522:	dd65                	beqz	a0,4200351a <mutex_init+0x5e>
42003524:	420175b7          	lui	a1,0x42017
42003528:	46d9                	li	a3,22
4200352a:	4601                	li	a2,0
4200352c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42003530:	4511                	li	a0,4
42003532:	00000717          	auipc	a4,0x0
42003536:	3395                	jal	4200329a <logkf>
42003538:	00347793          	and	a5,s0,3
4200353c:	e395                	bnez	a5,42003560 <mutex_init+0xa4>
4200353e:	57f1                	li	a5,-4
42003540:	00f47f63          	bgeu	s0,a5,4200355e <mutex_init+0xa2>
42003544:	47d9                	li	a5,22
}
42003546:	40b2                	lw	ra,12(sp)
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003548:	00042223          	sw	zero,4(s0)
4200354c:	c01c                	sw	a5,0(s0)
}
4200354e:	4422                	lw	s0,8(sp)
42003550:	0141                	add	sp,sp,16
42003552:	8082                	ret
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) == MUTEX_MAGIC) {
42003554:	9002                	ebreak
    mutex->is_shared = false;
42003556:	9002                	ebreak
    atomic_store(&mutex->shares, 0);
42003558:	9002                	ebreak
    badge_err_set_ok(ec);
4200355a:	9002                	ebreak
4200355c:	9002                	ebreak
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
4200355e:	9002                	ebreak
42003560:	9002                	ebreak

42003562 <mutex_init_shared>:

// Initialise a mutex for shared use.
void mutex_init_shared(badge_err_t *ec, mutex_t *mutex) {
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) == MUTEX_MAGIC) {
42003562:	cdc9                	beqz	a1,420035fc <mutex_init_shared+0x9a>
42003564:	0035f793          	and	a5,a1,3
42003568:	ebd1                	bnez	a5,420035fc <mutex_init_shared+0x9a>
void mutex_init_shared(badge_err_t *ec, mutex_t *mutex) {
4200356a:	1141                	add	sp,sp,-16
4200356c:	c422                	sw	s0,8(sp)
4200356e:	c606                	sw	ra,12(sp)
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) == MUTEX_MAGIC) {
42003570:	4198                	lw	a4,0(a1)
42003572:	842a                	mv	s0,a0
42003574:	0ff0000f          	fence
42003578:	cafec7b7          	lui	a5,0xcafec
4200357c:	abe78793          	add	a5,a5,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
42003580:	04f70563          	beq	a4,a5,420035ca <mutex_init_shared+0x68>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
        return;
    }
    mutex->magic     = MUTEX_MAGIC;
42003584:	0f50000f          	fence	iorw,ow
42003588:	0cf5a02f          	amoswap.w.aq	zero,a5,(a1)
    mutex->is_shared = true;
4200358c:	57f1                	li	a5,-4
4200358e:	06f5f863          	bgeu	a1,a5,420035fe <mutex_init_shared+0x9c>
42003592:	4705                	li	a4,1
42003594:	00e58223          	sb	a4,4(a1)
    atomic_store(&mutex->shares, 0);
42003598:	5761                	li	a4,-8
4200359a:	06e5f363          	bgeu	a1,a4,42003600 <mutex_init_shared+0x9e>
4200359e:	00858713          	add	a4,a1,8
420035a2:	0f50000f          	fence	iorw,ow
420035a6:	0c07202f          	amoswap.w.aq	zero,zero,(a4)
    atomic_thread_fence(memory_order_release);
420035aa:	0ff0000f          	fence
    badge_err_set_ok(ec);
420035ae:	c911                	beqz	a0,420035c2 <mutex_init_shared+0x60>
420035b0:	00357713          	and	a4,a0,3
420035b4:	e739                	bnez	a4,42003602 <mutex_init_shared+0xa0>
420035b6:	04f57763          	bgeu	a0,a5,42003604 <mutex_init_shared+0xa2>
420035ba:	00052223          	sw	zero,4(a0)
420035be:	00052023          	sw	zero,0(a0)
}
420035c2:	40b2                	lw	ra,12(sp)
420035c4:	4422                	lw	s0,8(sp)
420035c6:	0141                	add	sp,sp,16
420035c8:	8082                	ret
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
420035ca:	dd65                	beqz	a0,420035c2 <mutex_init_shared+0x60>
420035cc:	420175b7          	lui	a1,0x42017
420035d0:	46d9                	li	a3,22
420035d2:	4601                	li	a2,0
420035d4:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420035d8:	4511                	li	a0,4
420035da:	00000717          	auipc	a4,0x0
420035de:	3975                	jal	4200329a <logkf>
420035e0:	00347793          	and	a5,s0,3
420035e4:	e395                	bnez	a5,42003608 <mutex_init_shared+0xa6>
420035e6:	57f1                	li	a5,-4
420035e8:	00f47f63          	bgeu	s0,a5,42003606 <mutex_init_shared+0xa4>
420035ec:	47d9                	li	a5,22
}
420035ee:	40b2                	lw	ra,12(sp)
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
420035f0:	00042223          	sw	zero,4(s0)
420035f4:	c01c                	sw	a5,0(s0)
}
420035f6:	4422                	lw	s0,8(sp)
420035f8:	0141                	add	sp,sp,16
420035fa:	8082                	ret
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) == MUTEX_MAGIC) {
420035fc:	9002                	ebreak
    mutex->is_shared = true;
420035fe:	9002                	ebreak
    atomic_store(&mutex->shares, 0);
42003600:	9002                	ebreak
    badge_err_set_ok(ec);
42003602:	9002                	ebreak
42003604:	9002                	ebreak
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003606:	9002                	ebreak
42003608:	9002                	ebreak

4200360a <mutex_destroy>:

// Clean up the mutex.
void mutex_destroy(badge_err_t *ec, mutex_t *mutex) {
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
4200360a:	c1ad                	beqz	a1,4200366c <mutex_destroy+0x62>
4200360c:	0035f793          	and	a5,a1,3
42003610:	efb1                	bnez	a5,4200366c <mutex_destroy+0x62>
42003612:	4198                	lw	a4,0(a1)
42003614:	0ff0000f          	fence
42003618:	cafec7b7          	lui	a5,0xcafec
4200361c:	abe78793          	add	a5,a5,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
42003620:	02f70f63          	beq	a4,a5,4200365e <mutex_destroy+0x54>
void mutex_destroy(badge_err_t *ec, mutex_t *mutex) {
42003624:	1141                	add	sp,sp,-16
42003626:	c422                	sw	s0,8(sp)
42003628:	c606                	sw	ra,12(sp)
4200362a:	842a                	mv	s0,a0
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
4200362c:	c50d                	beqz	a0,42003656 <mutex_destroy+0x4c>
4200362e:	420175b7          	lui	a1,0x42017
42003632:	46d9                	li	a3,22
42003634:	4601                	li	a2,0
42003636:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200363a:	4511                	li	a0,4
4200363c:	00000717          	auipc	a4,0x0
42003640:	39a9                	jal	4200329a <logkf>
42003642:	00347793          	and	a5,s0,3
42003646:	e785                	bnez	a5,4200366e <mutex_destroy+0x64>
42003648:	57f1                	li	a5,-4
4200364a:	02f47363          	bgeu	s0,a5,42003670 <mutex_destroy+0x66>
4200364e:	47d9                	li	a5,22
42003650:	00042223          	sw	zero,4(s0)
42003654:	c01c                	sw	a5,0(s0)
        return;
    }
    mutex->magic = 0;
    atomic_thread_fence(memory_order_release);
}
42003656:	40b2                	lw	ra,12(sp)
42003658:	4422                	lw	s0,8(sp)
4200365a:	0141                	add	sp,sp,16
4200365c:	8082                	ret
    mutex->magic = 0;
4200365e:	0f50000f          	fence	iorw,ow
42003662:	0c05a02f          	amoswap.w.aq	zero,zero,(a1)
    atomic_thread_fence(memory_order_release);
42003666:	0ff0000f          	fence
4200366a:	8082                	ret
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
4200366c:	9002                	ebreak
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
4200366e:	9002                	ebreak
42003670:	9002                	ebreak

42003672 <mutex_acquire>:

// Try to acquire `mutex` within `timeout` microseconds.
// Returns true if the mutex was successully acquired.
bool mutex_acquire(badge_err_t *ec, mutex_t *mutex, timestamp_us_t timeout) {
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003672:	18058863          	beqz	a1,42003802 <mutex_acquire+0x190>
bool mutex_acquire(badge_err_t *ec, mutex_t *mutex, timestamp_us_t timeout) {
42003676:	7179                	add	sp,sp,-48
42003678:	d422                	sw	s0,40(sp)
4200367a:	d606                	sw	ra,44(sp)
4200367c:	ce4e                	sw	s3,28(sp)
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
4200367e:	0035f793          	and	a5,a1,3
42003682:	842e                	mv	s0,a1
42003684:	10079663          	bnez	a5,42003790 <mutex_acquire+0x11e>
42003688:	4198                	lw	a4,0(a1)
4200368a:	89aa                	mv	s3,a0
4200368c:	0ff0000f          	fence
42003690:	cafec7b7          	lui	a5,0xcafec
42003694:	abe78793          	add	a5,a5,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
42003698:	02f70e63          	beq	a4,a5,420036d4 <mutex_acquire+0x62>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
4200369c:	c515                	beqz	a0,420036c8 <mutex_acquire+0x56>
4200369e:	420175b7          	lui	a1,0x42017
420036a2:	46d9                	li	a3,22
420036a4:	4601                	li	a2,0
420036a6:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420036aa:	4511                	li	a0,4
420036ac:	00000717          	auipc	a4,0x0
420036b0:	36ed                	jal	4200329a <logkf>
420036b2:	0039f793          	and	a5,s3,3
420036b6:	e3f5                	bnez	a5,4200379a <mutex_acquire+0x128>
420036b8:	57f1                	li	a5,-4
420036ba:	0ef9f463          	bgeu	s3,a5,420037a2 <mutex_acquire+0x130>
420036be:	47d9                	li	a5,22
420036c0:	0009a223          	sw	zero,4(s3)
420036c4:	00f9a023          	sw	a5,0(s3)
    } else {
        // Acquire failed.
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_TIMEOUT);
        return false;
    }
}
420036c8:	50b2                	lw	ra,44(sp)
420036ca:	5422                	lw	s0,40(sp)
420036cc:	49f2                	lw	s3,28(sp)
        return false;
420036ce:	4501                	li	a0,0
}
420036d0:	6145                	add	sp,sp,48
420036d2:	8082                	ret
420036d4:	d226                	sw	s1,36(sp)
420036d6:	84b6                	mv	s1,a3
    timestamp_us_t now = time_us();
420036d8:	d04a                	sw	s2,32(sp)
420036da:	cc52                	sw	s4,24(sp)
420036dc:	8932                	mv	s2,a2
420036de:	08a0d0ef          	jal	42010768 <time_us>
    if (timeout < 0 || timeout - TIMESTAMP_US_MAX + now >= 0) {
420036e2:	0804c263          	bltz	s1,42003766 <mutex_acquire+0xf4>
420036e6:	00190613          	add	a2,s2,1
420036ea:	80000737          	lui	a4,0x80000
420036ee:	012637b3          	sltu	a5,a2,s2
420036f2:	00e486b3          	add	a3,s1,a4
420036f6:	97b6                	add	a5,a5,a3
420036f8:	00a606b3          	add	a3,a2,a0
420036fc:	00c6b6b3          	sltu	a3,a3,a2
42003700:	00b78633          	add	a2,a5,a1
42003704:	96b2                	add	a3,a3,a2
42003706:	8fad                	xor	a5,a5,a1
42003708:	00b6c633          	xor	a2,a3,a1
4200370c:	fff7c793          	not	a5,a5
42003710:	8ff1                	and	a5,a5,a2
42003712:	0807cc63          	bltz	a5,420037aa <mutex_acquire+0x138>
        timeout = TIMESTAMP_US_MAX;
42003716:	5a7d                	li	s4,-1
42003718:	177d                	add	a4,a4,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
    if (timeout < 0 || timeout - TIMESTAMP_US_MAX + now >= 0) {
4200371a:	0406cb63          	bltz	a3,42003770 <mutex_acquire+0xfe>
        if (atomic_compare_exchange_weak_explicit(var, &old_value, new_value, order, memory_order_relaxed)) {
4200371e:	200004b7          	lui	s1,0x20000
    if (await_swap_atomic_int(&mutex->shares, timeout, 0, EXCLUSIVE_MAGIC, memory_order_acquire)) {
42003722:	57e1                	li	a5,-8
42003724:	00840913          	add	s2,s0,8
        if (atomic_compare_exchange_weak_explicit(var, &old_value, new_value, order, memory_order_relaxed)) {
42003728:	14fd                	add	s1,s1,-1 # 1fffffff <__stack_size+0x1fffdfff>
    if (await_swap_atomic_int(&mutex->shares, timeout, 0, EXCLUSIVE_MAGIC, memory_order_acquire)) {
4200372a:	06f47763          	bgeu	s0,a5,42003798 <mutex_acquire+0x126>
        if (atomic_compare_exchange_weak_explicit(var, &old_value, new_value, order, memory_order_relaxed)) {
4200372e:	100927af          	lr.w	a5,(s2)
42003732:	e781                	bnez	a5,4200373a <mutex_acquire+0xc8>
42003734:	1c9926af          	sc.w.aq	a3,s1,(s2)
42003738:	fafd                	bnez	a3,4200372e <mutex_acquire+0xbc>
4200373a:	ebad                	bnez	a5,420037ac <mutex_acquire+0x13a>
        badge_err_set_ok(ec);
4200373c:	00098c63          	beqz	s3,42003754 <mutex_acquire+0xe2>
42003740:	0039f793          	and	a5,s3,3
42003744:	efc5                	bnez	a5,420037fc <mutex_acquire+0x18a>
42003746:	57f1                	li	a5,-4
42003748:	0af9f963          	bgeu	s3,a5,420037fa <mutex_acquire+0x188>
4200374c:	0009a223          	sw	zero,4(s3)
42003750:	0009a023          	sw	zero,0(s3)
}
42003754:	50b2                	lw	ra,44(sp)
42003756:	5422                	lw	s0,40(sp)
42003758:	5492                	lw	s1,36(sp)
4200375a:	5902                	lw	s2,32(sp)
4200375c:	4a62                	lw	s4,24(sp)
4200375e:	49f2                	lw	s3,28(sp)
        return true;
42003760:	4505                	li	a0,1
}
42003762:	6145                	add	sp,sp,48
42003764:	8082                	ret
        timeout = TIMESTAMP_US_MAX;
42003766:	80000737          	lui	a4,0x80000
4200376a:	5a7d                	li	s4,-1
4200376c:	177d                	add	a4,a4,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200376e:	bf45                	j	4200371e <mutex_acquire+0xac>
        timeout += now;
42003770:	01250a33          	add	s4,a0,s2
42003774:	00958733          	add	a4,a1,s1
42003778:	00aa3533          	sltu	a0,s4,a0
4200377c:	972a                	add	a4,a4,a0
4200377e:	8da5                	xor	a1,a1,s1
42003780:	009746b3          	xor	a3,a4,s1
42003784:	fff5c593          	not	a1,a1
42003788:	8eed                	and	a3,a3,a1
4200378a:	f806dae3          	bgez	a3,4200371e <mutex_acquire+0xac>
4200378e:	9002                	ebreak
42003790:	d226                	sw	s1,36(sp)
42003792:	d04a                	sw	s2,32(sp)
42003794:	cc52                	sw	s4,24(sp)
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003796:	9002                	ebreak
    if (await_swap_atomic_int(&mutex->shares, timeout, 0, EXCLUSIVE_MAGIC, memory_order_acquire)) {
42003798:	9002                	ebreak
4200379a:	d226                	sw	s1,36(sp)
4200379c:	d04a                	sw	s2,32(sp)
4200379e:	cc52                	sw	s4,24(sp)
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
420037a0:	9002                	ebreak
420037a2:	d226                	sw	s1,36(sp)
420037a4:	d04a                	sw	s2,32(sp)
420037a6:	cc52                	sw	s4,24(sp)
420037a8:	9002                	ebreak
    if (timeout < 0 || timeout - TIMESTAMP_US_MAX + now >= 0) {
420037aa:	9002                	ebreak
420037ac:	c63a                	sw	a4,12(sp)
            sched_yield();
420037ae:	6070a0ef          	jal	4200e5b4 <sched_yield>
    } while (time_us() < timeout);
420037b2:	7b70c0ef          	jal	42010768 <time_us>
420037b6:	4732                	lw	a4,12(sp)
420037b8:	f6e5cbe3          	blt	a1,a4,4200372e <mutex_acquire+0xbc>
420037bc:	00b71463          	bne	a4,a1,420037c4 <mutex_acquire+0x152>
420037c0:	f74567e3          	bltu	a0,s4,4200372e <mutex_acquire+0xbc>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_TIMEOUT);
420037c4:	02098763          	beqz	s3,420037f2 <mutex_acquire+0x180>
420037c8:	420175b7          	lui	a1,0x42017
420037cc:	46a1                	li	a3,8
420037ce:	4601                	li	a2,0
420037d0:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420037d4:	4511                	li	a0,4
420037d6:	00000717          	auipc	a4,0x0
420037da:	34c1                	jal	4200329a <logkf>
420037dc:	0039f793          	and	a5,s3,3
420037e0:	e385                	bnez	a5,42003800 <mutex_acquire+0x18e>
420037e2:	57f1                	li	a5,-4
420037e4:	00f9fd63          	bgeu	s3,a5,420037fe <mutex_acquire+0x18c>
420037e8:	47a1                	li	a5,8
420037ea:	0009a223          	sw	zero,4(s3)
420037ee:	00f9a023          	sw	a5,0(s3)
420037f2:	5492                	lw	s1,36(sp)
420037f4:	5902                	lw	s2,32(sp)
420037f6:	4a62                	lw	s4,24(sp)
420037f8:	bdc1                	j	420036c8 <mutex_acquire+0x56>
        badge_err_set_ok(ec);
420037fa:	9002                	ebreak
420037fc:	9002                	ebreak
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_TIMEOUT);
420037fe:	9002                	ebreak
42003800:	9002                	ebreak
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003802:	9002                	ebreak

42003804 <mutex_release>:

// Release `mutex`, if it was initially acquired by this thread.
// Returns true if the mutex was successfully released.
bool mutex_release(badge_err_t *ec, mutex_t *mutex) {
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003804:	c1f1                	beqz	a1,420038c8 <mutex_release+0xc4>
42003806:	0035f793          	and	a5,a1,3
4200380a:	efdd                	bnez	a5,420038c8 <mutex_release+0xc4>
bool mutex_release(badge_err_t *ec, mutex_t *mutex) {
4200380c:	1141                	add	sp,sp,-16
4200380e:	c422                	sw	s0,8(sp)
42003810:	c606                	sw	ra,12(sp)
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003812:	4198                	lw	a4,0(a1)
42003814:	842a                	mv	s0,a0
42003816:	0ff0000f          	fence
4200381a:	cafec7b7          	lui	a5,0xcafec
4200381e:	abe78793          	add	a5,a5,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
42003822:	02f70c63          	beq	a4,a5,4200385a <mutex_release+0x56>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003826:	c50d                	beqz	a0,42003850 <mutex_release+0x4c>
42003828:	420175b7          	lui	a1,0x42017
4200382c:	46d9                	li	a3,22
4200382e:	4601                	li	a2,0
42003830:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42003834:	4511                	li	a0,4
42003836:	00000717          	auipc	a4,0x0
4200383a:	3485                	jal	4200329a <logkf>
4200383c:	00347793          	and	a5,s0,3
42003840:	e7d1                	bnez	a5,420038cc <mutex_release+0xc8>
42003842:	57f1                	li	a5,-4
42003844:	08f47763          	bgeu	s0,a5,420038d2 <mutex_release+0xce>
42003848:	47d9                	li	a5,22
4200384a:	00042223          	sw	zero,4(s0)
4200384e:	c01c                	sw	a5,0(s0)
    } else {
        // Mutex was not taken exclusively.
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
        return false;
    }
}
42003850:	40b2                	lw	ra,12(sp)
42003852:	4422                	lw	s0,8(sp)
        return false;
42003854:	4501                	li	a0,0
}
42003856:	0141                	add	sp,sp,16
42003858:	8082                	ret
4200385a:	c226                	sw	s1,4(sp)
4200385c:	c04a                	sw	s2,0(sp)
    assert_dev_drop(atomic_load(&mutex->shares) >= EXCLUSIVE_MAGIC);
4200385e:	57e1                	li	a5,-8
42003860:	06f5f563          	bgeu	a1,a5,420038ca <mutex_release+0xc6>
42003864:	00858913          	add	s2,a1,8
42003868:	0ff0000f          	fence
4200386c:	4598                	lw	a4,8(a1)
4200386e:	0ff0000f          	fence
42003872:	200007b7          	lui	a5,0x20000
        if (atomic_compare_exchange_weak_explicit(var, &old_value, new_value, order, memory_order_relaxed)) {
42003876:	200004b7          	lui	s1,0x20000
    assert_dev_drop(atomic_load(&mutex->shares) >= EXCLUSIVE_MAGIC);
4200387a:	17f9                	add	a5,a5,-2 # 1ffffffe <__stack_size+0x1fffdffe>
        if (atomic_compare_exchange_weak_explicit(var, &old_value, new_value, order, memory_order_relaxed)) {
4200387c:	14fd                	add	s1,s1,-1 # 1fffffff <__stack_size+0x1fffdfff>
    assert_dev_drop(atomic_load(&mutex->shares) >= EXCLUSIVE_MAGIC);
4200387e:	02e7dd63          	bge	a5,a4,420038b8 <mutex_release+0xb4>
        if (atomic_compare_exchange_weak_explicit(var, &old_value, new_value, order, memory_order_relaxed)) {
42003882:	100927af          	lr.w	a5,(s2)
42003886:	00979563          	bne	a5,s1,42003890 <mutex_release+0x8c>
4200388a:	1809272f          	sc.w	a4,zero,(s2)
4200388e:	fb75                	bnez	a4,42003882 <mutex_release+0x7e>
42003890:	04979663          	bne	a5,s1,420038dc <mutex_release+0xd8>
        badge_err_set_ok(ec);
42003894:	c819                	beqz	s0,420038aa <mutex_release+0xa6>
42003896:	00347793          	and	a5,s0,3
4200389a:	e3a1                	bnez	a5,420038da <mutex_release+0xd6>
4200389c:	57f1                	li	a5,-4
4200389e:	02f47d63          	bgeu	s0,a5,420038d8 <mutex_release+0xd4>
420038a2:	00042223          	sw	zero,4(s0)
420038a6:	00042023          	sw	zero,0(s0)
}
420038aa:	40b2                	lw	ra,12(sp)
420038ac:	4422                	lw	s0,8(sp)
420038ae:	4492                	lw	s1,4(sp)
420038b0:	4902                	lw	s2,0(sp)
        return true;
420038b2:	4505                	li	a0,1
}
420038b4:	0141                	add	sp,sp,16
420038b6:	8082                	ret
    assert_dev_drop(atomic_load(&mutex->shares) >= EXCLUSIVE_MAGIC);
420038b8:	420175b7          	lui	a1,0x42017
420038bc:	22c58593          	add	a1,a1,556 # 4201722c <hextab+0x560>
420038c0:	4501                	li	a0,0
420038c2:	993ff0ef          	jal	42003254 <logk>
420038c6:	9002                	ebreak
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
420038c8:	9002                	ebreak
    assert_dev_drop(atomic_load(&mutex->shares) >= EXCLUSIVE_MAGIC);
420038ca:	9002                	ebreak
420038cc:	c226                	sw	s1,4(sp)
420038ce:	c04a                	sw	s2,0(sp)
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
420038d0:	9002                	ebreak
420038d2:	c226                	sw	s1,4(sp)
420038d4:	c04a                	sw	s2,0(sp)
420038d6:	9002                	ebreak
        badge_err_set_ok(ec);
420038d8:	9002                	ebreak
420038da:	9002                	ebreak
            sched_yield();
420038dc:	4d90a0ef          	jal	4200e5b4 <sched_yield>
    } while (time_us() < timeout);
420038e0:	6890c0ef          	jal	42010768 <time_us>
420038e4:	57fd                	li	a5,-1
420038e6:	f8f51ee3          	bne	a0,a5,42003882 <mutex_release+0x7e>
420038ea:	800007b7          	lui	a5,0x80000
420038ee:	17fd                	add	a5,a5,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
420038f0:	f8f599e3          	bne	a1,a5,42003882 <mutex_release+0x7e>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
420038f4:	c415                	beqz	s0,42003920 <mutex_release+0x11c>
420038f6:	420175b7          	lui	a1,0x42017
420038fa:	46d9                	li	a3,22
420038fc:	4601                	li	a2,0
420038fe:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42003902:	4511                	li	a0,4
42003904:	00000717          	auipc	a4,0x0
42003908:	993ff0ef          	jal	4200329a <logkf>
4200390c:	00347793          	and	a5,s0,3
42003910:	ef81                	bnez	a5,42003928 <mutex_release+0x124>
42003912:	57f1                	li	a5,-4
42003914:	00f47963          	bgeu	s0,a5,42003926 <mutex_release+0x122>
42003918:	47d9                	li	a5,22
4200391a:	00042223          	sw	zero,4(s0)
4200391e:	c01c                	sw	a5,0(s0)
42003920:	4492                	lw	s1,4(sp)
42003922:	4902                	lw	s2,0(sp)
42003924:	b735                	j	42003850 <mutex_release+0x4c>
42003926:	9002                	ebreak
42003928:	9002                	ebreak

4200392a <mutex_acquire_shared>:

// Try to acquire a share in `mutex` within `timeout` microseconds.
// Returns true if the share was successfully acquired.
bool mutex_acquire_shared(badge_err_t *ec, mutex_t *mutex, timestamp_us_t timeout) {
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
4200392a:	20058c63          	beqz	a1,42003b42 <mutex_acquire_shared+0x218>
bool mutex_acquire_shared(badge_err_t *ec, mutex_t *mutex, timestamp_us_t timeout) {
4200392e:	1101                	add	sp,sp,-32
42003930:	cc22                	sw	s0,24(sp)
42003932:	ce06                	sw	ra,28(sp)
42003934:	c64e                	sw	s3,12(sp)
42003936:	c452                	sw	s4,8(sp)
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003938:	0035f793          	and	a5,a1,3
4200393c:	842e                	mv	s0,a1
4200393e:	1c079b63          	bnez	a5,42003b14 <mutex_acquire_shared+0x1ea>
42003942:	4198                	lw	a4,0(a1)
42003944:	89aa                	mv	s3,a0
42003946:	0ff0000f          	fence
4200394a:	cafec7b7          	lui	a5,0xcafec
4200394e:	abe78793          	add	a5,a5,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
42003952:	04f70263          	beq	a4,a5,42003996 <mutex_acquire_shared+0x6c>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003956:	c905                	beqz	a0,42003986 <mutex_acquire_shared+0x5c>
42003958:	420175b7          	lui	a1,0x42017
4200395c:	46d9                	li	a3,22
4200395e:	4601                	li	a2,0
42003960:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42003964:	4511                	li	a0,4
42003966:	00000717          	auipc	a4,0x0
4200396a:	931ff0ef          	jal	4200329a <logkf>
4200396e:	0039f793          	and	a5,s3,3
42003972:	1a079b63          	bnez	a5,42003b28 <mutex_acquire_shared+0x1fe>
42003976:	57f1                	li	a5,-4
42003978:	1af9fd63          	bgeu	s3,a5,42003b32 <mutex_acquire_shared+0x208>
        return false;
    }
    if (!mutex->is_shared) {
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
4200397c:	47d9                	li	a5,22
4200397e:	0009a223          	sw	zero,4(s3)
42003982:	00f9a023          	sw	a5,0(s3)
        return false;
42003986:	4a01                	li	s4,0
    } else {
        // If that fails, abort trying to lock.
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_TIMEOUT);
        return false;
    }
}
42003988:	40f2                	lw	ra,28(sp)
4200398a:	4462                	lw	s0,24(sp)
4200398c:	49b2                	lw	s3,12(sp)
4200398e:	8552                	mv	a0,s4
42003990:	4a22                	lw	s4,8(sp)
42003992:	6105                	add	sp,sp,32
42003994:	8082                	ret
    if (!mutex->is_shared) {
42003996:	0045ca03          	lbu	s4,4(a1)
4200399a:	4785                	li	a5,1
4200399c:	1b47e763          	bltu	a5,s4,42003b4a <mutex_acquire_shared+0x220>
420039a0:	001a7a13          	and	s4,s4,1
420039a4:	020a1a63          	bnez	s4,420039d8 <mutex_acquire_shared+0xae>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
420039a8:	dd79                	beqz	a0,42003986 <mutex_acquire_shared+0x5c>
420039aa:	420175b7          	lui	a1,0x42017
420039ae:	46d9                	li	a3,22
420039b0:	4601                	li	a2,0
420039b2:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420039b6:	4511                	li	a0,4
420039b8:	00000717          	auipc	a4,0x0
420039bc:	8dfff0ef          	jal	4200329a <logkf>
420039c0:	0039f793          	and	a5,s3,3
420039c4:	14079d63          	bnez	a5,42003b1e <mutex_acquire_shared+0x1f4>
420039c8:	57f1                	li	a5,-4
420039ca:	faf9e9e3          	bltu	s3,a5,4200397c <mutex_acquire_shared+0x52>
420039ce:	ca26                	sw	s1,20(sp)
420039d0:	c84a                	sw	s2,16(sp)
420039d2:	c256                	sw	s5,4(sp)
420039d4:	c05a                	sw	s6,0(sp)
420039d6:	9002                	ebreak
420039d8:	ca26                	sw	s1,20(sp)
420039da:	84b6                	mv	s1,a3
    timestamp_us_t now = time_us();
420039dc:	c84a                	sw	s2,16(sp)
420039de:	c256                	sw	s5,4(sp)
420039e0:	c05a                	sw	s6,0(sp)
420039e2:	8932                	mv	s2,a2
420039e4:	5850c0ef          	jal	42010768 <time_us>
    if (timeout < 0 || timeout - TIMESTAMP_US_MAX + now >= 0) {
420039e8:	0804ce63          	bltz	s1,42003a84 <mutex_acquire_shared+0x15a>
420039ec:	00190693          	add	a3,s2,1
420039f0:	80000ab7          	lui	s5,0x80000
420039f4:	0126b7b3          	sltu	a5,a3,s2
420039f8:	01548733          	add	a4,s1,s5
420039fc:	97ba                	add	a5,a5,a4
420039fe:	00a68733          	add	a4,a3,a0
42003a02:	00d73733          	sltu	a4,a4,a3
42003a06:	00b786b3          	add	a3,a5,a1
42003a0a:	9736                	add	a4,a4,a3
42003a0c:	8fad                	xor	a5,a5,a1
42003a0e:	00b746b3          	xor	a3,a4,a1
42003a12:	fff7c793          	not	a5,a5
42003a16:	8ff5                	and	a5,a5,a3
42003a18:	1207c363          	bltz	a5,42003b3e <mutex_acquire_shared+0x214>
        timeout = TIMESTAMP_US_MAX;
42003a1c:	5b7d                	li	s6,-1
42003a1e:	1afd                	add	s5,s5,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
    if (timeout < 0 || timeout - TIMESTAMP_US_MAX + now >= 0) {
42003a20:	0a074e63          	bltz	a4,42003adc <mutex_acquire_shared+0x1b2>
    if (thresh_add_atomic_int(&mutex->shares, timeout, EXCLUSIVE_MAGIC, memory_order_acquire)) {
42003a24:	57e1                	li	a5,-8
42003a26:	00840493          	add	s1,s0,8
42003a2a:	10f47963          	bgeu	s0,a5,42003b3c <mutex_acquire_shared+0x212>
        if (!(old_value >= threshold || new_value >= threshold) &&
42003a2e:	20000437          	lui	s0,0x20000
42003a32:	20000937          	lui	s2,0x20000
42003a36:	1479                	add	s0,s0,-2 # 1ffffffe <__stack_size+0x1fffdffe>
42003a38:	197d                	add	s2,s2,-1 # 1fffffff <__stack_size+0x1fffdfff>
        int old_value = atomic_load(var);
42003a3a:	0ff0000f          	fence
42003a3e:	409c                	lw	a5,0(s1)
42003a40:	0ff0000f          	fence
        if (!(old_value >= threshold || new_value >= threshold) &&
42003a44:	04f44563          	blt	s0,a5,42003a8e <mutex_acquire_shared+0x164>
        int new_value = old_value + 1;
42003a48:	00178713          	add	a4,a5,1
        if (!(old_value >= threshold || new_value >= threshold) &&
42003a4c:	05270163          	beq	a4,s2,42003a8e <mutex_acquire_shared+0x164>
            atomic_compare_exchange_weak_explicit(var, &old_value, new_value, order, memory_order_relaxed)) {
42003a50:	1004a6af          	lr.w	a3,(s1)
42003a54:	00f69563          	bne	a3,a5,42003a5e <mutex_acquire_shared+0x134>
42003a58:	1ce4a62f          	sc.w.aq	a2,a4,(s1)
42003a5c:	fa75                	bnez	a2,42003a50 <mutex_acquire_shared+0x126>
        if (!(old_value >= threshold || new_value >= threshold) &&
42003a5e:	02f69863          	bne	a3,a5,42003a8e <mutex_acquire_shared+0x164>
        badge_err_set_ok(ec);
42003a62:	0a098463          	beqz	s3,42003b0a <mutex_acquire_shared+0x1e0>
42003a66:	0039f793          	and	a5,s3,3
42003a6a:	eff9                	bnez	a5,42003b48 <mutex_acquire_shared+0x21e>
42003a6c:	57f1                	li	a5,-4
42003a6e:	0cf9f963          	bgeu	s3,a5,42003b40 <mutex_acquire_shared+0x216>
42003a72:	44d2                	lw	s1,20(sp)
42003a74:	4942                	lw	s2,16(sp)
42003a76:	4a92                	lw	s5,4(sp)
42003a78:	4b02                	lw	s6,0(sp)
42003a7a:	0009a223          	sw	zero,4(s3)
42003a7e:	0009a023          	sw	zero,0(s3)
42003a82:	b719                	j	42003988 <mutex_acquire_shared+0x5e>
        timeout = TIMESTAMP_US_MAX;
42003a84:	80000ab7          	lui	s5,0x80000
42003a88:	5b7d                	li	s6,-1
42003a8a:	1afd                	add	s5,s5,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
42003a8c:	bf61                	j	42003a24 <mutex_acquire_shared+0xfa>
            sched_yield();
42003a8e:	3270a0ef          	jal	4200e5b4 <sched_yield>
    } while (time_us() < timeout);
42003a92:	4d70c0ef          	jal	42010768 <time_us>
42003a96:	fb55c2e3          	blt	a1,s5,42003a3a <mutex_acquire_shared+0x110>
42003a9a:	00ba9463          	bne	s5,a1,42003aa2 <mutex_acquire_shared+0x178>
42003a9e:	f9656ee3          	bltu	a0,s6,42003a3a <mutex_acquire_shared+0x110>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_TIMEOUT);
42003aa2:	04098f63          	beqz	s3,42003b00 <mutex_acquire_shared+0x1d6>
42003aa6:	420175b7          	lui	a1,0x42017
42003aaa:	46a1                	li	a3,8
42003aac:	4601                	li	a2,0
42003aae:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42003ab2:	4511                	li	a0,4
42003ab4:	00000717          	auipc	a4,0x0
42003ab8:	fe2ff0ef          	jal	4200329a <logkf>
42003abc:	0039f793          	and	a5,s3,3
42003ac0:	e3d9                	bnez	a5,42003b46 <mutex_acquire_shared+0x21c>
42003ac2:	57f1                	li	a5,-4
42003ac4:	08f9f063          	bgeu	s3,a5,42003b44 <mutex_acquire_shared+0x21a>
42003ac8:	47a1                	li	a5,8
42003aca:	44d2                	lw	s1,20(sp)
42003acc:	4942                	lw	s2,16(sp)
42003ace:	4a92                	lw	s5,4(sp)
42003ad0:	4b02                	lw	s6,0(sp)
42003ad2:	0009a223          	sw	zero,4(s3)
42003ad6:	00f9a023          	sw	a5,0(s3)
42003ada:	b575                	j	42003986 <mutex_acquire_shared+0x5c>
        timeout += now;
42003adc:	01250633          	add	a2,a0,s2
42003ae0:	009587b3          	add	a5,a1,s1
42003ae4:	00a63533          	sltu	a0,a2,a0
42003ae8:	953e                	add	a0,a0,a5
42003aea:	8da5                	xor	a1,a1,s1
42003aec:	009546b3          	xor	a3,a0,s1
42003af0:	fff5c593          	not	a1,a1
42003af4:	8eed                	and	a3,a3,a1
42003af6:	8b32                	mv	s6,a2
42003af8:	8aaa                	mv	s5,a0
42003afa:	f206d5e3          	bgez	a3,42003a24 <mutex_acquire_shared+0xfa>
42003afe:	9002                	ebreak
42003b00:	44d2                	lw	s1,20(sp)
42003b02:	4942                	lw	s2,16(sp)
42003b04:	4a92                	lw	s5,4(sp)
42003b06:	4b02                	lw	s6,0(sp)
42003b08:	bdbd                	j	42003986 <mutex_acquire_shared+0x5c>
42003b0a:	44d2                	lw	s1,20(sp)
42003b0c:	4942                	lw	s2,16(sp)
42003b0e:	4a92                	lw	s5,4(sp)
42003b10:	4b02                	lw	s6,0(sp)
42003b12:	bd9d                	j	42003988 <mutex_acquire_shared+0x5e>
42003b14:	ca26                	sw	s1,20(sp)
42003b16:	c84a                	sw	s2,16(sp)
42003b18:	c256                	sw	s5,4(sp)
42003b1a:	c05a                	sw	s6,0(sp)
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003b1c:	9002                	ebreak
42003b1e:	ca26                	sw	s1,20(sp)
42003b20:	c84a                	sw	s2,16(sp)
42003b22:	c256                	sw	s5,4(sp)
42003b24:	c05a                	sw	s6,0(sp)
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003b26:	9002                	ebreak
42003b28:	ca26                	sw	s1,20(sp)
42003b2a:	c84a                	sw	s2,16(sp)
42003b2c:	c256                	sw	s5,4(sp)
42003b2e:	c05a                	sw	s6,0(sp)
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003b30:	9002                	ebreak
42003b32:	ca26                	sw	s1,20(sp)
42003b34:	c84a                	sw	s2,16(sp)
42003b36:	c256                	sw	s5,4(sp)
42003b38:	c05a                	sw	s6,0(sp)
42003b3a:	9002                	ebreak
    if (thresh_add_atomic_int(&mutex->shares, timeout, EXCLUSIVE_MAGIC, memory_order_acquire)) {
42003b3c:	9002                	ebreak
    if (timeout < 0 || timeout - TIMESTAMP_US_MAX + now >= 0) {
42003b3e:	9002                	ebreak
        badge_err_set_ok(ec);
42003b40:	9002                	ebreak
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003b42:	9002                	ebreak
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_TIMEOUT);
42003b44:	9002                	ebreak
42003b46:	9002                	ebreak
        badge_err_set_ok(ec);
42003b48:	9002                	ebreak
42003b4a:	ca26                	sw	s1,20(sp)
42003b4c:	c84a                	sw	s2,16(sp)
42003b4e:	c256                	sw	s5,4(sp)
42003b50:	c05a                	sw	s6,0(sp)
    if (!mutex->is_shared) {
42003b52:	9002                	ebreak

42003b54 <mutex_release_shared>:

// Release `mutex`, if it was initially acquired by this thread.
// Returns true if the mutex was successfully released.
bool mutex_release_shared(badge_err_t *ec, mutex_t *mutex) {
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003b54:	c1f5                	beqz	a1,42003c38 <mutex_release_shared+0xe4>
42003b56:	0035f793          	and	a5,a1,3
42003b5a:	eff9                	bnez	a5,42003c38 <mutex_release_shared+0xe4>
bool mutex_release_shared(badge_err_t *ec, mutex_t *mutex) {
42003b5c:	1141                	add	sp,sp,-16
42003b5e:	c422                	sw	s0,8(sp)
42003b60:	c606                	sw	ra,12(sp)
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003b62:	4198                	lw	a4,0(a1)
42003b64:	842a                	mv	s0,a0
42003b66:	0ff0000f          	fence
42003b6a:	cafec7b7          	lui	a5,0xcafec
42003b6e:	abe78793          	add	a5,a5,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
42003b72:	02f70d63          	beq	a4,a5,42003bac <mutex_release_shared+0x58>
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003b76:	c515                	beqz	a0,42003ba2 <mutex_release_shared+0x4e>
42003b78:	420175b7          	lui	a1,0x42017
42003b7c:	46d9                	li	a3,22
42003b7e:	4601                	li	a2,0
42003b80:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42003b84:	4511                	li	a0,4
42003b86:	00000717          	auipc	a4,0x0
42003b8a:	f10ff0ef          	jal	4200329a <logkf>
42003b8e:	00347793          	and	a5,s0,3
42003b92:	e7cd                	bnez	a5,42003c3c <mutex_release_shared+0xe8>
42003b94:	57f1                	li	a5,-4
42003b96:	0af47663          	bgeu	s0,a5,42003c42 <mutex_release_shared+0xee>
42003b9a:	47d9                	li	a5,22
42003b9c:	00042223          	sw	zero,4(s0)
42003ba0:	c01c                	sw	a5,0(s0)
    } else {
        // Successful release.
        badge_err_set_ok(ec);
        return true;
    }
}
42003ba2:	40b2                	lw	ra,12(sp)
42003ba4:	4422                	lw	s0,8(sp)
        return false;
42003ba6:	4501                	li	a0,0
}
42003ba8:	0141                	add	sp,sp,16
42003baa:	8082                	ret
42003bac:	c226                	sw	s1,4(sp)
42003bae:	c04a                	sw	s2,0(sp)
    assert_dev_drop(atomic_load(&mutex->shares) < EXCLUSIVE_MAGIC);
42003bb0:	57e1                	li	a5,-8
42003bb2:	08f5f463          	bgeu	a1,a5,42003c3a <mutex_release_shared+0xe6>
42003bb6:	00858493          	add	s1,a1,8
42003bba:	0ff0000f          	fence
42003bbe:	4598                	lw	a4,8(a1)
42003bc0:	0ff0000f          	fence
42003bc4:	200007b7          	lui	a5,0x20000
        if (!(old_value == unequal0 || old_value == unequal1) &&
42003bc8:	20000937          	lui	s2,0x20000
    assert_dev_drop(atomic_load(&mutex->shares) < EXCLUSIVE_MAGIC);
42003bcc:	17f9                	add	a5,a5,-2 # 1ffffffe <__stack_size+0x1fffdffe>
        if (!(old_value == unequal0 || old_value == unequal1) &&
42003bce:	197d                	add	s2,s2,-1 # 1fffffff <__stack_size+0x1fffdfff>
    assert_dev_drop(atomic_load(&mutex->shares) < EXCLUSIVE_MAGIC);
42003bd0:	04e7cc63          	blt	a5,a4,42003c28 <mutex_release_shared+0xd4>
        int old_value = atomic_load(var);
42003bd4:	0ff0000f          	fence
42003bd8:	409c                	lw	a5,0(s1)
42003bda:	0ff0000f          	fence
        if (!(old_value == unequal0 || old_value == unequal1) &&
42003bde:	c3b1                	beqz	a5,42003c22 <mutex_release_shared+0xce>
42003be0:	05278163          	beq	a5,s2,42003c22 <mutex_release_shared+0xce>
        int new_value = old_value - 1;
42003be4:	fff78713          	add	a4,a5,-1
42003be8:	06e7c263          	blt	a5,a4,42003c4c <mutex_release_shared+0xf8>
            atomic_compare_exchange_weak_explicit(var, &old_value, new_value, order, memory_order_relaxed)) {
42003bec:	1004a6af          	lr.w	a3,(s1)
42003bf0:	00f69563          	bne	a3,a5,42003bfa <mutex_release_shared+0xa6>
42003bf4:	18e4a62f          	sc.w	a2,a4,(s1)
42003bf8:	fa75                	bnez	a2,42003bec <mutex_release_shared+0x98>
        if (!(old_value == unequal0 || old_value == unequal1) &&
42003bfa:	02f69463          	bne	a3,a5,42003c22 <mutex_release_shared+0xce>
        badge_err_set_ok(ec);
42003bfe:	c819                	beqz	s0,42003c14 <mutex_release_shared+0xc0>
42003c00:	00347793          	and	a5,s0,3
42003c04:	e3b9                	bnez	a5,42003c4a <mutex_release_shared+0xf6>
42003c06:	57f1                	li	a5,-4
42003c08:	04f47063          	bgeu	s0,a5,42003c48 <mutex_release_shared+0xf4>
42003c0c:	00042223          	sw	zero,4(s0)
42003c10:	00042023          	sw	zero,0(s0)
}
42003c14:	40b2                	lw	ra,12(sp)
42003c16:	4422                	lw	s0,8(sp)
        return true;
42003c18:	4492                	lw	s1,4(sp)
42003c1a:	4902                	lw	s2,0(sp)
42003c1c:	4505                	li	a0,1
}
42003c1e:	0141                	add	sp,sp,16
42003c20:	8082                	ret
            sched_yield();
42003c22:	1930a0ef          	jal	4200e5b4 <sched_yield>
    while (1) {
42003c26:	b77d                	j	42003bd4 <mutex_release_shared+0x80>
    assert_dev_drop(atomic_load(&mutex->shares) < EXCLUSIVE_MAGIC);
42003c28:	420175b7          	lui	a1,0x42017
42003c2c:	37858593          	add	a1,a1,888 # 42017378 <hextab+0x6ac>
42003c30:	4501                	li	a0,0
42003c32:	e22ff0ef          	jal	42003254 <logk>
42003c36:	9002                	ebreak
    if (atomic_load_explicit(&mutex->magic, memory_order_acquire) != MUTEX_MAGIC) {
42003c38:	9002                	ebreak
    assert_dev_drop(atomic_load(&mutex->shares) < EXCLUSIVE_MAGIC);
42003c3a:	9002                	ebreak
42003c3c:	c226                	sw	s1,4(sp)
42003c3e:	c04a                	sw	s2,0(sp)
        badge_err_set(ec, ELOC_UNKNOWN, ECAUSE_ILLEGAL);
42003c40:	9002                	ebreak
42003c42:	c226                	sw	s1,4(sp)
42003c44:	c04a                	sw	s2,0(sp)
42003c46:	9002                	ebreak
        badge_err_set_ok(ec);
42003c48:	9002                	ebreak
42003c4a:	9002                	ebreak
        int new_value = old_value - 1;
42003c4c:	9002                	ebreak

42003c4e <num_uint16_to_str>:
void num_uint16_to_str(uint16_t val, char outbuf[5]) {
    // This is an implementation of the double dabble algorithm.

    // Shift in first 3 bits.
    uint32_t buf   = val >> 13;
    val          <<= 3;
42003c4e:	00351613          	sll	a2,a0,0x3

    // Perform double dabble on the remaining 13 bits.
    for (int i = 0; i < 13; i++) {
        uint32_t mask   = ((buf | (buf >> 1)) & (buf >> 2)) | (buf >> 3);
        buf            += (mask & 0x11111) * 3;
42003c52:	68c5                	lui	a7,0x11
    val          <<= 3;
42003c54:	0642                	sll	a2,a2,0x10
    uint32_t buf   = val >> 13;
42003c56:	00d55713          	srl	a4,a0,0xd
    val          <<= 3;
42003c5a:	8241                	srl	a2,a2,0x10
42003c5c:	4535                	li	a0,13
        buf            += (mask & 0x11111) * 3;
42003c5e:	11188893          	add	a7,a7,273 # 11111 <__stack_size+0xf111>
        uint32_t mask   = ((buf | (buf >> 1)) & (buf >> 2)) | (buf >> 3);
42003c62:	00175793          	srl	a5,a4,0x1
42003c66:	8fd9                	or	a5,a5,a4
42003c68:	00275813          	srl	a6,a4,0x2
42003c6c:	00375693          	srl	a3,a4,0x3
42003c70:	0107f7b3          	and	a5,a5,a6
42003c74:	8fd5                	or	a5,a5,a3
        buf            += (mask & 0x11111) * 3;
42003c76:	0117f7b3          	and	a5,a5,a7
42003c7a:	00179693          	sll	a3,a5,0x1
42003c7e:	97b6                	add	a5,a5,a3
42003c80:	97ba                	add	a5,a5,a4
        buf           <<= 1;
        buf            |= val >> 15;
42003c82:	00f65713          	srl	a4,a2,0xf
        val           <<= 1;
42003c86:	0606                	sll	a2,a2,0x1
        buf           <<= 1;
42003c88:	0786                	sll	a5,a5,0x1
        val           <<= 1;
42003c8a:	0642                	sll	a2,a2,0x10
    for (int i = 0; i < 13; i++) {
42003c8c:	157d                	add	a0,a0,-1
        buf            |= val >> 15;
42003c8e:	8f5d                	or	a4,a4,a5
        val           <<= 1;
42003c90:	8241                	srl	a2,a2,0x10
    for (int i = 0; i < 13; i++) {
42003c92:	f961                	bnez	a0,42003c62 <num_uint16_to_str+0x14>
    }

    // Output the ASCII values.
    for (int i = 0; i < 5; i++) {
42003c94:	00458513          	add	a0,a1,4
42003c98:	4601                	li	a2,0
        outbuf[4 - i] = '0' + ((buf >> (4 * i)) & 15);
42003c9a:	4891                	li	a7,4
    for (int i = 0; i < 5; i++) {
42003c9c:	4815                	li	a6,5
        outbuf[4 - i] = '0' + ((buf >> (4 * i)) & 15);
42003c9e:	00261793          	sll	a5,a2,0x2
42003ca2:	40c886b3          	sub	a3,a7,a2
42003ca6:	00f757b3          	srl	a5,a4,a5
42003caa:	96ae                	add	a3,a3,a1
42003cac:	8bbd                	and	a5,a5,15
42003cae:	00b6ec63          	bltu	a3,a1,42003cc6 <num_uint16_to_str+0x78>
42003cb2:	03078793          	add	a5,a5,48
42003cb6:	c901                	beqz	a0,42003cc6 <num_uint16_to_str+0x78>
42003cb8:	00f50023          	sb	a5,0(a0)
    for (int i = 0; i < 5; i++) {
42003cbc:	0605                	add	a2,a2,1
42003cbe:	157d                	add	a0,a0,-1
42003cc0:	fd061fe3          	bne	a2,a6,42003c9e <num_uint16_to_str+0x50>
    }
}
42003cc4:	8082                	ret
        outbuf[4 - i] = '0' + ((buf >> (4 * i)) & 15);
42003cc6:	9002                	ebreak

42003cc8 <num_uint32_to_str>:
    val          <<= 3;

    // Perform double dabble on the remaining 29 bits.
    for (int i = 0; i < 29; i++) {
        uint64_t mask   = ((buf | (buf >> 1)) & (buf >> 2)) | (buf >> 3);
        buf            += (mask & 0x1111111111) * 3;
42003cc8:	11111337          	lui	t1,0x11111
    uint64_t buf   = val >> 29;
42003ccc:	01d55693          	srl	a3,a0,0x1d
42003cd0:	4801                	li	a6,0
    val          <<= 3;
42003cd2:	050e                	sll	a0,a0,0x3
42003cd4:	48f5                	li	a7,29
        buf            += (mask & 0x1111111111) * 3;
42003cd6:	11130313          	add	t1,t1,273 # 11111111 <__stack_size+0x1110f111>
        uint64_t mask   = ((buf | (buf >> 1)) & (buf >> 2)) | (buf >> 3);
42003cda:	01f81793          	sll	a5,a6,0x1f
42003cde:	0016d713          	srl	a4,a3,0x1
42003ce2:	01e81f13          	sll	t5,a6,0x1e
42003ce6:	0026de93          	srl	t4,a3,0x2
42003cea:	8f5d                	or	a4,a4,a5
42003cec:	00185613          	srl	a2,a6,0x1
42003cf0:	00d767b3          	or	a5,a4,a3
42003cf4:	01d81f93          	sll	t6,a6,0x1d
42003cf8:	0036de13          	srl	t3,a3,0x3
42003cfc:	01df6eb3          	or	t4,t5,t4
42003d00:	01066733          	or	a4,a2,a6
42003d04:	00285f13          	srl	t5,a6,0x2
42003d08:	01cfee33          	or	t3,t6,t3
42003d0c:	01d7f7b3          	and	a5,a5,t4
42003d10:	00385613          	srl	a2,a6,0x3
42003d14:	01c7e7b3          	or	a5,a5,t3
42003d18:	01e77733          	and	a4,a4,t5
        buf            += (mask & 0x1111111111) * 3;
42003d1c:	0067f7b3          	and	a5,a5,t1
        uint64_t mask   = ((buf | (buf >> 1)) & (buf >> 2)) | (buf >> 3);
42003d20:	8f51                	or	a4,a4,a2
        buf            += (mask & 0x1111111111) * 3;
42003d22:	8b45                	and	a4,a4,17
42003d24:	00179613          	sll	a2,a5,0x1
42003d28:	97b2                	add	a5,a5,a2
42003d2a:	00171e13          	sll	t3,a4,0x1
42003d2e:	00c7b633          	sltu	a2,a5,a2
42003d32:	9772                	add	a4,a4,t3
42003d34:	96be                	add	a3,a3,a5
42003d36:	963a                	add	a2,a2,a4
42003d38:	9642                	add	a2,a2,a6
42003d3a:	00f6b7b3          	sltu	a5,a3,a5
42003d3e:	97b2                	add	a5,a5,a2
        buf           <<= 1;
42003d40:	0786                	sll	a5,a5,0x1
42003d42:	01f6d613          	srl	a2,a3,0x1f
        buf            |= val >> 31;
42003d46:	01f55713          	srl	a4,a0,0x1f
        buf           <<= 1;
42003d4a:	8fd1                	or	a5,a5,a2
42003d4c:	0686                	sll	a3,a3,0x1
    for (int i = 0; i < 29; i++) {
42003d4e:	18fd                	add	a7,a7,-1
        buf            |= val >> 31;
42003d50:	8ed9                	or	a3,a3,a4
42003d52:	883e                	mv	a6,a5
        val           <<= 1;
42003d54:	0506                	sll	a0,a0,0x1
    for (int i = 0; i < 29; i++) {
42003d56:	f80892e3          	bnez	a7,42003cda <num_uint32_to_str+0x12>
    }

    // Output the ASCII values.
    for (int i = 0; i < 10; i++) {
42003d5a:	00958513          	add	a0,a1,9
42003d5e:	4601                	li	a2,0
        outbuf[9 - i] = '0' + ((buf >> (4 * i)) & 15);
42003d60:	00179813          	sll	a6,a5,0x1
42003d64:	4f7d                	li	t5,31
42003d66:	4ea5                	li	t4,9
    for (int i = 0; i < 10; i++) {
42003d68:	4e29                	li	t3,10
42003d6a:	a015                	j	42003d8e <num_uint32_to_str+0xc6>
        outbuf[9 - i] = '0' + ((buf >> (4 * i)) & 15);
42003d6c:	00e7d733          	srl	a4,a5,a4
42003d70:	40ce88b3          	sub	a7,t4,a2
42003d74:	98ae                	add	a7,a7,a1
42003d76:	8b3d                	and	a4,a4,15
42003d78:	02b8eb63          	bltu	a7,a1,42003dae <num_uint32_to_str+0xe6>
42003d7c:	03070713          	add	a4,a4,48 # 42003bb6 <mutex_release_shared+0x62>
42003d80:	c51d                	beqz	a0,42003dae <num_uint32_to_str+0xe6>
42003d82:	00e50023          	sb	a4,0(a0)
    for (int i = 0; i < 10; i++) {
42003d86:	0605                	add	a2,a2,1
42003d88:	157d                	add	a0,a0,-1
42003d8a:	03c60163          	beq	a2,t3,42003dac <num_uint32_to_str+0xe4>
        outbuf[9 - i] = '0' + ((buf >> (4 * i)) & 15);
42003d8e:	00261893          	sll	a7,a2,0x2
42003d92:	fe088713          	add	a4,a7,-32
42003d96:	fc075be3          	bgez	a4,42003d6c <num_uint32_to_str+0xa4>
42003d9a:	411f0333          	sub	t1,t5,a7
42003d9e:	00681333          	sll	t1,a6,t1
42003da2:	0116d733          	srl	a4,a3,a7
42003da6:	00e36733          	or	a4,t1,a4
42003daa:	b7d9                	j	42003d70 <num_uint32_to_str+0xa8>
    }
}
42003dac:	8082                	ret
        outbuf[9 - i] = '0' + ((buf >> (4 * i)) & 15);
42003dae:	9002                	ebreak

42003db0 <num_uint64_to_str>:

// Exactly 64-bit binary to decimal into a 20-char buffer.
void num_uint64_to_str(uint64_t val, char outbuf[20]) {
42003db0:	1141                	add	sp,sp,-16
    // This is an implementation of the double dabble algorithm.

    // Shift in first 3 bits.
    uint64_t buf_lo   = val >> 61;
    uint16_t buf_hi   = 0;
    val             <<= 3;
42003db2:	01d55793          	srl	a5,a0,0x1d
42003db6:	00359813          	sll	a6,a1,0x3

    // Perform double dabble on the remaining 61 bits.
    for (int i = 0; i < 61; i++) {
        // Increment the digits.
        uint64_t mask  = ((buf_lo | (buf_lo >> 1)) & (buf_lo >> 2)) | (buf_lo >> 3);
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003dba:	11111337          	lui	t1,0x11111
        mask           = ((buf_hi | (buf_hi >> 1)) & (buf_hi >> 2)) | (buf_hi >> 3);
        buf_hi        += (mask & 0x1111) * 3;
42003dbe:	6e05                	lui	t3,0x1
void num_uint64_to_str(uint64_t val, char outbuf[20]) {
42003dc0:	c622                	sw	s0,12(sp)
42003dc2:	c426                	sw	s1,8(sp)
    uint64_t buf_lo   = val >> 61;
42003dc4:	01d5d693          	srl	a3,a1,0x1d
42003dc8:	4e81                	li	t4,0
    val             <<= 3;
42003dca:	0107e833          	or	a6,a5,a6
42003dce:	050e                	sll	a0,a0,0x3
42003dd0:	03d00893          	li	a7,61
    uint16_t buf_hi   = 0;
42003dd4:	4f01                	li	t5,0
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003dd6:	11130313          	add	t1,t1,273 # 11111111 <__stack_size+0x1110f111>
        buf_hi        += (mask & 0x1111) * 3;
42003dda:	111e0e13          	add	t3,t3,273 # 1111 <isr_ctx_t_is_kernel_thread+0x1069>
        uint64_t mask  = ((buf_lo | (buf_lo >> 1)) & (buf_lo >> 2)) | (buf_lo >> 3);
42003dde:	01fe9593          	sll	a1,t4,0x1f
42003de2:	0016d793          	srl	a5,a3,0x1
42003de6:	01ee9713          	sll	a4,t4,0x1e
42003dea:	0026d293          	srl	t0,a3,0x2
42003dee:	8fcd                	or	a5,a5,a1
42003df0:	001ed593          	srl	a1,t4,0x1
42003df4:	01de9393          	sll	t2,t4,0x1d
42003df8:	005762b3          	or	t0,a4,t0
42003dfc:	0036df93          	srl	t6,a3,0x3
42003e00:	01d5e5b3          	or	a1,a1,t4
42003e04:	002ed493          	srl	s1,t4,0x2
        mask           = ((buf_hi | (buf_hi >> 1)) & (buf_hi >> 2)) | (buf_hi >> 3);
42003e08:	001f5713          	srl	a4,t5,0x1
        uint64_t mask  = ((buf_lo | (buf_lo >> 1)) & (buf_lo >> 2)) | (buf_lo >> 3);
42003e0c:	01f3efb3          	or	t6,t2,t6
42003e10:	8fd5                	or	a5,a5,a3
42003e12:	003ed413          	srl	s0,t4,0x3
        mask           = ((buf_hi | (buf_hi >> 1)) & (buf_hi >> 2)) | (buf_hi >> 3);
42003e16:	00ef6733          	or	a4,t5,a4
42003e1a:	002f5393          	srl	t2,t5,0x2
        uint64_t mask  = ((buf_lo | (buf_lo >> 1)) & (buf_lo >> 2)) | (buf_lo >> 3);
42003e1e:	8de5                	and	a1,a1,s1
42003e20:	0057f7b3          	and	a5,a5,t0
42003e24:	8dc1                	or	a1,a1,s0
        mask           = ((buf_hi | (buf_hi >> 1)) & (buf_hi >> 2)) | (buf_hi >> 3);
42003e26:	003f5293          	srl	t0,t5,0x3
42003e2a:	00777733          	and	a4,a4,t2
        uint64_t mask  = ((buf_lo | (buf_lo >> 1)) & (buf_lo >> 2)) | (buf_lo >> 3);
42003e2e:	01f7e7b3          	or	a5,a5,t6
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003e32:	0065f5b3          	and	a1,a1,t1
        mask           = ((buf_hi | (buf_hi >> 1)) & (buf_hi >> 2)) | (buf_hi >> 3);
42003e36:	00576733          	or	a4,a4,t0
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003e3a:	0067f7b3          	and	a5,a5,t1
        buf_hi        += (mask & 0x1111) * 3;
42003e3e:	01c77733          	and	a4,a4,t3
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003e42:	00159293          	sll	t0,a1,0x1
42003e46:	9596                	add	a1,a1,t0
42003e48:	00179f93          	sll	t6,a5,0x1
        buf_hi        += (mask & 0x1111) * 3;
42003e4c:	00171293          	sll	t0,a4,0x1
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003e50:	97fe                	add	a5,a5,t6
        buf_hi        += (mask & 0x1111) * 3;
42003e52:	9716                	add	a4,a4,t0
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003e54:	01f7bfb3          	sltu	t6,a5,t6
        buf_hi        += (mask & 0x1111) * 3;
42003e58:	977a                	add	a4,a4,t5
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003e5a:	96be                	add	a3,a3,a5
42003e5c:	9fae                	add	t6,t6,a1
        buf_hi        += (mask & 0x1111) * 3;
42003e5e:	0742                	sll	a4,a4,0x10
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003e60:	9ff6                	add	t6,t6,t4
42003e62:	00f6b7b3          	sltu	a5,a3,a5
        buf_hi        += (mask & 0x1111) * 3;
42003e66:	8341                	srl	a4,a4,0x10
        buf_lo        += (mask & 0x1111111111111111) * 3;
42003e68:	97fe                	add	a5,a5,t6

        // Shift the bits.
        buf_hi <<= 1;
42003e6a:	0706                	sll	a4,a4,0x1
        buf_hi  |= buf_lo >> 63;
        buf_lo <<= 1;
42003e6c:	01f6df13          	srl	t5,a3,0x1f
42003e70:	00179593          	sll	a1,a5,0x1
        buf_hi <<= 1;
42003e74:	0742                	sll	a4,a4,0x10
        buf_lo  |= val >> 63;
42003e76:	01f85e93          	srl	t4,a6,0x1f
        val    <<= 1;
42003e7a:	01f55f93          	srl	t6,a0,0x1f
        buf_lo <<= 1;
42003e7e:	00bf65b3          	or	a1,t5,a1
        buf_hi <<= 1;
42003e82:	8341                	srl	a4,a4,0x10
        buf_hi  |= buf_lo >> 63;
42003e84:	83fd                	srl	a5,a5,0x1f
        buf_lo <<= 1;
42003e86:	0686                	sll	a3,a3,0x1
        val    <<= 1;
42003e88:	0806                	sll	a6,a6,0x1
    for (int i = 0; i < 61; i++) {
42003e8a:	18fd                	add	a7,a7,-1
        buf_lo  |= val >> 63;
42003e8c:	00dee6b3          	or	a3,t4,a3
        buf_hi  |= buf_lo >> 63;
42003e90:	00f76f33          	or	t5,a4,a5
        buf_lo  |= val >> 63;
42003e94:	8eae                	mv	t4,a1
        val    <<= 1;
42003e96:	010fe833          	or	a6,t6,a6
42003e9a:	0506                	sll	a0,a0,0x1
    for (int i = 0; i < 61; i++) {
42003e9c:	f40891e3          	bnez	a7,42003dde <num_uint64_to_str+0x2e>
42003ea0:	01360513          	add	a0,a2,19
    }

    // Output the ASCII values.
    for (int i = 0; i < 16; i++) {
42003ea4:	4701                	li	a4,0
        outbuf[19 - i] = '0' + ((buf_lo >> (4 * i)) & 15);
42003ea6:	00159e93          	sll	t4,a1,0x1
42003eaa:	4ffd                	li	t6,31
42003eac:	4e4d                	li	t3,19
    for (int i = 0; i < 16; i++) {
42003eae:	4341                	li	t1,16
42003eb0:	a015                	j	42003ed4 <num_uint64_to_str+0x124>
        outbuf[19 - i] = '0' + ((buf_lo >> (4 * i)) & 15);
42003eb2:	00f5d7b3          	srl	a5,a1,a5
42003eb6:	40ee0833          	sub	a6,t3,a4
42003eba:	9832                	add	a6,a6,a2
42003ebc:	8bbd                	and	a5,a5,15
42003ebe:	06c86663          	bltu	a6,a2,42003f2a <num_uint64_to_str+0x17a>
42003ec2:	03078793          	add	a5,a5,48
42003ec6:	c135                	beqz	a0,42003f2a <num_uint64_to_str+0x17a>
42003ec8:	00f50023          	sb	a5,0(a0)
    for (int i = 0; i < 16; i++) {
42003ecc:	0705                	add	a4,a4,1
42003ece:	157d                	add	a0,a0,-1
42003ed0:	02670163          	beq	a4,t1,42003ef2 <num_uint64_to_str+0x142>
        outbuf[19 - i] = '0' + ((buf_lo >> (4 * i)) & 15);
42003ed4:	00271813          	sll	a6,a4,0x2
42003ed8:	fe080793          	add	a5,a6,-32
42003edc:	fc07dbe3          	bgez	a5,42003eb2 <num_uint64_to_str+0x102>
42003ee0:	410f88b3          	sub	a7,t6,a6
42003ee4:	011e98b3          	sll	a7,t4,a7
42003ee8:	0106d7b3          	srl	a5,a3,a6
42003eec:	00f8e7b3          	or	a5,a7,a5
42003ef0:	b7d9                	j	42003eb6 <num_uint64_to_str+0x106>
42003ef2:	00360593          	add	a1,a2,3
    }
    for (int i = 0; i < 4; i++) {
42003ef6:	4681                	li	a3,0
        outbuf[3 - i] = '0' + ((buf_hi >> (4 * i)) & 15);
42003ef8:	480d                	li	a6,3
    for (int i = 0; i < 4; i++) {
42003efa:	4511                	li	a0,4
        outbuf[3 - i] = '0' + ((buf_hi >> (4 * i)) & 15);
42003efc:	00269793          	sll	a5,a3,0x2
42003f00:	40d80733          	sub	a4,a6,a3
42003f04:	40ff57b3          	sra	a5,t5,a5
42003f08:	9732                	add	a4,a4,a2
42003f0a:	8bbd                	and	a5,a5,15
42003f0c:	00c76f63          	bltu	a4,a2,42003f2a <num_uint64_to_str+0x17a>
42003f10:	03078793          	add	a5,a5,48
42003f14:	c999                	beqz	a1,42003f2a <num_uint64_to_str+0x17a>
42003f16:	00f58023          	sb	a5,0(a1)
    for (int i = 0; i < 4; i++) {
42003f1a:	0685                	add	a3,a3,1
42003f1c:	15fd                	add	a1,a1,-1
42003f1e:	fca69fe3          	bne	a3,a0,42003efc <num_uint64_to_str+0x14c>
    }
}
42003f22:	4432                	lw	s0,12(sp)
42003f24:	44a2                	lw	s1,8(sp)
42003f26:	0141                	add	sp,sp,16
42003f28:	8082                	ret
        outbuf[3 - i] = '0' + ((buf_hi >> (4 * i)) & 15);
42003f2a:	9002                	ebreak

42003f2c <num_uint_to_str>:

// Up to 64-bit binary to decimal into a 20-char buffer.
// Pads the buffer with zeroes.
// Returns the amount of non-zero digits, which may be 0.
size_t num_uint_to_str(uint64_t val, char outbuf[20]) {
42003f2c:	1141                	add	sp,sp,-16
42003f2e:	c422                	sw	s0,8(sp)
42003f30:	c606                	sw	ra,12(sp)
42003f32:	8432                	mv	s0,a2
    size_t buf_digits;
    if (!(val & 0xffffffffffff0000)) {
42003f34:	c99d                	beqz	a1,42003f6a <num_uint_to_str+0x3e>
            outbuf[i] = '0';
        }
        buf_digits = 10;
    } else {
        // 64-bit.
        num_uint64_to_str(val, outbuf);
42003f36:	3dad                	jal	42003db0 <num_uint64_to_str>
        buf_digits = 20;
42003f38:	4551                	li	a0,20
42003f3a:	40a407b3          	sub	a5,s0,a0
42003f3e:	07d1                	add	a5,a5,20
    }

    // Count number of digits.
    while (buf_digits && outbuf[20 - buf_digits] == '0') buf_digits--;
42003f40:	4651                	li	a2,20
42003f42:	03000693          	li	a3,48
42003f46:	a021                	j	42003f4e <num_uint_to_str+0x22>
42003f48:	157d                	add	a0,a0,-1
42003f4a:	0785                	add	a5,a5,1
42003f4c:	c919                	beqz	a0,42003f62 <num_uint_to_str+0x36>
42003f4e:	40a60733          	sub	a4,a2,a0
42003f52:	9722                	add	a4,a4,s0
42003f54:	08876063          	bltu	a4,s0,42003fd4 <num_uint_to_str+0xa8>
42003f58:	cfb5                	beqz	a5,42003fd4 <num_uint_to_str+0xa8>
42003f5a:	0007c703          	lbu	a4,0(a5)
42003f5e:	fed705e3          	beq	a4,a3,42003f48 <num_uint_to_str+0x1c>
    return buf_digits;
}
42003f62:	40b2                	lw	ra,12(sp)
42003f64:	4422                	lw	s0,8(sp)
42003f66:	0141                	add	sp,sp,16
42003f68:	8082                	ret
    if (!(val & 0xffffffffffff0000)) {
42003f6a:	6741                	lui	a4,0x10
42003f6c:	02e56a63          	bltu	a0,a4,42003fa0 <num_uint_to_str+0x74>
        num_uint32_to_str(val, outbuf + 10);
42003f70:	57d9                	li	a5,-10
42003f72:	06f67163          	bgeu	a2,a5,42003fd4 <num_uint_to_str+0xa8>
42003f76:	00a60593          	add	a1,a2,10
42003f7a:	33b9                	jal	42003cc8 <num_uint32_to_str>
        for (int i = 0; i < 10; i++) {
42003f7c:	8722                	mv	a4,s0
42003f7e:	4781                	li	a5,0
            outbuf[i] = '0';
42003f80:	03000593          	li	a1,48
        for (int i = 0; i < 10; i++) {
42003f84:	4629                	li	a2,10
            outbuf[i] = '0';
42003f86:	008786b3          	add	a3,a5,s0
42003f8a:	0486e563          	bltu	a3,s0,42003fd4 <num_uint_to_str+0xa8>
42003f8e:	c339                	beqz	a4,42003fd4 <num_uint_to_str+0xa8>
42003f90:	00b70023          	sb	a1,0(a4) # 10000 <__stack_size+0xe000>
        for (int i = 0; i < 10; i++) {
42003f94:	0785                	add	a5,a5,1
42003f96:	0705                	add	a4,a4,1
42003f98:	fec797e3          	bne	a5,a2,42003f86 <num_uint_to_str+0x5a>
        buf_digits = 10;
42003f9c:	4529                	li	a0,10
42003f9e:	bf71                	j	42003f3a <num_uint_to_str+0xe>
        num_uint16_to_str(val, outbuf + 15);
42003fa0:	0542                	sll	a0,a0,0x10
42003fa2:	5745                	li	a4,-15
42003fa4:	8141                	srl	a0,a0,0x10
42003fa6:	02e67763          	bgeu	a2,a4,42003fd4 <num_uint_to_str+0xa8>
42003faa:	00f60593          	add	a1,a2,15
42003fae:	3145                	jal	42003c4e <num_uint16_to_str>
        for (int i = 0; i < 15; i++) {
42003fb0:	8722                	mv	a4,s0
42003fb2:	4781                	li	a5,0
            outbuf[i] = '0';
42003fb4:	03000593          	li	a1,48
        for (int i = 0; i < 15; i++) {
42003fb8:	463d                	li	a2,15
            outbuf[i] = '0';
42003fba:	008786b3          	add	a3,a5,s0
42003fbe:	0086eb63          	bltu	a3,s0,42003fd4 <num_uint_to_str+0xa8>
42003fc2:	cb09                	beqz	a4,42003fd4 <num_uint_to_str+0xa8>
42003fc4:	00b70023          	sb	a1,0(a4)
        for (int i = 0; i < 15; i++) {
42003fc8:	0785                	add	a5,a5,1
42003fca:	0705                	add	a4,a4,1
42003fcc:	fec797e3          	bne	a5,a2,42003fba <num_uint_to_str+0x8e>
        buf_digits = 5;
42003fd0:	4515                	li	a0,5
42003fd2:	b7a5                	j	42003f3a <num_uint_to_str+0xe>
    while (buf_digits && outbuf[20 - buf_digits] == '0') buf_digits--;
42003fd4:	9002                	ebreak

42003fd6 <int_to_cstr>:


// Generic signed binary to decimal.
// Does not pad the buffer and places a NULL terminator.
// Returns the length of the generated string.
size_t int_to_cstr(int64_t val, char *outbuf, size_t size) {
42003fd6:	7139                	add	sp,sp,-64
42003fd8:	de06                	sw	ra,60(sp)
42003fda:	d84a                	sw	s2,48(sp)
    if (!size || !outbuf)
42003fdc:	cec1                	beqz	a3,42004074 <int_to_cstr+0x9e>
42003fde:	da26                	sw	s1,52(sp)
42003fe0:	84b2                	mv	s1,a2
42003fe2:	ce5d                	beqz	a2,420040a0 <int_to_cstr+0xca>
42003fe4:	dc22                	sw	s0,56(sp)
        return 0;
    if (size == 1) {
42003fe6:	4785                	li	a5,1
42003fe8:	8436                	mv	s0,a3
42003fea:	08f68163          	beq	a3,a5,4200406c <int_to_cstr+0x96>
        *outbuf = 0;
        return 0;
    }

    // Add the '-'.
    bool sign = val < 0;
42003fee:	d64e                	sw	s3,44(sp)
42003ff0:	d452                	sw	s4,40(sp)
42003ff2:	01f5d993          	srl	s3,a1,0x1f
    if (sign) {
42003ff6:	0805c563          	bltz	a1,42004080 <int_to_cstr+0xaa>
        outbuf[0] = '-';
    }

    // Convert to decimal.
    char   buf[20];
    size_t digits = num_uint_to_str(val, buf);
42003ffa:	00c10a13          	add	s4,sp,12
42003ffe:	8652                	mv	a2,s4
42004000:	3735                	jal	42003f2c <num_uint_to_str>
42004002:	862a                	mv	a2,a0
    if (!digits)
42004004:	e111                	bnez	a0,42004008 <int_to_cstr+0x32>
42004006:	4605                	li	a2,1
        digits = 1;

    // Copy the buffer.
    size_t copy_size = digits + sign < size - 1 ? digits : size - 1 - sign;
42004008:	00c98933          	add	s2,s3,a2
4200400c:	147d                	add	s0,s0,-1
4200400e:	00896563          	bltu	s2,s0,42004018 <int_to_cstr+0x42>
42004012:	41340633          	sub	a2,s0,s3
42004016:	8922                	mv	s2,s0
    mem_copy(&outbuf[sign], &buf[20 - copy_size], copy_size);
42004018:	01348533          	add	a0,s1,s3
4200401c:	04956463          	bltu	a0,s1,42004064 <int_to_cstr+0x8e>
42004020:	45d1                	li	a1,20
42004022:	8d91                	sub	a1,a1,a2
42004024:	47d5                	li	a5,21
42004026:	02f5ff63          	bgeu	a1,a5,42004064 <int_to_cstr+0x8e>
4200402a:	00ba07b3          	add	a5,s4,a1
4200402e:	0205cc63          	bltz	a1,42004066 <int_to_cstr+0x90>
42004032:	0347e963          	bltu	a5,s4,42004064 <int_to_cstr+0x8e>
42004036:	95d2                	add	a1,a1,s4
42004038:	b34fe0ef          	jal	4200236c <mem_copy>
    outbuf[sign + copy_size] = 0;
4200403c:	012487b3          	add	a5,s1,s2
42004040:	02094063          	bltz	s2,42004060 <int_to_cstr+0x8a>
42004044:	0297e063          	bltu	a5,s1,42004064 <int_to_cstr+0x8e>
42004048:	cf91                	beqz	a5,42004064 <int_to_cstr+0x8e>
4200404a:	00078023          	sb	zero,0(a5)
4200404e:	5462                	lw	s0,56(sp)

    return copy_size + sign;
}
42004050:	50f2                	lw	ra,60(sp)
    outbuf[sign + copy_size] = 0;
42004052:	54d2                	lw	s1,52(sp)
42004054:	59b2                	lw	s3,44(sp)
42004056:	5a22                	lw	s4,40(sp)
}
42004058:	854a                	mv	a0,s2
4200405a:	5942                	lw	s2,48(sp)
4200405c:	6121                	add	sp,sp,64
4200405e:	8082                	ret
    outbuf[sign + copy_size] = 0;
42004060:	fef4f4e3          	bgeu	s1,a5,42004048 <int_to_cstr+0x72>
42004064:	9002                	ebreak
    mem_copy(&outbuf[sign], &buf[20 - copy_size], copy_size);
42004066:	fcfa78e3          	bgeu	s4,a5,42004036 <int_to_cstr+0x60>
    outbuf[sign + copy_size] = 0;
4200406a:	9002                	ebreak
        *outbuf = 0;
4200406c:	00060023          	sb	zero,0(a2)
42004070:	5462                	lw	s0,56(sp)
42004072:	54d2                	lw	s1,52(sp)
        return 0;
42004074:	4901                	li	s2,0
}
42004076:	50f2                	lw	ra,60(sp)
42004078:	854a                	mv	a0,s2
4200407a:	5942                	lw	s2,48(sp)
4200407c:	6121                	add	sp,sp,64
4200407e:	8082                	ret
        val       = -val;
42004080:	00a036b3          	snez	a3,a0
42004084:	40b007b3          	neg	a5,a1
42004088:	40a00733          	neg	a4,a0
4200408c:	8f95                	sub	a5,a5,a3
4200408e:	cd01                	beqz	a0,420040a6 <int_to_cstr+0xd0>
42004090:	853a                	mv	a0,a4
42004092:	85be                	mv	a1,a5
        outbuf[0] = '-';
42004094:	d8e1                	beqz	s1,42004064 <int_to_cstr+0x8e>
42004096:	02d00793          	li	a5,45
4200409a:	00f48023          	sb	a5,0(s1)
4200409e:	bfb1                	j	42003ffa <int_to_cstr+0x24>
420040a0:	54d2                	lw	s1,52(sp)
        return 0;
420040a2:	4901                	li	s2,0
420040a4:	bfc9                	j	42004076 <int_to_cstr+0xa0>
        val       = -val;
420040a6:	800006b7          	lui	a3,0x80000
420040aa:	fed593e3          	bne	a1,a3,42004090 <int_to_cstr+0xba>
    outbuf[sign + copy_size] = 0;
420040ae:	9002                	ebreak

420040b0 <uint_to_cstr>:

// Generic unsigned binary to decimal.
// Does not pad the buffer and places a NULL terminator.
// Returns the length of the generated string.
size_t uint_to_cstr(uint64_t val, char *outbuf, size_t size) {
420040b0:	7179                	add	sp,sp,-48
420040b2:	d606                	sw	ra,44(sp)
420040b4:	d422                	sw	s0,40(sp)
    if (!size || !outbuf)
420040b6:	c6a5                	beqz	a3,4200411e <uint_to_cstr+0x6e>
420040b8:	d226                	sw	s1,36(sp)
420040ba:	84b2                	mv	s1,a2
420040bc:	c259                	beqz	a2,42004142 <uint_to_cstr+0x92>
        return 0;
    if (size == 1) {
420040be:	4785                	li	a5,1
420040c0:	8436                	mv	s0,a3
420040c2:	04f68b63          	beq	a3,a5,42004118 <uint_to_cstr+0x68>
        return 0;
    }

    // Convert to decimal.
    char   buf[20];
    size_t digits = num_uint_to_str(val, buf);
420040c6:	d04a                	sw	s2,32(sp)
420040c8:	00c10913          	add	s2,sp,12
420040cc:	864a                	mv	a2,s2
420040ce:	3db9                	jal	42003f2c <num_uint_to_str>
    if (!digits)
        digits = 1;

    // Copy the buffer.
    size_t copy_size = digits < size - 1 ? digits : size - 1;
420040d0:	147d                	add	s0,s0,-1
420040d2:	cd21                	beqz	a0,4200412a <uint_to_cstr+0x7a>
420040d4:	06856563          	bltu	a0,s0,4200413e <uint_to_cstr+0x8e>
    mem_copy(outbuf, &buf[20 - copy_size], copy_size);
420040d8:	45d1                	li	a1,20
420040da:	8d81                	sub	a1,a1,s0
420040dc:	47d5                	li	a5,21
420040de:	04f5fc63          	bgeu	a1,a5,42004136 <uint_to_cstr+0x86>
420040e2:	00b907b3          	add	a5,s2,a1
420040e6:	0405d963          	bgez	a1,42004138 <uint_to_cstr+0x88>
420040ea:	04f96663          	bltu	s2,a5,42004136 <uint_to_cstr+0x86>
420040ee:	8622                	mv	a2,s0
420040f0:	95ca                	add	a1,a1,s2
420040f2:	8526                	mv	a0,s1
420040f4:	a78fe0ef          	jal	4200236c <mem_copy>
    outbuf[copy_size] = 0;
420040f8:	008487b3          	add	a5,s1,s0
420040fc:	02045b63          	bgez	s0,42004132 <uint_to_cstr+0x82>
42004100:	02f4eb63          	bltu	s1,a5,42004136 <uint_to_cstr+0x86>
42004104:	cb8d                	beqz	a5,42004136 <uint_to_cstr+0x86>
42004106:	00078023          	sb	zero,0(a5)

    return copy_size;
}
4200410a:	50b2                	lw	ra,44(sp)
4200410c:	8522                	mv	a0,s0
4200410e:	5422                	lw	s0,40(sp)
    outbuf[copy_size] = 0;
42004110:	5492                	lw	s1,36(sp)
42004112:	5902                	lw	s2,32(sp)
}
42004114:	6145                	add	sp,sp,48
42004116:	8082                	ret
        *outbuf = 0;
42004118:	00060023          	sb	zero,0(a2)
4200411c:	5492                	lw	s1,36(sp)
        return 0;
4200411e:	4401                	li	s0,0
}
42004120:	50b2                	lw	ra,44(sp)
42004122:	8522                	mv	a0,s0
42004124:	5422                	lw	s0,40(sp)
42004126:	6145                	add	sp,sp,48
42004128:	8082                	ret
    size_t copy_size = digits < size - 1 ? digits : size - 1;
4200412a:	4505                	li	a0,1
4200412c:	fa8576e3          	bgeu	a0,s0,420040d8 <uint_to_cstr+0x28>
42004130:	a039                	j	4200413e <uint_to_cstr+0x8e>
    outbuf[copy_size] = 0;
42004132:	fc97f9e3          	bgeu	a5,s1,42004104 <uint_to_cstr+0x54>
42004136:	9002                	ebreak
    mem_copy(outbuf, &buf[20 - copy_size], copy_size);
42004138:	fb27fbe3          	bgeu	a5,s2,420040ee <uint_to_cstr+0x3e>
    outbuf[copy_size] = 0;
4200413c:	9002                	ebreak
    size_t copy_size = digits < size - 1 ? digits : size - 1;
4200413e:	842a                	mv	s0,a0
42004140:	bf61                	j	420040d8 <uint_to_cstr+0x28>
42004142:	5492                	lw	s1,36(sp)
        return 0;
42004144:	4401                	li	s0,0
42004146:	bfe9                	j	42004120 <uint_to_cstr+0x70>

42004148 <int_to_cstr_packed>:

// Generic signed binary to decimal.
// Does not pad the buffer and places a NULL terminator if the buffer is not filled entirely
// Returns the length of the generated string.
size_t int_to_cstr_packed(int64_t val, char *outbuf, size_t size) {
    if (!size || !outbuf)
42004148:	cae1                	beqz	a3,42004218 <int_to_cstr_packed+0xd0>
size_t int_to_cstr_packed(int64_t val, char *outbuf, size_t size) {
4200414a:	7139                	add	sp,sp,-64
4200414c:	dc22                	sw	s0,56(sp)
4200414e:	de06                	sw	ra,60(sp)
42004150:	8432                	mv	s0,a2
    if (!size || !outbuf)
42004152:	ca61                	beqz	a2,42004222 <int_to_cstr_packed+0xda>
        return 0;

    // Add the '-'.
    bool sign = val < 0;
42004154:	da26                	sw	s1,52(sp)
42004156:	d84a                	sw	s2,48(sp)
42004158:	d64e                	sw	s3,44(sp)
4200415a:	d452                	sw	s4,40(sp)
4200415c:	8936                	mv	s2,a3
4200415e:	01f5d493          	srl	s1,a1,0x1f
    if (sign) {
42004162:	0805c463          	bltz	a1,420041ea <int_to_cstr_packed+0xa2>
        outbuf[0] = '-';
    }

    // Convert to decimal.
    char   buf[21];
    size_t digits = num_uint_to_str(val, buf);
42004166:	00810a13          	add	s4,sp,8
4200416a:	8652                	mv	a2,s4
4200416c:	33c1                	jal	42003f2c <num_uint_to_str>
    if (!digits)
        digits = 1;

    // Copy the buffer.
    size_t copy_size = digits < size - sign ? digits : size - sign;
4200416e:	409909b3          	sub	s3,s2,s1
42004172:	c53d                	beqz	a0,420041e0 <int_to_cstr_packed+0x98>
42004174:	07356963          	bltu	a0,s3,420041e6 <int_to_cstr_packed+0x9e>

    mem_copy(&outbuf[sign], &buf[20 - copy_size], copy_size);
42004178:	00940533          	add	a0,s0,s1
4200417c:	0a856863          	bltu	a0,s0,4200422c <int_to_cstr_packed+0xe4>
42004180:	45d1                	li	a1,20
42004182:	413585b3          	sub	a1,a1,s3
42004186:	47d9                	li	a5,22
42004188:	0af5f363          	bgeu	a1,a5,4200422e <int_to_cstr_packed+0xe6>
4200418c:	00ba07b3          	add	a5,s4,a1
42004190:	0405d563          	bgez	a1,420041da <int_to_cstr_packed+0x92>
42004194:	04fa6563          	bltu	s4,a5,420041de <int_to_cstr_packed+0x96>
42004198:	864e                	mv	a2,s3
4200419a:	95d2                	add	a1,a1,s4
4200419c:	9d0fe0ef          	jal	4200236c <mem_copy>
    if (sign + copy_size < size)
420041a0:	01348533          	add	a0,s1,s3
420041a4:	01256a63          	bltu	a0,s2,420041b8 <int_to_cstr_packed+0x70>
        outbuf[sign + copy_size] = 0;

    return copy_size + sign;
}
420041a8:	50f2                	lw	ra,60(sp)
420041aa:	5462                	lw	s0,56(sp)
420041ac:	54d2                	lw	s1,52(sp)
420041ae:	5942                	lw	s2,48(sp)
420041b0:	59b2                	lw	s3,44(sp)
420041b2:	5a22                	lw	s4,40(sp)
420041b4:	6121                	add	sp,sp,64
420041b6:	8082                	ret
        outbuf[sign + copy_size] = 0;
420041b8:	00a407b3          	add	a5,s0,a0
420041bc:	06055063          	bgez	a0,4200421c <int_to_cstr_packed+0xd4>
420041c0:	06f46063          	bltu	s0,a5,42004220 <int_to_cstr_packed+0xd8>
420041c4:	c7b5                	beqz	a5,42004230 <int_to_cstr_packed+0xe8>
420041c6:	00078023          	sb	zero,0(a5)
}
420041ca:	50f2                	lw	ra,60(sp)
420041cc:	5462                	lw	s0,56(sp)
420041ce:	54d2                	lw	s1,52(sp)
420041d0:	5942                	lw	s2,48(sp)
420041d2:	59b2                	lw	s3,44(sp)
420041d4:	5a22                	lw	s4,40(sp)
420041d6:	6121                	add	sp,sp,64
420041d8:	8082                	ret
    mem_copy(&outbuf[sign], &buf[20 - copy_size], copy_size);
420041da:	fb47ffe3          	bgeu	a5,s4,42004198 <int_to_cstr_packed+0x50>
420041de:	9002                	ebreak
    size_t copy_size = digits < size - sign ? digits : size - sign;
420041e0:	4505                	li	a0,1
420041e2:	f9357be3          	bgeu	a0,s3,42004178 <int_to_cstr_packed+0x30>
420041e6:	89aa                	mv	s3,a0
420041e8:	bf41                	j	42004178 <int_to_cstr_packed+0x30>
        val       = -val;
420041ea:	00a036b3          	snez	a3,a0
420041ee:	40b007b3          	neg	a5,a1
420041f2:	40a00733          	neg	a4,a0
420041f6:	8f95                	sub	a5,a5,a3
420041f8:	cd0d                	beqz	a0,42004232 <int_to_cstr_packed+0xea>
420041fa:	853a                	mv	a0,a4
420041fc:	85be                	mv	a1,a5
        outbuf[0] = '-';
420041fe:	cc1d                	beqz	s0,4200423c <int_to_cstr_packed+0xf4>
42004200:	02d00793          	li	a5,45
    size_t digits = num_uint_to_str(val, buf);
42004204:	00810a13          	add	s4,sp,8
        outbuf[0] = '-';
42004208:	00f40023          	sb	a5,0(s0)
    size_t digits = num_uint_to_str(val, buf);
4200420c:	8652                	mv	a2,s4
4200420e:	3b39                	jal	42003f2c <num_uint_to_str>
    size_t copy_size = digits < size - sign ? digits : size - sign;
42004210:	409909b3          	sub	s3,s2,s1
42004214:	f125                	bnez	a0,42004174 <int_to_cstr_packed+0x2c>
42004216:	b7e9                	j	420041e0 <int_to_cstr_packed+0x98>
        return 0;
42004218:	4501                	li	a0,0
}
4200421a:	8082                	ret
        outbuf[sign + copy_size] = 0;
4200421c:	fa87f4e3          	bgeu	a5,s0,420041c4 <int_to_cstr_packed+0x7c>
42004220:	9002                	ebreak
}
42004222:	50f2                	lw	ra,60(sp)
42004224:	5462                	lw	s0,56(sp)
        return 0;
42004226:	4501                	li	a0,0
}
42004228:	6121                	add	sp,sp,64
4200422a:	8082                	ret
    mem_copy(&outbuf[sign], &buf[20 - copy_size], copy_size);
4200422c:	9002                	ebreak
4200422e:	9002                	ebreak
        outbuf[sign + copy_size] = 0;
42004230:	9002                	ebreak
        val       = -val;
42004232:	800006b7          	lui	a3,0x80000
42004236:	fcd592e3          	bne	a1,a3,420041fa <int_to_cstr_packed+0xb2>
4200423a:	9002                	ebreak
        outbuf[0] = '-';
4200423c:	9002                	ebreak

4200423e <uint_to_cstr_packed>:

// Generic unsigned binary to decimal.
// Does not pad the buffer and places a NULL terminator if the buffer is not filled entirely
// Returns the length of the generated string.
size_t uint_to_cstr_packed(uint64_t val, char *outbuf, size_t size) {
4200423e:	7139                	add	sp,sp,-64
42004240:	dc22                	sw	s0,56(sp)
42004242:	de06                	sw	ra,60(sp)
42004244:	da26                	sw	s1,52(sp)
42004246:	8436                	mv	s0,a3
    if (!size || !outbuf)
42004248:	c6a5                	beqz	a3,420042b0 <uint_to_cstr_packed+0x72>
4200424a:	d64e                	sw	s3,44(sp)
4200424c:	89b2                	mv	s3,a2
4200424e:	ca75                	beqz	a2,42004342 <uint_to_cstr_packed+0x104>
        return 0;
    if (size == 1) {
42004250:	4705                	li	a4,1
42004252:	06e68663          	beq	a3,a4,420042be <uint_to_cstr_packed+0x80>
42004256:	d84a                	sw	s2,48(sp)
        return 1;
    }

    // Convert to decimal.
    char   buf[20];
    size_t digits = num_uint_to_str(val, buf);
42004258:	00c10913          	add	s2,sp,12
4200425c:	864a                	mv	a2,s2
4200425e:	31f9                	jal	42003f2c <num_uint_to_str>
42004260:	84aa                	mv	s1,a0
    if (!digits)
        digits = 1;

    // Copy the buffer.
    size_t copy_size = digits < size ? digits : size;
42004262:	cd45                	beqz	a0,4200431a <uint_to_cstr_packed+0xdc>
42004264:	0c946a63          	bltu	s0,s1,42004338 <uint_to_cstr_packed+0xfa>
    mem_copy(outbuf, &buf[20 - copy_size], copy_size);
42004268:	45d1                	li	a1,20
4200426a:	8d85                	sub	a1,a1,s1
4200426c:	47d5                	li	a5,21
4200426e:	0cf5f463          	bgeu	a1,a5,42004336 <uint_to_cstr_packed+0xf8>
42004272:	00b907b3          	add	a5,s2,a1
42004276:	0a05de63          	bgez	a1,42004332 <uint_to_cstr_packed+0xf4>
4200427a:	0af96e63          	bltu	s2,a5,42004336 <uint_to_cstr_packed+0xf8>
4200427e:	8626                	mv	a2,s1
42004280:	95ca                	add	a1,a1,s2
42004282:	854e                	mv	a0,s3
    if (copy_size < size - 1)
42004284:	147d                	add	s0,s0,-1
    mem_copy(outbuf, &buf[20 - copy_size], copy_size);
42004286:	8e6fe0ef          	jal	4200236c <mem_copy>
    if (copy_size < size - 1)
4200428a:	0884fc63          	bgeu	s1,s0,42004322 <uint_to_cstr_packed+0xe4>
        outbuf[copy_size] = 0;
4200428e:	009987b3          	add	a5,s3,s1
42004292:	0a04c563          	bltz	s1,4200433c <uint_to_cstr_packed+0xfe>
42004296:	0b37e063          	bltu	a5,s3,42004336 <uint_to_cstr_packed+0xf8>
4200429a:	cfd1                	beqz	a5,42004336 <uint_to_cstr_packed+0xf8>
4200429c:	00078023          	sb	zero,0(a5)

    return copy_size;
}
420042a0:	50f2                	lw	ra,60(sp)
420042a2:	5462                	lw	s0,56(sp)
420042a4:	5942                	lw	s2,48(sp)
420042a6:	59b2                	lw	s3,44(sp)
420042a8:	8526                	mv	a0,s1
420042aa:	54d2                	lw	s1,52(sp)
420042ac:	6121                	add	sp,sp,64
420042ae:	8082                	ret
420042b0:	50f2                	lw	ra,60(sp)
420042b2:	5462                	lw	s0,56(sp)
        return 0;
420042b4:	4481                	li	s1,0
}
420042b6:	8526                	mv	a0,s1
420042b8:	54d2                	lw	s1,52(sp)
420042ba:	6121                	add	sp,sp,64
420042bc:	8082                	ret
        *outbuf = '0' | (val % 10);
420042be:	00b50733          	add	a4,a0,a1
420042c2:	00a73633          	sltu	a2,a4,a0
420042c6:	9732                	add	a4,a4,a2
420042c8:	4615                	li	a2,5
420042ca:	02c77733          	remu	a4,a4,a2
420042ce:	87ae                	mv	a5,a1
420042d0:	ccccd637          	lui	a2,0xccccd
420042d4:	ccd60613          	add	a2,a2,-819 # cccccccd <__stop_free_lpsram+0x7ccc8ccd>
        return 1;
420042d8:	4485                	li	s1,1
        *outbuf = '0' | (val % 10);
420042da:	40e50733          	sub	a4,a0,a4
420042de:	00e535b3          	sltu	a1,a0,a4
420042e2:	8f8d                	sub	a5,a5,a1
420042e4:	02c787b3          	mul	a5,a5,a2
420042e8:	02c735b3          	mulhu	a1,a4,a2
420042ec:	02c70733          	mul	a4,a4,a2
420042f0:	97ae                	add	a5,a5,a1
420042f2:	07fe                	sll	a5,a5,0x1f
420042f4:	8305                	srl	a4,a4,0x1
420042f6:	8f5d                	or	a4,a4,a5
420042f8:	00271793          	sll	a5,a4,0x2
420042fc:	97ba                	add	a5,a5,a4
420042fe:	0786                	sll	a5,a5,0x1
42004300:	40f507b3          	sub	a5,a0,a5
42004304:	0307e793          	or	a5,a5,48
42004308:	00f98023          	sb	a5,0(s3)
}
4200430c:	50f2                	lw	ra,60(sp)
4200430e:	5462                	lw	s0,56(sp)
        return 1;
42004310:	59b2                	lw	s3,44(sp)
}
42004312:	8526                	mv	a0,s1
42004314:	54d2                	lw	s1,52(sp)
42004316:	6121                	add	sp,sp,64
42004318:	8082                	ret
    size_t copy_size = digits < size ? digits : size;
4200431a:	4485                	li	s1,1
4200431c:	f49476e3          	bgeu	s0,s1,42004268 <uint_to_cstr_packed+0x2a>
42004320:	a821                	j	42004338 <uint_to_cstr_packed+0xfa>
}
42004322:	50f2                	lw	ra,60(sp)
42004324:	5462                	lw	s0,56(sp)
42004326:	5942                	lw	s2,48(sp)
42004328:	59b2                	lw	s3,44(sp)
4200432a:	8526                	mv	a0,s1
4200432c:	54d2                	lw	s1,52(sp)
4200432e:	6121                	add	sp,sp,64
42004330:	8082                	ret
    mem_copy(outbuf, &buf[20 - copy_size], copy_size);
42004332:	f527f6e3          	bgeu	a5,s2,4200427e <uint_to_cstr_packed+0x40>
        outbuf[copy_size] = 0;
42004336:	9002                	ebreak
    size_t copy_size = digits < size ? digits : size;
42004338:	84a2                	mv	s1,s0
4200433a:	b73d                	j	42004268 <uint_to_cstr_packed+0x2a>
        outbuf[copy_size] = 0;
4200433c:	f4f9ffe3          	bgeu	s3,a5,4200429a <uint_to_cstr_packed+0x5c>
42004340:	9002                	ebreak
}
42004342:	50f2                	lw	ra,60(sp)
42004344:	5462                	lw	s0,56(sp)
        return 0;
42004346:	4481                	li	s1,0
42004348:	59b2                	lw	s3,44(sp)
}
4200434a:	8526                	mv	a0,s1
4200434c:	54d2                	lw	s1,52(sp)
4200434e:	6121                	add	sp,sp,64
42004350:	8082                	ret

42004352 <blkdev_ram_open>:

#include "badge_strings.h"

void blkdev_ram_open(badge_err_t *ec, blkdev_t *dev) {
    (void)dev;
    badge_err_set_ok(ec);
42004352:	c919                	beqz	a0,42004368 <blkdev_ram_open+0x16>
42004354:	00357793          	and	a5,a0,3
42004358:	eb89                	bnez	a5,4200436a <blkdev_ram_open+0x18>
4200435a:	57f1                	li	a5,-4
4200435c:	00f57763          	bgeu	a0,a5,4200436a <blkdev_ram_open+0x18>
42004360:	00052223          	sw	zero,4(a0)
42004364:	00052023          	sw	zero,0(a0)
}
42004368:	8082                	ret
    badge_err_set_ok(ec);
4200436a:	9002                	ebreak

4200436c <blkdev_ram_close>:

void blkdev_ram_close(badge_err_t *ec, blkdev_t *dev) {
4200436c:	c919                	beqz	a0,42004382 <blkdev_ram_close+0x16>
4200436e:	00357793          	and	a5,a0,3
42004372:	eb89                	bnez	a5,42004384 <blkdev_ram_close+0x18>
42004374:	57f1                	li	a5,-4
42004376:	00f57763          	bgeu	a0,a5,42004384 <blkdev_ram_close+0x18>
4200437a:	00052223          	sw	zero,4(a0)
4200437e:	00052023          	sw	zero,0(a0)
42004382:	8082                	ret
42004384:	9002                	ebreak

42004386 <blkdev_ram_is_erased>:
    (void)dev;
    badge_err_set_ok(ec);
}

bool blkdev_ram_is_erased(badge_err_t *ec, blkdev_t *dev, blksize_t block) {
    if (block >= dev->blocks) {
42004386:	c9b5                	beqz	a1,420043fa <blkdev_ram_is_erased+0x74>
42004388:	0035f793          	and	a5,a1,3
4200438c:	e7bd                	bnez	a5,420043fa <blkdev_ram_is_erased+0x74>
4200438e:	57d1                	li	a5,-12
42004390:	06f5f463          	bgeu	a1,a5,420043f8 <blkdev_ram_is_erased+0x72>
42004394:	45dc                	lw	a5,12(a1)
bool blkdev_ram_is_erased(badge_err_t *ec, blkdev_t *dev, blksize_t block) {
42004396:	1141                	add	sp,sp,-16
42004398:	c422                	sw	s0,8(sp)
4200439a:	c606                	sw	ra,12(sp)
4200439c:	842a                	mv	s0,a0
    if (block >= dev->blocks) {
4200439e:	02f66d63          	bltu	a2,a5,420043d8 <blkdev_ram_is_erased+0x52>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
420043a2:	c515                	beqz	a0,420043ce <blkdev_ram_is_erased+0x48>
420043a4:	420175b7          	lui	a1,0x42017
420043a8:	468d                	li	a3,3
420043aa:	4639                	li	a2,14
420043ac:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420043b0:	4511                	li	a0,4
420043b2:	00000717          	auipc	a4,0x0
420043b6:	ee5fe0ef          	jal	4200329a <logkf>
420043ba:	00347793          	and	a5,s0,3
420043be:	e3a9                	bnez	a5,42004400 <blkdev_ram_is_erased+0x7a>
420043c0:	57f1                	li	a5,-4
420043c2:	04f47063          	bgeu	s0,a5,42004402 <blkdev_ram_is_erased+0x7c>
420043c6:	47b9                	li	a5,14
420043c8:	c05c                	sw	a5,4(s0)
420043ca:	478d                	li	a5,3
420043cc:	c01c                	sw	a5,0(s0)
    } else {
        badge_err_set_ok(ec);
    }
    return true;
}
420043ce:	40b2                	lw	ra,12(sp)
420043d0:	4422                	lw	s0,8(sp)
420043d2:	4505                	li	a0,1
420043d4:	0141                	add	sp,sp,16
420043d6:	8082                	ret
        badge_err_set_ok(ec);
420043d8:	d97d                	beqz	a0,420043ce <blkdev_ram_is_erased+0x48>
420043da:	00357793          	and	a5,a0,3
420043de:	ef99                	bnez	a5,420043fc <blkdev_ram_is_erased+0x76>
420043e0:	57f1                	li	a5,-4
420043e2:	00f57e63          	bgeu	a0,a5,420043fe <blkdev_ram_is_erased+0x78>
}
420043e6:	40b2                	lw	ra,12(sp)
420043e8:	4422                	lw	s0,8(sp)
        badge_err_set_ok(ec);
420043ea:	00052223          	sw	zero,4(a0)
420043ee:	00052023          	sw	zero,0(a0)
}
420043f2:	4505                	li	a0,1
420043f4:	0141                	add	sp,sp,16
420043f6:	8082                	ret
    if (block >= dev->blocks) {
420043f8:	9002                	ebreak
420043fa:	9002                	ebreak
        badge_err_set_ok(ec);
420043fc:	9002                	ebreak
420043fe:	9002                	ebreak
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
42004400:	9002                	ebreak
42004402:	9002                	ebreak

42004404 <blkdev_ram_erase>:

void blkdev_ram_erase(badge_err_t *ec, blkdev_t *dev, blksize_t block) {
    if (block >= dev->blocks) {
42004404:	c9a5                	beqz	a1,42004474 <blkdev_ram_erase+0x70>
42004406:	0035f793          	and	a5,a1,3
4200440a:	e7ad                	bnez	a5,42004474 <blkdev_ram_erase+0x70>
4200440c:	57d1                	li	a5,-12
4200440e:	06f5f263          	bgeu	a1,a5,42004472 <blkdev_ram_erase+0x6e>
42004412:	45dc                	lw	a5,12(a1)
void blkdev_ram_erase(badge_err_t *ec, blkdev_t *dev, blksize_t block) {
42004414:	1141                	add	sp,sp,-16
42004416:	c422                	sw	s0,8(sp)
42004418:	c606                	sw	ra,12(sp)
4200441a:	842a                	mv	s0,a0
    if (block >= dev->blocks) {
4200441c:	02f66c63          	bltu	a2,a5,42004454 <blkdev_ram_erase+0x50>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
42004420:	c515                	beqz	a0,4200444c <blkdev_ram_erase+0x48>
42004422:	420175b7          	lui	a1,0x42017
42004426:	468d                	li	a3,3
42004428:	4639                	li	a2,14
4200442a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200442e:	4511                	li	a0,4
42004430:	00000717          	auipc	a4,0x0
42004434:	e67fe0ef          	jal	4200329a <logkf>
42004438:	00347793          	and	a5,s0,3
4200443c:	ef9d                	bnez	a5,4200447a <blkdev_ram_erase+0x76>
4200443e:	57f1                	li	a5,-4
42004440:	02f47e63          	bgeu	s0,a5,4200447c <blkdev_ram_erase+0x78>
42004444:	47b9                	li	a5,14
42004446:	c05c                	sw	a5,4(s0)
42004448:	478d                	li	a5,3
4200444a:	c01c                	sw	a5,0(s0)
    } else {
        badge_err_set_ok(ec);
    }
}
4200444c:	40b2                	lw	ra,12(sp)
4200444e:	4422                	lw	s0,8(sp)
42004450:	0141                	add	sp,sp,16
42004452:	8082                	ret
        badge_err_set_ok(ec);
42004454:	dd65                	beqz	a0,4200444c <blkdev_ram_erase+0x48>
42004456:	00357793          	and	a5,a0,3
4200445a:	ef91                	bnez	a5,42004476 <blkdev_ram_erase+0x72>
4200445c:	57f1                	li	a5,-4
4200445e:	00f57d63          	bgeu	a0,a5,42004478 <blkdev_ram_erase+0x74>
}
42004462:	40b2                	lw	ra,12(sp)
42004464:	4422                	lw	s0,8(sp)
        badge_err_set_ok(ec);
42004466:	00052223          	sw	zero,4(a0)
4200446a:	00052023          	sw	zero,0(a0)
}
4200446e:	0141                	add	sp,sp,16
42004470:	8082                	ret
    if (block >= dev->blocks) {
42004472:	9002                	ebreak
42004474:	9002                	ebreak
        badge_err_set_ok(ec);
42004476:	9002                	ebreak
42004478:	9002                	ebreak
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
4200447a:	9002                	ebreak
4200447c:	9002                	ebreak

4200447e <blkdev_ram_write>:

void blkdev_ram_write(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t const *writebuf) {
    if (block >= dev->blocks) {
4200447e:	cdc9                	beqz	a1,42004518 <blkdev_ram_write+0x9a>
42004480:	8732                	mv	a4,a2
42004482:	0035f613          	and	a2,a1,3
42004486:	87ae                	mv	a5,a1
42004488:	ea41                	bnez	a2,42004518 <blkdev_ram_write+0x9a>
4200448a:	5651                	li	a2,-12
4200448c:	08c5f563          	bgeu	a1,a2,42004516 <blkdev_ram_write+0x98>
42004490:	45d0                	lw	a2,12(a1)
void blkdev_ram_write(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t const *writebuf) {
42004492:	1141                	add	sp,sp,-16
42004494:	c422                	sw	s0,8(sp)
42004496:	c606                	sw	ra,12(sp)
42004498:	842a                	mv	s0,a0
    if (block >= dev->blocks) {
4200449a:	02c76c63          	bltu	a4,a2,420044d2 <blkdev_ram_write+0x54>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
4200449e:	c515                	beqz	a0,420044ca <blkdev_ram_write+0x4c>
420044a0:	420175b7          	lui	a1,0x42017
420044a4:	468d                	li	a3,3
420044a6:	4639                	li	a2,14
420044a8:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420044ac:	4511                	li	a0,4
420044ae:	00000717          	auipc	a4,0x0
420044b2:	de9fe0ef          	jal	4200329a <logkf>
420044b6:	00347793          	and	a5,s0,3
420044ba:	e3b5                	bnez	a5,4200451e <blkdev_ram_write+0xa0>
420044bc:	57f1                	li	a5,-4
420044be:	06f47163          	bgeu	s0,a5,42004520 <blkdev_ram_write+0xa2>
420044c2:	47b9                	li	a5,14
420044c4:	c05c                	sw	a5,4(s0)
420044c6:	478d                	li	a5,3
420044c8:	c01c                	sw	a5,0(s0)
    } else {
        badge_err_set_ok(ec);
        mem_copy(dev->ram_addr + block * dev->block_size, writebuf, dev->block_size);
    }
}
420044ca:	40b2                	lw	ra,12(sp)
420044cc:	4422                	lw	s0,8(sp)
420044ce:	0141                	add	sp,sp,16
420044d0:	8082                	ret
        badge_err_set_ok(ec);
420044d2:	c919                	beqz	a0,420044e8 <blkdev_ram_write+0x6a>
420044d4:	00357613          	and	a2,a0,3
420044d8:	e229                	bnez	a2,4200451a <blkdev_ram_write+0x9c>
420044da:	5671                	li	a2,-4
420044dc:	04c57063          	bgeu	a0,a2,4200451c <blkdev_ram_write+0x9e>
420044e0:	00052223          	sw	zero,4(a0)
420044e4:	00052023          	sw	zero,0(a0)
        mem_copy(dev->ram_addr + block * dev->block_size, writebuf, dev->block_size);
420044e8:	5631                	li	a2,-20
420044ea:	02c7f563          	bgeu	a5,a2,42004514 <blkdev_ram_write+0x96>
420044ee:	43d0                	lw	a2,4(a5)
420044f0:	4bdc                	lw	a5,20(a5)
420044f2:	02e60733          	mul	a4,a2,a4
420044f6:	00e78533          	add	a0,a5,a4
420044fa:	00075a63          	bgez	a4,4200450e <blkdev_ram_write+0x90>
420044fe:	00a7ea63          	bltu	a5,a0,42004512 <blkdev_ram_write+0x94>
}
42004502:	4422                	lw	s0,8(sp)
42004504:	40b2                	lw	ra,12(sp)
        mem_copy(dev->ram_addr + block * dev->block_size, writebuf, dev->block_size);
42004506:	85b6                	mv	a1,a3
}
42004508:	0141                	add	sp,sp,16
        mem_copy(dev->ram_addr + block * dev->block_size, writebuf, dev->block_size);
4200450a:	e63fd06f          	j	4200236c <mem_copy>
4200450e:	fef57ae3          	bgeu	a0,a5,42004502 <blkdev_ram_write+0x84>
42004512:	9002                	ebreak
42004514:	9002                	ebreak
    if (block >= dev->blocks) {
42004516:	9002                	ebreak
42004518:	9002                	ebreak
        badge_err_set_ok(ec);
4200451a:	9002                	ebreak
4200451c:	9002                	ebreak
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
4200451e:	9002                	ebreak
42004520:	9002                	ebreak

42004522 <blkdev_ram_read>:

void blkdev_ram_read(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t *readbuf) {
    if (block >= dev->blocks) {
42004522:	cdc1                	beqz	a1,420045ba <blkdev_ram_read+0x98>
42004524:	0035f713          	and	a4,a1,3
42004528:	eb49                	bnez	a4,420045ba <blkdev_ram_read+0x98>
4200452a:	5751                	li	a4,-12
4200452c:	08e5f663          	bgeu	a1,a4,420045b8 <blkdev_ram_read+0x96>
42004530:	45d8                	lw	a4,12(a1)
void blkdev_ram_read(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t *readbuf) {
42004532:	1141                	add	sp,sp,-16
42004534:	c422                	sw	s0,8(sp)
42004536:	c606                	sw	ra,12(sp)
42004538:	842a                	mv	s0,a0
4200453a:	87b2                	mv	a5,a2
    if (block >= dev->blocks) {
4200453c:	02e66c63          	bltu	a2,a4,42004574 <blkdev_ram_read+0x52>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
42004540:	c515                	beqz	a0,4200456c <blkdev_ram_read+0x4a>
42004542:	420175b7          	lui	a1,0x42017
42004546:	468d                	li	a3,3
42004548:	4639                	li	a2,14
4200454a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200454e:	4511                	li	a0,4
42004550:	00000717          	auipc	a4,0x0
42004554:	d47fe0ef          	jal	4200329a <logkf>
42004558:	00347793          	and	a5,s0,3
4200455c:	e3b5                	bnez	a5,420045c0 <blkdev_ram_read+0x9e>
4200455e:	57f1                	li	a5,-4
42004560:	06f47163          	bgeu	s0,a5,420045c2 <blkdev_ram_read+0xa0>
42004564:	47b9                	li	a5,14
42004566:	c05c                	sw	a5,4(s0)
42004568:	478d                	li	a5,3
4200456a:	c01c                	sw	a5,0(s0)
    } else {
        badge_err_set_ok(ec);
        mem_copy(readbuf, dev->ram_addr + block * dev->block_size, dev->block_size);
    }
}
4200456c:	40b2                	lw	ra,12(sp)
4200456e:	4422                	lw	s0,8(sp)
42004570:	0141                	add	sp,sp,16
42004572:	8082                	ret
        badge_err_set_ok(ec);
42004574:	c919                	beqz	a0,4200458a <blkdev_ram_read+0x68>
42004576:	00357713          	and	a4,a0,3
4200457a:	e329                	bnez	a4,420045bc <blkdev_ram_read+0x9a>
4200457c:	5771                	li	a4,-4
4200457e:	04e57063          	bgeu	a0,a4,420045be <blkdev_ram_read+0x9c>
42004582:	00052223          	sw	zero,4(a0)
42004586:	00052023          	sw	zero,0(a0)
        mem_copy(readbuf, dev->ram_addr + block * dev->block_size, dev->block_size);
4200458a:	5731                	li	a4,-20
4200458c:	02e5f563          	bgeu	a1,a4,420045b6 <blkdev_ram_read+0x94>
42004590:	41d0                	lw	a2,4(a1)
42004592:	49d8                	lw	a4,20(a1)
42004594:	02f607b3          	mul	a5,a2,a5
42004598:	00f705b3          	add	a1,a4,a5
4200459c:	0007da63          	bgez	a5,420045b0 <blkdev_ram_read+0x8e>
420045a0:	00b76a63          	bltu	a4,a1,420045b4 <blkdev_ram_read+0x92>
}
420045a4:	4422                	lw	s0,8(sp)
420045a6:	40b2                	lw	ra,12(sp)
        mem_copy(readbuf, dev->ram_addr + block * dev->block_size, dev->block_size);
420045a8:	8536                	mv	a0,a3
}
420045aa:	0141                	add	sp,sp,16
        mem_copy(readbuf, dev->ram_addr + block * dev->block_size, dev->block_size);
420045ac:	dc1fd06f          	j	4200236c <mem_copy>
420045b0:	fee5fae3          	bgeu	a1,a4,420045a4 <blkdev_ram_read+0x82>
420045b4:	9002                	ebreak
420045b6:	9002                	ebreak
    if (block >= dev->blocks) {
420045b8:	9002                	ebreak
420045ba:	9002                	ebreak
        badge_err_set_ok(ec);
420045bc:	9002                	ebreak
420045be:	9002                	ebreak
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
420045c0:	9002                	ebreak
420045c2:	9002                	ebreak

420045c4 <blkdev_ram_flush>:

void blkdev_ram_flush(badge_err_t *ec, blkdev_t *dev) {
420045c4:	c919                	beqz	a0,420045da <blkdev_ram_flush+0x16>
420045c6:	00357793          	and	a5,a0,3
420045ca:	eb89                	bnez	a5,420045dc <blkdev_ram_flush+0x18>
420045cc:	57f1                	li	a5,-4
420045ce:	00f57763          	bgeu	a0,a5,420045dc <blkdev_ram_flush+0x18>
420045d2:	00052223          	sw	zero,4(a0)
420045d6:	00052023          	sw	zero,0(a0)
420045da:	8082                	ret
420045dc:	9002                	ebreak

420045de <blkdev_alloc_cache>:

// Find an empty cache entry.
// Returns -1 when not found.
static inline ptrdiff_t blkdev_alloc_cache(blkdev_t *dev, blksize_t block) __attribute__((pure));
static inline ptrdiff_t blkdev_alloc_cache(blkdev_t *dev, blksize_t block) {
    if (!dev->cache)
420045de:	16050a63          	beqz	a0,42004752 <blkdev_alloc_cache+0x174>
static inline ptrdiff_t blkdev_alloc_cache(blkdev_t *dev, blksize_t block) {
420045e2:	1101                	add	sp,sp,-32
420045e4:	c84a                	sw	s2,16(sp)
420045e6:	ce06                	sw	ra,28(sp)
    if (!dev->cache)
420045e8:	00357793          	and	a5,a0,3
420045ec:	892a                	mv	s2,a0
420045ee:	14079e63          	bnez	a5,4200474a <blkdev_alloc_cache+0x16c>
420045f2:	5791                	li	a5,-28
420045f4:	14f57863          	bgeu	a0,a5,42004744 <blkdev_alloc_cache+0x166>
420045f8:	4d5c                	lw	a5,28(a0)
420045fa:	12078b63          	beqz	a5,42004730 <blkdev_alloc_cache+0x152>
420045fe:	cc22                	sw	s0,24(sp)
42004600:	ca26                	sw	s1,20(sp)
        return -1;

    blkdev_flags_t *flags = dev->cache->block_flags;
42004602:	0037f713          	and	a4,a5,3
42004606:	14071563          	bnez	a4,42004750 <blkdev_alloc_cache+0x172>
4200460a:	5771                	li	a4,-4
4200460c:	12e7f663          	bgeu	a5,a4,42004738 <blkdev_alloc_cache+0x15a>
42004610:	43c0                	lw	s0,4(a5)

    timestamp_us_t oldest_read_time  = time_us() - BLKDEV_READ_CACHE_TIMEOUT;
42004612:	84ae                	mv	s1,a1
42004614:	1540c0ef          	jal	42010768 <time_us>
42004618:	fff0cf37          	lui	t5,0xfff0c
4200461c:	dc0f0f13          	add	t5,t5,-576 # fff0bdc0 <__stop_free_lpsram+0xaff07dc0>
42004620:	9f2a                	add	t5,t5,a0
42004622:	00af37b3          	sltu	a5,t5,a0
42004626:	fff58e93          	add	t4,a1,-1
4200462a:	9ebe                	add	t4,t4,a5
4200462c:	11d5ca63          	blt	a1,t4,42004740 <blkdev_alloc_cache+0x162>
42004630:	10be8663          	beq	t4,a1,4200473c <blkdev_alloc_cache+0x15e>
    ptrdiff_t      oldest_read_index = -1;

    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
42004634:	01c92783          	lw	a5,28(s2)
42004638:	10078163          	beqz	a5,4200473a <blkdev_alloc_cache+0x15c>
4200463c:	0037f713          	and	a4,a5,3
42004640:	ef6d                	bnez	a4,4200473a <blkdev_alloc_cache+0x15c>
42004642:	5761                	li	a4,-8
42004644:	0ee7ff63          	bgeu	a5,a4,42004742 <blkdev_alloc_cache+0x164>
42004648:	478c                	lw	a1,8(a5)
4200464a:	0cb05c63          	blez	a1,42004722 <blkdev_alloc_cache+0x144>
4200464e:	87a2                	mv	a5,s0
42004650:	4501                	li	a0,0
    ptrdiff_t      oldest_read_index = -1;
42004652:	53fd                	li	t2,-1
        if (!flags[i].present || flags[i].index == block) {
42004654:	4f85                	li	t6,1
42004656:	52e1                	li	t0,-8
42004658:	00451693          	sll	a3,a0,0x4
4200465c:	00d40733          	add	a4,s0,a3
42004660:	0a06c263          	bltz	a3,42004704 <blkdev_alloc_cache+0x126>
42004664:	0a876263          	bltu	a4,s0,42004708 <blkdev_alloc_cache+0x12a>
42004668:	c7f1                	beqz	a5,42004734 <blkdev_alloc_cache+0x156>
4200466a:	0037f613          	and	a2,a5,3
4200466e:	e279                	bnez	a2,42004734 <blkdev_alloc_cache+0x156>
42004670:	00c7c603          	lbu	a2,12(a5)
42004674:	0ecfe063          	bltu	t6,a2,42004754 <blkdev_alloc_cache+0x176>
42004678:	8a05                	and	a2,a2,1
4200467a:	ce3d                	beqz	a2,420046f8 <blkdev_alloc_cache+0x11a>
4200467c:	0806c763          	bltz	a3,4200470a <blkdev_alloc_cache+0x12c>
42004680:	08876763          	bltu	a4,s0,4200470e <blkdev_alloc_cache+0x130>
42004684:	0a57f963          	bgeu	a5,t0,42004736 <blkdev_alloc_cache+0x158>
42004688:	4790                	lw	a2,8(a5)
4200468a:	06960763          	beq	a2,s1,420046f8 <blkdev_alloc_cache+0x11a>
            // Vacant cache entry found.
            return i;
        } else if (!blkdev_is_dirty(flags[i]) && oldest_read_time > flags[i].update_time) {
4200468e:	0806c163          	bltz	a3,42004710 <blkdev_alloc_cache+0x132>
42004692:	08876163          	bltu	a4,s0,42004714 <blkdev_alloc_cache+0x136>
42004696:	47d0                	lw	a2,12(a5)
42004698:	00e7c883          	lbu	a7,14(a5)
    return flags.present && (flags.erase || flags.dirty);
4200469c:	00d7ce03          	lbu	t3,13(a5)
420046a0:	c632                	sw	a2,12(sp)
420046a2:	01110723          	sb	a7,14(sp)
420046a6:	01c106a3          	sb	t3,13(sp)
420046aa:	0087a303          	lw	t1,8(a5)
420046ae:	48b2                	lw	a7,12(sp)
420046b0:	0007a803          	lw	a6,0(a5)
420046b4:	43d0                	lw	a2,4(a5)
420046b6:	c41a                	sw	t1,8(sp)
420046b8:	00889313          	sll	t1,a7,0x8
420046bc:	c042                	sw	a6,0(sp)
420046be:	c232                	sw	a2,4(sp)
420046c0:	01035313          	srl	t1,t1,0x10
420046c4:	02031363          	bnez	t1,420046ea <blkdev_alloc_cache+0x10c>
        } else if (!blkdev_is_dirty(flags[i]) && oldest_read_time > flags[i].update_time) {
420046c8:	0406c763          	bltz	a3,42004716 <blkdev_alloc_cache+0x138>
420046cc:	04876763          	bltu	a4,s0,4200471a <blkdev_alloc_cache+0x13c>
420046d0:	01d64663          	blt	a2,t4,420046dc <blkdev_alloc_cache+0xfe>
420046d4:	00ce9b63          	bne	t4,a2,420046ea <blkdev_alloc_cache+0x10c>
420046d8:	01e87963          	bgeu	a6,t5,420046ea <blkdev_alloc_cache+0x10c>
            // Sufficiently old read cache entry found.
            oldest_read_time  = flags[i].update_time;
420046dc:	0406c063          	bltz	a3,4200471c <blkdev_alloc_cache+0x13e>
420046e0:	04876063          	bltu	a4,s0,42004720 <blkdev_alloc_cache+0x142>
            oldest_read_index = i;
420046e4:	83aa                	mv	t2,a0
            oldest_read_time  = flags[i].update_time;
420046e6:	8f42                	mv	t5,a6
420046e8:	8eb2                	mv	t4,a2
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
420046ea:	0505                	add	a0,a0,1
420046ec:	07c1                	add	a5,a5,16
420046ee:	f6b515e3          	bne	a0,a1,42004658 <blkdev_alloc_cache+0x7a>
        }
    }

    if (oldest_read_index >= 0) {
420046f2:	851e                	mv	a0,t2
420046f4:	0203c763          	bltz	t2,42004722 <blkdev_alloc_cache+0x144>
420046f8:	4462                	lw	s0,24(sp)
420046fa:	44d2                	lw	s1,20(sp)
        // Only the oldest read cache entry is replaced.
        return oldest_read_index;
    }

    return -1;
}
420046fc:	40f2                	lw	ra,28(sp)
420046fe:	4942                	lw	s2,16(sp)
42004700:	6105                	add	sp,sp,32
42004702:	8082                	ret
        if (!flags[i].present || flags[i].index == block) {
42004704:	f6e472e3          	bgeu	s0,a4,42004668 <blkdev_alloc_cache+0x8a>
42004708:	9002                	ebreak
4200470a:	f6e47de3          	bgeu	s0,a4,42004684 <blkdev_alloc_cache+0xa6>
4200470e:	9002                	ebreak
        } else if (!blkdev_is_dirty(flags[i]) && oldest_read_time > flags[i].update_time) {
42004710:	f8e473e3          	bgeu	s0,a4,42004696 <blkdev_alloc_cache+0xb8>
42004714:	9002                	ebreak
42004716:	fae47de3          	bgeu	s0,a4,420046d0 <blkdev_alloc_cache+0xf2>
4200471a:	9002                	ebreak
            oldest_read_time  = flags[i].update_time;
4200471c:	fce474e3          	bgeu	s0,a4,420046e4 <blkdev_alloc_cache+0x106>
42004720:	9002                	ebreak
42004722:	4462                	lw	s0,24(sp)
}
42004724:	40f2                	lw	ra,28(sp)
42004726:	44d2                	lw	s1,20(sp)
42004728:	4942                	lw	s2,16(sp)
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
4200472a:	557d                	li	a0,-1
}
4200472c:	6105                	add	sp,sp,32
4200472e:	8082                	ret
        return -1;
42004730:	557d                	li	a0,-1
42004732:	b7e9                	j	420046fc <blkdev_alloc_cache+0x11e>
        if (!flags[i].present || flags[i].index == block) {
42004734:	9002                	ebreak
42004736:	9002                	ebreak
    blkdev_flags_t *flags = dev->cache->block_flags;
42004738:	9002                	ebreak
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
4200473a:	9002                	ebreak
    timestamp_us_t oldest_read_time  = time_us() - BLKDEV_READ_CACHE_TIMEOUT;
4200473c:	efe57ce3          	bgeu	a0,t5,42004634 <blkdev_alloc_cache+0x56>
42004740:	9002                	ebreak
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
42004742:	9002                	ebreak
42004744:	cc22                	sw	s0,24(sp)
42004746:	ca26                	sw	s1,20(sp)
    if (!dev->cache)
42004748:	9002                	ebreak
4200474a:	cc22                	sw	s0,24(sp)
4200474c:	ca26                	sw	s1,20(sp)
4200474e:	9002                	ebreak
    blkdev_flags_t *flags = dev->cache->block_flags;
42004750:	9002                	ebreak
    if (!dev->cache)
42004752:	9002                	ebreak
        if (!flags[i].present || flags[i].index == block) {
42004754:	9002                	ebreak

42004756 <blkdev_write_raw>:



// Write without caching.
void blkdev_write_raw(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t const *writebuf) {
    switch (dev->type) {
42004756:	c5a9                	beqz	a1,420047a0 <blkdev_write_raw+0x4a>
42004758:	0035f713          	and	a4,a1,3
4200475c:	e331                	bnez	a4,420047a0 <blkdev_write_raw+0x4a>
4200475e:	419c                	lw	a5,0(a1)
42004760:	cf9d                	beqz	a5,4200479e <blkdev_write_raw+0x48>
void blkdev_write_raw(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t const *writebuf) {
42004762:	1141                	add	sp,sp,-16
42004764:	c422                	sw	s0,8(sp)
42004766:	c606                	sw	ra,12(sp)
42004768:	842a                	mv	s0,a0
        case BLKDEV_TYPE_RAM: return blkdev_ram_write(ec, dev, block, writebuf);
        // case BLKDEV_TYPE_I2C_EEPROM: return blkdev_i2c_eeprom_write(ec, dev, block, writebuf);
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
4200476a:	c515                	beqz	a0,42004796 <blkdev_write_raw+0x40>
4200476c:	420175b7          	lui	a1,0x42017
42004770:	4689                	li	a3,2
42004772:	4639                	li	a2,14
42004774:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42004778:	4511                	li	a0,4
4200477a:	00000717          	auipc	a4,0x0
4200477e:	b1dfe0ef          	jal	4200329a <logkf>
42004782:	00347793          	and	a5,s0,3
42004786:	ef91                	bnez	a5,420047a2 <blkdev_write_raw+0x4c>
42004788:	57f1                	li	a5,-4
4200478a:	00f47d63          	bgeu	s0,a5,420047a4 <blkdev_write_raw+0x4e>
4200478e:	47b9                	li	a5,14
42004790:	c05c                	sw	a5,4(s0)
42004792:	4789                	li	a5,2
42004794:	c01c                	sw	a5,0(s0)
    }
}
42004796:	40b2                	lw	ra,12(sp)
42004798:	4422                	lw	s0,8(sp)
4200479a:	0141                	add	sp,sp,16
4200479c:	8082                	ret
        case BLKDEV_TYPE_RAM: return blkdev_ram_write(ec, dev, block, writebuf);
4200479e:	b1c5                	j	4200447e <blkdev_ram_write>
    switch (dev->type) {
420047a0:	9002                	ebreak
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
420047a2:	9002                	ebreak
420047a4:	9002                	ebreak

420047a6 <blkdev_read_raw>:

// Read without caching.
void blkdev_read_raw(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t *readbuf) {
    switch (dev->type) {
420047a6:	c5a9                	beqz	a1,420047f0 <blkdev_read_raw+0x4a>
420047a8:	0035f713          	and	a4,a1,3
420047ac:	e331                	bnez	a4,420047f0 <blkdev_read_raw+0x4a>
420047ae:	419c                	lw	a5,0(a1)
420047b0:	cf9d                	beqz	a5,420047ee <blkdev_read_raw+0x48>
void blkdev_read_raw(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t *readbuf) {
420047b2:	1141                	add	sp,sp,-16
420047b4:	c422                	sw	s0,8(sp)
420047b6:	c606                	sw	ra,12(sp)
420047b8:	842a                	mv	s0,a0
        case BLKDEV_TYPE_RAM: return blkdev_ram_read(ec, dev, block, readbuf);
        // case BLKDEV_TYPE_I2C_EEPROM: return blkdev_i2c_eeprom_read(ec, dev, block, readbuf);
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
420047ba:	c515                	beqz	a0,420047e6 <blkdev_read_raw+0x40>
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
420047bc:	420175b7          	lui	a1,0x42017
420047c0:	4689                	li	a3,2
420047c2:	4639                	li	a2,14
420047c4:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420047c8:	4511                	li	a0,4
420047ca:	00000717          	auipc	a4,0x0
420047ce:	acdfe0ef          	jal	4200329a <logkf>
420047d2:	00347793          	and	a5,s0,3
420047d6:	ef91                	bnez	a5,420047f2 <blkdev_read_raw+0x4c>
420047d8:	57f1                	li	a5,-4
420047da:	00f47d63          	bgeu	s0,a5,420047f4 <blkdev_read_raw+0x4e>
420047de:	47b9                	li	a5,14
420047e0:	c05c                	sw	a5,4(s0)
420047e2:	4789                	li	a5,2
420047e4:	c01c                	sw	a5,0(s0)
    }
}
420047e6:	40b2                	lw	ra,12(sp)
420047e8:	4422                	lw	s0,8(sp)
420047ea:	0141                	add	sp,sp,16
420047ec:	8082                	ret
        case BLKDEV_TYPE_RAM: return blkdev_ram_read(ec, dev, block, readbuf);
420047ee:	bb15                	j	42004522 <blkdev_ram_read>
    switch (dev->type) {
420047f0:	9002                	ebreak
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
420047f2:	9002                	ebreak
420047f4:	9002                	ebreak

420047f6 <blkdev_erase_raw>:

// Erase without caching.
void blkdev_erase_raw(badge_err_t *ec, blkdev_t *dev, blksize_t block) {
    switch (dev->type) {
420047f6:	c5a9                	beqz	a1,42004840 <blkdev_erase_raw+0x4a>
420047f8:	0035f713          	and	a4,a1,3
420047fc:	e331                	bnez	a4,42004840 <blkdev_erase_raw+0x4a>
420047fe:	419c                	lw	a5,0(a1)
42004800:	cf9d                	beqz	a5,4200483e <blkdev_erase_raw+0x48>
void blkdev_erase_raw(badge_err_t *ec, blkdev_t *dev, blksize_t block) {
42004802:	1141                	add	sp,sp,-16
42004804:	c422                	sw	s0,8(sp)
42004806:	c606                	sw	ra,12(sp)
42004808:	842a                	mv	s0,a0
        case BLKDEV_TYPE_RAM: return blkdev_ram_erase(ec, dev, block);
        // case BLKDEV_TYPE_I2C_EEPROM: return blkdev_i2c_eeprom_erase(ec, dev, block);
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
4200480a:	c515                	beqz	a0,42004836 <blkdev_erase_raw+0x40>
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
4200480c:	420175b7          	lui	a1,0x42017
42004810:	4689                	li	a3,2
42004812:	4639                	li	a2,14
42004814:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42004818:	4511                	li	a0,4
4200481a:	00000717          	auipc	a4,0x0
4200481e:	a7dfe0ef          	jal	4200329a <logkf>
42004822:	00347793          	and	a5,s0,3
42004826:	ef91                	bnez	a5,42004842 <blkdev_erase_raw+0x4c>
42004828:	57f1                	li	a5,-4
4200482a:	00f47d63          	bgeu	s0,a5,42004844 <blkdev_erase_raw+0x4e>
4200482e:	47b9                	li	a5,14
42004830:	c05c                	sw	a5,4(s0)
42004832:	4789                	li	a5,2
42004834:	c01c                	sw	a5,0(s0)
    }
}
42004836:	40b2                	lw	ra,12(sp)
42004838:	4422                	lw	s0,8(sp)
4200483a:	0141                	add	sp,sp,16
4200483c:	8082                	ret
        case BLKDEV_TYPE_RAM: return blkdev_ram_erase(ec, dev, block);
4200483e:	b6d9                	j	42004404 <blkdev_ram_erase>
    switch (dev->type) {
42004840:	9002                	ebreak
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
42004842:	9002                	ebreak
42004844:	9002                	ebreak

42004846 <blkdev_flush_cache>:
    uint8_t        *cache = dev->cache->block_cache;
42004846:	18058e63          	beqz	a1,420049e2 <blkdev_flush_cache+0x19c>
static void blkdev_flush_cache(badge_err_t *ec, blkdev_t *dev, size_t i) {
4200484a:	1101                	add	sp,sp,-32
4200484c:	c84a                	sw	s2,16(sp)
4200484e:	ce06                	sw	ra,28(sp)
42004850:	cc22                	sw	s0,24(sp)
42004852:	ca26                	sw	s1,20(sp)
42004854:	c64e                	sw	s3,12(sp)
42004856:	c452                	sw	s4,8(sp)
42004858:	c256                	sw	s5,4(sp)
4200485a:	c05a                	sw	s6,0(sp)
    uint8_t        *cache = dev->cache->block_cache;
4200485c:	0035f793          	and	a5,a1,3
42004860:	892e                	mv	s2,a1
42004862:	16079b63          	bnez	a5,420049d8 <blkdev_flush_cache+0x192>
42004866:	5791                	li	a5,-28
42004868:	16f5f763          	bgeu	a1,a5,420049d6 <blkdev_flush_cache+0x190>
4200486c:	4ddc                	lw	a5,28(a1)
4200486e:	16078963          	beqz	a5,420049e0 <blkdev_flush_cache+0x19a>
42004872:	0037f713          	and	a4,a5,3
42004876:	16071563          	bnez	a4,420049e0 <blkdev_flush_cache+0x19a>
    blkdev_flags_t *flags = dev->cache->block_flags;
4200487a:	5771                	li	a4,-4
    uint8_t        *cache = dev->cache->block_cache;
4200487c:	0007ab03          	lw	s6,0(a5)
    blkdev_flags_t *flags = dev->cache->block_flags;
42004880:	14e7fd63          	bgeu	a5,a4,420049da <blkdev_flush_cache+0x194>
42004884:	43c4                	lw	s1,4(a5)
    bool dirty     = flags[i].dirty;
42004886:	00461993          	sll	s3,a2,0x4
4200488a:	8aaa                	mv	s5,a0
4200488c:	8a32                	mv	s4,a2
4200488e:	01348433          	add	s0,s1,s3
42004892:	0a09cf63          	bltz	s3,42004950 <blkdev_flush_cache+0x10a>
42004896:	0a946f63          	bltu	s0,s1,42004954 <blkdev_flush_cache+0x10e>
4200489a:	14040263          	beqz	s0,420049de <blkdev_flush_cache+0x198>
4200489e:	00347793          	and	a5,s0,3
420048a2:	12079e63          	bnez	a5,420049de <blkdev_flush_cache+0x198>
420048a6:	00e44783          	lbu	a5,14(s0)
420048aa:	4705                	li	a4,1
420048ac:	12f76c63          	bltu	a4,a5,420049e4 <blkdev_flush_cache+0x19e>
420048b0:	8b85                	and	a5,a5,1
    bool erase     = flags[i].erase;
420048b2:	0809cc63          	bltz	s3,4200494a <blkdev_flush_cache+0x104>
420048b6:	08946c63          	bltu	s0,s1,4200494e <blkdev_flush_cache+0x108>
420048ba:	00d44703          	lbu	a4,13(s0)
420048be:	4685                	li	a3,1
420048c0:	12e6e263          	bltu	a3,a4,420049e4 <blkdev_flush_cache+0x19e>
    flags[i].dirty = false;
420048c4:	0809c063          	bltz	s3,42004944 <blkdev_flush_cache+0xfe>
420048c8:	08946063          	bltu	s0,s1,42004948 <blkdev_flush_cache+0x102>
420048cc:	56c9                	li	a3,-14
420048ce:	10d47763          	bgeu	s0,a3,420049dc <blkdev_flush_cache+0x196>
420048d2:	00040723          	sb	zero,14(s0)
    flags[i].erase = false;
420048d6:	0609c463          	bltz	s3,4200493e <blkdev_flush_cache+0xf8>
420048da:	06946463          	bltu	s0,s1,42004942 <blkdev_flush_cache+0xfc>
420048de:	000406a3          	sb	zero,13(s0)
    if (dirty) {
420048e2:	cbb5                	beqz	a5,42004956 <blkdev_flush_cache+0x110>
        flags[i].present = dev->cache_read;
420048e4:	0809db63          	bgez	s3,4200497a <blkdev_flush_cache+0x134>
420048e8:	0884eb63          	bltu	s1,s0,4200497e <blkdev_flush_cache+0x138>
420048ec:	01894783          	lbu	a5,24(s2)
420048f0:	4705                	li	a4,1
420048f2:	0ef76963          	bltu	a4,a5,420049e4 <blkdev_flush_cache+0x19e>
420048f6:	8b85                	and	a5,a5,1
420048f8:	00f40623          	sb	a5,12(s0)
        if (dev->cache_read) {
420048fc:	01894783          	lbu	a5,24(s2)
42004900:	0ef76263          	bltu	a4,a5,420049e4 <blkdev_flush_cache+0x19e>
42004904:	8b85                	and	a5,a5,1
42004906:	e7c5                	bnez	a5,420049ae <blkdev_flush_cache+0x168>
        blkdev_write_raw(ec, dev, flags[i].index, cache + (i * dev->block_size));
42004908:	0609d663          	bgez	s3,42004974 <blkdev_flush_cache+0x12e>
4200490c:	0684e663          	bltu	s1,s0,42004978 <blkdev_flush_cache+0x132>
42004910:	00492783          	lw	a5,4(s2)
42004914:	4410                	lw	a2,8(s0)
42004916:	02fa0a33          	mul	s4,s4,a5
4200491a:	014b06b3          	add	a3,s6,s4
4200491e:	040a5863          	bgez	s4,4200496e <blkdev_flush_cache+0x128>
42004922:	04db6863          	bltu	s6,a3,42004972 <blkdev_flush_cache+0x12c>
}
42004926:	4462                	lw	s0,24(sp)
42004928:	40f2                	lw	ra,28(sp)
4200492a:	44d2                	lw	s1,20(sp)
4200492c:	49b2                	lw	s3,12(sp)
4200492e:	4a22                	lw	s4,8(sp)
42004930:	4b02                	lw	s6,0(sp)
        blkdev_write_raw(ec, dev, flags[i].index, cache + (i * dev->block_size));
42004932:	85ca                	mv	a1,s2
42004934:	8556                	mv	a0,s5
}
42004936:	4942                	lw	s2,16(sp)
42004938:	4a92                	lw	s5,4(sp)
4200493a:	6105                	add	sp,sp,32
        blkdev_write_raw(ec, dev, flags[i].index, cache + (i * dev->block_size));
4200493c:	bd29                	j	42004756 <blkdev_write_raw>
    flags[i].erase = false;
4200493e:	fa84f0e3          	bgeu	s1,s0,420048de <blkdev_flush_cache+0x98>
42004942:	9002                	ebreak
    flags[i].dirty = false;
42004944:	f884f4e3          	bgeu	s1,s0,420048cc <blkdev_flush_cache+0x86>
42004948:	9002                	ebreak
    bool erase     = flags[i].erase;
4200494a:	f684f8e3          	bgeu	s1,s0,420048ba <blkdev_flush_cache+0x74>
4200494e:	9002                	ebreak
    bool dirty     = flags[i].dirty;
42004950:	f484f5e3          	bgeu	s1,s0,4200489a <blkdev_flush_cache+0x54>
42004954:	9002                	ebreak
    } else if (erase) {
42004956:	8b05                	and	a4,a4,1
42004958:	e705                	bnez	a4,42004980 <blkdev_flush_cache+0x13a>
}
4200495a:	40f2                	lw	ra,28(sp)
4200495c:	4462                	lw	s0,24(sp)
4200495e:	44d2                	lw	s1,20(sp)
42004960:	4942                	lw	s2,16(sp)
42004962:	49b2                	lw	s3,12(sp)
42004964:	4a22                	lw	s4,8(sp)
42004966:	4a92                	lw	s5,4(sp)
42004968:	4b02                	lw	s6,0(sp)
4200496a:	6105                	add	sp,sp,32
4200496c:	8082                	ret
        blkdev_write_raw(ec, dev, flags[i].index, cache + (i * dev->block_size));
4200496e:	fb66fce3          	bgeu	a3,s6,42004926 <blkdev_flush_cache+0xe0>
42004972:	9002                	ebreak
42004974:	f8947ee3          	bgeu	s0,s1,42004910 <blkdev_flush_cache+0xca>
42004978:	9002                	ebreak
        flags[i].present = dev->cache_read;
4200497a:	f69479e3          	bgeu	s0,s1,420048ec <blkdev_flush_cache+0xa6>
4200497e:	9002                	ebreak
        flags[i].present = false;
42004980:	0409c863          	bltz	s3,420049d0 <blkdev_flush_cache+0x18a>
42004984:	04946863          	bltu	s0,s1,420049d4 <blkdev_flush_cache+0x18e>
42004988:	00040623          	sb	zero,12(s0)
        blkdev_erase_raw(ec, dev, flags[i].index);
4200498c:	0209cf63          	bltz	s3,420049ca <blkdev_flush_cache+0x184>
42004990:	02946f63          	bltu	s0,s1,420049ce <blkdev_flush_cache+0x188>
42004994:	4410                	lw	a2,8(s0)
}
42004996:	4462                	lw	s0,24(sp)
42004998:	40f2                	lw	ra,28(sp)
4200499a:	44d2                	lw	s1,20(sp)
4200499c:	49b2                	lw	s3,12(sp)
4200499e:	4a22                	lw	s4,8(sp)
420049a0:	4b02                	lw	s6,0(sp)
        blkdev_erase_raw(ec, dev, flags[i].index);
420049a2:	85ca                	mv	a1,s2
420049a4:	8556                	mv	a0,s5
}
420049a6:	4942                	lw	s2,16(sp)
420049a8:	4a92                	lw	s5,4(sp)
420049aa:	6105                	add	sp,sp,32
        blkdev_erase_raw(ec, dev, flags[i].index);
420049ac:	b5a9                	j	420047f6 <blkdev_erase_raw>
            flags[i].update_time = time_us();
420049ae:	0009cb63          	bltz	s3,420049c4 <blkdev_flush_cache+0x17e>
420049b2:	00946b63          	bltu	s0,s1,420049c8 <blkdev_flush_cache+0x182>
420049b6:	5b30b0ef          	jal	42010768 <time_us>
420049ba:	c008                	sw	a0,0(s0)
420049bc:	c04c                	sw	a1,4(s0)
        blkdev_write_raw(ec, dev, flags[i].index, cache + (i * dev->block_size));
420049be:	f409c7e3          	bltz	s3,4200490c <blkdev_flush_cache+0xc6>
420049c2:	bf4d                	j	42004974 <blkdev_flush_cache+0x12e>
            flags[i].update_time = time_us();
420049c4:	fe84f9e3          	bgeu	s1,s0,420049b6 <blkdev_flush_cache+0x170>
420049c8:	9002                	ebreak
        blkdev_erase_raw(ec, dev, flags[i].index);
420049ca:	fc84f5e3          	bgeu	s1,s0,42004994 <blkdev_flush_cache+0x14e>
420049ce:	9002                	ebreak
        flags[i].present = false;
420049d0:	fa84fce3          	bgeu	s1,s0,42004988 <blkdev_flush_cache+0x142>
420049d4:	9002                	ebreak
    uint8_t        *cache = dev->cache->block_cache;
420049d6:	9002                	ebreak
420049d8:	9002                	ebreak
    blkdev_flags_t *flags = dev->cache->block_flags;
420049da:	9002                	ebreak
    flags[i].dirty = false;
420049dc:	9002                	ebreak
    bool dirty     = flags[i].dirty;
420049de:	9002                	ebreak
    uint8_t        *cache = dev->cache->block_cache;
420049e0:	9002                	ebreak
420049e2:	9002                	ebreak
    bool dirty     = flags[i].dirty;
420049e4:	9002                	ebreak

420049e6 <blkdev_write_partial_fallback>:
    blksize_t      block,
    size_t         subblock_offset,
    uint8_t const *writebuf,
    size_t         writebuf_len
) {
    uint8_t        *cache = dev->cache->block_cache;
420049e6:	2c058963          	beqz	a1,42004cb8 <blkdev_write_partial_fallback+0x2d2>
) {
420049ea:	7139                	add	sp,sp,-64
420049ec:	d256                	sw	s5,36(sp)
420049ee:	ca66                	sw	s9,20(sp)
420049f0:	de06                	sw	ra,60(sp)
420049f2:	8cbe                	mv	s9,a5
    uint8_t        *cache = dev->cache->block_cache;
420049f4:	0035f793          	and	a5,a1,3
420049f8:	8aae                	mv	s5,a1
420049fa:	26079e63          	bnez	a5,42004c76 <blkdev_write_partial_fallback+0x290>
420049fe:	5791                	li	a5,-28
42004a00:	26f5f163          	bgeu	a1,a5,42004c62 <blkdev_write_partial_fallback+0x27c>
42004a04:	01c5a803          	lw	a6,28(a1)
42004a08:	24080363          	beqz	a6,42004c4e <blkdev_write_partial_fallback+0x268>
42004a0c:	00387793          	and	a5,a6,3
42004a10:	22079f63          	bnez	a5,42004c4e <blkdev_write_partial_fallback+0x268>
42004a14:	c86a                	sw	s10,16(sp)
    blkdev_flags_t *flags = dev->cache->block_flags;
42004a16:	57f1                	li	a5,-4
    uint8_t        *cache = dev->cache->block_cache;
42004a18:	00082d03          	lw	s10,0(a6)
    blkdev_flags_t *flags = dev->cache->block_flags;
42004a1c:	dc22                	sw	s0,56(sp)
42004a1e:	da26                	sw	s1,52(sp)
42004a20:	26f87c63          	bgeu	a6,a5,42004c98 <blkdev_write_partial_fallback+0x2b2>
42004a24:	d452                	sw	s4,40(sp)
42004a26:	d05a                	sw	s6,32(sp)
42004a28:	ce5e                	sw	s7,28(sp)
42004a2a:	cc62                	sw	s8,24(sp)
42004a2c:	00482483          	lw	s1,4(a6)

    // Try to look up the block in the cache.
    ptrdiff_t i = blkdev_find_cache(dev, block);
42004a30:	8b2a                	mv	s6,a0
42004a32:	8a32                	mv	s4,a2
    if (!dev->cache)
42004a34:	8bb6                	mv	s7,a3
42004a36:	8c3a                	mv	s8,a4
42004a38:	06080363          	beqz	a6,42004a9e <blkdev_write_partial_fallback+0xb8>
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
42004a3c:	57e1                	li	a5,-8
42004a3e:	26f87463          	bgeu	a6,a5,42004ca6 <blkdev_write_partial_fallback+0x2c0>
42004a42:	00882e03          	lw	t3,8(a6)
42004a46:	05c05c63          	blez	t3,42004a9e <blkdev_write_partial_fallback+0xb8>
42004a4a:	d84a                	sw	s2,48(sp)
42004a4c:	8826                	mv	a6,s1
42004a4e:	4401                	li	s0,0
        if (flags[i].present && flags[i].index == block) {
42004a50:	4e85                	li	t4,1
42004a52:	5561                	li	a0,-8
42004a54:	00441913          	sll	s2,s0,0x4
42004a58:	01248333          	add	t1,s1,s2
42004a5c:	0a094663          	bltz	s2,42004b08 <blkdev_write_partial_fallback+0x122>
42004a60:	0a936663          	bltu	t1,s1,42004b0c <blkdev_write_partial_fallback+0x126>
42004a64:	1e080063          	beqz	a6,42004c44 <blkdev_write_partial_fallback+0x25e>
42004a68:	00387893          	and	a7,a6,3
42004a6c:	1c089c63          	bnez	a7,42004c44 <blkdev_write_partial_fallback+0x25e>
42004a70:	00c84883          	lbu	a7,12(a6)
42004a74:	251ee363          	bltu	t4,a7,42004cba <blkdev_write_partial_fallback+0x2d4>
42004a78:	0018f893          	and	a7,a7,1
42004a7c:	00088c63          	beqz	a7,42004a94 <blkdev_write_partial_fallback+0xae>
42004a80:	08094863          	bltz	s2,42004b10 <blkdev_write_partial_fallback+0x12a>
42004a84:	08936863          	bltu	t1,s1,42004b14 <blkdev_write_partial_fallback+0x12e>
42004a88:	1ca87063          	bgeu	a6,a0,42004c48 <blkdev_write_partial_fallback+0x262>
42004a8c:	00882883          	lw	a7,8(a6)
42004a90:	091a0463          	beq	s4,a7,42004b18 <blkdev_write_partial_fallback+0x132>
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
42004a94:	0405                	add	s0,s0,1
42004a96:	0841                	add	a6,a6,16
42004a98:	fa8e1ee3          	bne	t3,s0,42004a54 <blkdev_write_partial_fallback+0x6e>
42004a9c:	5942                	lw	s2,48(sp)
        mem_copy(cache + i * dev->block_size + subblock_offset, writebuf, writebuf_len);
        badge_err_set_ok(ec);

    } else {
        // Cache was not available, allocate some on the heap.
        uint8_t *tmp = malloc(dev->block_size);
42004a9e:	004aa503          	lw	a0,4(s5)
42004aa2:	6af080ef          	jal	4200d950 <malloc>
42004aa6:	842a                	mv	s0,a0
        if (!tmp) {
42004aa8:	16050463          	beqz	a0,42004c10 <blkdev_write_partial_fallback+0x22a>
            badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
            return;
        }
        // Read into the temporary buffer.
        badge_err_t ec0;
        if (!ec)
42004aac:	140b0b63          	beqz	s6,42004c02 <blkdev_write_partial_fallback+0x21c>
            ec = &ec0;
        blkdev_read_raw(ec, dev, block, tmp);
42004ab0:	86a2                	mv	a3,s0
42004ab2:	8652                	mv	a2,s4
42004ab4:	85d6                	mv	a1,s5
42004ab6:	855a                	mv	a0,s6
42004ab8:	31fd                	jal	420047a6 <blkdev_read_raw>
        if (!badge_err_is_ok(ec)) {
42004aba:	1e0b0c63          	beqz	s6,42004cb2 <blkdev_write_partial_fallback+0x2cc>
42004abe:	003b7793          	and	a5,s6,3
42004ac2:	1e079863          	bnez	a5,42004cb2 <blkdev_write_partial_fallback+0x2cc>
42004ac6:	000b2783          	lw	a5,0(s6)
42004aca:	e385                	bnez	a5,42004aea <blkdev_write_partial_fallback+0x104>
            free(tmp);
            return;
        }
        // Modify and write back.
        mem_copy(tmp + subblock_offset, writebuf, writebuf_len);
42004acc:	01740533          	add	a0,s0,s7
42004ad0:	120bcb63          	bltz	s7,42004c06 <blkdev_write_partial_fallback+0x220>
42004ad4:	12856b63          	bltu	a0,s0,42004c0a <blkdev_write_partial_fallback+0x224>
42004ad8:	8666                	mv	a2,s9
42004ada:	85e2                	mv	a1,s8
42004adc:	891fd0ef          	jal	4200236c <mem_copy>
        blkdev_write_raw(ec, dev, block, tmp);
42004ae0:	86a2                	mv	a3,s0
42004ae2:	8652                	mv	a2,s4
42004ae4:	85d6                	mv	a1,s5
42004ae6:	855a                	mv	a0,s6
42004ae8:	31bd                	jal	42004756 <blkdev_write_raw>
        free(tmp);
42004aea:	8522                	mv	a0,s0
42004aec:	070090ef          	jal	4200db5c <free>
42004af0:	5462                	lw	s0,56(sp)
    }
}
42004af2:	50f2                	lw	ra,60(sp)
42004af4:	54d2                	lw	s1,52(sp)
42004af6:	5a22                	lw	s4,40(sp)
42004af8:	5b02                	lw	s6,32(sp)
42004afa:	4bf2                	lw	s7,28(sp)
42004afc:	4c62                	lw	s8,24(sp)
42004afe:	4d42                	lw	s10,16(sp)
42004b00:	5a92                	lw	s5,36(sp)
42004b02:	4cd2                	lw	s9,20(sp)
42004b04:	6121                	add	sp,sp,64
42004b06:	8082                	ret
        if (flags[i].present && flags[i].index == block) {
42004b08:	f464fee3          	bgeu	s1,t1,42004a64 <blkdev_write_partial_fallback+0x7e>
42004b0c:	d64e                	sw	s3,44(sp)
42004b0e:	9002                	ebreak
42004b10:	f664fce3          	bgeu	s1,t1,42004a88 <blkdev_write_partial_fallback+0xa2>
42004b14:	d64e                	sw	s3,44(sp)
42004b16:	9002                	ebreak
42004b18:	d64e                	sw	s3,44(sp)
        flags[i].erase = false;
42004b1a:	012489b3          	add	s3,s1,s2
42004b1e:	08095263          	bgez	s2,42004ba2 <blkdev_write_partial_fallback+0x1bc>
42004b22:	0934e263          	bltu	s1,s3,42004ba6 <blkdev_write_partial_fallback+0x1c0>
42004b26:	16098263          	beqz	s3,42004c8a <blkdev_write_partial_fallback+0x2a4>
42004b2a:	0039f793          	and	a5,s3,3
42004b2e:	14079e63          	bnez	a5,42004c8a <blkdev_write_partial_fallback+0x2a4>
42004b32:	57cd                	li	a5,-13
42004b34:	16f9fc63          	bgeu	s3,a5,42004cac <blkdev_write_partial_fallback+0x2c6>
42004b38:	000986a3          	sb	zero,13(s3)
        flags[i].dirty = false;
42004b3c:	06094c63          	bltz	s2,42004bb4 <blkdev_write_partial_fallback+0x1ce>
42004b40:	0699ec63          	bltu	s3,s1,42004bb8 <blkdev_write_partial_fallback+0x1d2>
42004b44:	57c9                	li	a5,-14
42004b46:	16f9f463          	bgeu	s3,a5,42004cae <blkdev_write_partial_fallback+0x2c8>
42004b4a:	00098723          	sb	zero,14(s3)
        if (!flags[i].present) {
42004b4e:	06094063          	bltz	s2,42004bae <blkdev_write_partial_fallback+0x1c8>
42004b52:	0699e063          	bltu	s3,s1,42004bb2 <blkdev_write_partial_fallback+0x1cc>
42004b56:	00c9c783          	lbu	a5,12(s3)
42004b5a:	4705                	li	a4,1
42004b5c:	16f76063          	bltu	a4,a5,42004cbc <blkdev_write_partial_fallback+0x2d6>
42004b60:	8b85                	and	a5,a5,1
42004b62:	cfa1                	beqz	a5,42004bba <blkdev_write_partial_fallback+0x1d4>
        mem_copy(cache + i * dev->block_size + subblock_offset, writebuf, writebuf_len);
42004b64:	004aa503          	lw	a0,4(s5)
42004b68:	02a40533          	mul	a0,s0,a0
42004b6c:	017506b3          	add	a3,a0,s7
42004b70:	00dd0533          	add	a0,s10,a3
42004b74:	0206ca63          	bltz	a3,42004ba8 <blkdev_write_partial_fallback+0x1c2>
42004b78:	03a56a63          	bltu	a0,s10,42004bac <blkdev_write_partial_fallback+0x1c6>
42004b7c:	8666                	mv	a2,s9
42004b7e:	85e2                	mv	a1,s8
42004b80:	fecfd0ef          	jal	4200236c <mem_copy>
        badge_err_set_ok(ec);
42004b84:	060b0363          	beqz	s6,42004bea <blkdev_write_partial_fallback+0x204>
42004b88:	003b7793          	and	a5,s6,3
42004b8c:	e3e1                	bnez	a5,42004c4c <blkdev_write_partial_fallback+0x266>
42004b8e:	57f1                	li	a5,-4
42004b90:	12fb7063          	bgeu	s6,a5,42004cb0 <blkdev_write_partial_fallback+0x2ca>
42004b94:	5942                	lw	s2,48(sp)
42004b96:	59b2                	lw	s3,44(sp)
42004b98:	000b2223          	sw	zero,4(s6)
42004b9c:	000b2023          	sw	zero,0(s6)
42004ba0:	bf81                	j	42004af0 <blkdev_write_partial_fallback+0x10a>
        flags[i].erase = false;
42004ba2:	f899f2e3          	bgeu	s3,s1,42004b26 <blkdev_write_partial_fallback+0x140>
42004ba6:	9002                	ebreak
        mem_copy(cache + i * dev->block_size + subblock_offset, writebuf, writebuf_len);
42004ba8:	fcad7ae3          	bgeu	s10,a0,42004b7c <blkdev_write_partial_fallback+0x196>
42004bac:	9002                	ebreak
        if (!flags[i].present) {
42004bae:	fb34f4e3          	bgeu	s1,s3,42004b56 <blkdev_write_partial_fallback+0x170>
42004bb2:	9002                	ebreak
        flags[i].dirty = false;
42004bb4:	f934f8e3          	bgeu	s1,s3,42004b44 <blkdev_write_partial_fallback+0x15e>
42004bb8:	9002                	ebreak
            flags[i].present     = true;
42004bba:	04095163          	bgez	s2,42004bfc <blkdev_write_partial_fallback+0x216>
42004bbe:	0534e163          	bltu	s1,s3,42004c00 <blkdev_write_partial_fallback+0x21a>
42004bc2:	4785                	li	a5,1
42004bc4:	00f98623          	sb	a5,12(s3)
            flags[i].update_time = time_us();
42004bc8:	02095763          	bgez	s2,42004bf6 <blkdev_write_partial_fallback+0x210>
42004bcc:	0334e763          	bltu	s1,s3,42004bfa <blkdev_write_partial_fallback+0x214>
42004bd0:	3990b0ef          	jal	42010768 <time_us>
42004bd4:	00a9a023          	sw	a0,0(s3)
42004bd8:	00b9a223          	sw	a1,4(s3)
            flags[i].index       = block;
42004bdc:	00095a63          	bgez	s2,42004bf0 <blkdev_write_partial_fallback+0x20a>
42004be0:	0134ea63          	bltu	s1,s3,42004bf4 <blkdev_write_partial_fallback+0x20e>
42004be4:	0149a423          	sw	s4,8(s3)
42004be8:	bfb5                	j	42004b64 <blkdev_write_partial_fallback+0x17e>
42004bea:	5942                	lw	s2,48(sp)
42004bec:	59b2                	lw	s3,44(sp)
42004bee:	b709                	j	42004af0 <blkdev_write_partial_fallback+0x10a>
42004bf0:	fe99fae3          	bgeu	s3,s1,42004be4 <blkdev_write_partial_fallback+0x1fe>
42004bf4:	9002                	ebreak
            flags[i].update_time = time_us();
42004bf6:	fc99fde3          	bgeu	s3,s1,42004bd0 <blkdev_write_partial_fallback+0x1ea>
42004bfa:	9002                	ebreak
            flags[i].present     = true;
42004bfc:	fc99f3e3          	bgeu	s3,s1,42004bc2 <blkdev_write_partial_fallback+0x1dc>
42004c00:	9002                	ebreak
            ec = &ec0;
42004c02:	8b0a                	mv	s6,sp
42004c04:	b575                	j	42004ab0 <blkdev_write_partial_fallback+0xca>
        mem_copy(tmp + subblock_offset, writebuf, writebuf_len);
42004c06:	eca479e3          	bgeu	s0,a0,42004ad8 <blkdev_write_partial_fallback+0xf2>
42004c0a:	d84a                	sw	s2,48(sp)
42004c0c:	d64e                	sw	s3,44(sp)
42004c0e:	9002                	ebreak
            badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42004c10:	ee0b00e3          	beqz	s6,42004af0 <blkdev_write_partial_fallback+0x10a>
42004c14:	420175b7          	lui	a1,0x42017
42004c18:	4699                	li	a3,6
42004c1a:	4639                	li	a2,14
42004c1c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42004c20:	4511                	li	a0,4
42004c22:	00000717          	auipc	a4,0x0
42004c26:	e74fe0ef          	jal	4200329a <logkf>
42004c2a:	003b7793          	and	a5,s6,3
42004c2e:	e3b5                	bnez	a5,42004c92 <blkdev_write_partial_fallback+0x2ac>
42004c30:	57f1                	li	a5,-4
42004c32:	04fb7d63          	bgeu	s6,a5,42004c8c <blkdev_write_partial_fallback+0x2a6>
42004c36:	47b9                	li	a5,14
42004c38:	00fb2223          	sw	a5,4(s6)
42004c3c:	4799                	li	a5,6
42004c3e:	00fb2023          	sw	a5,0(s6)
42004c42:	b57d                	j	42004af0 <blkdev_write_partial_fallback+0x10a>
42004c44:	d64e                	sw	s3,44(sp)
        if (flags[i].present && flags[i].index == block) {
42004c46:	9002                	ebreak
42004c48:	d64e                	sw	s3,44(sp)
42004c4a:	9002                	ebreak
        badge_err_set_ok(ec);
42004c4c:	9002                	ebreak
42004c4e:	dc22                	sw	s0,56(sp)
42004c50:	da26                	sw	s1,52(sp)
42004c52:	d84a                	sw	s2,48(sp)
42004c54:	d64e                	sw	s3,44(sp)
42004c56:	d452                	sw	s4,40(sp)
42004c58:	d05a                	sw	s6,32(sp)
42004c5a:	ce5e                	sw	s7,28(sp)
42004c5c:	cc62                	sw	s8,24(sp)
42004c5e:	c86a                	sw	s10,16(sp)
    uint8_t        *cache = dev->cache->block_cache;
42004c60:	9002                	ebreak
42004c62:	dc22                	sw	s0,56(sp)
42004c64:	da26                	sw	s1,52(sp)
42004c66:	d84a                	sw	s2,48(sp)
42004c68:	d64e                	sw	s3,44(sp)
42004c6a:	d452                	sw	s4,40(sp)
42004c6c:	d05a                	sw	s6,32(sp)
42004c6e:	ce5e                	sw	s7,28(sp)
42004c70:	cc62                	sw	s8,24(sp)
42004c72:	c86a                	sw	s10,16(sp)
42004c74:	9002                	ebreak
42004c76:	dc22                	sw	s0,56(sp)
42004c78:	da26                	sw	s1,52(sp)
42004c7a:	d84a                	sw	s2,48(sp)
42004c7c:	d64e                	sw	s3,44(sp)
42004c7e:	d452                	sw	s4,40(sp)
42004c80:	d05a                	sw	s6,32(sp)
42004c82:	ce5e                	sw	s7,28(sp)
42004c84:	cc62                	sw	s8,24(sp)
42004c86:	c86a                	sw	s10,16(sp)
42004c88:	9002                	ebreak
        flags[i].erase = false;
42004c8a:	9002                	ebreak
42004c8c:	d84a                	sw	s2,48(sp)
42004c8e:	d64e                	sw	s3,44(sp)
            badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42004c90:	9002                	ebreak
42004c92:	d84a                	sw	s2,48(sp)
42004c94:	d64e                	sw	s3,44(sp)
42004c96:	9002                	ebreak
42004c98:	d84a                	sw	s2,48(sp)
42004c9a:	d64e                	sw	s3,44(sp)
42004c9c:	d452                	sw	s4,40(sp)
42004c9e:	d05a                	sw	s6,32(sp)
42004ca0:	ce5e                	sw	s7,28(sp)
42004ca2:	cc62                	sw	s8,24(sp)
    blkdev_flags_t *flags = dev->cache->block_flags;
42004ca4:	9002                	ebreak
42004ca6:	d84a                	sw	s2,48(sp)
42004ca8:	d64e                	sw	s3,44(sp)
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
42004caa:	9002                	ebreak
        flags[i].erase = false;
42004cac:	9002                	ebreak
        flags[i].dirty = false;
42004cae:	9002                	ebreak
        badge_err_set_ok(ec);
42004cb0:	9002                	ebreak
42004cb2:	d84a                	sw	s2,48(sp)
42004cb4:	d64e                	sw	s3,44(sp)
        if (!badge_err_is_ok(ec)) {
42004cb6:	9002                	ebreak
    uint8_t        *cache = dev->cache->block_cache;
42004cb8:	9002                	ebreak
42004cba:	d64e                	sw	s3,44(sp)
        if (flags[i].present && flags[i].index == block) {
42004cbc:	9002                	ebreak

42004cbe <blkdev_read_partial_fallback>:
// Perform a read-modify-write operation for partial write.
// Made for block devices that don't support partial write.
void blkdev_read_partial_fallback(
    badge_err_t *ec, blkdev_t *dev, blksize_t block, size_t subblock_offset, uint8_t *readbuf, size_t readbuf_len
) {
    uint8_t        *cache = dev->cache->block_cache;
42004cbe:	26058f63          	beqz	a1,42004f3c <blkdev_read_partial_fallback+0x27e>
) {
42004cc2:	7139                	add	sp,sp,-64
42004cc4:	da26                	sw	s1,52(sp)
42004cc6:	d05a                	sw	s6,32(sp)
42004cc8:	de06                	sw	ra,60(sp)
42004cca:	8b3e                	mv	s6,a5
42004ccc:	dc22                	sw	s0,56(sp)
42004cce:	d84a                	sw	s2,48(sp)
42004cd0:	d64e                	sw	s3,44(sp)
42004cd2:	d452                	sw	s4,40(sp)
42004cd4:	d256                	sw	s5,36(sp)
42004cd6:	cc62                	sw	s8,24(sp)
42004cd8:	ca66                	sw	s9,20(sp)
42004cda:	c86a                	sw	s10,16(sp)
    uint8_t        *cache = dev->cache->block_cache;
42004cdc:	0035f793          	and	a5,a1,3
42004ce0:	84ae                	mv	s1,a1
42004ce2:	22079a63          	bnez	a5,42004f16 <blkdev_read_partial_fallback+0x258>
42004ce6:	5791                	li	a5,-28
42004ce8:	22f5f563          	bgeu	a1,a5,42004f12 <blkdev_read_partial_fallback+0x254>
42004cec:	01c5a803          	lw	a6,28(a1)
42004cf0:	22080763          	beqz	a6,42004f1e <blkdev_read_partial_fallback+0x260>
42004cf4:	00387793          	and	a5,a6,3
42004cf8:	22079363          	bnez	a5,42004f1e <blkdev_read_partial_fallback+0x260>
    blkdev_flags_t *flags = dev->cache->block_flags;
42004cfc:	57f1                	li	a5,-4
    uint8_t        *cache = dev->cache->block_cache;
42004cfe:	00082d03          	lw	s10,0(a6)
    blkdev_flags_t *flags = dev->cache->block_flags;
42004d02:	20f87c63          	bgeu	a6,a5,42004f1a <blkdev_read_partial_fallback+0x25c>
42004d06:	8c2a                	mv	s8,a0

    // Try to look up the block in the cache.
    ptrdiff_t i = blkdev_alloc_cache(dev, block);
42004d08:	85b2                	mv	a1,a2
42004d0a:	8526                	mv	a0,s1
    blkdev_flags_t *flags = dev->cache->block_flags;
42004d0c:	00482c83          	lw	s9,4(a6)
    ptrdiff_t i = blkdev_alloc_cache(dev, block);
42004d10:	89b2                	mv	s3,a2
42004d12:	8a36                	mv	s4,a3
42004d14:	8aba                	mv	s5,a4
42004d16:	8c9ff0ef          	jal	420045de <blkdev_alloc_cache>
42004d1a:	892a                	mv	s2,a0
    if (i >= 0 && flags[i].present) {
42004d1c:	14054663          	bltz	a0,42004e68 <blkdev_read_partial_fallback+0x1aa>
42004d20:	ce5e                	sw	s7,28(sp)
42004d22:	00451b93          	sll	s7,a0,0x4
42004d26:	017c8433          	add	s0,s9,s7
42004d2a:	0a0bdb63          	bgez	s7,42004de0 <blkdev_read_partial_fallback+0x122>
42004d2e:	0a8ceb63          	bltu	s9,s0,42004de4 <blkdev_read_partial_fallback+0x126>
42004d32:	1e040863          	beqz	s0,42004f22 <blkdev_read_partial_fallback+0x264>
42004d36:	00347793          	and	a5,s0,3
42004d3a:	1e079463          	bnez	a5,42004f22 <blkdev_read_partial_fallback+0x264>
42004d3e:	00c44783          	lbu	a5,12(s0)
42004d42:	4705                	li	a4,1
42004d44:	1ef76d63          	bltu	a4,a5,42004f3e <blkdev_read_partial_fallback+0x280>
42004d48:	8b85                	and	a5,a5,1
42004d4a:	efd1                	bnez	a5,42004de6 <blkdev_read_partial_fallback+0x128>
        badge_err_set_ok(ec);

    } else if (i >= 0) {
        // Empty cache entry found.
        badge_err_t ec0;
        if (!ec)
42004d4c:	180c0163          	beqz	s8,42004ece <blkdev_read_partial_fallback+0x210>
            ec = &ec0;
        // Create read cache regardless of read cache enable.
        blkdev_read_raw(ec, dev, block, cache + i * dev->block_offset);
42004d50:	449c                	lw	a5,8(s1)
42004d52:	02f907b3          	mul	a5,s2,a5
42004d56:	00fd06b3          	add	a3,s10,a5
42004d5a:	1007c463          	bltz	a5,42004e62 <blkdev_read_partial_fallback+0x1a4>
42004d5e:	11a6e463          	bltu	a3,s10,42004e66 <blkdev_read_partial_fallback+0x1a8>
42004d62:	864e                	mv	a2,s3
42004d64:	85a6                	mv	a1,s1
42004d66:	8562                	mv	a0,s8
42004d68:	a3fff0ef          	jal	420047a6 <blkdev_read_raw>
        flags[i] = (blkdev_flags_t){
42004d6c:	0e0bc863          	bltz	s7,42004e5c <blkdev_read_partial_fallback+0x19e>
42004d70:	0f946863          	bltu	s0,s9,42004e60 <blkdev_read_partial_fallback+0x1a2>
            .update_time = time_us(),
42004d74:	1f50b0ef          	jal	42010768 <time_us>
        flags[i] = (blkdev_flags_t){
42004d78:	c008                	sw	a0,0(s0)
42004d7a:	c04c                	sw	a1,4(s0)
42004d7c:	57e1                	li	a5,-8
42004d7e:	1af47463          	bgeu	s0,a5,42004f26 <blkdev_read_partial_fallback+0x268>
42004d82:	01342423          	sw	s3,8(s0)
42004d86:	57d1                	li	a5,-12
42004d88:	1af47063          	bgeu	s0,a5,42004f28 <blkdev_read_partial_fallback+0x26a>
42004d8c:	4785                	li	a5,1
42004d8e:	00f40623          	sb	a5,12(s0)
42004d92:	57cd                	li	a5,-13
42004d94:	18f47b63          	bgeu	s0,a5,42004f2a <blkdev_read_partial_fallback+0x26c>
42004d98:	000406a3          	sb	zero,13(s0)
42004d9c:	57c9                	li	a5,-14
42004d9e:	18f47363          	bgeu	s0,a5,42004f24 <blkdev_read_partial_fallback+0x266>
            .erase       = false,
            .dirty       = false,
        };

        // Partial copy.
        mem_copy(readbuf, cache + i * dev->block_offset + subblock_offset, readbuf_len);
42004da2:	449c                	lw	a5,8(s1)
        flags[i] = (blkdev_flags_t){
42004da4:	00040723          	sb	zero,14(s0)
        mem_copy(readbuf, cache + i * dev->block_offset + subblock_offset, readbuf_len);
42004da8:	02f90933          	mul	s2,s2,a5
42004dac:	014906b3          	add	a3,s2,s4
42004db0:	00dd05b3          	add	a1,s10,a3
42004db4:	0a06c163          	bltz	a3,42004e56 <blkdev_read_partial_fallback+0x198>
42004db8:	0ba5e163          	bltu	a1,s10,42004e5a <blkdev_read_partial_fallback+0x19c>
42004dbc:	865a                	mv	a2,s6
42004dbe:	8556                	mv	a0,s5
42004dc0:	dacfd0ef          	jal	4200236c <mem_copy>
42004dc4:	4bf2                	lw	s7,28(sp)
        }
        // Partial copy.
        mem_copy(readbuf, tmp + subblock_offset, readbuf_len);
        free(tmp);
    }
}
42004dc6:	50f2                	lw	ra,60(sp)
42004dc8:	5462                	lw	s0,56(sp)
42004dca:	54d2                	lw	s1,52(sp)
42004dcc:	5942                	lw	s2,48(sp)
42004dce:	59b2                	lw	s3,44(sp)
42004dd0:	5a22                	lw	s4,40(sp)
42004dd2:	5a92                	lw	s5,36(sp)
42004dd4:	5b02                	lw	s6,32(sp)
42004dd6:	4c62                	lw	s8,24(sp)
42004dd8:	4cd2                	lw	s9,20(sp)
42004dda:	4d42                	lw	s10,16(sp)
42004ddc:	6121                	add	sp,sp,64
42004dde:	8082                	ret
    if (i >= 0 && flags[i].present) {
42004de0:	f59479e3          	bgeu	s0,s9,42004d32 <blkdev_read_partial_fallback+0x74>
42004de4:	9002                	ebreak
        mem_copy(readbuf, cache + i * dev->block_size + subblock_offset, readbuf_len);
42004de6:	40dc                	lw	a5,4(s1)
42004de8:	02f907b3          	mul	a5,s2,a5
42004dec:	97d2                	add	a5,a5,s4
42004dee:	00fd05b3          	add	a1,s10,a5
42004df2:	0c07d663          	bgez	a5,42004ebe <blkdev_read_partial_fallback+0x200>
42004df6:	0cbd6663          	bltu	s10,a1,42004ec2 <blkdev_read_partial_fallback+0x204>
42004dfa:	865a                	mv	a2,s6
42004dfc:	8556                	mv	a0,s5
42004dfe:	d6efd0ef          	jal	4200236c <mem_copy>
        if (!blkdev_is_dirty(flags[i])) {
42004e02:	0a0bdb63          	bgez	s7,42004eb8 <blkdev_read_partial_fallback+0x1fa>
42004e06:	0a8ceb63          	bltu	s9,s0,42004ebc <blkdev_read_partial_fallback+0x1fe>
42004e0a:	4054                	lw	a3,4(s0)
42004e0c:	441c                	lw	a5,8(s0)
42004e0e:	4010                	lw	a2,0(s0)
42004e10:	4458                	lw	a4,12(s0)
42004e12:	c236                	sw	a3,4(sp)
42004e14:	c032                	sw	a2,0(sp)
42004e16:	c43e                	sw	a5,8(sp)
42004e18:	c63a                	sw	a4,12(sp)
42004e1a:	00c44783          	lbu	a5,12(s0)
    return flags.present && (flags.erase || flags.dirty);
42004e1e:	4685                	li	a3,1
42004e20:	10f6ef63          	bltu	a3,a5,42004f3e <blkdev_read_partial_fallback+0x280>
42004e24:	8b85                	and	a5,a5,1
42004e26:	e7c1                	bnez	a5,42004eae <blkdev_read_partial_fallback+0x1f0>
            flags[i].update_time = time_us();
42004e28:	0a0bc063          	bltz	s7,42004ec8 <blkdev_read_partial_fallback+0x20a>
42004e2c:	0b946063          	bltu	s0,s9,42004ecc <blkdev_read_partial_fallback+0x20e>
42004e30:	1390b0ef          	jal	42010768 <time_us>
42004e34:	c008                	sw	a0,0(s0)
42004e36:	c04c                	sw	a1,4(s0)
        badge_err_set_ok(ec);
42004e38:	0a0c0163          	beqz	s8,42004eda <blkdev_read_partial_fallback+0x21c>
42004e3c:	003c7793          	and	a5,s8,3
42004e40:	0e079963          	bnez	a5,42004f32 <blkdev_read_partial_fallback+0x274>
42004e44:	57f1                	li	a5,-4
42004e46:	0efc7563          	bgeu	s8,a5,42004f30 <blkdev_read_partial_fallback+0x272>
42004e4a:	4bf2                	lw	s7,28(sp)
42004e4c:	000c2223          	sw	zero,4(s8)
42004e50:	000c2023          	sw	zero,0(s8)
42004e54:	bf8d                	j	42004dc6 <blkdev_read_partial_fallback+0x108>
        mem_copy(readbuf, cache + i * dev->block_offset + subblock_offset, readbuf_len);
42004e56:	f6bd73e3          	bgeu	s10,a1,42004dbc <blkdev_read_partial_fallback+0xfe>
42004e5a:	9002                	ebreak
        flags[i] = (blkdev_flags_t){
42004e5c:	f08cfce3          	bgeu	s9,s0,42004d74 <blkdev_read_partial_fallback+0xb6>
42004e60:	9002                	ebreak
        blkdev_read_raw(ec, dev, block, cache + i * dev->block_offset);
42004e62:	f0dd70e3          	bgeu	s10,a3,42004d62 <blkdev_read_partial_fallback+0xa4>
42004e66:	9002                	ebreak
        uint8_t *tmp = malloc(dev->block_size);
42004e68:	40c8                	lw	a0,4(s1)
42004e6a:	2e7080ef          	jal	4200d950 <malloc>
42004e6e:	842a                	mv	s0,a0
        if (!tmp) {
42004e70:	c53d                	beqz	a0,42004ede <blkdev_read_partial_fallback+0x220>
        if (!ec)
42004e72:	040c0963          	beqz	s8,42004ec4 <blkdev_read_partial_fallback+0x206>
        blkdev_read_raw(ec, dev, block, tmp);
42004e76:	86a2                	mv	a3,s0
42004e78:	864e                	mv	a2,s3
42004e7a:	85a6                	mv	a1,s1
42004e7c:	8562                	mv	a0,s8
42004e7e:	929ff0ef          	jal	420047a6 <blkdev_read_raw>
        if (!badge_err_is_ok(ec)) {
42004e82:	0a0c0563          	beqz	s8,42004f2c <blkdev_read_partial_fallback+0x26e>
42004e86:	003c7793          	and	a5,s8,3
42004e8a:	e3cd                	bnez	a5,42004f2c <blkdev_read_partial_fallback+0x26e>
42004e8c:	000c2783          	lw	a5,0(s8)
42004e90:	eb99                	bnez	a5,42004ea6 <blkdev_read_partial_fallback+0x1e8>
        mem_copy(readbuf, tmp + subblock_offset, readbuf_len);
42004e92:	014405b3          	add	a1,s0,s4
42004e96:	020a4e63          	bltz	s4,42004ed2 <blkdev_read_partial_fallback+0x214>
42004e9a:	0285ee63          	bltu	a1,s0,42004ed6 <blkdev_read_partial_fallback+0x218>
42004e9e:	865a                	mv	a2,s6
42004ea0:	8556                	mv	a0,s5
42004ea2:	ccafd0ef          	jal	4200236c <mem_copy>
        free(tmp);
42004ea6:	8522                	mv	a0,s0
42004ea8:	4b5080ef          	jal	4200db5c <free>
42004eac:	bf29                	j	42004dc6 <blkdev_read_partial_fallback+0x108>
    return flags.present && (flags.erase || flags.dirty);
42004eae:	00871793          	sll	a5,a4,0x8
42004eb2:	83c1                	srl	a5,a5,0x10
42004eb4:	f3d1                	bnez	a5,42004e38 <blkdev_read_partial_fallback+0x17a>
42004eb6:	bf8d                	j	42004e28 <blkdev_read_partial_fallback+0x16a>
        if (!blkdev_is_dirty(flags[i])) {
42004eb8:	f59479e3          	bgeu	s0,s9,42004e0a <blkdev_read_partial_fallback+0x14c>
42004ebc:	9002                	ebreak
        mem_copy(readbuf, cache + i * dev->block_size + subblock_offset, readbuf_len);
42004ebe:	f3a5fee3          	bgeu	a1,s10,42004dfa <blkdev_read_partial_fallback+0x13c>
42004ec2:	9002                	ebreak
            ec = &ec0;
42004ec4:	8c0a                	mv	s8,sp
42004ec6:	bf45                	j	42004e76 <blkdev_read_partial_fallback+0x1b8>
            flags[i].update_time = time_us();
42004ec8:	f68cf4e3          	bgeu	s9,s0,42004e30 <blkdev_read_partial_fallback+0x172>
42004ecc:	9002                	ebreak
            ec = &ec0;
42004ece:	8c0a                	mv	s8,sp
42004ed0:	b541                	j	42004d50 <blkdev_read_partial_fallback+0x92>
        mem_copy(readbuf, tmp + subblock_offset, readbuf_len);
42004ed2:	fcb476e3          	bgeu	s0,a1,42004e9e <blkdev_read_partial_fallback+0x1e0>
42004ed6:	ce5e                	sw	s7,28(sp)
42004ed8:	9002                	ebreak
42004eda:	4bf2                	lw	s7,28(sp)
42004edc:	b5ed                	j	42004dc6 <blkdev_read_partial_fallback+0x108>
            badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42004ede:	ee0c04e3          	beqz	s8,42004dc6 <blkdev_read_partial_fallback+0x108>
42004ee2:	420175b7          	lui	a1,0x42017
42004ee6:	4699                	li	a3,6
42004ee8:	4639                	li	a2,14
42004eea:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42004eee:	4511                	li	a0,4
42004ef0:	00000717          	auipc	a4,0x0
42004ef4:	ba6fe0ef          	jal	4200329a <logkf>
42004ef8:	003c7793          	and	a5,s8,3
42004efc:	ef95                	bnez	a5,42004f38 <blkdev_read_partial_fallback+0x27a>
42004efe:	57f1                	li	a5,-4
42004f00:	02fc7a63          	bgeu	s8,a5,42004f34 <blkdev_read_partial_fallback+0x276>
42004f04:	47b9                	li	a5,14
42004f06:	00fc2223          	sw	a5,4(s8)
42004f0a:	4799                	li	a5,6
42004f0c:	00fc2023          	sw	a5,0(s8)
42004f10:	bd5d                	j	42004dc6 <blkdev_read_partial_fallback+0x108>
42004f12:	ce5e                	sw	s7,28(sp)
    uint8_t        *cache = dev->cache->block_cache;
42004f14:	9002                	ebreak
42004f16:	ce5e                	sw	s7,28(sp)
42004f18:	9002                	ebreak
42004f1a:	ce5e                	sw	s7,28(sp)
    blkdev_flags_t *flags = dev->cache->block_flags;
42004f1c:	9002                	ebreak
42004f1e:	ce5e                	sw	s7,28(sp)
    uint8_t        *cache = dev->cache->block_cache;
42004f20:	9002                	ebreak
    if (i >= 0 && flags[i].present) {
42004f22:	9002                	ebreak
        flags[i] = (blkdev_flags_t){
42004f24:	9002                	ebreak
42004f26:	9002                	ebreak
42004f28:	9002                	ebreak
42004f2a:	9002                	ebreak
42004f2c:	ce5e                	sw	s7,28(sp)
        if (!badge_err_is_ok(ec)) {
42004f2e:	9002                	ebreak
        badge_err_set_ok(ec);
42004f30:	9002                	ebreak
42004f32:	9002                	ebreak
42004f34:	ce5e                	sw	s7,28(sp)
            badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42004f36:	9002                	ebreak
42004f38:	ce5e                	sw	s7,28(sp)
42004f3a:	9002                	ebreak
    uint8_t        *cache = dev->cache->block_cache;
42004f3c:	9002                	ebreak
    if (i >= 0 && flags[i].present) {
42004f3e:	9002                	ebreak

42004f40 <blkdev_open>:



// Prepare a block device for reading and/or writing.
// For some block devices, this may allocate caches.
void blkdev_open(badge_err_t *ec, blkdev_t *dev) {
42004f40:	1141                	add	sp,sp,-16
42004f42:	c422                	sw	s0,8(sp)
42004f44:	c606                	sw	ra,12(sp)
42004f46:	842a                	mv	s0,a0
    if (!dev) {
42004f48:	c591                	beqz	a1,42004f54 <blkdev_open+0x14>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }
    switch (dev->type) {
42004f4a:	0035f713          	and	a4,a1,3
42004f4e:	e331                	bnez	a4,42004f92 <blkdev_open+0x52>
42004f50:	419c                	lw	a5,0(a1)
42004f52:	cb9d                	beqz	a5,42004f88 <blkdev_open+0x48>
        case BLKDEV_TYPE_RAM: return blkdev_ram_open(ec, dev);
        // case BLKDEV_TYPE_I2C_EEPROM: return blkdev_i2c_eeprom_open(ec, dev);
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
42004f54:	c415                	beqz	s0,42004f80 <blkdev_open+0x40>
42004f56:	420175b7          	lui	a1,0x42017
42004f5a:	4689                	li	a3,2
42004f5c:	4639                	li	a2,14
42004f5e:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42004f62:	4511                	li	a0,4
42004f64:	00000717          	auipc	a4,0x0
42004f68:	b32fe0ef          	jal	4200329a <logkf>
42004f6c:	00347793          	and	a5,s0,3
42004f70:	e38d                	bnez	a5,42004f92 <blkdev_open+0x52>
42004f72:	57f1                	li	a5,-4
42004f74:	00f47f63          	bgeu	s0,a5,42004f92 <blkdev_open+0x52>
42004f78:	47b9                	li	a5,14
42004f7a:	c05c                	sw	a5,4(s0)
42004f7c:	4789                	li	a5,2
42004f7e:	c01c                	sw	a5,0(s0)
    }
}
42004f80:	40b2                	lw	ra,12(sp)
42004f82:	4422                	lw	s0,8(sp)
42004f84:	0141                	add	sp,sp,16
42004f86:	8082                	ret
42004f88:	4422                	lw	s0,8(sp)
42004f8a:	40b2                	lw	ra,12(sp)
42004f8c:	0141                	add	sp,sp,16
        case BLKDEV_TYPE_RAM: return blkdev_ram_open(ec, dev);
42004f8e:	bc4ff06f          	j	42004352 <blkdev_ram_open>
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
42004f92:	9002                	ebreak

42004f94 <blkdev_is_erased>:


// Query the erased status of a block.
// On devices which cannot erase blocks, this will always return true.
// Returns true on error.
bool blkdev_is_erased(badge_err_t *ec, blkdev_t *dev, blksize_t block) {
42004f94:	1141                	add	sp,sp,-16
42004f96:	c422                	sw	s0,8(sp)
42004f98:	c606                	sw	ra,12(sp)
42004f9a:	842a                	mv	s0,a0
    if (!dev) {
42004f9c:	c5c1                	beqz	a1,42005024 <blkdev_is_erased+0x90>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return true;
    }
    if (dev->readonly) {
42004f9e:	0035f793          	and	a5,a1,3
42004fa2:	efd5                	bnez	a5,4200505e <blkdev_is_erased+0xca>
42004fa4:	0105c783          	lbu	a5,16(a1)
42004fa8:	4705                	li	a4,1
42004faa:	0af76a63          	bltu	a4,a5,4200505e <blkdev_is_erased+0xca>
42004fae:	8b85                	and	a5,a5,1
42004fb0:	ebdd                	bnez	a5,42005066 <blkdev_is_erased+0xd2>
    if (!dev->cache)
42004fb2:	5791                	li	a5,-28
42004fb4:	0af5f563          	bgeu	a1,a5,4200505e <blkdev_is_erased+0xca>
42004fb8:	4ddc                	lw	a5,28(a1)
42004fba:	c3bd                	beqz	a5,42005020 <blkdev_is_erased+0x8c>
    blkdev_flags_t *flags = dev->cache->block_flags;
42004fbc:	0037f713          	and	a4,a5,3
42004fc0:	ef59                	bnez	a4,4200505e <blkdev_is_erased+0xca>
42004fc2:	5771                	li	a4,-4
42004fc4:	08e7fd63          	bgeu	a5,a4,4200505e <blkdev_is_erased+0xca>
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
42004fc8:	5761                	li	a4,-8
    blkdev_flags_t *flags = dev->cache->block_flags;
42004fca:	0047a883          	lw	a7,4(a5)
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
42004fce:	08e7f863          	bgeu	a5,a4,4200505e <blkdev_is_erased+0xca>
42004fd2:	0087ae03          	lw	t3,8(a5)
42004fd6:	05c05563          	blez	t3,42005020 <blkdev_is_erased+0x8c>
42004fda:	87c6                	mv	a5,a7
42004fdc:	4681                	li	a3,0
        if (flags[i].present && flags[i].index == block) {
42004fde:	4e85                	li	t4,1
42004fe0:	5f61                	li	t5,-8
42004fe2:	00469813          	sll	a6,a3,0x4
42004fe6:	01088333          	add	t1,a7,a6
42004fea:	06084863          	bltz	a6,4200505a <blkdev_is_erased+0xc6>
42004fee:	07136863          	bltu	t1,a7,4200505e <blkdev_is_erased+0xca>
42004ff2:	c7b5                	beqz	a5,4200505e <blkdev_is_erased+0xca>
42004ff4:	0037f713          	and	a4,a5,3
42004ff8:	e33d                	bnez	a4,4200505e <blkdev_is_erased+0xca>
42004ffa:	00c7c703          	lbu	a4,12(a5)
42004ffe:	06eee063          	bltu	t4,a4,4200505e <blkdev_is_erased+0xca>
42005002:	8b05                	and	a4,a4,1
42005004:	cb11                	beqz	a4,42005018 <blkdev_is_erased+0x84>
42005006:	04084d63          	bltz	a6,42005060 <blkdev_is_erased+0xcc>
4200500a:	05136a63          	bltu	t1,a7,4200505e <blkdev_is_erased+0xca>
4200500e:	05e7f863          	bgeu	a5,t5,4200505e <blkdev_is_erased+0xca>
42005012:	4798                	lw	a4,8(a5)
42005014:	08e60163          	beq	a2,a4,42005096 <blkdev_is_erased+0x102>
    for (ptrdiff_t i = 0; i < (ptrdiff_t)dev->cache->cache_depth; i++) {
42005018:	0685                	add	a3,a3,1 # 80000001 <__stop_free_lpsram+0x2fffc001>
4200501a:	07c1                	add	a5,a5,16
4200501c:	fdc693e3          	bne	a3,t3,42004fe2 <blkdev_is_erased+0x4e>
    ptrdiff_t i = blkdev_find_cache(dev, block);
    if (i >= 0) {
        return dev->cache->block_flags[i].erase;
    }

    switch (dev->type) {
42005020:	419c                	lw	a5,0(a1)
42005022:	c3cd                	beqz	a5,420050c4 <blkdev_is_erased+0x130>
        case BLKDEV_TYPE_RAM: return blkdev_ram_is_erased(ec, dev, block);
        // case BLKDEV_TYPE_I2C_EEPROM: return blkdev_i2c_eeprom_is_erased(ec, dev, block);
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); return true;
42005024:	c415                	beqz	s0,42005050 <blkdev_is_erased+0xbc>
42005026:	420175b7          	lui	a1,0x42017
4200502a:	4689                	li	a3,2
4200502c:	4639                	li	a2,14
4200502e:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005032:	4511                	li	a0,4
42005034:	00000717          	auipc	a4,0x0
42005038:	a62fe0ef          	jal	4200329a <logkf>
4200503c:	00347793          	and	a5,s0,3
42005040:	ef99                	bnez	a5,4200505e <blkdev_is_erased+0xca>
42005042:	57f1                	li	a5,-4
42005044:	00f47d63          	bgeu	s0,a5,4200505e <blkdev_is_erased+0xca>
42005048:	47b9                	li	a5,14
4200504a:	c05c                	sw	a5,4(s0)
4200504c:	4789                	li	a5,2
4200504e:	c01c                	sw	a5,0(s0)
        return true;
42005050:	4505                	li	a0,1
    }
}
42005052:	40b2                	lw	ra,12(sp)
42005054:	4422                	lw	s0,8(sp)
42005056:	0141                	add	sp,sp,16
42005058:	8082                	ret
        if (flags[i].present && flags[i].index == block) {
4200505a:	f868fce3          	bgeu	a7,t1,42004ff2 <blkdev_is_erased+0x5e>
        return dev->cache->block_flags[i].erase;
4200505e:	9002                	ebreak
        if (flags[i].present && flags[i].index == block) {
42005060:	fa68f7e3          	bgeu	a7,t1,4200500e <blkdev_is_erased+0x7a>
        return dev->cache->block_flags[i].erase;
42005064:	9002                	ebreak
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
42005066:	d56d                	beqz	a0,42005050 <blkdev_is_erased+0xbc>
42005068:	420175b7          	lui	a1,0x42017
4200506c:	46dd                	li	a3,23
4200506e:	4639                	li	a2,14
42005070:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005074:	4511                	li	a0,4
42005076:	00000717          	auipc	a4,0x0
4200507a:	a20fe0ef          	jal	4200329a <logkf>
4200507e:	00347793          	and	a5,s0,3
42005082:	fff1                	bnez	a5,4200505e <blkdev_is_erased+0xca>
42005084:	57f1                	li	a5,-4
42005086:	fcf47ce3          	bgeu	s0,a5,4200505e <blkdev_is_erased+0xca>
4200508a:	47b9                	li	a5,14
4200508c:	c05c                	sw	a5,4(s0)
4200508e:	47dd                	li	a5,23
42005090:	c01c                	sw	a5,0(s0)
        return true;
42005092:	4505                	li	a0,1
42005094:	bf7d                	j	42005052 <blkdev_is_erased+0xbe>
        return dev->cache->block_flags[i].erase;
42005096:	010887b3          	add	a5,a7,a6
4200509a:	02085263          	bgez	a6,420050be <blkdev_is_erased+0x12a>
4200509e:	fcf8e0e3          	bltu	a7,a5,4200505e <blkdev_is_erased+0xca>
420050a2:	dfd5                	beqz	a5,4200505e <blkdev_is_erased+0xca>
420050a4:	0037f713          	and	a4,a5,3
420050a8:	fb5d                	bnez	a4,4200505e <blkdev_is_erased+0xca>
420050aa:	00d7c503          	lbu	a0,13(a5)
420050ae:	4785                	li	a5,1
420050b0:	faa7e7e3          	bltu	a5,a0,4200505e <blkdev_is_erased+0xca>
}
420050b4:	40b2                	lw	ra,12(sp)
420050b6:	4422                	lw	s0,8(sp)
        return dev->cache->block_flags[i].erase;
420050b8:	8905                	and	a0,a0,1
}
420050ba:	0141                	add	sp,sp,16
420050bc:	8082                	ret
        return dev->cache->block_flags[i].erase;
420050be:	ff17f2e3          	bgeu	a5,a7,420050a2 <blkdev_is_erased+0x10e>
420050c2:	9002                	ebreak
        case BLKDEV_TYPE_RAM: return blkdev_ram_is_erased(ec, dev, block);
420050c4:	8522                	mv	a0,s0
}
420050c6:	4422                	lw	s0,8(sp)
420050c8:	40b2                	lw	ra,12(sp)
420050ca:	0141                	add	sp,sp,16
        case BLKDEV_TYPE_RAM: return blkdev_ram_is_erased(ec, dev, block);
420050cc:	abaff06f          	j	42004386 <blkdev_ram_is_erased>

420050d0 <blkdev_erase>:

// Explicitly erase a block, if possible.
// On devices which cannot erase blocks, this will do nothing.
void blkdev_erase(badge_err_t *ec, blkdev_t *dev, blksize_t block) {
420050d0:	1101                	add	sp,sp,-32
420050d2:	ca26                	sw	s1,20(sp)
420050d4:	ce06                	sw	ra,28(sp)
420050d6:	84aa                	mv	s1,a0
    if (!dev) {
420050d8:	12058863          	beqz	a1,42005208 <blkdev_erase+0x138>
420050dc:	cc22                	sw	s0,24(sp)
420050de:	c84a                	sw	s2,16(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }
    if (dev->readonly) {
420050e0:	0035f793          	and	a5,a1,3
420050e4:	842e                	mv	s0,a1
420050e6:	1a079363          	bnez	a5,4200528c <blkdev_erase+0x1bc>
420050ea:	0105c783          	lbu	a5,16(a1)
420050ee:	4705                	li	a4,1
420050f0:	18f76e63          	bltu	a4,a5,4200528c <blkdev_erase+0x1bc>
420050f4:	0017f913          	and	s2,a5,1
420050f8:	0a091463          	bnez	s2,420051a0 <blkdev_erase+0xd0>
420050fc:	c64e                	sw	s3,12(sp)
420050fe:	c452                	sw	s4,8(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
        return;
    }

    blkdev_flags_t *flags = dev->cache->block_flags;
42005100:	5791                	li	a5,-28
42005102:	08f5fe63          	bgeu	a1,a5,4200519e <blkdev_erase+0xce>
42005106:	4ddc                	lw	a5,28(a1)
42005108:	cbd9                	beqz	a5,4200519e <blkdev_erase+0xce>
4200510a:	0037f713          	and	a4,a5,3
4200510e:	eb41                	bnez	a4,4200519e <blkdev_erase+0xce>
42005110:	5771                	li	a4,-4
42005112:	08e7f663          	bgeu	a5,a4,4200519e <blkdev_erase+0xce>

    // Attempt to cache erase operation.
    ptrdiff_t i = blkdev_alloc_cache(dev, block);
42005116:	85b2                	mv	a1,a2
42005118:	8522                	mv	a0,s0
    blkdev_flags_t *flags = dev->cache->block_flags;
4200511a:	0047aa03          	lw	s4,4(a5)
    ptrdiff_t i = blkdev_alloc_cache(dev, block);
4200511e:	89b2                	mv	s3,a2
42005120:	cbeff0ef          	jal	420045de <blkdev_alloc_cache>
    if (i >= 0) {
42005124:	0a054a63          	bltz	a0,420051d8 <blkdev_erase+0x108>
        if (flags[i].present) {
42005128:	0512                	sll	a0,a0,0x4
4200512a:	00aa0433          	add	s0,s4,a0
4200512e:	06054663          	bltz	a0,4200519a <blkdev_erase+0xca>
42005132:	07446663          	bltu	s0,s4,4200519e <blkdev_erase+0xce>
42005136:	c425                	beqz	s0,4200519e <blkdev_erase+0xce>
42005138:	00347793          	and	a5,s0,3
4200513c:	e3ad                	bnez	a5,4200519e <blkdev_erase+0xce>
4200513e:	00c44783          	lbu	a5,12(s0)
42005142:	4705                	li	a4,1
42005144:	04f76d63          	bltu	a4,a5,4200519e <blkdev_erase+0xce>
42005148:	8b85                	and	a5,a5,1
4200514a:	c7f5                	beqz	a5,42005236 <blkdev_erase+0x166>
            // Set flag in existing cache entry.
            flags[i].erase = true;
4200514c:	0a055263          	bgez	a0,420051f0 <blkdev_erase+0x120>
42005150:	048a6763          	bltu	s4,s0,4200519e <blkdev_erase+0xce>
42005154:	57cd                	li	a5,-13
42005156:	04f47463          	bgeu	s0,a5,4200519e <blkdev_erase+0xce>
4200515a:	4785                	li	a5,1
4200515c:	00f406a3          	sb	a5,13(s0)
            flags[i].dirty = false;
42005160:	08055b63          	bgez	a0,420051f6 <blkdev_erase+0x126>
42005164:	028a6d63          	bltu	s4,s0,4200519e <blkdev_erase+0xce>
42005168:	57c9                	li	a5,-14
4200516a:	02f47a63          	bgeu	s0,a5,4200519e <blkdev_erase+0xce>
4200516e:	01240723          	sb	s2,14(s0)
                .present     = true,
                .erase       = false,
                .dirty       = true,
            };
        }
        badge_err_set_ok(ec);
42005172:	10048263          	beqz	s1,42005276 <blkdev_erase+0x1a6>
42005176:	0034f793          	and	a5,s1,3
4200517a:	e395                	bnez	a5,4200519e <blkdev_erase+0xce>
4200517c:	57f1                	li	a5,-4
4200517e:	02f4f063          	bgeu	s1,a5,4200519e <blkdev_erase+0xce>
42005182:	4462                	lw	s0,24(sp)
42005184:	4942                	lw	s2,16(sp)
42005186:	49b2                	lw	s3,12(sp)
42005188:	4a22                	lw	s4,8(sp)
4200518a:	0004a223          	sw	zero,4(s1)
4200518e:	0004a023          	sw	zero,0(s1)

    } else {
        // Uncached or out of free cache.
        blkdev_erase_raw(ec, dev, block);
    }
}
42005192:	40f2                	lw	ra,28(sp)
42005194:	44d2                	lw	s1,20(sp)
42005196:	6105                	add	sp,sp,32
42005198:	8082                	ret
        if (flags[i].present) {
4200519a:	f88a7ee3          	bgeu	s4,s0,42005136 <blkdev_erase+0x66>
        badge_err_set_ok(ec);
4200519e:	9002                	ebreak
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
420051a0:	cd31                	beqz	a0,420051fc <blkdev_erase+0x12c>
420051a2:	420175b7          	lui	a1,0x42017
420051a6:	46dd                	li	a3,23
420051a8:	4639                	li	a2,14
420051aa:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420051ae:	4511                	li	a0,4
420051b0:	00000717          	auipc	a4,0x0
420051b4:	8e6fe0ef          	jal	4200329a <logkf>
420051b8:	0034f793          	and	a5,s1,3
420051bc:	ebf9                	bnez	a5,42005292 <blkdev_erase+0x1c2>
420051be:	57f1                	li	a5,-4
420051c0:	0cf4f963          	bgeu	s1,a5,42005292 <blkdev_erase+0x1c2>
420051c4:	4462                	lw	s0,24(sp)
}
420051c6:	40f2                	lw	ra,28(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
420051c8:	47b9                	li	a5,14
420051ca:	c0dc                	sw	a5,4(s1)
420051cc:	47dd                	li	a5,23
420051ce:	c09c                	sw	a5,0(s1)
420051d0:	4942                	lw	s2,16(sp)
}
420051d2:	44d2                	lw	s1,20(sp)
420051d4:	6105                	add	sp,sp,32
420051d6:	8082                	ret
        blkdev_erase_raw(ec, dev, block);
420051d8:	85a2                	mv	a1,s0
420051da:	4462                	lw	s0,24(sp)
420051dc:	4942                	lw	s2,16(sp)
420051de:	4a22                	lw	s4,8(sp)
}
420051e0:	40f2                	lw	ra,28(sp)
        blkdev_erase_raw(ec, dev, block);
420051e2:	864e                	mv	a2,s3
420051e4:	8526                	mv	a0,s1
420051e6:	49b2                	lw	s3,12(sp)
}
420051e8:	44d2                	lw	s1,20(sp)
420051ea:	6105                	add	sp,sp,32
        blkdev_erase_raw(ec, dev, block);
420051ec:	e0aff06f          	j	420047f6 <blkdev_erase_raw>
            flags[i].erase = true;
420051f0:	f74472e3          	bgeu	s0,s4,42005154 <blkdev_erase+0x84>
        badge_err_set_ok(ec);
420051f4:	9002                	ebreak
            flags[i].dirty = false;
420051f6:	f74479e3          	bgeu	s0,s4,42005168 <blkdev_erase+0x98>
        badge_err_set_ok(ec);
420051fa:	9002                	ebreak
420051fc:	4462                	lw	s0,24(sp)
}
420051fe:	40f2                	lw	ra,28(sp)
42005200:	4942                	lw	s2,16(sp)
42005202:	44d2                	lw	s1,20(sp)
42005204:	6105                	add	sp,sp,32
42005206:	8082                	ret
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005208:	d549                	beqz	a0,42005192 <blkdev_erase+0xc2>
4200520a:	420175b7          	lui	a1,0x42017
4200520e:	4689                	li	a3,2
42005210:	4639                	li	a2,14
42005212:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005216:	4511                	li	a0,4
42005218:	00000717          	auipc	a4,0x0
4200521c:	87efe0ef          	jal	4200329a <logkf>
42005220:	0034f793          	and	a5,s1,3
42005224:	ebb5                	bnez	a5,42005298 <blkdev_erase+0x1c8>
42005226:	57f1                	li	a5,-4
42005228:	06f4f863          	bgeu	s1,a5,42005298 <blkdev_erase+0x1c8>
4200522c:	47b9                	li	a5,14
4200522e:	c0dc                	sw	a5,4(s1)
42005230:	4789                	li	a5,2
42005232:	c09c                	sw	a5,0(s1)
42005234:	bfb9                	j	42005192 <blkdev_erase+0xc2>
            flags[i] = (blkdev_flags_t){
42005236:	04054863          	bltz	a0,42005286 <blkdev_erase+0x1b6>
4200523a:	f74462e3          	bltu	s0,s4,4200519e <blkdev_erase+0xce>
                .update_time = time_us(),
4200523e:	52a0b0ef          	jal	42010768 <time_us>
            flags[i] = (blkdev_flags_t){
42005242:	c008                	sw	a0,0(s0)
42005244:	c04c                	sw	a1,4(s0)
42005246:	57e1                	li	a5,-8
42005248:	f4f47be3          	bgeu	s0,a5,4200519e <blkdev_erase+0xce>
4200524c:	01342423          	sw	s3,8(s0)
42005250:	57d1                	li	a5,-12
42005252:	f4f476e3          	bgeu	s0,a5,4200519e <blkdev_erase+0xce>
42005256:	4785                	li	a5,1
42005258:	00f40623          	sb	a5,12(s0)
4200525c:	57cd                	li	a5,-13
4200525e:	f4f470e3          	bgeu	s0,a5,4200519e <blkdev_erase+0xce>
42005262:	000406a3          	sb	zero,13(s0)
42005266:	57c9                	li	a5,-14
42005268:	4905                	li	s2,1
4200526a:	f2f47ae3          	bgeu	s0,a5,4200519e <blkdev_erase+0xce>
            flags[i].dirty = false;
4200526e:	01240723          	sb	s2,14(s0)
        badge_err_set_ok(ec);
42005272:	f00492e3          	bnez	s1,42005176 <blkdev_erase+0xa6>
42005276:	4462                	lw	s0,24(sp)
}
42005278:	40f2                	lw	ra,28(sp)
4200527a:	4942                	lw	s2,16(sp)
4200527c:	49b2                	lw	s3,12(sp)
4200527e:	4a22                	lw	s4,8(sp)
42005280:	44d2                	lw	s1,20(sp)
42005282:	6105                	add	sp,sp,32
42005284:	8082                	ret
            flags[i] = (blkdev_flags_t){
42005286:	fa8a7ce3          	bgeu	s4,s0,4200523e <blkdev_erase+0x16e>
        badge_err_set_ok(ec);
4200528a:	9002                	ebreak
4200528c:	c64e                	sw	s3,12(sp)
4200528e:	c452                	sw	s4,8(sp)
42005290:	9002                	ebreak
42005292:	c64e                	sw	s3,12(sp)
42005294:	c452                	sw	s4,8(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
42005296:	9002                	ebreak
42005298:	cc22                	sw	s0,24(sp)
4200529a:	c84a                	sw	s2,16(sp)
4200529c:	c64e                	sw	s3,12(sp)
4200529e:	c452                	sw	s4,8(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
420052a0:	9002                	ebreak

420052a2 <blkdev_write>:

// Erase if necessary and write a block.
// This operation may be cached and therefor delayed.
void blkdev_write(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t const *writebuf) {
420052a2:	7179                	add	sp,sp,-48
420052a4:	c85a                	sw	s6,16(sp)
420052a6:	d606                	sw	ra,44(sp)
420052a8:	8b2a                	mv	s6,a0
    if (!dev) {
420052aa:	16058663          	beqz	a1,42005416 <blkdev_write+0x174>
420052ae:	d422                	sw	s0,40(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }
    if (dev->readonly) {
420052b0:	0035f793          	and	a5,a1,3
420052b4:	842e                	mv	s0,a1
420052b6:	1c079863          	bnez	a5,42005486 <blkdev_write+0x1e4>
420052ba:	0105c783          	lbu	a5,16(a1)
420052be:	4705                	li	a4,1
420052c0:	1cf76363          	bltu	a4,a5,42005486 <blkdev_write+0x1e4>
420052c4:	8b85                	and	a5,a5,1
420052c6:	e3ed                	bnez	a5,420053a8 <blkdev_write+0x106>
420052c8:	d04a                	sw	s2,32(sp)
420052ca:	ce4e                	sw	s3,28(sp)
420052cc:	cc52                	sw	s4,24(sp)
420052ce:	ca56                	sw	s5,20(sp)
420052d0:	c65e                	sw	s7,12(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
        return;
    }

    uint8_t        *cache = dev->cache->block_cache;
420052d2:	5791                	li	a5,-28
420052d4:	1af5f663          	bgeu	a1,a5,42005480 <blkdev_write+0x1de>
420052d8:	4ddc                	lw	a5,28(a1)
420052da:	1a078363          	beqz	a5,42005480 <blkdev_write+0x1de>
420052de:	0037f713          	and	a4,a5,3
420052e2:	18071f63          	bnez	a4,42005480 <blkdev_write+0x1de>
    blkdev_flags_t *flags = dev->cache->block_flags;
420052e6:	5771                	li	a4,-4
    uint8_t        *cache = dev->cache->block_cache;
420052e8:	0007ab83          	lw	s7,0(a5)
    blkdev_flags_t *flags = dev->cache->block_flags;
420052ec:	18e7fa63          	bgeu	a5,a4,42005480 <blkdev_write+0x1de>

    // Attempt to cache write operation.
    ptrdiff_t i = blkdev_alloc_cache(dev, block);
420052f0:	85b2                	mv	a1,a2
420052f2:	8522                	mv	a0,s0
    blkdev_flags_t *flags = dev->cache->block_flags;
420052f4:	0047a983          	lw	s3,4(a5)
    ptrdiff_t i = blkdev_alloc_cache(dev, block);
420052f8:	8a32                	mv	s4,a2
420052fa:	8ab6                	mv	s5,a3
420052fc:	ae2ff0ef          	jal	420045de <blkdev_alloc_cache>
42005300:	892a                	mv	s2,a0
    if (i >= 0) {
42005302:	0e054063          	bltz	a0,420053e2 <blkdev_write+0x140>
42005306:	d226                	sw	s1,36(sp)
        if (flags[i].present) {
42005308:	00451713          	sll	a4,a0,0x4
4200530c:	00e984b3          	add	s1,s3,a4
42005310:	08074963          	bltz	a4,420053a2 <blkdev_write+0x100>
42005314:	0934e663          	bltu	s1,s3,420053a0 <blkdev_write+0xfe>
42005318:	c4c1                	beqz	s1,420053a0 <blkdev_write+0xfe>
4200531a:	0034f793          	and	a5,s1,3
4200531e:	e3c9                	bnez	a5,420053a0 <blkdev_write+0xfe>
42005320:	00c4c783          	lbu	a5,12(s1)
42005324:	4685                	li	a3,1
42005326:	06f6ed63          	bltu	a3,a5,420053a0 <blkdev_write+0xfe>
4200532a:	8b85                	and	a5,a5,1
4200532c:	10078e63          	beqz	a5,42005448 <blkdev_write+0x1a6>
            // Set flag in existing cache entry.
            flags[i].erase = false;
42005330:	0c075b63          	bgez	a4,42005406 <blkdev_write+0x164>
42005334:	0699e663          	bltu	s3,s1,420053a0 <blkdev_write+0xfe>
42005338:	57cd                	li	a5,-13
4200533a:	06f4f363          	bgeu	s1,a5,420053a0 <blkdev_write+0xfe>
4200533e:	000486a3          	sb	zero,13(s1)
            flags[i].dirty = true;
42005342:	0a075f63          	bgez	a4,42005400 <blkdev_write+0x15e>
42005346:	0499ed63          	bltu	s3,s1,420053a0 <blkdev_write+0xfe>
        } else {
            // Set flag in new cache entry.
            flags[i] = (blkdev_flags_t){
4200534a:	57c9                	li	a5,-14
4200534c:	04f4fa63          	bgeu	s1,a5,420053a0 <blkdev_write+0xfe>
                .present     = true,
                .erase       = false,
                .dirty       = true,
            };
        }
        mem_copy(cache + i * dev->block_size, writebuf, dev->block_size);
42005350:	4050                	lw	a2,4(s0)
            flags[i].dirty = true;
42005352:	4785                	li	a5,1
42005354:	00f48723          	sb	a5,14(s1)
        mem_copy(cache + i * dev->block_size, writebuf, dev->block_size);
42005358:	02c90933          	mul	s2,s2,a2
4200535c:	012b8533          	add	a0,s7,s2
42005360:	02094e63          	bltz	s2,4200539c <blkdev_write+0xfa>
42005364:	03756e63          	bltu	a0,s7,420053a0 <blkdev_write+0xfe>
42005368:	85d6                	mv	a1,s5
4200536a:	802fd0ef          	jal	4200236c <mem_copy>
        badge_err_set_ok(ec);
4200536e:	000b0c63          	beqz	s6,42005386 <blkdev_write+0xe4>
42005372:	003b7793          	and	a5,s6,3
42005376:	e78d                	bnez	a5,420053a0 <blkdev_write+0xfe>
42005378:	57f1                	li	a5,-4
4200537a:	02fb7363          	bgeu	s6,a5,420053a0 <blkdev_write+0xfe>
4200537e:	000b2223          	sw	zero,4(s6)
42005382:	000b2023          	sw	zero,0(s6)
42005386:	5422                	lw	s0,40(sp)
42005388:	5492                	lw	s1,36(sp)
4200538a:	5902                	lw	s2,32(sp)
4200538c:	49f2                	lw	s3,28(sp)
4200538e:	4a62                	lw	s4,24(sp)
42005390:	4ad2                	lw	s5,20(sp)
42005392:	4bb2                	lw	s7,12(sp)

    } else {
        // Uncached or out of free cache.
        blkdev_write_raw(ec, dev, block, writebuf);
    }
}
42005394:	50b2                	lw	ra,44(sp)
42005396:	4b42                	lw	s6,16(sp)
42005398:	6145                	add	sp,sp,48
4200539a:	8082                	ret
        mem_copy(cache + i * dev->block_size, writebuf, dev->block_size);
4200539c:	fcabf6e3          	bgeu	s7,a0,42005368 <blkdev_write+0xc6>
        badge_err_set_ok(ec);
420053a0:	9002                	ebreak
        if (flags[i].present) {
420053a2:	f699fbe3          	bgeu	s3,s1,42005318 <blkdev_write+0x76>
        badge_err_set_ok(ec);
420053a6:	9002                	ebreak
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
420053a8:	c135                	beqz	a0,4200540c <blkdev_write+0x16a>
420053aa:	420175b7          	lui	a1,0x42017
420053ae:	46dd                	li	a3,23
420053b0:	4639                	li	a2,14
420053b2:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420053b6:	4511                	li	a0,4
420053b8:	00000717          	auipc	a4,0x0
420053bc:	edffd0ef          	jal	4200329a <logkf>
420053c0:	003b7793          	and	a5,s6,3
420053c4:	ebe1                	bnez	a5,42005494 <blkdev_write+0x1f2>
420053c6:	57f1                	li	a5,-4
420053c8:	0cfb7663          	bgeu	s6,a5,42005494 <blkdev_write+0x1f2>
420053cc:	5422                	lw	s0,40(sp)
}
420053ce:	50b2                	lw	ra,44(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
420053d0:	47b9                	li	a5,14
420053d2:	00fb2223          	sw	a5,4(s6)
420053d6:	47dd                	li	a5,23
420053d8:	00fb2023          	sw	a5,0(s6)
}
420053dc:	4b42                	lw	s6,16(sp)
420053de:	6145                	add	sp,sp,48
420053e0:	8082                	ret
        blkdev_write_raw(ec, dev, block, writebuf);
420053e2:	85a2                	mv	a1,s0
420053e4:	5422                	lw	s0,40(sp)
420053e6:	5902                	lw	s2,32(sp)
420053e8:	49f2                	lw	s3,28(sp)
420053ea:	4bb2                	lw	s7,12(sp)
}
420053ec:	50b2                	lw	ra,44(sp)
        blkdev_write_raw(ec, dev, block, writebuf);
420053ee:	86d6                	mv	a3,s5
420053f0:	8652                	mv	a2,s4
420053f2:	4ad2                	lw	s5,20(sp)
420053f4:	4a62                	lw	s4,24(sp)
420053f6:	855a                	mv	a0,s6
}
420053f8:	4b42                	lw	s6,16(sp)
420053fa:	6145                	add	sp,sp,48
        blkdev_write_raw(ec, dev, block, writebuf);
420053fc:	b5aff06f          	j	42004756 <blkdev_write_raw>
            flags[i].dirty = true;
42005400:	f534f5e3          	bgeu	s1,s3,4200534a <blkdev_write+0xa8>
        badge_err_set_ok(ec);
42005404:	9002                	ebreak
            flags[i].erase = false;
42005406:	f334f9e3          	bgeu	s1,s3,42005338 <blkdev_write+0x96>
        badge_err_set_ok(ec);
4200540a:	9002                	ebreak
4200540c:	5422                	lw	s0,40(sp)
}
4200540e:	50b2                	lw	ra,44(sp)
42005410:	4b42                	lw	s6,16(sp)
42005412:	6145                	add	sp,sp,48
42005414:	8082                	ret
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005416:	dd3d                	beqz	a0,42005394 <blkdev_write+0xf2>
42005418:	420175b7          	lui	a1,0x42017
4200541c:	4689                	li	a3,2
4200541e:	4639                	li	a2,14
42005420:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005424:	4511                	li	a0,4
42005426:	00000717          	auipc	a4,0x0
4200542a:	e71fd0ef          	jal	4200329a <logkf>
4200542e:	003b7793          	and	a5,s6,3
42005432:	eba9                	bnez	a5,42005484 <blkdev_write+0x1e2>
42005434:	57f1                	li	a5,-4
42005436:	04fb7763          	bgeu	s6,a5,42005484 <blkdev_write+0x1e2>
4200543a:	47b9                	li	a5,14
4200543c:	00fb2223          	sw	a5,4(s6)
42005440:	4789                	li	a5,2
42005442:	00fb2023          	sw	a5,0(s6)
42005446:	b7b9                	j	42005394 <blkdev_write+0xf2>
            flags[i] = (blkdev_flags_t){
42005448:	02074963          	bltz	a4,4200547a <blkdev_write+0x1d8>
4200544c:	f534eae3          	bltu	s1,s3,420053a0 <blkdev_write+0xfe>
                .update_time = time_us(),
42005450:	3180b0ef          	jal	42010768 <time_us>
            flags[i] = (blkdev_flags_t){
42005454:	c088                	sw	a0,0(s1)
42005456:	c0cc                	sw	a1,4(s1)
42005458:	57e1                	li	a5,-8
4200545a:	f4f4f3e3          	bgeu	s1,a5,420053a0 <blkdev_write+0xfe>
4200545e:	0144a423          	sw	s4,8(s1)
42005462:	57d1                	li	a5,-12
42005464:	f2f4fee3          	bgeu	s1,a5,420053a0 <blkdev_write+0xfe>
42005468:	4785                	li	a5,1
4200546a:	00f48623          	sb	a5,12(s1)
4200546e:	57cd                	li	a5,-13
42005470:	f2f4f8e3          	bgeu	s1,a5,420053a0 <blkdev_write+0xfe>
42005474:	000486a3          	sb	zero,13(s1)
42005478:	bdc9                	j	4200534a <blkdev_write+0xa8>
4200547a:	fc99fbe3          	bgeu	s3,s1,42005450 <blkdev_write+0x1ae>
        badge_err_set_ok(ec);
4200547e:	9002                	ebreak
42005480:	d226                	sw	s1,36(sp)
    blkdev_flags_t *flags = dev->cache->block_flags;
42005482:	9002                	ebreak
42005484:	d422                	sw	s0,40(sp)
42005486:	d226                	sw	s1,36(sp)
42005488:	d04a                	sw	s2,32(sp)
4200548a:	ce4e                	sw	s3,28(sp)
4200548c:	cc52                	sw	s4,24(sp)
4200548e:	ca56                	sw	s5,20(sp)
42005490:	c65e                	sw	s7,12(sp)
        badge_err_set_ok(ec);
42005492:	9002                	ebreak
42005494:	d226                	sw	s1,36(sp)
42005496:	d04a                	sw	s2,32(sp)
42005498:	ce4e                	sw	s3,28(sp)
4200549a:	cc52                	sw	s4,24(sp)
4200549c:	ca56                	sw	s5,20(sp)
4200549e:	c65e                	sw	s7,12(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
420054a0:	9002                	ebreak

420054a2 <blkdev_read>:

// Read a block.
// This operation may be cached.
void blkdev_read(badge_err_t *ec, blkdev_t *dev, blksize_t block, uint8_t *readbuf) {
420054a2:	7139                	add	sp,sp,-64
420054a4:	d84a                	sw	s2,48(sp)
420054a6:	de06                	sw	ra,60(sp)
420054a8:	892a                	mv	s2,a0
    if (!dev) {
420054aa:	1c058763          	beqz	a1,42005678 <blkdev_read+0x1d6>
420054ae:	dc22                	sw	s0,56(sp)
420054b0:	d64e                	sw	s3,44(sp)
420054b2:	d256                	sw	s5,36(sp)
420054b4:	d05a                	sw	s6,32(sp)
420054b6:	ce5e                	sw	s7,28(sp)
420054b8:	cc62                	sw	s8,24(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }

    uint8_t        *cache = dev->cache->block_cache;
420054ba:	0035f793          	and	a5,a1,3
420054be:	842e                	mv	s0,a1
420054c0:	20079a63          	bnez	a5,420056d4 <blkdev_read+0x232>
420054c4:	5791                	li	a5,-28
420054c6:	20f5f763          	bgeu	a1,a5,420056d4 <blkdev_read+0x232>
420054ca:	4ddc                	lw	a5,28(a1)
420054cc:	20078463          	beqz	a5,420056d4 <blkdev_read+0x232>
420054d0:	0037f713          	and	a4,a5,3
420054d4:	20071063          	bnez	a4,420056d4 <blkdev_read+0x232>
    blkdev_flags_t *flags = dev->cache->block_flags;
420054d8:	5771                	li	a4,-4
    uint8_t        *cache = dev->cache->block_cache;
420054da:	0007ab03          	lw	s6,0(a5)
    blkdev_flags_t *flags = dev->cache->block_flags;
420054de:	1ee7fb63          	bgeu	a5,a4,420056d4 <blkdev_read+0x232>

    // Look for the entry in the cache.
    ptrdiff_t i = blkdev_alloc_cache(dev, block);
420054e2:	85b2                	mv	a1,a2
420054e4:	8522                	mv	a0,s0
    blkdev_flags_t *flags = dev->cache->block_flags;
420054e6:	0047ac03          	lw	s8,4(a5)
    ptrdiff_t i = blkdev_alloc_cache(dev, block);
420054ea:	8bb2                	mv	s7,a2
420054ec:	8ab6                	mv	s5,a3
420054ee:	8f0ff0ef          	jal	420045de <blkdev_alloc_cache>
420054f2:	89aa                	mv	s3,a0
    if (i >= 0 && flags[i].present) {
420054f4:	14054163          	bltz	a0,42005636 <blkdev_read+0x194>
420054f8:	da26                	sw	s1,52(sp)
420054fa:	d452                	sw	s4,40(sp)
420054fc:	00451a13          	sll	s4,a0,0x4
42005500:	014c04b3          	add	s1,s8,s4
42005504:	120a5463          	bgez	s4,4200562c <blkdev_read+0x18a>
42005508:	129c6463          	bltu	s8,s1,42005630 <blkdev_read+0x18e>
4200550c:	12048263          	beqz	s1,42005630 <blkdev_read+0x18e>
42005510:	0034f793          	and	a5,s1,3
42005514:	10079e63          	bnez	a5,42005630 <blkdev_read+0x18e>
42005518:	00c4c783          	lbu	a5,12(s1)
4200551c:	4705                	li	a4,1
4200551e:	10f76963          	bltu	a4,a5,42005630 <blkdev_read+0x18e>
42005522:	8b85                	and	a5,a5,1
42005524:	ebd1                	bnez	a5,420055b8 <blkdev_read+0x116>
            }
            mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
        }
        badge_err_set_ok(ec);

    } else if (i >= 0 && dev->cache_read) {
42005526:	01844783          	lbu	a5,24(s0)
4200552a:	10f76363          	bltu	a4,a5,42005630 <blkdev_read+0x18e>
4200552e:	8b85                	and	a5,a5,1
42005530:	10078163          	beqz	a5,42005632 <blkdev_read+0x190>
        // Read caching is enabled.
        badge_err_t ec0;
        if (!ec)
42005534:	18090e63          	beqz	s2,420056d0 <blkdev_read+0x22e>
            ec = &ec0;
        blkdev_read_raw(ec, dev, block, cache + i * dev->block_size);
42005538:	405c                	lw	a5,4(s0)
4200553a:	02f987b3          	mul	a5,s3,a5
4200553e:	00fb06b3          	add	a3,s6,a5
42005542:	1607c763          	bltz	a5,420056b0 <blkdev_read+0x20e>
42005546:	0f66e563          	bltu	a3,s6,42005630 <blkdev_read+0x18e>
4200554a:	865e                	mv	a2,s7
4200554c:	85a2                	mv	a1,s0
4200554e:	854a                	mv	a0,s2
42005550:	a56ff0ef          	jal	420047a6 <blkdev_read_raw>

        flags[i] = (blkdev_flags_t){
42005554:	140a4b63          	bltz	s4,420056aa <blkdev_read+0x208>
42005558:	0d84ec63          	bltu	s1,s8,42005630 <blkdev_read+0x18e>
            .update_time = time_us(),
4200555c:	20c0b0ef          	jal	42010768 <time_us>
        flags[i] = (blkdev_flags_t){
42005560:	c088                	sw	a0,0(s1)
42005562:	c0cc                	sw	a1,4(s1)
42005564:	57e1                	li	a5,-8
42005566:	0cf4f563          	bgeu	s1,a5,42005630 <blkdev_read+0x18e>
4200556a:	0174a423          	sw	s7,8(s1)
4200556e:	57d1                	li	a5,-12
42005570:	0cf4f063          	bgeu	s1,a5,42005630 <blkdev_read+0x18e>
42005574:	4785                	li	a5,1
42005576:	00f48623          	sb	a5,12(s1)
4200557a:	57cd                	li	a5,-13
4200557c:	0af4fa63          	bgeu	s1,a5,42005630 <blkdev_read+0x18e>
42005580:	000486a3          	sb	zero,13(s1)
42005584:	57c9                	li	a5,-14
42005586:	0af4f563          	bgeu	s1,a5,42005630 <blkdev_read+0x18e>
4200558a:	00048723          	sb	zero,14(s1)
            .present     = true,
            .erase       = false,
            .dirty       = false,
        };

        if (!badge_err_is_ok(ec))
4200558e:	0a090163          	beqz	s2,42005630 <blkdev_read+0x18e>
42005592:	00397793          	and	a5,s2,3
42005596:	efc9                	bnez	a5,42005630 <blkdev_read+0x18e>
42005598:	00092783          	lw	a5,0(s2)
4200559c:	efa5                	bnez	a5,42005614 <blkdev_read+0x172>
            return;
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
4200559e:	4050                	lw	a2,4(s0)
420055a0:	02c989b3          	mul	s3,s3,a2
420055a4:	013b05b3          	add	a1,s6,s3
420055a8:	1009de63          	bgez	s3,420056c4 <blkdev_read+0x222>
420055ac:	08bb6263          	bltu	s6,a1,42005630 <blkdev_read+0x18e>
420055b0:	8556                	mv	a0,s5
420055b2:	dbbfc0ef          	jal	4200236c <mem_copy>
420055b6:	a8b9                	j	42005614 <blkdev_read+0x172>
        if (flags[i].erase) {
420055b8:	080a5e63          	bgez	s4,42005654 <blkdev_read+0x1b2>
420055bc:	069c6a63          	bltu	s8,s1,42005630 <blkdev_read+0x18e>
420055c0:	00d4c783          	lbu	a5,13(s1)
420055c4:	4705                	li	a4,1
420055c6:	06f76563          	bltu	a4,a5,42005630 <blkdev_read+0x18e>
420055ca:	8b85                	and	a5,a5,1
420055cc:	e7ed                	bnez	a5,420056b6 <blkdev_read+0x214>
            if (!flags[i].dirty) {
420055ce:	080a5963          	bgez	s4,42005660 <blkdev_read+0x1be>
420055d2:	049c6f63          	bltu	s8,s1,42005630 <blkdev_read+0x18e>
420055d6:	00e4c783          	lbu	a5,14(s1)
420055da:	4705                	li	a4,1
420055dc:	04f76a63          	bltu	a4,a5,42005630 <blkdev_read+0x18e>
420055e0:	8b85                	and	a5,a5,1
420055e2:	c3d1                	beqz	a5,42005666 <blkdev_read+0x1c4>
            mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
420055e4:	4050                	lw	a2,4(s0)
420055e6:	02c989b3          	mul	s3,s3,a2
420055ea:	013b05b3          	add	a1,s6,s3
420055ee:	0609d663          	bgez	s3,4200565a <blkdev_read+0x1b8>
420055f2:	02bb6f63          	bltu	s6,a1,42005630 <blkdev_read+0x18e>
420055f6:	8556                	mv	a0,s5
420055f8:	d75fc0ef          	jal	4200236c <mem_copy>
        badge_err_set_ok(ec);
420055fc:	00090c63          	beqz	s2,42005614 <blkdev_read+0x172>
42005600:	00397793          	and	a5,s2,3
42005604:	e795                	bnez	a5,42005630 <blkdev_read+0x18e>
42005606:	57f1                	li	a5,-4
42005608:	02f97463          	bgeu	s2,a5,42005630 <blkdev_read+0x18e>
4200560c:	00092223          	sw	zero,4(s2)
42005610:	00092023          	sw	zero,0(s2)
42005614:	5462                	lw	s0,56(sp)
42005616:	54d2                	lw	s1,52(sp)
42005618:	59b2                	lw	s3,44(sp)
4200561a:	5a22                	lw	s4,40(sp)
4200561c:	5a92                	lw	s5,36(sp)
4200561e:	5b02                	lw	s6,32(sp)
42005620:	4bf2                	lw	s7,28(sp)
42005622:	4c62                	lw	s8,24(sp)
    } else {
        // Uncached or out of free cache.
        blkdev_read_raw(ec, dev, block, readbuf);
    }
}
42005624:	50f2                	lw	ra,60(sp)
42005626:	5942                	lw	s2,48(sp)
42005628:	6121                	add	sp,sp,64
4200562a:	8082                	ret
    if (i >= 0 && flags[i].present) {
4200562c:	ef84f0e3          	bgeu	s1,s8,4200550c <blkdev_read+0x6a>
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
42005630:	9002                	ebreak
42005632:	54d2                	lw	s1,52(sp)
42005634:	5a22                	lw	s4,40(sp)
        blkdev_read_raw(ec, dev, block, readbuf);
42005636:	85a2                	mv	a1,s0
42005638:	5462                	lw	s0,56(sp)
4200563a:	59b2                	lw	s3,44(sp)
4200563c:	5b02                	lw	s6,32(sp)
4200563e:	4c62                	lw	s8,24(sp)
}
42005640:	50f2                	lw	ra,60(sp)
        blkdev_read_raw(ec, dev, block, readbuf);
42005642:	86d6                	mv	a3,s5
42005644:	865e                	mv	a2,s7
42005646:	5a92                	lw	s5,36(sp)
42005648:	4bf2                	lw	s7,28(sp)
4200564a:	854a                	mv	a0,s2
}
4200564c:	5942                	lw	s2,48(sp)
4200564e:	6121                	add	sp,sp,64
        blkdev_read_raw(ec, dev, block, readbuf);
42005650:	956ff06f          	j	420047a6 <blkdev_read_raw>
        if (flags[i].erase) {
42005654:	f784f6e3          	bgeu	s1,s8,420055c0 <blkdev_read+0x11e>
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
42005658:	9002                	ebreak
            mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
4200565a:	f965fee3          	bgeu	a1,s6,420055f6 <blkdev_read+0x154>
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
4200565e:	9002                	ebreak
            if (!flags[i].dirty) {
42005660:	f784fbe3          	bgeu	s1,s8,420055d6 <blkdev_read+0x134>
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
42005664:	9002                	ebreak
                flags[i].update_time = time_us();
42005666:	060a5263          	bgez	s4,420056ca <blkdev_read+0x228>
4200566a:	fc9c63e3          	bltu	s8,s1,42005630 <blkdev_read+0x18e>
4200566e:	0fa0b0ef          	jal	42010768 <time_us>
42005672:	c088                	sw	a0,0(s1)
42005674:	c0cc                	sw	a1,4(s1)
42005676:	b7bd                	j	420055e4 <blkdev_read+0x142>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005678:	d555                	beqz	a0,42005624 <blkdev_read+0x182>
4200567a:	420175b7          	lui	a1,0x42017
4200567e:	4689                	li	a3,2
42005680:	4639                	li	a2,14
42005682:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005686:	4511                	li	a0,4
42005688:	00000717          	auipc	a4,0x0
4200568c:	c0ffd0ef          	jal	4200329a <logkf>
42005690:	00397793          	and	a5,s2,3
42005694:	e3b9                	bnez	a5,420056da <blkdev_read+0x238>
42005696:	57f1                	li	a5,-4
42005698:	04f97163          	bgeu	s2,a5,420056da <blkdev_read+0x238>
4200569c:	47b9                	li	a5,14
4200569e:	00f92223          	sw	a5,4(s2)
420056a2:	4789                	li	a5,2
420056a4:	00f92023          	sw	a5,0(s2)
420056a8:	bfb5                	j	42005624 <blkdev_read+0x182>
        flags[i] = (blkdev_flags_t){
420056aa:	ea9c79e3          	bgeu	s8,s1,4200555c <blkdev_read+0xba>
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
420056ae:	9002                	ebreak
        blkdev_read_raw(ec, dev, block, cache + i * dev->block_size);
420056b0:	e8db7de3          	bgeu	s6,a3,4200554a <blkdev_read+0xa8>
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
420056b4:	9002                	ebreak
            mem_set(readbuf, 255, dev->block_size);
420056b6:	4050                	lw	a2,4(s0)
420056b8:	0ff00593          	li	a1,255
420056bc:	8556                	mv	a0,s5
420056be:	98efd0ef          	jal	4200284c <mem_set>
420056c2:	bf2d                	j	420055fc <blkdev_read+0x15a>
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
420056c4:	ef65f6e3          	bgeu	a1,s6,420055b0 <blkdev_read+0x10e>
420056c8:	9002                	ebreak
                flags[i].update_time = time_us();
420056ca:	fb84f2e3          	bgeu	s1,s8,4200566e <blkdev_read+0x1cc>
        mem_copy(readbuf, cache + i * dev->block_size, dev->block_size);
420056ce:	9002                	ebreak
            ec = &ec0;
420056d0:	890a                	mv	s2,sp
420056d2:	b59d                	j	42005538 <blkdev_read+0x96>
420056d4:	da26                	sw	s1,52(sp)
420056d6:	d452                	sw	s4,40(sp)
    blkdev_flags_t *flags = dev->cache->block_flags;
420056d8:	9002                	ebreak
420056da:	dc22                	sw	s0,56(sp)
420056dc:	da26                	sw	s1,52(sp)
420056de:	d64e                	sw	s3,44(sp)
420056e0:	d452                	sw	s4,40(sp)
420056e2:	d256                	sw	s5,36(sp)
420056e4:	d05a                	sw	s6,32(sp)
420056e6:	ce5e                	sw	s7,28(sp)
420056e8:	cc62                	sw	s8,24(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
420056ea:	9002                	ebreak

420056ec <blkdev_write_partial>:
    blkdev_t      *dev,
    blksize_t      block,
    size_t         subblock_offset,
    uint8_t const *writebuf,
    size_t         writebuf_len
) {
420056ec:	1141                	add	sp,sp,-16
420056ee:	c422                	sw	s0,8(sp)
420056f0:	c606                	sw	ra,12(sp)
420056f2:	842a                	mv	s0,a0
    if (!dev) {
420056f4:	c99d                	beqz	a1,4200572a <blkdev_write_partial+0x3e>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }
    if (dev->readonly) {
420056f6:	0035f513          	and	a0,a1,3
420056fa:	0e051b63          	bnez	a0,420057f0 <blkdev_write_partial+0x104>
420056fe:	0105c503          	lbu	a0,16(a1)
42005702:	4805                	li	a6,1
42005704:	0ea86663          	bltu	a6,a0,420057f0 <blkdev_write_partial+0x104>
42005708:	8905                	and	a0,a0,1
4200570a:	e541                	bnez	a0,42005792 <blkdev_write_partial+0xa6>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
        return;
    }

    // Perform some bounds checking.
    if (writebuf_len == 0) {
4200570c:	cfcd                	beqz	a5,420057c6 <blkdev_write_partial+0xda>
        badge_err_set_ok(ec);
        return;
    }
    if (subblock_offset >= dev->block_size || writebuf_len > dev->block_size ||
4200570e:	5571                	li	a0,-4
42005710:	0ea5f063          	bgeu	a1,a0,420057f0 <blkdev_write_partial+0x104>
42005714:	41c8                	lw	a0,4(a1)
42005716:	04a6f463          	bgeu	a3,a0,4200575e <blkdev_write_partial+0x72>
4200571a:	04f56263          	bltu	a0,a5,4200575e <blkdev_write_partial+0x72>
        subblock_offset + writebuf_len > dev->block_size) {
4200571e:	00d78833          	add	a6,a5,a3
    if (subblock_offset >= dev->block_size || writebuf_len > dev->block_size ||
42005722:	03056e63          	bltu	a0,a6,4200575e <blkdev_write_partial+0x72>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
        return;
    }

    switch (dev->type) {
42005726:	4188                	lw	a0,0(a1)
42005728:	cd55                	beqz	a0,420057e4 <blkdev_write_partial+0xf8>
        case BLKDEV_TYPE_RAM: return blkdev_ram_write_partial(ec, dev, block, subblock_offset, writebuf, writebuf_len);
        // case BLKDEV_TYPE_I2C_EEPROM:
        //     return blkdev_i2c_eeprom_write_partial(ec, dev, block, subblock_offset, writebuf, writebuf_len);
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
4200572a:	c415                	beqz	s0,42005756 <blkdev_write_partial+0x6a>
4200572c:	420175b7          	lui	a1,0x42017
42005730:	4689                	li	a3,2
42005732:	4639                	li	a2,14
42005734:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005738:	4511                	li	a0,4
4200573a:	00000717          	auipc	a4,0x0
4200573e:	b5dfd0ef          	jal	4200329a <logkf>
42005742:	00347793          	and	a5,s0,3
42005746:	e7cd                	bnez	a5,420057f0 <blkdev_write_partial+0x104>
42005748:	57f1                	li	a5,-4
4200574a:	0af47363          	bgeu	s0,a5,420057f0 <blkdev_write_partial+0x104>
4200574e:	47b9                	li	a5,14
42005750:	c05c                	sw	a5,4(s0)
42005752:	4789                	li	a5,2
42005754:	c01c                	sw	a5,0(s0)
    }
}
42005756:	40b2                	lw	ra,12(sp)
42005758:	4422                	lw	s0,8(sp)
4200575a:	0141                	add	sp,sp,16
4200575c:	8082                	ret
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
4200575e:	dc65                	beqz	s0,42005756 <blkdev_write_partial+0x6a>
42005760:	420175b7          	lui	a1,0x42017
42005764:	468d                	li	a3,3
42005766:	4639                	li	a2,14
42005768:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200576c:	4511                	li	a0,4
4200576e:	00000717          	auipc	a4,0x0
42005772:	b29fd0ef          	jal	4200329a <logkf>
42005776:	00347793          	and	a5,s0,3
4200577a:	ebbd                	bnez	a5,420057f0 <blkdev_write_partial+0x104>
4200577c:	57f1                	li	a5,-4
4200577e:	06f47963          	bgeu	s0,a5,420057f0 <blkdev_write_partial+0x104>
42005782:	47b9                	li	a5,14
42005784:	c05c                	sw	a5,4(s0)
42005786:	478d                	li	a5,3
}
42005788:	40b2                	lw	ra,12(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
4200578a:	c01c                	sw	a5,0(s0)
}
4200578c:	4422                	lw	s0,8(sp)
4200578e:	0141                	add	sp,sp,16
42005790:	8082                	ret
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
42005792:	d071                	beqz	s0,42005756 <blkdev_write_partial+0x6a>
42005794:	420175b7          	lui	a1,0x42017
42005798:	46dd                	li	a3,23
4200579a:	4639                	li	a2,14
4200579c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420057a0:	4511                	li	a0,4
420057a2:	00000717          	auipc	a4,0x0
420057a6:	af5fd0ef          	jal	4200329a <logkf>
420057aa:	00347793          	and	a5,s0,3
420057ae:	e3a9                	bnez	a5,420057f0 <blkdev_write_partial+0x104>
420057b0:	57f1                	li	a5,-4
420057b2:	02f47f63          	bgeu	s0,a5,420057f0 <blkdev_write_partial+0x104>
420057b6:	47b9                	li	a5,14
420057b8:	c05c                	sw	a5,4(s0)
420057ba:	47dd                	li	a5,23
}
420057bc:	40b2                	lw	ra,12(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
420057be:	c01c                	sw	a5,0(s0)
}
420057c0:	4422                	lw	s0,8(sp)
420057c2:	0141                	add	sp,sp,16
420057c4:	8082                	ret
        badge_err_set_ok(ec);
420057c6:	d841                	beqz	s0,42005756 <blkdev_write_partial+0x6a>
420057c8:	00347793          	and	a5,s0,3
420057cc:	e395                	bnez	a5,420057f0 <blkdev_write_partial+0x104>
420057ce:	57f1                	li	a5,-4
420057d0:	02f47063          	bgeu	s0,a5,420057f0 <blkdev_write_partial+0x104>
}
420057d4:	40b2                	lw	ra,12(sp)
        badge_err_set_ok(ec);
420057d6:	00042223          	sw	zero,4(s0)
420057da:	00042023          	sw	zero,0(s0)
}
420057de:	4422                	lw	s0,8(sp)
420057e0:	0141                	add	sp,sp,16
420057e2:	8082                	ret
    blksize_t      block,
    size_t         subblock_offset,
    uint8_t const *writebuf,
    size_t         writebuf_len
) {
    blkdev_write_partial_fallback(ec, dev, block, subblock_offset, writebuf, writebuf_len);
420057e4:	8522                	mv	a0,s0
420057e6:	4422                	lw	s0,8(sp)
420057e8:	40b2                	lw	ra,12(sp)
420057ea:	0141                	add	sp,sp,16
420057ec:	9faff06f          	j	420049e6 <blkdev_write_partial_fallback>
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
420057f0:	9002                	ebreak

420057f2 <blkdev_read_partial>:

// Partially read a block.
// This may use read caching if the device doesn't support partial read.
void blkdev_read_partial(
    badge_err_t *ec, blkdev_t *dev, blksize_t block, size_t subblock_offset, uint8_t *readbuf, size_t readbuf_len
) {
420057f2:	1141                	add	sp,sp,-16
420057f4:	c422                	sw	s0,8(sp)
420057f6:	c606                	sw	ra,12(sp)
420057f8:	842a                	mv	s0,a0
    if (!dev) {
420057fa:	c5b5                	beqz	a1,42005866 <blkdev_read_partial+0x74>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }

    // Perform some bounds checking.
    if (readbuf_len == 0) {
420057fc:	cfd9                	beqz	a5,4200589a <blkdev_read_partial+0xa8>
        badge_err_set_ok(ec);
        return;
    }
    if (subblock_offset >= dev->block_size || readbuf_len > dev->block_size ||
420057fe:	0035fe13          	and	t3,a1,3
42005802:	0a0e1b63          	bnez	t3,420058b8 <blkdev_read_partial+0xc6>
42005806:	5e71                	li	t3,-4
42005808:	0bc5f863          	bgeu	a1,t3,420058b8 <blkdev_read_partial+0xc6>
4200580c:	0045ae03          	lw	t3,4(a1)
42005810:	03c6f163          	bgeu	a3,t3,42005832 <blkdev_read_partial+0x40>
42005814:	00fe6f63          	bltu	t3,a5,42005832 <blkdev_read_partial+0x40>
        subblock_offset + readbuf_len > dev->block_size) {
42005818:	00d788b3          	add	a7,a5,a3
    if (subblock_offset >= dev->block_size || readbuf_len > dev->block_size ||
4200581c:	011e6b63          	bltu	t3,a7,42005832 <blkdev_read_partial+0x40>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
        return;
    }

    switch (dev->type) {
42005820:	0005a803          	lw	a6,0(a1)
42005824:	04081163          	bnez	a6,42005866 <blkdev_read_partial+0x74>
        case BLKDEV_TYPE_RAM: return blkdev_ram_read_partial(ec, dev, block, subblock_offset, readbuf, readbuf_len);
        // case BLKDEV_TYPE_I2C_EEPROM:
        //     return blkdev_i2c_eeprom_read_partial(ec, dev, block, subblock_offset, readbuf, readbuf_len);
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
    }
}
42005828:	4422                	lw	s0,8(sp)
4200582a:	40b2                	lw	ra,12(sp)
4200582c:	0141                	add	sp,sp,16
// Partially read a block.
// This may use read caching if the device doesn't support partial read.
static inline void blkdev_ram_read_partial(
    badge_err_t *ec, blkdev_t *dev, blksize_t block, size_t subblock_offset, uint8_t *readbuf, size_t readbuf_len
) {
    blkdev_read_partial_fallback(ec, dev, block, subblock_offset, readbuf, readbuf_len);
4200582e:	c90ff06f          	j	42004cbe <blkdev_read_partial_fallback>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_RANGE);
42005832:	c415                	beqz	s0,4200585e <blkdev_read_partial+0x6c>
42005834:	420175b7          	lui	a1,0x42017
42005838:	468d                	li	a3,3
4200583a:	4639                	li	a2,14
4200583c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005840:	4511                	li	a0,4
42005842:	00000717          	auipc	a4,0x0
42005846:	a55fd0ef          	jal	4200329a <logkf>
4200584a:	00347793          	and	a5,s0,3
4200584e:	e7ad                	bnez	a5,420058b8 <blkdev_read_partial+0xc6>
42005850:	57f1                	li	a5,-4
42005852:	06f47363          	bgeu	s0,a5,420058b8 <blkdev_read_partial+0xc6>
42005856:	47b9                	li	a5,14
42005858:	c05c                	sw	a5,4(s0)
4200585a:	478d                	li	a5,3
4200585c:	c01c                	sw	a5,0(s0)
}
4200585e:	40b2                	lw	ra,12(sp)
42005860:	4422                	lw	s0,8(sp)
42005862:	0141                	add	sp,sp,16
42005864:	8082                	ret
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
42005866:	dc65                	beqz	s0,4200585e <blkdev_read_partial+0x6c>
42005868:	420175b7          	lui	a1,0x42017
4200586c:	4689                	li	a3,2
4200586e:	4639                	li	a2,14
42005870:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005874:	4511                	li	a0,4
42005876:	00000717          	auipc	a4,0x0
4200587a:	a21fd0ef          	jal	4200329a <logkf>
4200587e:	00347793          	and	a5,s0,3
42005882:	eb9d                	bnez	a5,420058b8 <blkdev_read_partial+0xc6>
42005884:	57f1                	li	a5,-4
42005886:	02f47963          	bgeu	s0,a5,420058b8 <blkdev_read_partial+0xc6>
4200588a:	47b9                	li	a5,14
4200588c:	c05c                	sw	a5,4(s0)
4200588e:	4789                	li	a5,2
}
42005890:	40b2                	lw	ra,12(sp)
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
42005892:	c01c                	sw	a5,0(s0)
}
42005894:	4422                	lw	s0,8(sp)
42005896:	0141                	add	sp,sp,16
42005898:	8082                	ret
        badge_err_set_ok(ec);
4200589a:	d171                	beqz	a0,4200585e <blkdev_read_partial+0x6c>
4200589c:	00357793          	and	a5,a0,3
420058a0:	ef81                	bnez	a5,420058b8 <blkdev_read_partial+0xc6>
420058a2:	57f1                	li	a5,-4
420058a4:	00f57a63          	bgeu	a0,a5,420058b8 <blkdev_read_partial+0xc6>
}
420058a8:	40b2                	lw	ra,12(sp)
420058aa:	4422                	lw	s0,8(sp)
        badge_err_set_ok(ec);
420058ac:	00052223          	sw	zero,4(a0)
420058b0:	00052023          	sw	zero,0(a0)
}
420058b4:	0141                	add	sp,sp,16
420058b6:	8082                	ret
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
420058b8:	9002                	ebreak

420058ba <blkdev_flush>:



// Flush the write cache to the block device.
void blkdev_flush(badge_err_t *ec, blkdev_t *dev) {
420058ba:	1101                	add	sp,sp,-32
420058bc:	cc22                	sw	s0,24(sp)
420058be:	ce06                	sw	ra,28(sp)
420058c0:	842a                	mv	s0,a0
    if (!dev) {
420058c2:	c9f9                	beqz	a1,42005998 <blkdev_flush+0xde>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }
    if (dev->readonly) {
420058c4:	0035f793          	and	a5,a1,3
420058c8:	ebc1                	bnez	a5,42005958 <blkdev_flush+0x9e>
420058ca:	0105c783          	lbu	a5,16(a1)
420058ce:	4705                	li	a4,1
420058d0:	08f76463          	bltu	a4,a5,42005958 <blkdev_flush+0x9e>
420058d4:	8b85                	and	a5,a5,1
420058d6:	e7c9                	bnez	a5,42005960 <blkdev_flush+0xa6>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
        return;
    }

    blkdev_flags_t *flags = dev->cache->block_flags;
420058d8:	5791                	li	a5,-28
420058da:	06f5ff63          	bgeu	a1,a5,42005958 <blkdev_flush+0x9e>
420058de:	4ddc                	lw	a5,28(a1)
420058e0:	cfa5                	beqz	a5,42005958 <blkdev_flush+0x9e>
420058e2:	0037f713          	and	a4,a5,3
420058e6:	eb2d                	bnez	a4,42005958 <blkdev_flush+0x9e>
420058e8:	5771                	li	a4,-4
420058ea:	06e7f763          	bgeu	a5,a4,42005958 <blkdev_flush+0x9e>
420058ee:	0047a803          	lw	a6,4(a5)

    badge_err_t ec0;
    if (!ec)
420058f2:	c14d                	beqz	a0,42005994 <blkdev_flush+0xda>
        ec = &ec0;

    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
420058f4:	5761                	li	a4,-8
420058f6:	06e7f163          	bgeu	a5,a4,42005958 <blkdev_flush+0x9e>
420058fa:	0087a303          	lw	t1,8(a5)
420058fe:	04030763          	beqz	t1,4200594c <blkdev_flush+0x92>
42005902:	87c2                	mv	a5,a6
42005904:	4601                	li	a2,0
        if (flags[i].present && (flags[i].dirty || flags[i].erase)) {
42005906:	4e05                	li	t3,1
42005908:	5551                	li	a0,-12
4200590a:	00461693          	sll	a3,a2,0x4
4200590e:	00d808b3          	add	a7,a6,a3
42005912:	0406c163          	bltz	a3,42005954 <blkdev_flush+0x9a>
42005916:	0508e163          	bltu	a7,a6,42005958 <blkdev_flush+0x9e>
4200591a:	cf9d                	beqz	a5,42005958 <blkdev_flush+0x9e>
4200591c:	0037f713          	and	a4,a5,3
42005920:	ef05                	bnez	a4,42005958 <blkdev_flush+0x9e>
42005922:	00c7c703          	lbu	a4,12(a5)
42005926:	02ee6963          	bltu	t3,a4,42005958 <blkdev_flush+0x9e>
4200592a:	8b05                	and	a4,a4,1
4200592c:	cf01                	beqz	a4,42005944 <blkdev_flush+0x8a>
4200592e:	0206c663          	bltz	a3,4200595a <blkdev_flush+0xa0>
42005932:	0308e363          	bltu	a7,a6,42005958 <blkdev_flush+0x9e>
42005936:	02a7f163          	bgeu	a5,a0,42005958 <blkdev_flush+0x9e>
4200593a:	47d8                	lw	a4,12(a5)
4200593c:	00871693          	sll	a3,a4,0x8
42005940:	82c1                	srl	a3,a3,0x10
42005942:	e2d1                	bnez	a3,420059c6 <blkdev_flush+0x10c>
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005944:	0605                	add	a2,a2,1
42005946:	07c1                	add	a5,a5,16
42005948:	fc6611e3          	bne	a2,t1,4200590a <blkdev_flush+0x50>
            blkdev_flush_cache(ec, dev, i);
            if (ec)
                return;
        }
    }
}
4200594c:	40f2                	lw	ra,28(sp)
4200594e:	4462                	lw	s0,24(sp)
42005950:	6105                	add	sp,sp,32
42005952:	8082                	ret
        if (flags[i].present && (flags[i].dirty || flags[i].erase)) {
42005954:	fd1873e3          	bgeu	a6,a7,4200591a <blkdev_flush+0x60>
42005958:	9002                	ebreak
4200595a:	fd187ee3          	bgeu	a6,a7,42005936 <blkdev_flush+0x7c>
4200595e:	9002                	ebreak
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
42005960:	d575                	beqz	a0,4200594c <blkdev_flush+0x92>
42005962:	420175b7          	lui	a1,0x42017
42005966:	46dd                	li	a3,23
42005968:	4639                	li	a2,14
4200596a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200596e:	4511                	li	a0,4
42005970:	00000717          	auipc	a4,0x0
42005974:	927fd0ef          	jal	4200329a <logkf>
42005978:	00347793          	and	a5,s0,3
4200597c:	fff1                	bnez	a5,42005958 <blkdev_flush+0x9e>
4200597e:	57f1                	li	a5,-4
42005980:	fcf47ce3          	bgeu	s0,a5,42005958 <blkdev_flush+0x9e>
42005984:	47b9                	li	a5,14
42005986:	c05c                	sw	a5,4(s0)
42005988:	47dd                	li	a5,23
}
4200598a:	40f2                	lw	ra,28(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
4200598c:	c01c                	sw	a5,0(s0)
}
4200598e:	4462                	lw	s0,24(sp)
42005990:	6105                	add	sp,sp,32
42005992:	8082                	ret
        ec = &ec0;
42005994:	840a                	mv	s0,sp
42005996:	bfb9                	j	420058f4 <blkdev_flush+0x3a>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005998:	d955                	beqz	a0,4200594c <blkdev_flush+0x92>
4200599a:	420175b7          	lui	a1,0x42017
4200599e:	4689                	li	a3,2
420059a0:	4639                	li	a2,14
420059a2:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420059a6:	4511                	li	a0,4
420059a8:	00000717          	auipc	a4,0x0
420059ac:	8effd0ef          	jal	4200329a <logkf>
420059b0:	00347793          	and	a5,s0,3
420059b4:	f3d5                	bnez	a5,42005958 <blkdev_flush+0x9e>
420059b6:	57f1                	li	a5,-4
420059b8:	faf470e3          	bgeu	s0,a5,42005958 <blkdev_flush+0x9e>
420059bc:	47b9                	li	a5,14
420059be:	c05c                	sw	a5,4(s0)
420059c0:	4789                	li	a5,2
420059c2:	c01c                	sw	a5,0(s0)
420059c4:	b761                	j	4200594c <blkdev_flush+0x92>
            blkdev_flush_cache(ec, dev, i);
420059c6:	8522                	mv	a0,s0
420059c8:	e7ffe0ef          	jal	42004846 <blkdev_flush_cache>
}
420059cc:	40f2                	lw	ra,28(sp)
420059ce:	4462                	lw	s0,24(sp)
420059d0:	6105                	add	sp,sp,32
420059d2:	8082                	ret

420059d4 <blkdev_close>:
void blkdev_close(badge_err_t *ec, blkdev_t *dev) {
420059d4:	1141                	add	sp,sp,-16
420059d6:	c422                	sw	s0,8(sp)
420059d8:	c606                	sw	ra,12(sp)
420059da:	842a                	mv	s0,a0
    if (!dev) {
420059dc:	c1a5                	beqz	a1,42005a3c <blkdev_close+0x68>
420059de:	c226                	sw	s1,4(sp)
420059e0:	84ae                	mv	s1,a1
    blkdev_flush(ec, dev);
420059e2:	3de1                	jal	420058ba <blkdev_flush>
    if (!badge_err_is_ok(ec))
420059e4:	c031                	beqz	s0,42005a28 <blkdev_close+0x54>
420059e6:	00347793          	and	a5,s0,3
420059ea:	ebd9                	bnez	a5,42005a80 <blkdev_close+0xac>
420059ec:	401c                	lw	a5,0(s0)
420059ee:	e3b1                	bnez	a5,42005a32 <blkdev_close+0x5e>
    switch (dev->type) {
420059f0:	0034f793          	and	a5,s1,3
420059f4:	e7d1                	bnez	a5,42005a80 <blkdev_close+0xac>
420059f6:	409c                	lw	a5,0(s1)
420059f8:	cfa5                	beqz	a5,42005a70 <blkdev_close+0x9c>
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
420059fa:	420175b7          	lui	a1,0x42017
420059fe:	4689                	li	a3,2
42005a00:	4639                	li	a2,14
42005a02:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005a06:	4511                	li	a0,4
42005a08:	00000717          	auipc	a4,0x0
42005a0c:	88ffd0ef          	jal	4200329a <logkf>
42005a10:	57f1                	li	a5,-4
42005a12:	06f47763          	bgeu	s0,a5,42005a80 <blkdev_close+0xac>
42005a16:	47b9                	li	a5,14
42005a18:	c05c                	sw	a5,4(s0)
42005a1a:	4789                	li	a5,2
}
42005a1c:	40b2                	lw	ra,12(sp)
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
42005a1e:	c01c                	sw	a5,0(s0)
}
42005a20:	4422                	lw	s0,8(sp)
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
42005a22:	4492                	lw	s1,4(sp)
}
42005a24:	0141                	add	sp,sp,16
42005a26:	8082                	ret
    switch (dev->type) {
42005a28:	0034f793          	and	a5,s1,3
42005a2c:	ebb1                	bnez	a5,42005a80 <blkdev_close+0xac>
42005a2e:	409c                	lw	a5,0(s1)
42005a30:	c3a1                	beqz	a5,42005a70 <blkdev_close+0x9c>
42005a32:	4492                	lw	s1,4(sp)
}
42005a34:	40b2                	lw	ra,12(sp)
42005a36:	4422                	lw	s0,8(sp)
42005a38:	0141                	add	sp,sp,16
42005a3a:	8082                	ret
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005a3c:	dd65                	beqz	a0,42005a34 <blkdev_close+0x60>
42005a3e:	420175b7          	lui	a1,0x42017
42005a42:	4689                	li	a3,2
42005a44:	4639                	li	a2,14
42005a46:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005a4a:	4511                	li	a0,4
42005a4c:	00000717          	auipc	a4,0x0
42005a50:	84bfd0ef          	jal	4200329a <logkf>
42005a54:	00347793          	and	a5,s0,3
42005a58:	e78d                	bnez	a5,42005a82 <blkdev_close+0xae>
42005a5a:	57f1                	li	a5,-4
42005a5c:	02f47363          	bgeu	s0,a5,42005a82 <blkdev_close+0xae>
42005a60:	47b9                	li	a5,14
42005a62:	c05c                	sw	a5,4(s0)
42005a64:	4789                	li	a5,2
}
42005a66:	40b2                	lw	ra,12(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005a68:	c01c                	sw	a5,0(s0)
}
42005a6a:	4422                	lw	s0,8(sp)
42005a6c:	0141                	add	sp,sp,16
42005a6e:	8082                	ret
        case BLKDEV_TYPE_RAM: return blkdev_ram_close(ec, dev);
42005a70:	8522                	mv	a0,s0
}
42005a72:	4422                	lw	s0,8(sp)
42005a74:	40b2                	lw	ra,12(sp)
        case BLKDEV_TYPE_RAM: return blkdev_ram_close(ec, dev);
42005a76:	85a6                	mv	a1,s1
42005a78:	4492                	lw	s1,4(sp)
}
42005a7a:	0141                	add	sp,sp,16
        case BLKDEV_TYPE_RAM: return blkdev_ram_close(ec, dev);
42005a7c:	8f1fe06f          	j	4200436c <blkdev_ram_close>
        default: badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM); break;
42005a80:	9002                	ebreak
42005a82:	c226                	sw	s1,4(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005a84:	9002                	ebreak

42005a86 <blkdev_housekeeping>:

// Call this function occasionally per block device to do housekeeping.
// Manages flushing of caches and erasure.
void blkdev_housekeeping(badge_err_t *ec, blkdev_t *dev) {
42005a86:	715d                	add	sp,sp,-80
42005a88:	d266                	sw	s9,36(sp)
    timestamp_us_t now     = time_us();
    timestamp_us_t timeout = now - BLKDEV_WRITE_CACHE_TIMEOUT;
42005a8a:	fff0ccb7          	lui	s9,0xfff0c
void blkdev_housekeeping(badge_err_t *ec, blkdev_t *dev) {
42005a8e:	d85a                	sw	s6,48(sp)
42005a90:	d65e                	sw	s7,44(sp)
42005a92:	d462                	sw	s8,40(sp)
42005a94:	c686                	sw	ra,76(sp)
42005a96:	c4a2                	sw	s0,72(sp)
42005a98:	c2a6                	sw	s1,68(sp)
42005a9a:	c0ca                	sw	s2,64(sp)
42005a9c:	de4e                	sw	s3,60(sp)
42005a9e:	dc52                	sw	s4,56(sp)
42005aa0:	da56                	sw	s5,52(sp)
42005aa2:	8c2a                	mv	s8,a0
42005aa4:	8bae                	mv	s7,a1
    timestamp_us_t timeout = now - BLKDEV_WRITE_CACHE_TIMEOUT;
42005aa6:	dc0c8c93          	add	s9,s9,-576 # fff0bdc0 <__stop_free_lpsram+0xaff07dc0>
    timestamp_us_t now     = time_us();
42005aaa:	4bf0a0ef          	jal	42010768 <time_us>
    timestamp_us_t timeout = now - BLKDEV_WRITE_CACHE_TIMEOUT;
42005aae:	9caa                	add	s9,s9,a0
42005ab0:	00acb7b3          	sltu	a5,s9,a0
42005ab4:	fff58b13          	add	s6,a1,-1
42005ab8:	9b3e                	add	s6,s6,a5
42005aba:	0d65c863          	blt	a1,s6,42005b8a <blkdev_housekeeping+0x104>
42005abe:	0ebb0f63          	beq	s6,a1,42005bbc <blkdev_housekeeping+0x136>

    blkdev_flags_t *flags = dev->cache->block_flags;
42005ac2:	0c0b8463          	beqz	s7,42005b8a <blkdev_housekeeping+0x104>
42005ac6:	003bf793          	and	a5,s7,3
42005aca:	e3e1                	bnez	a5,42005b8a <blkdev_housekeeping+0x104>
42005acc:	5791                	li	a5,-28
42005ace:	0afbfe63          	bgeu	s7,a5,42005b8a <blkdev_housekeeping+0x104>
42005ad2:	01cba703          	lw	a4,28(s7)
42005ad6:	cb55                	beqz	a4,42005b8a <blkdev_housekeeping+0x104>
42005ad8:	00377793          	and	a5,a4,3
42005adc:	e7dd                	bnez	a5,42005b8a <blkdev_housekeeping+0x104>
42005ade:	57f1                	li	a5,-4
42005ae0:	0af77563          	bgeu	a4,a5,42005b8a <blkdev_housekeeping+0x104>
42005ae4:	00472903          	lw	s2,4(a4) # 42005a50 <blkdev_close+0x7c>

    badge_err_t ec0;
    if (!ec)
42005ae8:	0c0c0863          	beqz	s8,42005bb8 <blkdev_housekeeping+0x132>
        ec = &ec0;

    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005aec:	57e1                	li	a5,-8
42005aee:	08f77e63          	bgeu	a4,a5,42005b8a <blkdev_housekeeping+0x104>
42005af2:	471c                	lw	a5,8(a4)
42005af4:	844a                	mv	s0,s2
42005af6:	4481                	li	s1,0
    return flags.present && (flags.erase || flags.dirty);
42005af8:	4a05                	li	s4,1
        if (blkdev_is_dirty(flags[i]) && flags[i].update_time < timeout) {
            blkdev_flush_cache(ec, dev, i);
            if (!badge_err_is_ok(ec))
42005afa:	003c7993          	and	s3,s8,3
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005afe:	5ae1                	li	s5,-8
42005b00:	c7b5                	beqz	a5,42005b6c <blkdev_housekeeping+0xe6>
        if (blkdev_is_dirty(flags[i]) && flags[i].update_time < timeout) {
42005b02:	00449693          	sll	a3,s1,0x4
42005b06:	00d90633          	add	a2,s2,a3
42005b0a:	0606ce63          	bltz	a3,42005b86 <blkdev_housekeeping+0x100>
42005b0e:	07266e63          	bltu	a2,s2,42005b8a <blkdev_housekeeping+0x104>
42005b12:	cc25                	beqz	s0,42005b8a <blkdev_housekeeping+0x104>
42005b14:	00347793          	and	a5,s0,3
42005b18:	ebad                	bnez	a5,42005b8a <blkdev_housekeeping+0x104>
42005b1a:	00042303          	lw	t1,0(s0)
42005b1e:	00442883          	lw	a7,4(s0)
42005b22:	00842e03          	lw	t3,8(s0)
42005b26:	00c42803          	lw	a6,12(s0)
42005b2a:	00c44783          	lbu	a5,12(s0)
42005b2e:	c81a                	sw	t1,16(sp)
42005b30:	ca46                	sw	a7,20(sp)
42005b32:	cc72                	sw	t3,24(sp)
42005b34:	ce42                	sw	a6,28(sp)
    return flags.present && (flags.erase || flags.dirty);
42005b36:	04fa6a63          	bltu	s4,a5,42005b8a <blkdev_housekeeping+0x104>
42005b3a:	8b85                	and	a5,a5,1
42005b3c:	cf89                	beqz	a5,42005b56 <blkdev_housekeeping+0xd0>
42005b3e:	00881793          	sll	a5,a6,0x8
42005b42:	83c1                	srl	a5,a5,0x10
42005b44:	cb89                	beqz	a5,42005b56 <blkdev_housekeeping+0xd0>
        if (blkdev_is_dirty(flags[i]) && flags[i].update_time < timeout) {
42005b46:	0406c363          	bltz	a3,42005b8c <blkdev_housekeeping+0x106>
42005b4a:	05266063          	bltu	a2,s2,42005b8a <blkdev_housekeeping+0x104>
42005b4e:	0568c363          	blt	a7,s6,42005b94 <blkdev_housekeeping+0x10e>
42005b52:	071b0063          	beq	s6,a7,42005bb2 <blkdev_housekeeping+0x12c>
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005b56:	0485                	add	s1,s1,1
42005b58:	cb0d                	beqz	a4,42005b8a <blkdev_housekeeping+0x104>
42005b5a:	00377793          	and	a5,a4,3
42005b5e:	e795                	bnez	a5,42005b8a <blkdev_housekeeping+0x104>
42005b60:	03577563          	bgeu	a4,s5,42005b8a <blkdev_housekeeping+0x104>
42005b64:	471c                	lw	a5,8(a4)
42005b66:	0441                	add	s0,s0,16
42005b68:	f8f4ede3          	bltu	s1,a5,42005b02 <blkdev_housekeeping+0x7c>
                return;
        }
    }
}
42005b6c:	40b6                	lw	ra,76(sp)
42005b6e:	4426                	lw	s0,72(sp)
42005b70:	4496                	lw	s1,68(sp)
42005b72:	4906                	lw	s2,64(sp)
42005b74:	59f2                	lw	s3,60(sp)
42005b76:	5a62                	lw	s4,56(sp)
42005b78:	5ad2                	lw	s5,52(sp)
42005b7a:	5b42                	lw	s6,48(sp)
42005b7c:	5bb2                	lw	s7,44(sp)
42005b7e:	5c22                	lw	s8,40(sp)
42005b80:	5c92                	lw	s9,36(sp)
42005b82:	6161                	add	sp,sp,80
42005b84:	8082                	ret
        if (blkdev_is_dirty(flags[i]) && flags[i].update_time < timeout) {
42005b86:	f8c976e3          	bgeu	s2,a2,42005b12 <blkdev_housekeeping+0x8c>
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005b8a:	9002                	ebreak
        if (blkdev_is_dirty(flags[i]) && flags[i].update_time < timeout) {
42005b8c:	fec96fe3          	bltu	s2,a2,42005b8a <blkdev_housekeeping+0x104>
42005b90:	fd68d1e3          	bge	a7,s6,42005b52 <blkdev_housekeeping+0xcc>
            blkdev_flush_cache(ec, dev, i);
42005b94:	8626                	mv	a2,s1
42005b96:	85de                	mv	a1,s7
42005b98:	8562                	mv	a0,s8
42005b9a:	cadfe0ef          	jal	42004846 <blkdev_flush_cache>
            if (!badge_err_is_ok(ec))
42005b9e:	fe0c06e3          	beqz	s8,42005b8a <blkdev_housekeeping+0x104>
42005ba2:	fe0994e3          	bnez	s3,42005b8a <blkdev_housekeeping+0x104>
42005ba6:	000c2783          	lw	a5,0(s8)
42005baa:	f3e9                	bnez	a5,42005b6c <blkdev_housekeeping+0xe6>
42005bac:	01cba703          	lw	a4,28(s7)
42005bb0:	b75d                	j	42005b56 <blkdev_housekeeping+0xd0>
        if (blkdev_is_dirty(flags[i]) && flags[i].update_time < timeout) {
42005bb2:	fb9372e3          	bgeu	t1,s9,42005b56 <blkdev_housekeeping+0xd0>
42005bb6:	bff9                	j	42005b94 <blkdev_housekeeping+0x10e>
        ec = &ec0;
42005bb8:	8c0a                	mv	s8,sp
42005bba:	bf0d                	j	42005aec <blkdev_housekeeping+0x66>
    timestamp_us_t timeout = now - BLKDEV_WRITE_CACHE_TIMEOUT;
42005bbc:	f19573e3          	bgeu	a0,s9,42005ac2 <blkdev_housekeeping+0x3c>
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005bc0:	9002                	ebreak

42005bc2 <blkdev_create_cache>:

// Allocate a cache for a block device.
void blkdev_create_cache(badge_err_t *ec, blkdev_t *dev, size_t cache_depth) {
42005bc2:	7179                	add	sp,sp,-48
42005bc4:	d226                	sw	s1,36(sp)
42005bc6:	d606                	sw	ra,44(sp)
42005bc8:	84aa                	mv	s1,a0
    if (!dev) {
42005bca:	1a058863          	beqz	a1,42005d7a <blkdev_create_cache+0x1b8>
42005bce:	d422                	sw	s0,40(sp)
42005bd0:	cc52                	sw	s4,24(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }
    if (dev->readonly && !dev->cache_read) {
42005bd2:	0035f793          	and	a5,a1,3
42005bd6:	842e                	mv	s0,a1
42005bd8:	24079763          	bnez	a5,42005e26 <blkdev_create_cache+0x264>
42005bdc:	0105c783          	lbu	a5,16(a1)
42005be0:	4705                	li	a4,1
42005be2:	24f76263          	bltu	a4,a5,42005e26 <blkdev_create_cache+0x264>
42005be6:	8b85                	and	a5,a5,1
42005be8:	8a32                	mv	s4,a2
42005bea:	ebe9                	bnez	a5,42005cbc <blkdev_create_cache+0xfa>
42005bec:	d04a                	sw	s2,32(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
        return;
    }
    if (dev->cache) {
42005bee:	5791                	li	a5,-28
42005bf0:	22f47963          	bgeu	s0,a5,42005e22 <blkdev_create_cache+0x260>
42005bf4:	4c5c                	lw	a5,28(s0)
42005bf6:	10078463          	beqz	a5,42005cfe <blkdev_create_cache+0x13c>
        // If cache is already present, flush and remove it first.
        badge_err_t ec0;
        if (!ec)
42005bfa:	12048063          	beqz	s1,42005d1a <blkdev_create_cache+0x158>
            ec = &ec0;
        blkdev_flush(ec, dev);
42005bfe:	85a2                	mv	a1,s0
42005c00:	8526                	mv	a0,s1
42005c02:	3965                	jal	420058ba <blkdev_flush>
        if (!badge_err_is_ok(ec))
42005c04:	20048f63          	beqz	s1,42005e22 <blkdev_create_cache+0x260>
42005c08:	0034f793          	and	a5,s1,3
42005c0c:	20079b63          	bnez	a5,42005e22 <blkdev_create_cache+0x260>
42005c10:	409c                	lw	a5,0(s1)
42005c12:	0e079d63          	bnez	a5,42005d0c <blkdev_create_cache+0x14a>
            return;
    }

    // Allocate cache info.
    dev->cache = malloc(sizeof(blkdev_cache_t));
42005c16:	4531                	li	a0,12
42005c18:	539070ef          	jal	4200d950 <malloc>
42005c1c:	cc48                	sw	a0,28(s0)
42005c1e:	892a                	mv	s2,a0
    if (!dev->cache) {
42005c20:	1a050e63          	beqz	a0,42005ddc <blkdev_create_cache+0x21a>
42005c24:	ce4e                	sw	s3,28(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
        return;
    }
    dev->cache->cache_depth = cache_depth;
42005c26:	00397793          	and	a5,s2,3
42005c2a:	1e079b63          	bnez	a5,42005e20 <blkdev_create_cache+0x25e>
42005c2e:	57e1                	li	a5,-8
42005c30:	1ef97863          	bgeu	s2,a5,42005e20 <blkdev_create_cache+0x25e>

    // Allocate block cache.
    dev->cache->block_cache = malloc(dev->block_size * cache_depth);
42005c34:	4048                	lw	a0,4(s0)
    dev->cache->cache_depth = cache_depth;
42005c36:	01492423          	sw	s4,8(s2)
    dev->cache->block_cache = malloc(dev->block_size * cache_depth);
42005c3a:	02aa0533          	mul	a0,s4,a0
42005c3e:	513070ef          	jal	4200d950 <malloc>
    if (!dev->cache->block_cache) {
42005c42:	01c42983          	lw	s3,28(s0)
    dev->cache->block_cache = malloc(dev->block_size * cache_depth);
42005c46:	00a92023          	sw	a0,0(s2)
    if (!dev->cache->block_cache) {
42005c4a:	1c098b63          	beqz	s3,42005e20 <blkdev_create_cache+0x25e>
42005c4e:	0039f793          	and	a5,s3,3
42005c52:	1c079763          	bnez	a5,42005e20 <blkdev_create_cache+0x25e>
42005c56:	0009a783          	lw	a5,0(s3)
42005c5a:	14078763          	beqz	a5,42005da8 <blkdev_create_cache+0x1e6>
        dev->cache = NULL;
        return;
    }

    // Allocate block flags.
    dev->cache->block_flags = malloc(sizeof(blkdev_flags_t) * cache_depth);
42005c5e:	0a12                	sll	s4,s4,0x4
42005c60:	8552                	mv	a0,s4
42005c62:	4ef070ef          	jal	4200d950 <malloc>
42005c66:	57f1                	li	a5,-4
42005c68:	1af9fc63          	bgeu	s3,a5,42005e20 <blkdev_create_cache+0x25e>
42005c6c:	00a9a223          	sw	a0,4(s3)
    if (!dev->cache->block_flags) {
42005c70:	01c42983          	lw	s3,28(s0)
42005c74:	1a098663          	beqz	s3,42005e20 <blkdev_create_cache+0x25e>
42005c78:	0039f713          	and	a4,s3,3
42005c7c:	1a071263          	bnez	a4,42005e20 <blkdev_create_cache+0x25e>
42005c80:	1af9f063          	bgeu	s3,a5,42005e20 <blkdev_create_cache+0x25e>
42005c84:	0049a503          	lw	a0,4(s3)
42005c88:	c959                	beqz	a0,42005d1e <blkdev_create_cache+0x15c>
        free(dev->cache->block_cache);
        free(dev->cache);
        dev->cache = NULL;
        return;
    }
    mem_set(dev->cache->block_flags, 0, sizeof(blkdev_flags_t) * cache_depth);
42005c8a:	8652                	mv	a2,s4
42005c8c:	4581                	li	a1,0
42005c8e:	bbffc0ef          	jal	4200284c <mem_set>
    badge_err_set_ok(ec);
42005c92:	18048263          	beqz	s1,42005e16 <blkdev_create_cache+0x254>
42005c96:	0034f793          	and	a5,s1,3
42005c9a:	18079363          	bnez	a5,42005e20 <blkdev_create_cache+0x25e>
42005c9e:	57f1                	li	a5,-4
42005ca0:	18f4f063          	bgeu	s1,a5,42005e20 <blkdev_create_cache+0x25e>
42005ca4:	5422                	lw	s0,40(sp)
}
42005ca6:	50b2                	lw	ra,44(sp)
    badge_err_set_ok(ec);
42005ca8:	0004a223          	sw	zero,4(s1)
42005cac:	0004a023          	sw	zero,0(s1)
42005cb0:	5902                	lw	s2,32(sp)
42005cb2:	49f2                	lw	s3,28(sp)
42005cb4:	4a62                	lw	s4,24(sp)
}
42005cb6:	5492                	lw	s1,36(sp)
42005cb8:	6145                	add	sp,sp,48
42005cba:	8082                	ret
    if (dev->readonly && !dev->cache_read) {
42005cbc:	0185c783          	lbu	a5,24(a1)
42005cc0:	16f76363          	bltu	a4,a5,42005e26 <blkdev_create_cache+0x264>
42005cc4:	8b85                	and	a5,a5,1
42005cc6:	f39d                	bnez	a5,42005bec <blkdev_create_cache+0x2a>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
42005cc8:	14050463          	beqz	a0,42005e10 <blkdev_create_cache+0x24e>
42005ccc:	420175b7          	lui	a1,0x42017
42005cd0:	46dd                	li	a3,23
42005cd2:	4639                	li	a2,14
42005cd4:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005cd8:	4511                	li	a0,4
42005cda:	00000717          	auipc	a4,0x0
42005cde:	dbcfd0ef          	jal	4200329a <logkf>
42005ce2:	0034f793          	and	a5,s1,3
42005ce6:	14079063          	bnez	a5,42005e26 <blkdev_create_cache+0x264>
42005cea:	57f1                	li	a5,-4
42005cec:	12f4fd63          	bgeu	s1,a5,42005e26 <blkdev_create_cache+0x264>
42005cf0:	47b9                	li	a5,14
42005cf2:	c0dc                	sw	a5,4(s1)
42005cf4:	47dd                	li	a5,23
42005cf6:	5422                	lw	s0,40(sp)
42005cf8:	4a62                	lw	s4,24(sp)
42005cfa:	c09c                	sw	a5,0(s1)
42005cfc:	a819                	j	42005d12 <blkdev_create_cache+0x150>
    dev->cache = malloc(sizeof(blkdev_cache_t));
42005cfe:	4531                	li	a0,12
42005d00:	451070ef          	jal	4200d950 <malloc>
42005d04:	cc48                	sw	a0,28(s0)
42005d06:	892a                	mv	s2,a0
    if (!dev->cache) {
42005d08:	fd11                	bnez	a0,42005c24 <blkdev_create_cache+0x62>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42005d0a:	e8e9                	bnez	s1,42005ddc <blkdev_create_cache+0x21a>
42005d0c:	5422                	lw	s0,40(sp)
42005d0e:	5902                	lw	s2,32(sp)
42005d10:	4a62                	lw	s4,24(sp)
}
42005d12:	50b2                	lw	ra,44(sp)
42005d14:	5492                	lw	s1,36(sp)
42005d16:	6145                	add	sp,sp,48
42005d18:	8082                	ret
            ec = &ec0;
42005d1a:	848a                	mv	s1,sp
42005d1c:	b5cd                	j	42005bfe <blkdev_create_cache+0x3c>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42005d1e:	c885                	beqz	s1,42005d4e <blkdev_create_cache+0x18c>
42005d20:	420175b7          	lui	a1,0x42017
42005d24:	4699                	li	a3,6
42005d26:	4639                	li	a2,14
42005d28:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005d2c:	4511                	li	a0,4
42005d2e:	00000717          	auipc	a4,0x0
42005d32:	d68fd0ef          	jal	4200329a <logkf>
42005d36:	0034f793          	and	a5,s1,3
42005d3a:	e3fd                	bnez	a5,42005e20 <blkdev_create_cache+0x25e>
42005d3c:	57f1                	li	a5,-4
42005d3e:	0ef4f163          	bgeu	s1,a5,42005e20 <blkdev_create_cache+0x25e>
42005d42:	47b9                	li	a5,14
42005d44:	01c42983          	lw	s3,28(s0)
42005d48:	c0dc                	sw	a5,4(s1)
42005d4a:	4799                	li	a5,6
42005d4c:	c09c                	sw	a5,0(s1)
        free(dev->cache->block_cache);
42005d4e:	0c098963          	beqz	s3,42005e20 <blkdev_create_cache+0x25e>
42005d52:	0039f793          	and	a5,s3,3
42005d56:	e7e9                	bnez	a5,42005e20 <blkdev_create_cache+0x25e>
42005d58:	0009a503          	lw	a0,0(s3)
42005d5c:	601070ef          	jal	4200db5c <free>
        free(dev->cache);
42005d60:	4c48                	lw	a0,28(s0)
42005d62:	5fb070ef          	jal	4200db5c <free>
}
42005d66:	50b2                	lw	ra,44(sp)
        dev->cache = NULL;
42005d68:	00042e23          	sw	zero,28(s0)
        return;
42005d6c:	5422                	lw	s0,40(sp)
42005d6e:	5902                	lw	s2,32(sp)
42005d70:	49f2                	lw	s3,28(sp)
42005d72:	4a62                	lw	s4,24(sp)
}
42005d74:	5492                	lw	s1,36(sp)
42005d76:	6145                	add	sp,sp,48
42005d78:	8082                	ret
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005d7a:	dd41                	beqz	a0,42005d12 <blkdev_create_cache+0x150>
42005d7c:	420175b7          	lui	a1,0x42017
42005d80:	4689                	li	a3,2
42005d82:	4639                	li	a2,14
42005d84:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005d88:	4511                	li	a0,4
42005d8a:	00000717          	auipc	a4,0x0
42005d8e:	d0cfd0ef          	jal	4200329a <logkf>
42005d92:	0034f793          	and	a5,s1,3
42005d96:	ebd9                	bnez	a5,42005e2c <blkdev_create_cache+0x26a>
42005d98:	57f1                	li	a5,-4
42005d9a:	08f4f963          	bgeu	s1,a5,42005e2c <blkdev_create_cache+0x26a>
42005d9e:	47b9                	li	a5,14
42005da0:	c0dc                	sw	a5,4(s1)
42005da2:	4789                	li	a5,2
42005da4:	c09c                	sw	a5,0(s1)
42005da6:	b7b5                	j	42005d12 <blkdev_create_cache+0x150>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42005da8:	c885                	beqz	s1,42005dd8 <blkdev_create_cache+0x216>
42005daa:	420175b7          	lui	a1,0x42017
42005dae:	4699                	li	a3,6
42005db0:	4639                	li	a2,14
42005db2:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005db6:	4511                	li	a0,4
42005db8:	00000717          	auipc	a4,0x0
42005dbc:	cdefd0ef          	jal	4200329a <logkf>
42005dc0:	0034f793          	and	a5,s1,3
42005dc4:	efb1                	bnez	a5,42005e20 <blkdev_create_cache+0x25e>
42005dc6:	57f1                	li	a5,-4
42005dc8:	04f4fc63          	bgeu	s1,a5,42005e20 <blkdev_create_cache+0x25e>
42005dcc:	47b9                	li	a5,14
42005dce:	01c42983          	lw	s3,28(s0)
42005dd2:	c0dc                	sw	a5,4(s1)
42005dd4:	4799                	li	a5,6
42005dd6:	c09c                	sw	a5,0(s1)
        free(dev->cache);
42005dd8:	854e                	mv	a0,s3
42005dda:	b761                	j	42005d62 <blkdev_create_cache+0x1a0>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42005ddc:	420175b7          	lui	a1,0x42017
42005de0:	4699                	li	a3,6
42005de2:	4639                	li	a2,14
42005de4:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005de8:	4511                	li	a0,4
42005dea:	00000717          	auipc	a4,0x0
42005dee:	cacfd0ef          	jal	4200329a <logkf>
42005df2:	c885                	beqz	s1,42005e22 <blkdev_create_cache+0x260>
42005df4:	0034f793          	and	a5,s1,3
42005df8:	e78d                	bnez	a5,42005e22 <blkdev_create_cache+0x260>
42005dfa:	57f1                	li	a5,-4
42005dfc:	02f4f363          	bgeu	s1,a5,42005e22 <blkdev_create_cache+0x260>
42005e00:	47b9                	li	a5,14
42005e02:	c0dc                	sw	a5,4(s1)
42005e04:	4799                	li	a5,6
42005e06:	5422                	lw	s0,40(sp)
42005e08:	5902                	lw	s2,32(sp)
42005e0a:	4a62                	lw	s4,24(sp)
42005e0c:	c09c                	sw	a5,0(s1)
42005e0e:	b711                	j	42005d12 <blkdev_create_cache+0x150>
42005e10:	5422                	lw	s0,40(sp)
42005e12:	4a62                	lw	s4,24(sp)
42005e14:	bdfd                	j	42005d12 <blkdev_create_cache+0x150>
42005e16:	5422                	lw	s0,40(sp)
42005e18:	5902                	lw	s2,32(sp)
42005e1a:	49f2                	lw	s3,28(sp)
42005e1c:	4a62                	lw	s4,24(sp)
42005e1e:	bdd5                	j	42005d12 <blkdev_create_cache+0x150>
    badge_err_set_ok(ec);
42005e20:	9002                	ebreak
42005e22:	ce4e                	sw	s3,28(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_NOMEM);
42005e24:	9002                	ebreak
42005e26:	d04a                	sw	s2,32(sp)
42005e28:	ce4e                	sw	s3,28(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_READONLY);
42005e2a:	9002                	ebreak
42005e2c:	d422                	sw	s0,40(sp)
42005e2e:	d04a                	sw	s2,32(sp)
42005e30:	ce4e                	sw	s3,28(sp)
42005e32:	cc52                	sw	s4,24(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005e34:	9002                	ebreak

42005e36 <blkdev_delete_cache>:

// Remove a cache from a block device.
void blkdev_delete_cache(badge_err_t *ec, blkdev_t *dev) {
42005e36:	1101                	add	sp,sp,-32
42005e38:	cc22                	sw	s0,24(sp)
42005e3a:	ce06                	sw	ra,28(sp)
42005e3c:	842a                	mv	s0,a0
    if (!dev) {
42005e3e:	c9d9                	beqz	a1,42005ed4 <blkdev_delete_cache+0x9e>
42005e40:	ca26                	sw	s1,20(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
        return;
    }
    if (dev->cache) {
42005e42:	0035f793          	and	a5,a1,3
42005e46:	84ae                	mv	s1,a1
42005e48:	efcd                	bnez	a5,42005f02 <blkdev_delete_cache+0xcc>
42005e4a:	5791                	li	a5,-28
42005e4c:	0af5fb63          	bgeu	a1,a5,42005f02 <blkdev_delete_cache+0xcc>
42005e50:	4ddc                	lw	a5,28(a1)
42005e52:	cfad                	beqz	a5,42005ecc <blkdev_delete_cache+0x96>
        badge_err_t ec0 = {.cause = ECAUSE_OK};
42005e54:	c002                	sw	zero,0(sp)
42005e56:	c202                	sw	zero,4(sp)
42005e58:	c402                	sw	zero,8(sp)
42005e5a:	c602                	sw	zero,12(sp)
        if (!ec)
42005e5c:	c935                	beqz	a0,42005ed0 <blkdev_delete_cache+0x9a>
            ec = &ec0;
        blkdev_flush(ec, dev);
42005e5e:	85a6                	mv	a1,s1
42005e60:	8522                	mv	a0,s0
42005e62:	a59ff0ef          	jal	420058ba <blkdev_flush>
        if (!badge_err_is_ok(ec))
42005e66:	cc51                	beqz	s0,42005f02 <blkdev_delete_cache+0xcc>
42005e68:	00347793          	and	a5,s0,3
42005e6c:	ebd9                	bnez	a5,42005f02 <blkdev_delete_cache+0xcc>
42005e6e:	401c                	lw	a5,0(s0)
42005e70:	c791                	beqz	a5,42005e7c <blkdev_delete_cache+0x46>
42005e72:	44d2                	lw	s1,20(sp)
        free(dev->cache->block_flags);
        free(dev->cache);
        dev->cache = NULL;
    }
    badge_err_set_ok(ec);
}
42005e74:	40f2                	lw	ra,28(sp)
42005e76:	4462                	lw	s0,24(sp)
42005e78:	6105                	add	sp,sp,32
42005e7a:	8082                	ret
        free(dev->cache->block_cache);
42005e7c:	4cdc                	lw	a5,28(s1)
42005e7e:	c3d1                	beqz	a5,42005f02 <blkdev_delete_cache+0xcc>
42005e80:	0037f713          	and	a4,a5,3
42005e84:	ef3d                	bnez	a4,42005f02 <blkdev_delete_cache+0xcc>
42005e86:	4388                	lw	a0,0(a5)
42005e88:	4d5070ef          	jal	4200db5c <free>
        free(dev->cache->block_flags);
42005e8c:	4cdc                	lw	a5,28(s1)
42005e8e:	cbb5                	beqz	a5,42005f02 <blkdev_delete_cache+0xcc>
42005e90:	0037f713          	and	a4,a5,3
42005e94:	e73d                	bnez	a4,42005f02 <blkdev_delete_cache+0xcc>
42005e96:	5771                	li	a4,-4
42005e98:	06e7f563          	bgeu	a5,a4,42005f02 <blkdev_delete_cache+0xcc>
42005e9c:	43c8                	lw	a0,4(a5)
42005e9e:	4bf070ef          	jal	4200db5c <free>
        free(dev->cache);
42005ea2:	4cc8                	lw	a0,28(s1)
42005ea4:	4b9070ef          	jal	4200db5c <free>
        dev->cache = NULL;
42005ea8:	0004ae23          	sw	zero,28(s1)
    badge_err_set_ok(ec);
42005eac:	c839                	beqz	s0,42005f02 <blkdev_delete_cache+0xcc>
42005eae:	00347793          	and	a5,s0,3
42005eb2:	eba1                	bnez	a5,42005f02 <blkdev_delete_cache+0xcc>
42005eb4:	57f1                	li	a5,-4
42005eb6:	04f47663          	bgeu	s0,a5,42005f02 <blkdev_delete_cache+0xcc>
}
42005eba:	40f2                	lw	ra,28(sp)
    badge_err_set_ok(ec);
42005ebc:	00042223          	sw	zero,4(s0)
42005ec0:	00042023          	sw	zero,0(s0)
}
42005ec4:	4462                	lw	s0,24(sp)
    badge_err_set_ok(ec);
42005ec6:	44d2                	lw	s1,20(sp)
}
42005ec8:	6105                	add	sp,sp,32
42005eca:	8082                	ret
    badge_err_set_ok(ec);
42005ecc:	d15d                	beqz	a0,42005e72 <blkdev_delete_cache+0x3c>
42005ece:	b7c5                	j	42005eae <blkdev_delete_cache+0x78>
            ec = &ec0;
42005ed0:	840a                	mv	s0,sp
42005ed2:	b771                	j	42005e5e <blkdev_delete_cache+0x28>
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005ed4:	d145                	beqz	a0,42005e74 <blkdev_delete_cache+0x3e>
42005ed6:	420175b7          	lui	a1,0x42017
42005eda:	4689                	li	a3,2
42005edc:	4639                	li	a2,14
42005ede:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42005ee2:	4511                	li	a0,4
42005ee4:	00000717          	auipc	a4,0x0
42005ee8:	bb2fd0ef          	jal	4200329a <logkf>
42005eec:	00347793          	and	a5,s0,3
42005ef0:	eb91                	bnez	a5,42005f04 <blkdev_delete_cache+0xce>
42005ef2:	57f1                	li	a5,-4
42005ef4:	00f47863          	bgeu	s0,a5,42005f04 <blkdev_delete_cache+0xce>
42005ef8:	47b9                	li	a5,14
42005efa:	c05c                	sw	a5,4(s0)
42005efc:	4789                	li	a5,2
42005efe:	c01c                	sw	a5,0(s0)
42005f00:	bf95                	j	42005e74 <blkdev_delete_cache+0x3e>
    badge_err_set_ok(ec);
42005f02:	9002                	ebreak
42005f04:	ca26                	sw	s1,20(sp)
        badge_err_set(ec, ELOC_BLKDEV, ECAUSE_PARAM);
42005f06:	9002                	ebreak

42005f08 <blkdev_dump_cache>:



// Show a summary of the cache entries.
void blkdev_dump_cache(blkdev_t *dev) {
    if (!dev)
42005f08:	1e050363          	beqz	a0,420060ee <blkdev_dump_cache+0x1e6>
void blkdev_dump_cache(blkdev_t *dev) {
42005f0c:	7179                	add	sp,sp,-48
42005f0e:	cc52                	sw	s4,24(sp)
42005f10:	d606                	sw	ra,44(sp)
        return;

    if (!dev->cache) {
42005f12:	00357793          	and	a5,a0,3
42005f16:	8a2a                	mv	s4,a0
42005f18:	20079363          	bnez	a5,4200611e <blkdev_dump_cache+0x216>
42005f1c:	5791                	li	a5,-28
42005f1e:	20f57863          	bgeu	a0,a5,4200612e <blkdev_dump_cache+0x226>
42005f22:	4d5c                	lw	a5,28(a0)
42005f24:	1c078663          	beqz	a5,420060f0 <blkdev_dump_cache+0x1e8>
        logk(LOG_DEBUG, "BLKDEV: uncached");
        return;
    }

    size_t used = 0;
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005f28:	0037f713          	and	a4,a5,3
42005f2c:	22071163          	bnez	a4,4200614e <blkdev_dump_cache+0x246>
42005f30:	5761                	li	a4,-8
42005f32:	20e7f663          	bgeu	a5,a4,4200613e <blkdev_dump_cache+0x236>
42005f36:	4788                	lw	a0,8(a5)
    size_t used = 0;
42005f38:	4601                	li	a2,0
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005f3a:	cd1d                	beqz	a0,42005f78 <blkdev_dump_cache+0x70>
42005f3c:	43cc                	lw	a1,4(a5)
42005f3e:	4701                	li	a4,0
    size_t used = 0;
42005f40:	4601                	li	a2,0
        if (dev->cache->block_flags[i].present) {
42005f42:	4805                	li	a6,1
42005f44:	00471693          	sll	a3,a4,0x4
42005f48:	00d587b3          	add	a5,a1,a3
42005f4c:	1206c063          	bltz	a3,4200606c <blkdev_dump_cache+0x164>
42005f50:	12b7e063          	bltu	a5,a1,42006070 <blkdev_dump_cache+0x168>
42005f54:	1a078963          	beqz	a5,42006106 <blkdev_dump_cache+0x1fe>
42005f58:	0037f693          	and	a3,a5,3
42005f5c:	1a069563          	bnez	a3,42006106 <blkdev_dump_cache+0x1fe>
42005f60:	00c7c783          	lbu	a5,12(a5)
42005f64:	22f86063          	bltu	a6,a5,42006184 <blkdev_dump_cache+0x27c>
            used++;
42005f68:	8b85                	and	a5,a5,1
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005f6a:	0705                	add	a4,a4,1 # 42005ee5 <blkdev_delete_cache+0xaf>
            used++;
42005f6c:	963e                	add	a2,a2,a5
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005f6e:	fca71be3          	bne	a4,a0,42005f44 <blkdev_dump_cache+0x3c>
        }
    }

    logkf(LOG_DEBUG, "BLKDEV: %{size;d} cache %{cs} used:", used, used == 1 ? "entry" : "entries");
42005f72:	4785                	li	a5,1
42005f74:	10f60663          	beq	a2,a5,42006080 <blkdev_dump_cache+0x178>
42005f78:	420176b7          	lui	a3,0x42017
42005f7c:	4cc68693          	add	a3,a3,1228 # 420174cc <hextab+0x800>
42005f80:	420175b7          	lui	a1,0x42017
42005f84:	4e858593          	add	a1,a1,1256 # 420174e8 <hextab+0x81c>
42005f88:	4511                	li	a0,4
42005f8a:	b10fd0ef          	jal	4200329a <logkf>

    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42005f8e:	01ca2703          	lw	a4,28(s4)
42005f92:	1c070963          	beqz	a4,42006164 <blkdev_dump_cache+0x25c>
42005f96:	00377793          	and	a5,a4,3
42005f9a:	1c079563          	bnez	a5,42006164 <blkdev_dump_cache+0x25c>
42005f9e:	57e1                	li	a5,-8
42005fa0:	1cf77a63          	bgeu	a4,a5,42006174 <blkdev_dump_cache+0x26c>
42005fa4:	471c                	lw	a5,8(a4)
42005fa6:	cfdd                	beqz	a5,42006064 <blkdev_dump_cache+0x15c>
42005fa8:	d422                	sw	s0,40(sp)
42005faa:	d226                	sw	s1,36(sp)
42005fac:	d04a                	sw	s2,32(sp)
42005fae:	ce4e                	sw	s3,28(sp)
42005fb0:	ca56                	sw	s5,20(sp)
42005fb2:	c85a                	sw	s6,16(sp)
42005fb4:	c65e                	sw	s7,12(sp)
42005fb6:	4401                	li	s0,0
        if (dev->cache->block_flags[i].present) {
42005fb8:	5bf1                	li	s7,-4
42005fba:	4a85                	li	s5,1
                    "BLKDEV: Entry %{size;d}: block %{u32;d} erase cache",
                    i,
                    dev->cache->block_flags[i].index
                );
            } else {
                logkf(
42005fbc:	5b61                	li	s6,-8
42005fbe:	42017937          	lui	s2,0x42017
                logkf(
42005fc2:	420174b7          	lui	s1,0x42017
                logkf(
42005fc6:	420179b7          	lui	s3,0x42017
        if (dev->cache->block_flags[i].present) {
42005fca:	14070663          	beqz	a4,42006116 <blkdev_dump_cache+0x20e>
42005fce:	13777b63          	bgeu	a4,s7,42006104 <blkdev_dump_cache+0x1fc>
42005fd2:	4354                	lw	a3,4(a4)
42005fd4:	00441613          	sll	a2,s0,0x4
42005fd8:	00c687b3          	add	a5,a3,a2
42005fdc:	0a064763          	bltz	a2,4200608a <blkdev_dump_cache+0x182>
42005fe0:	0ad7e763          	bltu	a5,a3,4200608e <blkdev_dump_cache+0x186>
42005fe4:	12078c63          	beqz	a5,4200611c <blkdev_dump_cache+0x214>
42005fe8:	0037f593          	and	a1,a5,3
42005fec:	12059863          	bnez	a1,4200611c <blkdev_dump_cache+0x214>
42005ff0:	00c7c583          	lbu	a1,12(a5)
42005ff4:	18baef63          	bltu	s5,a1,42006192 <blkdev_dump_cache+0x28a>
42005ff8:	8985                	and	a1,a1,1
42005ffa:	c5a1                	beqz	a1,42006042 <blkdev_dump_cache+0x13a>
            if (dev->cache->block_flags[i].dirty) {
42005ffc:	08064a63          	bltz	a2,42006090 <blkdev_dump_cache+0x188>
42006000:	08d7ea63          	bltu	a5,a3,42006094 <blkdev_dump_cache+0x18c>
42006004:	00e7c703          	lbu	a4,14(a5)
42006008:	18eae563          	bltu	s5,a4,42006192 <blkdev_dump_cache+0x28a>
4200600c:	8b05                	and	a4,a4,1
4200600e:	ef4d                	bnez	a4,420060c8 <blkdev_dump_cache+0x1c0>
            } else if (dev->cache->block_flags[i].erase) {
42006010:	08064363          	bltz	a2,42006096 <blkdev_dump_cache+0x18e>
42006014:	08d7e363          	bltu	a5,a3,4200609a <blkdev_dump_cache+0x192>
42006018:	00d7c703          	lbu	a4,13(a5)
4200601c:	16eaeb63          	bltu	s5,a4,42006192 <blkdev_dump_cache+0x28a>
42006020:	8b05                	and	a4,a4,1
42006022:	c341                	beqz	a4,420060a2 <blkdev_dump_cache+0x19a>
                    dev->cache->block_flags[i].index
42006024:	06064c63          	bltz	a2,4200609c <blkdev_dump_cache+0x194>
42006028:	06d7ec63          	bltu	a5,a3,420060a0 <blkdev_dump_cache+0x198>
                logkf(
4200602c:	1367f963          	bgeu	a5,s6,4200615e <blkdev_dump_cache+0x256>
42006030:	4794                	lw	a3,8(a5)
42006032:	8622                	mv	a2,s0
42006034:	54048593          	add	a1,s1,1344 # 42017540 <hextab+0x874>
42006038:	4511                	li	a0,4
4200603a:	a60fd0ef          	jal	4200329a <logkf>
4200603e:	01ca2703          	lw	a4,28(s4)
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42006042:	0405                	add	s0,s0,1
42006044:	cb71                	beqz	a4,42006118 <blkdev_dump_cache+0x210>
42006046:	00377793          	and	a5,a4,3
4200604a:	e7f9                	bnez	a5,42006118 <blkdev_dump_cache+0x210>
4200604c:	0d677763          	bgeu	a4,s6,4200611a <blkdev_dump_cache+0x212>
42006050:	471c                	lw	a5,8(a4)
42006052:	f6f46ce3          	bltu	s0,a5,42005fca <blkdev_dump_cache+0xc2>
42006056:	5422                	lw	s0,40(sp)
42006058:	5492                	lw	s1,36(sp)
4200605a:	5902                	lw	s2,32(sp)
4200605c:	49f2                	lw	s3,28(sp)
4200605e:	4ad2                	lw	s5,20(sp)
42006060:	4b42                	lw	s6,16(sp)
42006062:	4bb2                	lw	s7,12(sp)
                    dev->cache->block_flags[i].index
                );
            }
        }
    }
}
42006064:	50b2                	lw	ra,44(sp)
42006066:	4a62                	lw	s4,24(sp)
42006068:	6145                	add	sp,sp,48
4200606a:	8082                	ret
        if (dev->cache->block_flags[i].present) {
4200606c:	eef5f4e3          	bgeu	a1,a5,42005f54 <blkdev_dump_cache+0x4c>
42006070:	d422                	sw	s0,40(sp)
42006072:	d226                	sw	s1,36(sp)
42006074:	d04a                	sw	s2,32(sp)
42006076:	ce4e                	sw	s3,28(sp)
42006078:	ca56                	sw	s5,20(sp)
4200607a:	c85a                	sw	s6,16(sp)
4200607c:	c65e                	sw	s7,12(sp)
4200607e:	9002                	ebreak
    logkf(LOG_DEBUG, "BLKDEV: %{size;d} cache %{cs} used:", used, used == 1 ? "entry" : "entries");
42006080:	420176b7          	lui	a3,0x42017
42006084:	4c468693          	add	a3,a3,1220 # 420174c4 <hextab+0x7f8>
42006088:	bde5                	j	42005f80 <blkdev_dump_cache+0x78>
        if (dev->cache->block_flags[i].present) {
4200608a:	f4f6fde3          	bgeu	a3,a5,42005fe4 <blkdev_dump_cache+0xdc>
4200608e:	9002                	ebreak
            if (dev->cache->block_flags[i].dirty) {
42006090:	f6f6fae3          	bgeu	a3,a5,42006004 <blkdev_dump_cache+0xfc>
42006094:	9002                	ebreak
            } else if (dev->cache->block_flags[i].erase) {
42006096:	f8f6f1e3          	bgeu	a3,a5,42006018 <blkdev_dump_cache+0x110>
4200609a:	9002                	ebreak
                    dev->cache->block_flags[i].index
4200609c:	f8f6f8e3          	bgeu	a3,a5,4200602c <blkdev_dump_cache+0x124>
420060a0:	9002                	ebreak
                    dev->cache->block_flags[i].index
420060a2:	02064063          	bltz	a2,420060c2 <blkdev_dump_cache+0x1ba>
420060a6:	02d7e063          	bltu	a5,a3,420060c6 <blkdev_dump_cache+0x1be>
                logkf(
420060aa:	0b67fc63          	bgeu	a5,s6,42006162 <blkdev_dump_cache+0x25a>
420060ae:	4794                	lw	a3,8(a5)
420060b0:	8622                	mv	a2,s0
420060b2:	57490593          	add	a1,s2,1396 # 42017574 <hextab+0x8a8>
420060b6:	4511                	li	a0,4
420060b8:	9e2fd0ef          	jal	4200329a <logkf>
420060bc:	01ca2703          	lw	a4,28(s4)
420060c0:	b749                	j	42006042 <blkdev_dump_cache+0x13a>
                    dev->cache->block_flags[i].index
420060c2:	fef6f4e3          	bgeu	a3,a5,420060aa <blkdev_dump_cache+0x1a2>
420060c6:	9002                	ebreak
                    dev->cache->block_flags[i].index
420060c8:	02064063          	bltz	a2,420060e8 <blkdev_dump_cache+0x1e0>
420060cc:	02d7e063          	bltu	a5,a3,420060ec <blkdev_dump_cache+0x1e4>
                logkf(
420060d0:	0967f863          	bgeu	a5,s6,42006160 <blkdev_dump_cache+0x258>
420060d4:	4794                	lw	a3,8(a5)
420060d6:	8622                	mv	a2,s0
420060d8:	50c98593          	add	a1,s3,1292 # 4201750c <hextab+0x840>
420060dc:	4511                	li	a0,4
420060de:	9bcfd0ef          	jal	4200329a <logkf>
420060e2:	01ca2703          	lw	a4,28(s4)
420060e6:	bfb1                	j	42006042 <blkdev_dump_cache+0x13a>
                    dev->cache->block_flags[i].index
420060e8:	fef6f4e3          	bgeu	a3,a5,420060d0 <blkdev_dump_cache+0x1c8>
420060ec:	9002                	ebreak
420060ee:	8082                	ret
}
420060f0:	50b2                	lw	ra,44(sp)
420060f2:	4a62                	lw	s4,24(sp)
        logk(LOG_DEBUG, "BLKDEV: uncached");
420060f4:	420175b7          	lui	a1,0x42017
420060f8:	4d458593          	add	a1,a1,1236 # 420174d4 <hextab+0x808>
420060fc:	4511                	li	a0,4
}
420060fe:	6145                	add	sp,sp,48
        logk(LOG_DEBUG, "BLKDEV: uncached");
42006100:	954fd06f          	j	42003254 <logk>
        if (dev->cache->block_flags[i].present) {
42006104:	9002                	ebreak
42006106:	d422                	sw	s0,40(sp)
42006108:	d226                	sw	s1,36(sp)
4200610a:	d04a                	sw	s2,32(sp)
4200610c:	ce4e                	sw	s3,28(sp)
4200610e:	ca56                	sw	s5,20(sp)
42006110:	c85a                	sw	s6,16(sp)
42006112:	c65e                	sw	s7,12(sp)
        if (dev->cache->block_flags[i].present) {
42006114:	9002                	ebreak
        if (dev->cache->block_flags[i].present) {
42006116:	9002                	ebreak
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42006118:	9002                	ebreak
4200611a:	9002                	ebreak
        if (dev->cache->block_flags[i].present) {
4200611c:	9002                	ebreak
4200611e:	d422                	sw	s0,40(sp)
42006120:	d226                	sw	s1,36(sp)
42006122:	d04a                	sw	s2,32(sp)
42006124:	ce4e                	sw	s3,28(sp)
42006126:	ca56                	sw	s5,20(sp)
42006128:	c85a                	sw	s6,16(sp)
4200612a:	c65e                	sw	s7,12(sp)
    if (!dev->cache) {
4200612c:	9002                	ebreak
4200612e:	d422                	sw	s0,40(sp)
42006130:	d226                	sw	s1,36(sp)
42006132:	d04a                	sw	s2,32(sp)
42006134:	ce4e                	sw	s3,28(sp)
42006136:	ca56                	sw	s5,20(sp)
42006138:	c85a                	sw	s6,16(sp)
4200613a:	c65e                	sw	s7,12(sp)
4200613c:	9002                	ebreak
4200613e:	d422                	sw	s0,40(sp)
42006140:	d226                	sw	s1,36(sp)
42006142:	d04a                	sw	s2,32(sp)
42006144:	ce4e                	sw	s3,28(sp)
42006146:	ca56                	sw	s5,20(sp)
42006148:	c85a                	sw	s6,16(sp)
4200614a:	c65e                	sw	s7,12(sp)
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
4200614c:	9002                	ebreak
4200614e:	d422                	sw	s0,40(sp)
42006150:	d226                	sw	s1,36(sp)
42006152:	d04a                	sw	s2,32(sp)
42006154:	ce4e                	sw	s3,28(sp)
42006156:	ca56                	sw	s5,20(sp)
42006158:	c85a                	sw	s6,16(sp)
4200615a:	c65e                	sw	s7,12(sp)
4200615c:	9002                	ebreak
                logkf(
4200615e:	9002                	ebreak
                logkf(
42006160:	9002                	ebreak
                logkf(
42006162:	9002                	ebreak
42006164:	d422                	sw	s0,40(sp)
42006166:	d226                	sw	s1,36(sp)
42006168:	d04a                	sw	s2,32(sp)
4200616a:	ce4e                	sw	s3,28(sp)
4200616c:	ca56                	sw	s5,20(sp)
4200616e:	c85a                	sw	s6,16(sp)
42006170:	c65e                	sw	s7,12(sp)
    for (size_t i = 0; i < dev->cache->cache_depth; i++) {
42006172:	9002                	ebreak
42006174:	d422                	sw	s0,40(sp)
42006176:	d226                	sw	s1,36(sp)
42006178:	d04a                	sw	s2,32(sp)
4200617a:	ce4e                	sw	s3,28(sp)
4200617c:	ca56                	sw	s5,20(sp)
4200617e:	c85a                	sw	s6,16(sp)
42006180:	c65e                	sw	s7,12(sp)
42006182:	9002                	ebreak
42006184:	d422                	sw	s0,40(sp)
42006186:	d226                	sw	s1,36(sp)
42006188:	d04a                	sw	s2,32(sp)
4200618a:	ce4e                	sw	s3,28(sp)
4200618c:	ca56                	sw	s5,20(sp)
4200618e:	c85a                	sw	s6,16(sp)
42006190:	c65e                	sw	s7,12(sp)
        if (dev->cache->block_flags[i].present) {
42006192:	9002                	ebreak

42006194 <is_dir_handle>:
}



// Test that the handle exists and is a directory handle.
static bool is_dir_handle(badge_err_t *ec, file_t dir) {
42006194:	1141                	add	sp,sp,-16
42006196:	c04a                	sw	s2,0(sp)
    assert_always(mutex_acquire_shared(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42006198:	0016e637          	lui	a2,0x16e
static bool is_dir_handle(badge_err_t *ec, file_t dir) {
4200619c:	c226                	sw	s1,4(sp)
    assert_always(mutex_acquire_shared(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
4200619e:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
static bool is_dir_handle(badge_err_t *ec, file_t dir) {
420061a2:	84ae                	mv	s1,a1
    assert_always(mutex_acquire_shared(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
420061a4:	4681                	li	a3,0
420061a6:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
static bool is_dir_handle(badge_err_t *ec, file_t dir) {
420061aa:	c422                	sw	s0,8(sp)
420061ac:	c606                	sw	ra,12(sp)
420061ae:	842a                	mv	s0,a0
    assert_always(mutex_acquire_shared(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
420061b0:	f7afd0ef          	jal	4200392a <mutex_acquire_shared>
420061b4:	cd71                	beqz	a0,42006290 <is_dir_handle+0xfc>

    // Check the handle exists.
    ptrdiff_t index = vfs_file_by_handle(dir);
420061b6:	8526                	mv	a0,s1
420061b8:	230040ef          	jal	4200a3e8 <vfs_file_by_handle>
    if (index < 0) {
420061bc:	08054d63          	bltz	a0,42006256 <is_dir_handle+0xc2>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
        mutex_release_shared(ec, &vfs_handle_mtx);
        return false;
    }
    // Check the handle is that of a directory.
    vfs_file_handle_t *handle = &vfs_file_handle_list[index];
420061c0:	4080a7b7          	lui	a5,0x4080a
420061c4:	e2c7a683          	lw	a3,-468(a5) # 40809e2c <vfs_file_handle_list>
420061c8:	00351793          	sll	a5,a0,0x3
420061cc:	97aa                	add	a5,a5,a0
420061ce:	078a                	sll	a5,a5,0x2
420061d0:	00f68733          	add	a4,a3,a5
420061d4:	0607d263          	bgez	a5,42006238 <is_dir_handle+0xa4>
420061d8:	06e6e263          	bltu	a3,a4,4200623c <is_dir_handle+0xa8>
    if (!handle->is_dir) {
420061dc:	c325                	beqz	a4,4200623c <is_dir_handle+0xa8>
420061de:	00377793          	and	a5,a4,3
420061e2:	efa9                	bnez	a5,4200623c <is_dir_handle+0xa8>
420061e4:	00674483          	lbu	s1,6(a4)
420061e8:	4785                	li	a5,1
420061ea:	0497e963          	bltu	a5,s1,4200623c <is_dir_handle+0xa8>
420061ee:	8885                	and	s1,s1,1
420061f0:	e4b9                	bnez	s1,4200623e <is_dir_handle+0xaa>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
420061f2:	c415                	beqz	s0,4200621e <is_dir_handle+0x8a>
420061f4:	420175b7          	lui	a1,0x42017
420061f8:	46e9                	li	a3,26
420061fa:	4635                	li	a2,13
420061fc:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006200:	4511                	li	a0,4
42006202:	00000717          	auipc	a4,0x0
42006206:	894fd0ef          	jal	4200329a <logkf>
4200620a:	00347793          	and	a5,s0,3
4200620e:	e79d                	bnez	a5,4200623c <is_dir_handle+0xa8>
42006210:	57f1                	li	a5,-4
42006212:	02f47563          	bgeu	s0,a5,4200623c <is_dir_handle+0xa8>
42006216:	47b5                	li	a5,13
42006218:	c05c                	sw	a5,4(s0)
4200621a:	47e9                	li	a5,26
4200621c:	c01c                	sw	a5,0(s0)
        mutex_release_shared(ec, &vfs_handle_mtx);
4200621e:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006222:	8522                	mv	a0,s0
42006224:	931fd0ef          	jal	42003b54 <mutex_release_shared>
        return false;
42006228:	4481                	li	s1,0
        return false;
    }

    mutex_release_shared(ec, &vfs_handle_mtx);
    return true;
}
4200622a:	40b2                	lw	ra,12(sp)
4200622c:	4422                	lw	s0,8(sp)
4200622e:	4902                	lw	s2,0(sp)
42006230:	8526                	mv	a0,s1
42006232:	4492                	lw	s1,4(sp)
42006234:	0141                	add	sp,sp,16
42006236:	8082                	ret
    vfs_file_handle_t *handle = &vfs_file_handle_list[index];
42006238:	fad772e3          	bgeu	a4,a3,420061dc <is_dir_handle+0x48>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
4200623c:	9002                	ebreak
    mutex_release_shared(ec, &vfs_handle_mtx);
4200623e:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006242:	8522                	mv	a0,s0
42006244:	911fd0ef          	jal	42003b54 <mutex_release_shared>
}
42006248:	40b2                	lw	ra,12(sp)
4200624a:	4422                	lw	s0,8(sp)
4200624c:	4902                	lw	s2,0(sp)
4200624e:	8526                	mv	a0,s1
42006250:	4492                	lw	s1,4(sp)
42006252:	0141                	add	sp,sp,16
42006254:	8082                	ret
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42006256:	d461                	beqz	s0,4200621e <is_dir_handle+0x8a>
42006258:	420175b7          	lui	a1,0x42017
4200625c:	4689                	li	a3,2
4200625e:	4635                	li	a2,13
42006260:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006264:	4511                	li	a0,4
42006266:	00000717          	auipc	a4,0x0
4200626a:	830fd0ef          	jal	4200329a <logkf>
4200626e:	00347793          	and	a5,s0,3
42006272:	f7e9                	bnez	a5,4200623c <is_dir_handle+0xa8>
42006274:	57f1                	li	a5,-4
42006276:	fcf473e3          	bgeu	s0,a5,4200623c <is_dir_handle+0xa8>
4200627a:	47b5                	li	a5,13
4200627c:	c05c                	sw	a5,4(s0)
4200627e:	4789                	li	a5,2
42006280:	c01c                	sw	a5,0(s0)
        mutex_release_shared(ec, &vfs_handle_mtx);
42006282:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006286:	8522                	mv	a0,s0
42006288:	8cdfd0ef          	jal	42003b54 <mutex_release_shared>
        return false;
4200628c:	4481                	li	s1,0
4200628e:	bf71                	j	4200622a <is_dir_handle+0x96>
    assert_always(mutex_acquire_shared(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42006290:	420175b7          	lui	a1,0x42017
42006294:	5a858593          	add	a1,a1,1448 # 420175a8 <hextab+0x8dc>
42006298:	fbdfc0ef          	jal	42003254 <logk>
4200629c:	9002                	ebreak

4200629e <fs_detect>:
    badge_err_set_ok(ec);
4200629e:	c919                	beqz	a0,420062b4 <fs_detect+0x16>
420062a0:	00357793          	and	a5,a0,3
420062a4:	eb91                	bnez	a5,420062b8 <fs_detect+0x1a>
420062a6:	57f1                	li	a5,-4
420062a8:	00f57863          	bgeu	a0,a5,420062b8 <fs_detect+0x1a>
420062ac:	00052223          	sw	zero,4(a0)
420062b0:	00052023          	sw	zero,0(a0)
}
420062b4:	4501                	li	a0,0
420062b6:	8082                	ret
    badge_err_set_ok(ec);
420062b8:	9002                	ebreak

420062ba <fs_is_canonical_path>:
    if (*path != '/') {
420062ba:	c571                	beqz	a0,42006386 <fs_is_canonical_path+0xcc>
bool fs_is_canonical_path(char const *path) {
420062bc:	1101                	add	sp,sp,-32
420062be:	cc22                	sw	s0,24(sp)
420062c0:	ce06                	sw	ra,28(sp)
    if (*path != '/') {
420062c2:	00054783          	lbu	a5,0(a0)
420062c6:	02f00713          	li	a4,47
420062ca:	842a                	mv	s0,a0
420062cc:	08e79663          	bne	a5,a4,42006358 <fs_is_canonical_path+0x9e>
420062d0:	ca26                	sw	s1,20(sp)
420062d2:	c84a                	sw	s2,16(sp)
420062d4:	c64e                	sw	s3,12(sp)
        } else if (path[0] == '/' && path[1] == '/') {
420062d6:	02f00913          	li	s2,47
        if (path[0] == '.') {
420062da:	02e00993          	li	s3,46
        } else if (path[0] == '/' && path[1] == '/') {
420062de:	54fd                	li	s1,-1
        if (path[0] == '.') {
420062e0:	c859                	beqz	s0,42006376 <fs_is_canonical_path+0xbc>
420062e2:	05378263          	beq	a5,s3,42006326 <fs_is_canonical_path+0x6c>
        } else if (path[0] == '/' && path[1] == '/') {
420062e6:	07278e63          	beq	a5,s2,42006362 <fs_is_canonical_path+0xa8>
        ptrdiff_t index = cstr_index(path, '/');
420062ea:	02f00593          	li	a1,47
420062ee:	8522                	mv	a0,s0
420062f0:	ac9fb0ef          	jal	42001db8 <cstr_index>
        if (index == -1) {
420062f4:	00950e63          	beq	a0,s1,42006310 <fs_is_canonical_path+0x56>
        path = path + index + 1;
420062f8:	0505                	add	a0,a0,1
420062fa:	00a407b3          	add	a5,s0,a0
420062fe:	02054163          	bltz	a0,42006320 <fs_is_canonical_path+0x66>
42006302:	0287e163          	bltu	a5,s0,42006324 <fs_is_canonical_path+0x6a>
42006306:	843e                	mv	s0,a5
    while (*path) {
42006308:	cba5                	beqz	a5,42006378 <fs_is_canonical_path+0xbe>
4200630a:	0007c783          	lbu	a5,0(a5)
4200630e:	fbe9                	bnez	a5,420062e0 <fs_is_canonical_path+0x26>
}
42006310:	40f2                	lw	ra,28(sp)
42006312:	4462                	lw	s0,24(sp)
42006314:	44d2                	lw	s1,20(sp)
42006316:	4942                	lw	s2,16(sp)
42006318:	49b2                	lw	s3,12(sp)
            return true;
4200631a:	4505                	li	a0,1
}
4200631c:	6105                	add	sp,sp,32
4200631e:	8082                	ret
        path = path + index + 1;
42006320:	fef473e3          	bgeu	s0,a5,42006306 <fs_is_canonical_path+0x4c>
42006324:	9002                	ebreak
            size_t i = path[1] == '.';
42006326:	04947a63          	bgeu	s0,s1,4200637a <fs_is_canonical_path+0xc0>
4200632a:	00140793          	add	a5,s0,1
4200632e:	cbb1                	beqz	a5,42006382 <fs_is_canonical_path+0xc8>
42006330:	00144783          	lbu	a5,1(s0)
42006334:	fd278793          	add	a5,a5,-46
42006338:	0017b793          	seqz	a5,a5
            if (path[i] == 0 || path[i] == '/') {
4200633c:	97a2                	add	a5,a5,s0
4200633e:	0487e163          	bltu	a5,s0,42006380 <fs_is_canonical_path+0xc6>
42006342:	cf95                	beqz	a5,4200637e <fs_is_canonical_path+0xc4>
42006344:	0007c703          	lbu	a4,0(a5)
42006348:	c709                	beqz	a4,42006352 <fs_is_canonical_path+0x98>
4200634a:	0287e963          	bltu	a5,s0,4200637c <fs_is_canonical_path+0xc2>
4200634e:	f9271ee3          	bne	a4,s2,420062ea <fs_is_canonical_path+0x30>
42006352:	44d2                	lw	s1,20(sp)
42006354:	4942                	lw	s2,16(sp)
42006356:	49b2                	lw	s3,12(sp)
}
42006358:	40f2                	lw	ra,28(sp)
4200635a:	4462                	lw	s0,24(sp)
        return false;
4200635c:	4501                	li	a0,0
}
4200635e:	6105                	add	sp,sp,32
42006360:	8082                	ret
        } else if (path[0] == '/' && path[1] == '/') {
42006362:	02947163          	bgeu	s0,s1,42006384 <fs_is_canonical_path+0xca>
42006366:	00140793          	add	a5,s0,1
4200636a:	cf99                	beqz	a5,42006388 <fs_is_canonical_path+0xce>
4200636c:	00144783          	lbu	a5,1(s0)
42006370:	f7279de3          	bne	a5,s2,420062ea <fs_is_canonical_path+0x30>
42006374:	bff9                	j	42006352 <fs_is_canonical_path+0x98>
        if (path[0] == '.') {
42006376:	9002                	ebreak
    while (*path) {
42006378:	9002                	ebreak
            size_t i = path[1] == '.';
4200637a:	9002                	ebreak
            if (path[i] == 0 || path[i] == '/') {
4200637c:	9002                	ebreak
4200637e:	9002                	ebreak
42006380:	9002                	ebreak
            size_t i = path[1] == '.';
42006382:	9002                	ebreak
        } else if (path[0] == '/' && path[1] == '/') {
42006384:	9002                	ebreak
    if (*path != '/') {
42006386:	9002                	ebreak
        } else if (path[0] == '/' && path[1] == '/') {
42006388:	9002                	ebreak

4200638a <fs_open>:
}



// Open a file for reading and/or writing.
file_t fs_open(badge_err_t *ec, char const *path, oflags_t oflags) {
4200638a:	c9010113          	add	sp,sp,-880
4200638e:	36812423          	sw	s0,872(sp)
42006392:	36912223          	sw	s1,868(sp)
42006396:	36112623          	sw	ra,876(sp)
    badge_err_t ec0 = {.cause = ECAUSE_OK};
4200639a:	c802                	sw	zero,16(sp)
4200639c:	ca02                	sw	zero,20(sp)
4200639e:	cc02                	sw	zero,24(sp)
420063a0:	ce02                	sw	zero,28(sp)
file_t fs_open(badge_err_t *ec, char const *path, oflags_t oflags) {
420063a2:	c432                	sw	a2,8(sp)
420063a4:	842e                	mv	s0,a1
    if (!ec)
        ec = &ec0;
420063a6:	0804                	add	s1,sp,16
    if (!ec)
420063a8:	c111                	beqz	a0,420063ac <fs_open+0x22>
420063aa:	84aa                	mv	s1,a0

    // Test flag validity.
    if ((oflags & OFLAGS_DIRECTORY) && (oflags & ~VALID_OFLAGS_DIRECTORY)) {
420063ac:	4722                	lw	a4,8(sp)
420063ae:	08077793          	and	a5,a4,128
420063b2:	c63e                	sw	a5,12(sp)
420063b4:	62078163          	beqz	a5,420069d6 <fs_open+0x64c>
420063b8:	f0e77793          	and	a5,a4,-242
420063bc:	26079be3          	bnez	a5,42006e32 <fs_open+0xaa8>
        return FILE_NONE;
    } else if (!(oflags & OFLAGS_DIRECTORY) && (oflags & ~VALID_OFLAGS_FILE)) {
        // An invalid flag was given.
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
        return FILE_NONE;
    } else if (!(oflags & OFLAGS_READWRITE)) {
420063c0:	47a2                	lw	a5,8(sp)
420063c2:	8b8d                	and	a5,a5,3
420063c4:	44078ee3          	beqz	a5,42007020 <fs_open+0xc96>
420063c8:	33b12e23          	sw	s11,828(sp)
        return FILE_NONE;
    }

    // Copy the path.
    char canon_path[FILESYSTEM_PATH_MAX + 1];
    if (path[cstr_copy(canon_path, sizeof(canon_path), path)] != 0) {
420063cc:	13010d93          	add	s11,sp,304
420063d0:	8622                	mv	a2,s0
420063d2:	20000593          	li	a1,512
420063d6:	856e                	mv	a0,s11
420063d8:	c49fb0ef          	jal	42002020 <cstr_copy>
420063dc:	00a40733          	add	a4,s0,a0
420063e0:	62055a63          	bgez	a0,42006a14 <fs_open+0x68a>
420063e4:	62e46a63          	bltu	s0,a4,42006a18 <fs_open+0x68e>
420063e8:	600700e3          	beqz	a4,420071e8 <fs_open+0xe5e>
420063ec:	00074703          	lbu	a4,0(a4) # 42006266 <is_dir_handle+0xd2>
420063f0:	3e071be3          	bnez	a4,42006fe6 <fs_open+0xc5c>
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
420063f4:	35512a23          	sw	s5,852(sp)
420063f8:	0016e637          	lui	a2,0x16e
420063fc:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42006400:	4681                	li	a3,0
42006402:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006406:	4501                	li	a0,0
42006408:	a6afd0ef          	jal	42003672 <mutex_acquire>
4200640c:	37212023          	sw	s2,864(sp)
42006410:	35312e23          	sw	s3,860(sp)
42006414:	35412c23          	sw	s4,856(sp)
42006418:	35612823          	sw	s6,848(sp)
4200641c:	080500e3          	beqz	a0,42006c9c <fs_open+0x912>
    ptrdiff_t          existing = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
42006420:	3201a683          	lw	a3,800(gp) # 40800320 <vfs_root_index>
42006424:	35812423          	sw	s8,840(sp)
42006428:	4715                	li	a4,5
4200642a:	5ae6f1e3          	bgeu	a3,a4,420071cc <fs_open+0xe42>
4200642e:	03400713          	li	a4,52
42006432:	02e68733          	mul	a4,a3,a4
42006436:	33018c13          	add	s8,gp,816 # 40800330 <vfs_table>
4200643a:	00ec0633          	add	a2,s8,a4
4200643e:	60075963          	bgez	a4,42006a50 <fs_open+0x6c6>
42006442:	60cc6963          	bltu	s8,a2,42006a54 <fs_open+0x6ca>
42006446:	4a11                	li	s4,4
42006448:	00ec0533          	add	a0,s8,a4
4200644c:	5946f7e3          	bgeu	a3,s4,420071da <fs_open+0xe50>
42006450:	0741                	add	a4,a4,16
42006452:	00ec05b3          	add	a1,s8,a4
42006456:	418a0a33          	sub	s4,s4,s8
4200645a:	01458633          	add	a2,a1,s4
4200645e:	0d000813          	li	a6,208
42006462:	52c862e3          	bltu	a6,a2,42007186 <fs_open+0xdfc>
42006466:	00ec0633          	add	a2,s8,a4
4200646a:	5e075c63          	bgez	a4,42006a62 <fs_open+0x6d8>
4200646e:	5ecc6c63          	bltu	s8,a2,42006a66 <fs_open+0x6dc>
42006472:	03400713          	li	a4,52
42006476:	02e686b3          	mul	a3,a3,a4
4200647a:	96e2                	add	a3,a3,s8
4200647c:	4a8c                	lw	a1,16(a3)
4200647e:	6f5030ef          	jal	4200a372 <vfs_shared_by_inode>
42006482:	89aa                	mv	s3,a0
    ptrdiff_t          handle   = vfs_file_create_handle(existing);
42006484:	0a2040ef          	jal	4200a526 <vfs_file_create_handle>
    vfs_file_handle_t *ptr      = &vfs_file_handle_list[handle];
42006488:	4080a7b7          	lui	a5,0x4080a
4200648c:	e2c7a683          	lw	a3,-468(a5) # 40809e2c <vfs_file_handle_list>
42006490:	00351713          	sll	a4,a0,0x3
42006494:	972a                	add	a4,a4,a0
42006496:	070a                	sll	a4,a4,0x2
    ptrdiff_t          handle   = vfs_file_create_handle(existing);
42006498:	842a                	mv	s0,a0
    vfs_file_handle_t *ptr      = &vfs_file_handle_list[handle];
4200649a:	00e68933          	add	s2,a3,a4
4200649e:	5a075063          	bgez	a4,42006a3e <fs_open+0x6b4>
420064a2:	5b26e063          	bltu	a3,s2,42006a42 <fs_open+0x6b8>
    if (existing == -1) {
420064a6:	577d                	li	a4,-1
420064a8:	5ce98663          	beq	s3,a4,42006a74 <fs_open+0x6ea>
    ptr->offset         = 0;
420064ac:	580902e3          	beqz	s2,42007230 <fs_open+0xea6>
420064b0:	00397713          	and	a4,s2,3
420064b4:	56071ee3          	bnez	a4,42007230 <fs_open+0xea6>
420064b8:	00092023          	sw	zero,0(s2)
    ptr->write          = false;
420064bc:	5771                	li	a4,-4
420064be:	56e972e3          	bgeu	s2,a4,42007222 <fs_open+0xe98>
420064c2:	00090223          	sb	zero,4(s2)
    ptr->read           = true;
420064c6:	576d                	li	a4,-5
420064c8:	4ee97be3          	bgeu	s2,a4,420071be <fs_open+0xe34>
420064cc:	4705                	li	a4,1
420064ce:	00e902a3          	sb	a4,5(s2)
    ptr->is_dir         = true;
420064d2:	56e9                	li	a3,-6
420064d4:	4cd97ee3          	bgeu	s2,a3,420071b0 <fs_open+0xe26>
420064d8:	00e90323          	sb	a4,6(s2)
    ptr->dir_cache      = NULL;
420064dc:	5721                	li	a4,-24
420064de:	4ce972e3          	bgeu	s2,a4,420071a2 <fs_open+0xe18>
420064e2:	00092c23          	sw	zero,24(s2)
    ptr->dir_cache_size = 0;
420064e6:	00092a23          	sw	zero,20(s2)
    mutex_release(NULL, &vfs_handle_mtx);
420064ea:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420064ee:	4501                	li	a0,0
420064f0:	b14fd0ef          	jal	42003804 <mutex_release>
        return FILE_NONE;
    }

    // Locate the file.
    vfs_file_handle_t *parent = root_open(ec);
    if (!badge_err_is_ok(ec)) {
420064f4:	50048fe3          	beqz	s1,42007212 <fs_open+0xe88>
420064f8:	0034f713          	and	a4,s1,3
420064fc:	50071be3          	bnez	a4,42007212 <fs_open+0xe88>
42006500:	4098                	lw	a4,0(s1)
42006502:	28071fe3          	bnez	a4,42006fa0 <fs_open+0xc16>
        return FILE_NONE;
    }
    dirent_t  ent   = {0};
42006506:	11000613          	li	a2,272
4200650a:	4581                	li	a1,0
4200650c:	1008                	add	a0,sp,32
4200650e:	c08fc0ef          	jal	42002916 <memset>
    assert_dev_drop(dir != NULL);
42006512:	5a090963          	beqz	s2,42006ac4 <fs_open+0x73a>
    ptrdiff_t len   = (ptrdiff_t)cstr_length(path);
42006516:	856e                	mv	a0,s11
42006518:	35912223          	sw	s9,836(sp)
4200651c:	35a12023          	sw	s10,832(sp)
42006520:	83bfb0ef          	jal	42001d5a <cstr_length>
42006524:	89aa                	mv	s3,a0
    for (ptrdiff_t i = 0; i < len;) {
42006526:	7ca05c63          	blez	a0,42006cfe <fs_open+0x974>
4200652a:	4401                	li	s0,0
        if (path[i] == '/' && path[i + 1] == '/') {
4200652c:	20000d13          	li	s10,512
42006530:	02f00c93          	li	s9,47
42006534:	008d8733          	add	a4,s11,s0
42006538:	3c044d63          	bltz	s0,42006912 <fs_open+0x588>
4200653c:	3db76d63          	bltu	a4,s11,42006916 <fs_open+0x58c>
42006540:	008d86b3          	add	a3,s11,s0
42006544:	3c0688e3          	beqz	a3,42007114 <fs_open+0xd8a>
42006548:	00140713          	add	a4,s0,1
4200654c:	3aed6de3          	bltu	s10,a4,42007106 <fs_open+0xd7c>
42006550:	0006c683          	lbu	a3,0(a3)
42006554:	25968a63          	beq	a3,s9,420067a8 <fs_open+0x41e>
            i++;
42006558:	843a                	mv	s0,a4
    for (ptrdiff_t i = 0; i < len;) {
4200655a:	fd344de3          	blt	s0,s3,42006534 <fs_open+0x1aa>
    if (path[0] == '/') {
4200655e:	13014683          	lbu	a3,304(sp)
42006562:	02f00713          	li	a4,47
42006566:	5ee68263          	beq	a3,a4,42006b4a <fs_open+0x7c0>
    while (begin < len) {
4200656a:	4d01                	li	s10,0
4200656c:	353054e3          	blez	s3,420070b4 <fs_open+0xd2a>
42006570:	35712623          	sw	s7,844(sp)
        if (path[begin] == '/') {
42006574:	20000a13          	li	s4,512
42006578:	02f00b13          	li	s6,47
4200657c:	01ad86b3          	add	a3,s11,s10
42006580:	380d4e63          	bltz	s10,4200691c <fs_open+0x592>
42006584:	39b6ee63          	bltu	a3,s11,42006920 <fs_open+0x596>
42006588:	01ad86b3          	add	a3,s11,s10
4200658c:	36068ce3          	beqz	a3,42007104 <fs_open+0xd7a>
42006590:	001d0613          	add	a2,s10,1
42006594:	38ca63e3          	bltu	s4,a2,4200711a <fs_open+0xd90>
42006598:	0006c583          	lbu	a1,0(a3)
4200659c:	39658e63          	beq	a1,s6,42006938 <fs_open+0x5ae>
        end = cstr_index_from(path, '/', begin);
420065a0:	866a                	mv	a2,s10
420065a2:	02f00593          	li	a1,47
420065a6:	856e                	mv	a0,s11
420065a8:	c236                	sw	a3,4(sp)
420065aa:	895fb0ef          	jal	42001e3e <cstr_index_from>
        if (end < 0)
420065ae:	4692                	lw	a3,4(sp)
        end = cstr_index_from(path, '/', begin);
420065b0:	842a                	mv	s0,a0
        if (end < 0)
420065b2:	00055363          	bgez	a0,420065b8 <fs_open+0x22e>
            end = len;
420065b6:	844e                	mv	s0,s3
        char tmp    = path[end];
420065b8:	008d8bb3          	add	s7,s11,s0
420065bc:	3bbbece3          	bltu	s7,s11,42007174 <fs_open+0xdea>
420065c0:	380b83e3          	beqz	s7,42007146 <fs_open+0xdbc>
420065c4:	00140c93          	add	s9,s0,1
420065c8:	379a6ae3          	bltu	s4,s9,4200713c <fs_open+0xdb2>
        path[end]   = 0;
420065cc:	008d8633          	add	a2,s11,s0
        char tmp    = path[end];
420065d0:	000bcc03          	lbu	s8,0(s7)
        path[end]   = 0;
420065d4:	37b663e3          	bltu	a2,s11,4200713a <fs_open+0xdb0>
420065d8:	3b9a62e3          	bltu	s4,s9,4200717c <fs_open+0xdf2>
420065dc:	000b8023          	sb	zero,0(s7)
        found       = vfs_dir_find_ent(ec, dir->shared, ent, path + begin);
420065e0:	5791                	li	a5,-28
420065e2:	38f97ae3          	bgeu	s2,a5,42007176 <fs_open+0xdec>
420065e6:	01c92583          	lw	a1,28(s2)
420065ea:	01ad8633          	add	a2,s11,s10
420065ee:	320d4a63          	bltz	s10,42006922 <fs_open+0x598>
420065f2:	33b66a63          	bltu	a2,s11,42006926 <fs_open+0x59c>
420065f6:	1010                	add	a2,sp,32
420065f8:	8526                	mv	a0,s1
420065fa:	386040ef          	jal	4200a980 <vfs_dir_find_ent>
        path[end]   = tmp;
420065fe:	008d86b3          	add	a3,s11,s0
42006602:	37b6e6e3          	bltu	a3,s11,4200716e <fs_open+0xde4>
42006606:	359a6fe3          	bltu	s4,s9,42007164 <fs_open+0xdda>
4200660a:	018b8023          	sb	s8,0(s7)
        bool is_int = path[end] == '/' && path[end + 1] != 0;
4200660e:	008d86b3          	add	a3,s11,s0
42006612:	35b6e8e3          	bltu	a3,s11,42007162 <fs_open+0xdd8>
42006616:	079a67e3          	bltu	s4,s9,42006e84 <fs_open+0xafa>
4200661a:	1d6c0e63          	beq	s8,s6,420067f6 <fs_open+0x46c>
        if (!found && is_int) {
4200661e:	7c050763          	beqz	a0,42006dec <fs_open+0xa62>
            badge_err_set_ok(ec);
42006622:	56f1                	li	a3,-4
42006624:	32d4fae3          	bgeu	s1,a3,42007158 <fs_open+0xdce>
    ptrdiff_t slash = walk(ec, parent, canon_path, &ent);
    bool      found = ent.inode;
42006628:	5412                	lw	s0,36(sp)
            badge_err_set_ok(ec);
4200662a:	0004a223          	sw	zero,4(s1)
4200662e:	0004a023          	sw	zero,0(s1)
    while (len > 1 && path[len - 1] == '/') {
42006632:	4685                	li	a3,1
42006634:	04d98563          	beq	s3,a3,4200667e <fs_open+0x2f4>
42006638:	fff98693          	add	a3,s3,-1
4200663c:	00dd8633          	add	a2,s11,a3
42006640:	20000593          	li	a1,512
42006644:	02f00813          	li	a6,47
42006648:	4885                	li	a7,1
4200664a:	a831                	j	42006666 <fs_open+0x2dc>
        path[len - 1] = 0;
4200664c:	00dd8533          	add	a0,s11,a3
42006650:	2fb564e3          	bltu	a0,s11,42007138 <fs_open+0xdae>
42006654:	2d35e9e3          	bltu	a1,s3,42007126 <fs_open+0xd9c>
42006658:	00060023          	sb	zero,0(a2)
        len--;
4200665c:	89b6                	mv	s3,a3
    while (len > 1 && path[len - 1] == '/') {
4200665e:	167d                	add	a2,a2,-1
42006660:	01168f63          	beq	a3,a7,4200667e <fs_open+0x2f4>
42006664:	16fd                	add	a3,a3,-1
42006666:	00dd8533          	add	a0,s11,a3
4200666a:	31b563e3          	bltu	a0,s11,42007170 <fs_open+0xde6>
4200666e:	300602e3          	beqz	a2,42007172 <fs_open+0xde8>
42006672:	2b35eee3          	bltu	a1,s3,4200712e <fs_open+0xda4>
42006676:	00064503          	lbu	a0,0(a2)
4200667a:	fd0509e3          	beq	a0,a6,4200664c <fs_open+0x2c2>
    if (!badge_err_is_ok(ec)) {
4200667e:	4094                	lw	a3,0(s1)
42006680:	26069363          	bnez	a3,420068e6 <fs_open+0x55c>
        return FILE_NONE;
    }
    // Get the filename from canonical path.
    char *filename;
    if (slash == -2) {
42006684:	56f9                	li	a3,-2
42006686:	60dd0463          	beq	s10,a3,42006c8e <fs_open+0x904>
        filename = ".";
    } else if (slash == -1) {
4200668a:	56fd                	li	a3,-1
4200668c:	4add0663          	beq	s10,a3,42006b38 <fs_open+0x7ae>
        filename = canon_path;
    } else {
        filename = canon_path + slash;
42006690:	01ad86b3          	add	a3,s11,s10
42006694:	5c0d4963          	bltz	s10,42006c66 <fs_open+0x8dc>
42006698:	34c12b83          	lw	s7,844(sp)
4200669c:	49b6e5e3          	bltu	a3,s11,42007326 <fs_open+0xf9c>
420066a0:	01ad89b3          	add	s3,s11,s10
    }

    assert_always(mutex_acquire(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
420066a4:	0016e637          	lui	a2,0x16e
420066a8:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
420066ac:	4681                	li	a3,0
420066ae:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420066b2:	8526                	mv	a0,s1
420066b4:	fbffc0ef          	jal	42003672 <mutex_acquire>
420066b8:	7e050a63          	beqz	a0,42006eac <fs_open+0xb22>
    ptrdiff_t existing = -1;
    bool      is_dir;
    if (found) {
420066bc:	5a040063          	beqz	s0,42006c5c <fs_open+0x8d2>
        // File exists.
        is_dir = ent.is_dir;
420066c0:	02814a03          	lbu	s4,40(sp)
420066c4:	4785                	li	a5,1
420066c6:	5547e7e3          	bltu	a5,s4,42007414 <fs_open+0x108a>
420066ca:	001a7a13          	and	s4,s4,1

        // Check file type.
        if (ent.is_dir && !(oflags & OFLAGS_DIRECTORY)) {
420066ce:	47b2                	lw	a5,12(sp)
420066d0:	680a1163          	bnez	s4,42006d52 <fs_open+0x9c8>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_DIR);
            mutex_release(NULL, &vfs_handle_mtx);
            goto error;
        } else if (!ent.is_dir && (oflags & OFLAGS_DIRECTORY)) {
420066d4:	72079763          	bnez	a5,42006e02 <fs_open+0xa78>
            mutex_release(NULL, &vfs_handle_mtx);
            goto error;
        }

        // Check for existing shared handles.
        existing = vfs_shared_by_inode(parent->shared->vfs, ent.inode);
420066d8:	5791                	li	a5,-28
420066da:	42f97de3          	bgeu	s2,a5,42007314 <fs_open+0xf8a>
420066de:	01c92783          	lw	a5,28(s2)
420066e2:	420786e3          	beqz	a5,4200730e <fs_open+0xf84>
420066e6:	0037f713          	and	a4,a5,3
420066ea:	420712e3          	bnez	a4,4200730e <fs_open+0xf84>
420066ee:	fdc00713          	li	a4,-36
420066f2:	42e7fde3          	bgeu	a5,a4,4200732c <fs_open+0xfa2>
420066f6:	5592                	lw	a1,36(sp)
420066f8:	53c8                	lw	a0,36(a5)
420066fa:	479030ef          	jal	4200a372 <vfs_shared_by_inode>
420066fe:	8c2a                	mv	s8,a0
        is_dir   = (oflags & OFLAGS_DIRECTORY);
        existing = -1;
    }

    // Create a new handle from existing shared handle.
    ptrdiff_t handle = vfs_file_create_handle(existing);
42006700:	8562                	mv	a0,s8
42006702:	625030ef          	jal	4200a526 <vfs_file_create_handle>
    if (handle == -1) {
42006706:	57fd                	li	a5,-1
    ptrdiff_t handle = vfs_file_create_handle(existing);
42006708:	8b2a                	mv	s6,a0
    if (handle == -1) {
4200670a:	7af50a63          	beq	a0,a5,42006ebe <fs_open+0xb34>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
        mutex_release(NULL, &vfs_handle_mtx);
        goto error;
    }
    vfs_file_handle_t *ptr = &vfs_file_handle_list[handle];
4200670e:	4080a7b7          	lui	a5,0x4080a
42006712:	e2c7a703          	lw	a4,-468(a5) # 40809e2c <vfs_file_handle_list>
42006716:	00351793          	sll	a5,a0,0x3
4200671a:	97aa                	add	a5,a5,a0
4200671c:	078a                	sll	a5,a5,0x2
4200671e:	00f70433          	add	s0,a4,a5
42006722:	4007cf63          	bltz	a5,42006b40 <fs_open+0x7b6>
42006726:	40e46f63          	bltu	s0,a4,42006b44 <fs_open+0x7ba>

    // Apply opening flags.
    ptr->read   = oflags & OFLAGS_READONLY;
4200672a:	47a2                	lw	a5,8(sp)
4200672c:	0017f713          	and	a4,a5,1
42006730:	400401e3          	beqz	s0,42007332 <fs_open+0xfa8>
42006734:	00347793          	and	a5,s0,3
42006738:	3e079de3          	bnez	a5,42007332 <fs_open+0xfa8>
4200673c:	57ed                	li	a5,-5
4200673e:	3ef471e3          	bgeu	s0,a5,42007320 <fs_open+0xf96>
    ptr->write  = oflags & OFLAGS_WRITEONLY;
42006742:	47a2                	lw	a5,8(sp)
    ptr->read   = oflags & OFLAGS_READONLY;
42006744:	00e402a3          	sb	a4,5(s0)
    ptr->write  = oflags & OFLAGS_WRITEONLY;
42006748:	8385                	srl	a5,a5,0x1
4200674a:	8b85                	and	a5,a5,1
4200674c:	00f40223          	sb	a5,4(s0)
    ptr->is_dir = is_dir;
42006750:	57e9                	li	a5,-6
42006752:	3cf474e3          	bgeu	s0,a5,4200731a <fs_open+0xf90>
42006756:	01440323          	sb	s4,6(s0)

    if (existing == -1) {
4200675a:	57fd                	li	a5,-1
4200675c:	5afc0f63          	beq	s8,a5,42006d1a <fs_open+0x990>
        }
        shared->refcount = 1;
    }

    // Successful opening of new handle.
    mutex_release(NULL, &vfs_handle_mtx);
42006760:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006764:	4501                	li	a0,0
42006766:	89efd0ef          	jal	42003804 <mutex_release>

    return ptr->fileno;
4200676a:	5781                	li	a5,-32
4200676c:	2ef47be3          	bgeu	s0,a5,42007262 <fs_open+0xed8>
42006770:	5008                	lw	a0,32(s0)
42006772:	36012903          	lw	s2,864(sp)
42006776:	35c12983          	lw	s3,860(sp)
4200677a:	35812a03          	lw	s4,856(sp)
4200677e:	35412a83          	lw	s5,852(sp)
42006782:	35012b03          	lw	s6,848(sp)
42006786:	34812c03          	lw	s8,840(sp)
4200678a:	34412c83          	lw	s9,836(sp)
4200678e:	34012d03          	lw	s10,832(sp)
42006792:	33c12d83          	lw	s11,828(sp)
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
    ptrdiff_t index = vfs_file_by_handle(parent->fileno);
    vfs_file_destroy_handle(index);
    mutex_release(NULL, &vfs_handle_mtx);
    return FILE_NONE;
}
42006796:	36c12083          	lw	ra,876(sp)
4200679a:	36812403          	lw	s0,872(sp)
4200679e:	36412483          	lw	s1,868(sp)
420067a2:	37010113          	add	sp,sp,880
420067a6:	8082                	ret
        if (path[i] == '/' && path[i + 1] == '/') {
420067a8:	00ed86b3          	add	a3,s11,a4
420067ac:	18074163          	bltz	a4,4200692e <fs_open+0x5a4>
420067b0:	19b6e163          	bltu	a3,s11,42006932 <fs_open+0x5a8>
420067b4:	00ed8533          	add	a0,s11,a4
420067b8:	1a0502e3          	beqz	a0,4200715c <fs_open+0xdd2>
420067bc:	00240613          	add	a2,s0,2
420067c0:	18cd64e3          	bltu	s10,a2,42007148 <fs_open+0xdbe>
420067c4:	00054683          	lbu	a3,0(a0)
420067c8:	d99698e3          	bne	a3,s9,42006558 <fs_open+0x1ce>
            cstr_copy(path + i + 1, FILESYSTEM_PATH_MAX + 1, path + i + 2);
420067cc:	00ed86b3          	add	a3,s11,a4
420067d0:	32074063          	bltz	a4,42006af0 <fs_open+0x766>
420067d4:	33b6e063          	bltu	a3,s11,42006af4 <fs_open+0x76a>
420067d8:	00cd8733          	add	a4,s11,a2
420067dc:	30064563          	bltz	a2,42006ae6 <fs_open+0x75c>
420067e0:	31b76563          	bltu	a4,s11,42006aea <fs_open+0x760>
420067e4:	966e                	add	a2,a2,s11
420067e6:	20000593          	li	a1,512
            len--;
420067ea:	19fd                	add	s3,s3,-1
            cstr_copy(path + i + 1, FILESYSTEM_PATH_MAX + 1, path + i + 2);
420067ec:	835fb0ef          	jal	42002020 <cstr_copy>
    for (ptrdiff_t i = 0; i < len;) {
420067f0:	d53442e3          	blt	s0,s3,42006534 <fs_open+0x1aa>
420067f4:	b3ad                	j	4200655e <fs_open+0x1d4>
        bool is_int = path[end] == '/' && path[end + 1] != 0;
420067f6:	019d86b3          	add	a3,s11,s9
420067fa:	140ccb63          	bltz	s9,42006950 <fs_open+0x5c6>
420067fe:	15b6eb63          	bltu	a3,s11,42006954 <fs_open+0x5ca>
42006802:	019d8833          	add	a6,s11,s9
42006806:	200804e3          	beqz	a6,4200720e <fs_open+0xe84>
4200680a:	00240693          	add	a3,s0,2
4200680e:	18da66e3          	bltu	s4,a3,4200719a <fs_open+0xe10>
42006812:	00084683          	lbu	a3,0(a6)
42006816:	e00684e3          	beqz	a3,4200661e <fs_open+0x294>
        if (!found && is_int) {
4200681a:	72050263          	beqz	a0,42006f3e <fs_open+0xbb4>
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
4200681e:	0016e637          	lui	a2,0x16e
42006822:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42006826:	4681                	li	a3,0
42006828:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
4200682c:	4501                	li	a0,0
4200682e:	e45fc0ef          	jal	42003672 <mutex_acquire>
42006832:	2c050463          	beqz	a0,42006afa <fs_open+0x770>
    ptrdiff_t          shared = vfs_shared_by_inode(dir->shared->vfs, ent->inode);
42006836:	01c92703          	lw	a4,28(s2)
4200683a:	120700e3          	beqz	a4,4200715a <fs_open+0xdd0>
4200683e:	00377693          	and	a3,a4,3
42006842:	10069ce3          	bnez	a3,4200715a <fs_open+0xdd0>
42006846:	fdc00793          	li	a5,-36
4200684a:	12f777e3          	bgeu	a4,a5,42007178 <fs_open+0xdee>
4200684e:	5592                	lw	a1,36(sp)
42006850:	5348                	lw	a0,36(a4)
42006852:	321030ef          	jal	4200a372 <vfs_shared_by_inode>
    if (shared == -1) {
42006856:	57fd                	li	a5,-1
42006858:	10f50f63          	beq	a0,a5,42006976 <fs_open+0x5ec>
        shptr = vfs_file_shared_list[shared];
4200685c:	4080a7b7          	lui	a5,0x4080a
42006860:	e387a683          	lw	a3,-456(a5) # 40809e38 <vfs_file_shared_list>
42006864:	050a                	sll	a0,a0,0x2
42006866:	00a68733          	add	a4,a3,a0
4200686a:	0a054f63          	bltz	a0,42006928 <fs_open+0x59e>
4200686e:	0ad76f63          	bltu	a4,a3,4200692c <fs_open+0x5a2>
42006872:	100704e3          	beqz	a4,4200717a <fs_open+0xdf0>
42006876:	00377693          	and	a3,a4,3
4200687a:	100690e3          	bnez	a3,4200717a <fs_open+0xdf0>
4200687e:	00072d03          	lw	s10,0(a4)
    vfs_file_shared_t *old = dir->shared;
42006882:	01c92583          	lw	a1,28(s2)
    dir->shared            = shptr;
42006886:	01a92e23          	sw	s10,28(s2)
    shptr->refcount++;
4200688a:	080d0de3          	beqz	s10,42007124 <fs_open+0xd9a>
4200688e:	003d7713          	and	a4,s10,3
42006892:	080719e3          	bnez	a4,42007124 <fs_open+0xd9a>
42006896:	000d2703          	lw	a4,0(s10)
4200689a:	0705                	add	a4,a4,1
4200689c:	00ed2023          	sw	a4,0(s10)
    old->refcount--;
420068a0:	0a058be3          	beqz	a1,42007156 <fs_open+0xdcc>
420068a4:	0035f713          	and	a4,a1,3
420068a8:	0a0717e3          	bnez	a4,42007156 <fs_open+0xdcc>
420068ac:	4198                	lw	a4,0(a1)
420068ae:	177d                	add	a4,a4,-1
420068b0:	c198                	sw	a4,0(a1)
    if (old->refcount == 0) {
420068b2:	c355                	beqz	a4,42006956 <fs_open+0x5cc>
        badge_err_set_ok(ec);
420068b4:	57f1                	li	a5,-4
420068b6:	16f4f5e3          	bgeu	s1,a5,42007220 <fs_open+0xe96>
420068ba:	0004a223          	sw	zero,4(s1)
420068be:	0004a023          	sw	zero,0(s1)
    mutex_release(NULL, &vfs_handle_mtx);
420068c2:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420068c6:	4501                	li	a0,0
420068c8:	f3dfc0ef          	jal	42003804 <mutex_release>
            if (!badge_err_is_ok(ec)) {
420068cc:	4098                	lw	a4,0(s1)
420068ce:	50071963          	bnez	a4,42006de0 <fs_open+0xa56>
            begin = end;
420068d2:	8d22                	mv	s10,s0
    while (begin < len) {
420068d4:	cb3d44e3          	blt	s10,s3,4200657c <fs_open+0x1f2>
    while (len > 1 && path[len - 1] == '/') {
420068d8:	4685                	li	a3,1
    bool      found = ent.inode;
420068da:	5412                	lw	s0,36(sp)
    while (len > 1 && path[len - 1] == '/') {
420068dc:	d4d99ee3          	bne	s3,a3,42006638 <fs_open+0x2ae>
    if (!badge_err_is_ok(ec)) {
420068e0:	4094                	lw	a3,0(s1)
420068e2:	da0684e3          	beqz	a3,4200668a <fs_open+0x300>
420068e6:	36012903          	lw	s2,864(sp)
420068ea:	35c12983          	lw	s3,860(sp)
420068ee:	35812a03          	lw	s4,856(sp)
420068f2:	35412a83          	lw	s5,852(sp)
420068f6:	35012b03          	lw	s6,848(sp)
420068fa:	34c12b83          	lw	s7,844(sp)
420068fe:	34812c03          	lw	s8,840(sp)
42006902:	34412c83          	lw	s9,836(sp)
42006906:	34012d03          	lw	s10,832(sp)
4200690a:	33c12d83          	lw	s11,828(sp)
        return FILE_NONE;
4200690e:	557d                	li	a0,-1
42006910:	b559                	j	42006796 <fs_open+0x40c>
        if (path[i] == '/' && path[i + 1] == '/') {
42006912:	c2edf7e3          	bgeu	s11,a4,42006540 <fs_open+0x1b6>
42006916:	35712623          	sw	s7,844(sp)
4200691a:	9002                	ebreak
        if (path[begin] == '/') {
4200691c:	c6ddf6e3          	bgeu	s11,a3,42006588 <fs_open+0x1fe>
42006920:	9002                	ebreak
        found       = vfs_dir_find_ent(ec, dir->shared, ent, path + begin);
42006922:	cccdfae3          	bgeu	s11,a2,420065f6 <fs_open+0x26c>
42006926:	9002                	ebreak
        shptr = vfs_file_shared_list[shared];
42006928:	f4e6f5e3          	bgeu	a3,a4,42006872 <fs_open+0x4e8>
4200692c:	9002                	ebreak
        if (path[i] == '/' && path[i + 1] == '/') {
4200692e:	e8ddf3e3          	bgeu	s11,a3,420067b4 <fs_open+0x42a>
42006932:	35712623          	sw	s7,844(sp)
42006936:	9002                	ebreak
            if (!dir->is_dir) {
42006938:	00694703          	lbu	a4,6(s2)
4200693c:	4685                	li	a3,1
4200693e:	2ce6ede3          	bltu	a3,a4,42007418 <fs_open+0x108e>
42006942:	8b05                	and	a4,a4,1
42006944:	62070b63          	beqz	a4,42006f7a <fs_open+0xbf0>
            begin++;
42006948:	8d32                	mv	s10,a2
    while (begin < len) {
4200694a:	c33d49e3          	blt	s10,s3,4200657c <fs_open+0x1f2>
4200694e:	b769                	j	420068d8 <fs_open+0x54e>
        bool is_int = path[end] == '/' && path[end + 1] != 0;
42006950:	eaddf9e3          	bgeu	s11,a3,42006802 <fs_open+0x478>
42006954:	9002                	ebreak
        vfs_file_close(ec, old);
42006956:	8526                	mv	a0,s1
42006958:	c22e                	sw	a1,4(sp)
4200695a:	1cc040ef          	jal	4200ab26 <vfs_file_close>
        badge_err_assert_dev(ec);
4200695e:	0004ad03          	lw	s10,0(s1)
42006962:	4592                	lw	a1,4(sp)
42006964:	57f1                	li	a5,-4
42006966:	360d1363          	bnez	s10,42006ccc <fs_open+0x942>
        vfs_file_destroy_shared(old->index);
4200696a:	0af5f3e3          	bgeu	a1,a5,42007210 <fs_open+0xe86>
4200696e:	41c8                	lw	a0,4(a1)
42006970:	4df030ef          	jal	4200a64e <vfs_file_destroy_shared>
42006974:	b7b9                	j	420068c2 <fs_open+0x538>
        shared = vfs_file_create_shared();
42006976:	2c9030ef          	jal	4200a43e <vfs_file_create_shared>
        if (shared == -1) {
4200697a:	57fd                	li	a5,-1
        shared = vfs_file_create_shared();
4200697c:	882a                	mv	a6,a0
        if (shared == -1) {
4200697e:	18f50563          	beq	a0,a5,42006b08 <fs_open+0x77e>
        shptr = vfs_file_shared_list[shared];
42006982:	4080a737          	lui	a4,0x4080a
42006986:	e3872683          	lw	a3,-456(a4) # 40809e38 <vfs_file_shared_list>
4200698a:	00251613          	sll	a2,a0,0x2
4200698e:	00c68733          	add	a4,a3,a2
42006992:	14064763          	bltz	a2,42006ae0 <fs_open+0x756>
42006996:	14d76763          	bltu	a4,a3,42006ae4 <fs_open+0x75a>
4200699a:	0a0705e3          	beqz	a4,42007244 <fs_open+0xeba>
4200699e:	00377693          	and	a3,a4,3
420069a2:	0a0691e3          	bnez	a3,42007244 <fs_open+0xeba>
420069a6:	00072d03          	lw	s10,0(a4)
        vfs_file_open(ec, dir->shared, shptr, ent->name, 0);
420069aa:	01c92583          	lw	a1,28(s2)
420069ae:	4701                	li	a4,0
420069b0:	1814                	add	a3,sp,48
420069b2:	866a                	mv	a2,s10
420069b4:	8526                	mv	a0,s1
420069b6:	c242                	sw	a6,4(sp)
420069b8:	000040ef          	jal	4200a9b8 <vfs_file_open>
        if (!badge_err_is_ok(ec)) {
420069bc:	4098                	lw	a4,0(s1)
420069be:	4812                	lw	a6,4(sp)
420069c0:	2e071d63          	bnez	a4,42006cba <fs_open+0x930>
        shptr->refcount = 0;
420069c4:	100d01e3          	beqz	s10,420072c6 <fs_open+0xf3c>
420069c8:	003d7713          	and	a4,s10,3
420069cc:	0e071de3          	bnez	a4,420072c6 <fs_open+0xf3c>
420069d0:	000d2023          	sw	zero,0(s10)
420069d4:	b57d                	j	42006882 <fs_open+0x4f8>
    } else if (!(oflags & OFLAGS_DIRECTORY) && (oflags & ~VALID_OFLAGS_FILE)) {
420069d6:	4722                	lw	a4,8(sp)
420069d8:	07f00793          	li	a5,127
420069dc:	9ee7f2e3          	bgeu	a5,a4,420063c0 <fs_open+0x36>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
420069e0:	420175b7          	lui	a1,0x42017
420069e4:	4689                	li	a3,2
420069e6:	4635                	li	a2,13
420069e8:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420069ec:	4511                	li	a0,4
420069ee:	00000717          	auipc	a4,0x0
420069f2:	8a9fc0ef          	jal	4200329a <logkf>
420069f6:	180485e3          	beqz	s1,42007380 <fs_open+0xff6>
420069fa:	0034f793          	and	a5,s1,3
420069fe:	180791e3          	bnez	a5,42007380 <fs_open+0xff6>
42006a02:	57f1                	li	a5,-4
42006a04:	14f4f9e3          	bgeu	s1,a5,42007356 <fs_open+0xfcc>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42006a08:	47b5                	li	a5,13
42006a0a:	c0dc                	sw	a5,4(s1)
42006a0c:	4789                	li	a5,2
42006a0e:	c09c                	sw	a5,0(s1)
        return FILE_NONE;
42006a10:	557d                	li	a0,-1
42006a12:	b351                	j	42006796 <fs_open+0x40c>
    if (path[cstr_copy(canon_path, sizeof(canon_path), path)] != 0) {
42006a14:	9c877ae3          	bgeu	a4,s0,420063e8 <fs_open+0x5e>
42006a18:	37212023          	sw	s2,864(sp)
42006a1c:	35312e23          	sw	s3,860(sp)
42006a20:	35412c23          	sw	s4,856(sp)
42006a24:	35512a23          	sw	s5,852(sp)
42006a28:	35612823          	sw	s6,848(sp)
42006a2c:	35712623          	sw	s7,844(sp)
42006a30:	35812423          	sw	s8,840(sp)
42006a34:	35912223          	sw	s9,836(sp)
42006a38:	35a12023          	sw	s10,832(sp)
42006a3c:	9002                	ebreak
    vfs_file_handle_t *ptr      = &vfs_file_handle_list[handle];
42006a3e:	a6d974e3          	bgeu	s2,a3,420064a6 <fs_open+0x11c>
42006a42:	35712623          	sw	s7,844(sp)
42006a46:	35912223          	sw	s9,836(sp)
42006a4a:	35a12023          	sw	s10,832(sp)
42006a4e:	9002                	ebreak
    ptrdiff_t          existing = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
42006a50:	9f867be3          	bgeu	a2,s8,42006446 <fs_open+0xbc>
42006a54:	35712623          	sw	s7,844(sp)
42006a58:	35912223          	sw	s9,836(sp)
42006a5c:	35a12023          	sw	s10,832(sp)
42006a60:	9002                	ebreak
42006a62:	a18678e3          	bgeu	a2,s8,42006472 <fs_open+0xe8>
42006a66:	35712623          	sw	s7,844(sp)
42006a6a:	35912223          	sw	s9,836(sp)
42006a6e:	35a12023          	sw	s10,832(sp)
42006a72:	9002                	ebreak
        vfs_root_open(ec, ptr->shared);
42006a74:	7c090963          	beqz	s2,42007246 <fs_open+0xebc>
42006a78:	00397713          	and	a4,s2,3
42006a7c:	7c071563          	bnez	a4,42007246 <fs_open+0xebc>
42006a80:	5711                	li	a4,-28
42006a82:	7ce97963          	bgeu	s2,a4,42007254 <fs_open+0xeca>
42006a86:	01c92583          	lw	a1,28(s2)
42006a8a:	8526                	mv	a0,s1
42006a8c:	5b5030ef          	jal	4200a840 <vfs_root_open>
        if (!badge_err_is_ok(ec)) {
42006a90:	02048ce3          	beqz	s1,420072c8 <fs_open+0xf3e>
42006a94:	0034f713          	and	a4,s1,3
42006a98:	020718e3          	bnez	a4,420072c8 <fs_open+0xf3e>
42006a9c:	4098                	lw	a4,0(s1)
42006a9e:	a00707e3          	beqz	a4,420064ac <fs_open+0x122>
            vfs_file_destroy_handle(handle);
42006aa2:	8522                	mv	a0,s0
42006aa4:	3af030ef          	jal	4200a652 <vfs_file_destroy_handle>
            mutex_release(NULL, &vfs_handle_mtx);
42006aa8:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006aac:	4501                	li	a0,0
42006aae:	d57fc0ef          	jal	42003804 <mutex_release>
    if (!badge_err_is_ok(ec)) {
42006ab2:	409c                	lw	a5,0(s1)
42006ab4:	4e079663          	bnez	a5,42006fa0 <fs_open+0xc16>
    dirent_t  ent   = {0};
42006ab8:	11000613          	li	a2,272
42006abc:	4581                	li	a1,0
42006abe:	1008                	add	a0,sp,32
42006ac0:	e57fb0ef          	jal	42002916 <memset>
    assert_dev_drop(dir != NULL);
42006ac4:	420175b7          	lui	a1,0x42017
42006ac8:	6f858593          	add	a1,a1,1784 # 420176f8 <hextab+0xa2c>
42006acc:	4501                	li	a0,0
42006ace:	35712623          	sw	s7,844(sp)
42006ad2:	35912223          	sw	s9,836(sp)
42006ad6:	35a12023          	sw	s10,832(sp)
42006ada:	f7afc0ef          	jal	42003254 <logk>
42006ade:	9002                	ebreak
        shptr = vfs_file_shared_list[shared];
42006ae0:	eae6fde3          	bgeu	a3,a4,4200699a <fs_open+0x610>
42006ae4:	9002                	ebreak
            cstr_copy(path + i + 1, FILESYSTEM_PATH_MAX + 1, path + i + 2);
42006ae6:	ceedffe3          	bgeu	s11,a4,420067e4 <fs_open+0x45a>
42006aea:	35712623          	sw	s7,844(sp)
42006aee:	9002                	ebreak
42006af0:	ceddf4e3          	bgeu	s11,a3,420067d8 <fs_open+0x44e>
42006af4:	35712623          	sw	s7,844(sp)
42006af8:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42006afa:	420185b7          	lui	a1,0x42018
42006afe:	85c58593          	add	a1,a1,-1956 # 4201785c <hextab+0xb90>
42006b02:	f52fc0ef          	jal	42003254 <logk>
42006b06:	9002                	ebreak
            mutex_release(NULL, &vfs_handle_mtx);
42006b08:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006b0c:	4501                	li	a0,0
42006b0e:	cf7fc0ef          	jal	42003804 <mutex_release>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
42006b12:	420175b7          	lui	a1,0x42017
42006b16:	4699                	li	a3,6
42006b18:	4635                	li	a2,13
42006b1a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006b1e:	4511                	li	a0,4
42006b20:	00000717          	auipc	a4,0x0
42006b24:	f76fc0ef          	jal	4200329a <logkf>
42006b28:	5771                	li	a4,-4
42006b2a:	7ae4f663          	bgeu	s1,a4,420072d6 <fs_open+0xf4c>
42006b2e:	4735                	li	a4,13
42006b30:	c0d8                	sw	a4,4(s1)
42006b32:	4719                	li	a4,6
42006b34:	c098                	sw	a4,0(s1)
            return;
42006b36:	bb59                	j	420068cc <fs_open+0x542>
        filename = canon_path;
42006b38:	34c12b83          	lw	s7,844(sp)
42006b3c:	89ee                	mv	s3,s11
42006b3e:	b69d                	j	420066a4 <fs_open+0x31a>
    vfs_file_handle_t *ptr = &vfs_file_handle_list[handle];
42006b40:	be8775e3          	bgeu	a4,s0,4200672a <fs_open+0x3a0>
42006b44:	35712623          	sw	s7,844(sp)
42006b48:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42006b4a:	0016e637          	lui	a2,0x16e
42006b4e:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42006b52:	4681                	li	a3,0
42006b54:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006b58:	4501                	li	a0,0
42006b5a:	b19fc0ef          	jal	42003672 <mutex_acquire>
42006b5e:	46050b63          	beqz	a0,42006fd4 <fs_open+0xc4a>
    ptrdiff_t          shared = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
42006b62:	3201a683          	lw	a3,800(gp) # 40800320 <vfs_root_index>
42006b66:	4715                	li	a4,5
42006b68:	7ce6f863          	bgeu	a3,a4,42007338 <fs_open+0xfae>
42006b6c:	03400713          	li	a4,52
42006b70:	02e68733          	mul	a4,a3,a4
42006b74:	00ec0633          	add	a2,s8,a4
42006b78:	0e074c63          	bltz	a4,42006c70 <fs_open+0x8e6>
42006b7c:	0f866c63          	bltu	a2,s8,42006c74 <fs_open+0x8ea>
42006b80:	4611                	li	a2,4
42006b82:	00ec0533          	add	a0,s8,a4
42006b86:	02c6f8e3          	bgeu	a3,a2,420073b6 <fs_open+0x102c>
42006b8a:	0741                	add	a4,a4,16 # 42006b30 <fs_open+0x7a6>
42006b8c:	00ec0633          	add	a2,s8,a4
42006b90:	9a32                	add	s4,s4,a2
42006b92:	0d000593          	li	a1,208
42006b96:	0145eae3          	bltu	a1,s4,420073aa <fs_open+0x1020>
42006b9a:	00ec0633          	add	a2,s8,a4
42006b9e:	0c074e63          	bltz	a4,42006c7a <fs_open+0x8f0>
42006ba2:	0d866e63          	bltu	a2,s8,42006c7e <fs_open+0x8f4>
42006ba6:	03400713          	li	a4,52
42006baa:	02e686b3          	mul	a3,a3,a4
42006bae:	9c36                	add	s8,s8,a3
42006bb0:	010c2583          	lw	a1,16(s8)
42006bb4:	7be030ef          	jal	4200a372 <vfs_shared_by_inode>
    if (shared == -1) {
42006bb8:	577d                	li	a4,-1
    ptrdiff_t          shared = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
42006bba:	842a                	mv	s0,a0
    if (shared == -1) {
42006bbc:	32e50963          	beq	a0,a4,42006eee <fs_open+0xb64>
        shptr = vfs_file_shared_list[shared];
42006bc0:	4080a737          	lui	a4,0x4080a
42006bc4:	e3872683          	lw	a3,-456(a4) # 40809e38 <vfs_file_shared_list>
42006bc8:	00251413          	sll	s0,a0,0x2
42006bcc:	00868733          	add	a4,a3,s0
42006bd0:	0a044a63          	bltz	s0,42006c84 <fs_open+0x8fa>
42006bd4:	0ad76a63          	bltu	a4,a3,42006c88 <fs_open+0x8fe>
42006bd8:	7e070563          	beqz	a4,420073c2 <fs_open+0x1038>
42006bdc:	00377693          	and	a3,a4,3
42006be0:	7e069163          	bnez	a3,420073c2 <fs_open+0x1038>
42006be4:	4300                	lw	s0,0(a4)
    vfs_file_shared_t *old = dir->shared;
42006be6:	5711                	li	a4,-28
42006be8:	7ce97a63          	bgeu	s2,a4,420073bc <fs_open+0x1032>
42006bec:	01c92a03          	lw	s4,28(s2)
    dir->shared            = shptr;
42006bf0:	00892e23          	sw	s0,28(s2)
    shptr->refcount++;
42006bf4:	7e040463          	beqz	s0,420073dc <fs_open+0x1052>
42006bf8:	00347713          	and	a4,s0,3
42006bfc:	7e071063          	bnez	a4,420073dc <fs_open+0x1052>
42006c00:	4018                	lw	a4,0(s0)
42006c02:	0705                	add	a4,a4,1
42006c04:	c018                	sw	a4,0(s0)
    old->refcount--;
42006c06:	7c0a0863          	beqz	s4,420073d6 <fs_open+0x104c>
42006c0a:	003a7713          	and	a4,s4,3
42006c0e:	7c071463          	bnez	a4,420073d6 <fs_open+0x104c>
42006c12:	000a2703          	lw	a4,0(s4)
42006c16:	177d                	add	a4,a4,-1
42006c18:	00ea2023          	sw	a4,0(s4)
    if (old->refcount == 0) {
42006c1c:	26070963          	beqz	a4,42006e8e <fs_open+0xb04>
        badge_err_set_ok(ec);
42006c20:	5771                	li	a4,-4
42006c22:	7ae4f763          	bgeu	s1,a4,420073d0 <fs_open+0x1046>
42006c26:	0004a223          	sw	zero,4(s1)
42006c2a:	0004a023          	sw	zero,0(s1)
    mutex_release(NULL, &vfs_handle_mtx);
42006c2e:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006c32:	4501                	li	a0,0
42006c34:	bd1fc0ef          	jal	42003804 <mutex_release>
        if (!badge_err_is_ok(ec)) {
42006c38:	4098                	lw	a4,0(s1)
42006c3a:	16071f63          	bnez	a4,42006db8 <fs_open+0xa2e>
    if (path[0] == '/' && len == 1) {
42006c3e:	13014683          	lbu	a3,304(sp)
42006c42:	02f00713          	li	a4,47
42006c46:	92e692e3          	bne	a3,a4,4200656a <fs_open+0x1e0>
42006c4a:	4705                	li	a4,1
42006c4c:	90e99fe3          	bne	s3,a4,4200656a <fs_open+0x1e0>
        filename = ".";
42006c50:	42017737          	lui	a4,0x42017
    bool      found = ent.inode;
42006c54:	5412                	lw	s0,36(sp)
        filename = ".";
42006c56:	65070993          	add	s3,a4,1616 # 42017650 <hextab+0x984>
42006c5a:	b4a9                	j	420066a4 <fs_open+0x31a>
        is_dir   = (oflags & OFLAGS_DIRECTORY);
42006c5c:	47b2                	lw	a5,12(sp)
        existing = -1;
42006c5e:	5c7d                	li	s8,-1
        is_dir   = (oflags & OFLAGS_DIRECTORY);
42006c60:	00f03a33          	snez	s4,a5
        existing = -1;
42006c64:	bc71                	j	42006700 <fs_open+0x376>
        filename = canon_path + slash;
42006c66:	6cdde263          	bltu	s11,a3,4200732a <fs_open+0xfa0>
42006c6a:	34c12b83          	lw	s7,844(sp)
42006c6e:	bc0d                	j	420066a0 <fs_open+0x316>
    ptrdiff_t          shared = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
42006c70:	f0cc78e3          	bgeu	s8,a2,42006b80 <fs_open+0x7f6>
42006c74:	35712623          	sw	s7,844(sp)
42006c78:	9002                	ebreak
42006c7a:	f2cc76e3          	bgeu	s8,a2,42006ba6 <fs_open+0x81c>
42006c7e:	35712623          	sw	s7,844(sp)
42006c82:	9002                	ebreak
        shptr = vfs_file_shared_list[shared];
42006c84:	f4e6fae3          	bgeu	a3,a4,42006bd8 <fs_open+0x84e>
42006c88:	35712623          	sw	s7,844(sp)
42006c8c:	9002                	ebreak
        filename = ".";
42006c8e:	42017737          	lui	a4,0x42017
42006c92:	34c12b83          	lw	s7,844(sp)
42006c96:	65070993          	add	s3,a4,1616 # 42017650 <hextab+0x984>
42006c9a:	b429                	j	420066a4 <fs_open+0x31a>
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42006c9c:	420175b7          	lui	a1,0x42017
42006ca0:	65458593          	add	a1,a1,1620 # 42017654 <hextab+0x988>
42006ca4:	35712623          	sw	s7,844(sp)
42006ca8:	35812423          	sw	s8,840(sp)
42006cac:	35912223          	sw	s9,836(sp)
42006cb0:	35a12023          	sw	s10,832(sp)
42006cb4:	da0fc0ef          	jal	42003254 <logk>
42006cb8:	9002                	ebreak
            vfs_file_destroy_shared(shared);
42006cba:	8542                	mv	a0,a6
42006cbc:	193030ef          	jal	4200a64e <vfs_file_destroy_shared>
            mutex_release(NULL, &vfs_handle_mtx);
42006cc0:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006cc4:	4501                	li	a0,0
42006cc6:	b3ffc0ef          	jal	42003804 <mutex_release>
            return;
42006cca:	b109                	j	420068cc <fs_open+0x542>
        badge_err_assert_dev(ec);
42006ccc:	70f4f163          	bgeu	s1,a5,420073ce <fs_open+0x1044>
42006cd0:	40c8                	lw	a0,4(s1)
42006cd2:	87efa0ef          	jal	42000d50 <badge_eloc_get_name>
42006cd6:	842a                	mv	s0,a0
42006cd8:	856a                	mv	a0,s10
42006cda:	8b4fa0ef          	jal	42000d8e <badge_ecause_get_name>
42006cde:	42018637          	lui	a2,0x42018
42006ce2:	420175b7          	lui	a1,0x42017
42006ce6:	87aa                	mv	a5,a0
42006ce8:	8722                	mv	a4,s0
42006cea:	06e00693          	li	a3,110
42006cee:	81460613          	add	a2,a2,-2028 # 42017814 <hextab+0xb48>
42006cf2:	df058593          	add	a1,a1,-528 # 42016df0 <hextab+0x124>
42006cf6:	4501                	li	a0,0
42006cf8:	da2fc0ef          	jal	4200329a <logkf>
42006cfc:	9002                	ebreak
    if (path[0] == '/') {
42006cfe:	13014683          	lbu	a3,304(sp)
42006d02:	02f00713          	li	a4,47
42006d06:	e4e682e3          	beq	a3,a4,42006b4a <fs_open+0x7c0>
42006d0a:	4401                	li	s0,0
    if (!badge_err_is_ok(ec)) {
42006d0c:	4098                	lw	a4,0(s1)
42006d0e:	e74d                	bnez	a4,42006db8 <fs_open+0xa2e>
42006d10:	86ee                	mv	a3,s11
42006d12:	4d01                	li	s10,0
        filename = canon_path + slash;
42006d14:	99b6f6e3          	bgeu	a3,s11,420066a0 <fs_open+0x316>
42006d18:	a539                	j	42007326 <fs_open+0xf9c>
        vfs_file_shared_t *shared = ptr->shared;
42006d1a:	5791                	li	a5,-28
42006d1c:	62f47763          	bgeu	s0,a5,4200734a <fs_open+0xfc0>
42006d20:	01c42a03          	lw	s4,28(s0)
        vfs_file_open(ec, parent->shared, shared, filename, oflags);
42006d24:	62f97063          	bgeu	s2,a5,42007344 <fs_open+0xfba>
42006d28:	01c92583          	lw	a1,28(s2)
42006d2c:	4722                	lw	a4,8(sp)
42006d2e:	86ce                	mv	a3,s3
42006d30:	8652                	mv	a2,s4
42006d32:	8526                	mv	a0,s1
42006d34:	485030ef          	jal	4200a9b8 <vfs_file_open>
        if (!badge_err_is_ok(ec)) {
42006d38:	409c                	lw	a5,0(s1)
42006d3a:	28079463          	bnez	a5,42006fc2 <fs_open+0xc38>
        shared->refcount = 1;
42006d3e:	600a0063          	beqz	s4,4200733e <fs_open+0xfb4>
42006d42:	003a7793          	and	a5,s4,3
42006d46:	5e079c63          	bnez	a5,4200733e <fs_open+0xfb4>
42006d4a:	4785                	li	a5,1
42006d4c:	00fa2023          	sw	a5,0(s4)
42006d50:	bc01                	j	42006760 <fs_open+0x3d6>
        if (ent.is_dir && !(oflags & OFLAGS_DIRECTORY)) {
42006d52:	980793e3          	bnez	a5,420066d8 <fs_open+0x34e>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_DIR);
42006d56:	420175b7          	lui	a1,0x42017
42006d5a:	46e5                	li	a3,25
42006d5c:	4635                	li	a2,13
42006d5e:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006d62:	4511                	li	a0,4
42006d64:	00000717          	auipc	a4,0x0
42006d68:	d32fc0ef          	jal	4200329a <logkf>
42006d6c:	57f1                	li	a5,-4
42006d6e:	56f4f863          	bgeu	s1,a5,420072de <fs_open+0xf54>
42006d72:	47b5                	li	a5,13
42006d74:	c0dc                	sw	a5,4(s1)
42006d76:	47e5                	li	a5,25
42006d78:	c09c                	sw	a5,0(s1)
            mutex_release(NULL, &vfs_handle_mtx);
42006d7a:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006d7e:	4501                	li	a0,0
42006d80:	a85fc0ef          	jal	42003804 <mutex_release>
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42006d84:	0016e637          	lui	a2,0x16e
42006d88:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42006d8c:	4681                	li	a3,0
42006d8e:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006d92:	4501                	li	a0,0
42006d94:	8dffc0ef          	jal	42003672 <mutex_acquire>
42006d98:	2c050d63          	beqz	a0,42007072 <fs_open+0xce8>
    ptrdiff_t index = vfs_file_by_handle(parent->fileno);
42006d9c:	5781                	li	a5,-32
42006d9e:	52f97d63          	bgeu	s2,a5,420072d8 <fs_open+0xf4e>
42006da2:	02092503          	lw	a0,32(s2)
42006da6:	642030ef          	jal	4200a3e8 <vfs_file_by_handle>
    vfs_file_destroy_handle(index);
42006daa:	0a9030ef          	jal	4200a652 <vfs_file_destroy_handle>
    mutex_release(NULL, &vfs_handle_mtx);
42006dae:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006db2:	4501                	li	a0,0
42006db4:	a51fc0ef          	jal	42003804 <mutex_release>
    return FILE_NONE;
42006db8:	36012903          	lw	s2,864(sp)
42006dbc:	35c12983          	lw	s3,860(sp)
42006dc0:	35812a03          	lw	s4,856(sp)
42006dc4:	35412a83          	lw	s5,852(sp)
42006dc8:	35012b03          	lw	s6,848(sp)
42006dcc:	34812c03          	lw	s8,840(sp)
42006dd0:	34412c83          	lw	s9,836(sp)
42006dd4:	34012d03          	lw	s10,832(sp)
42006dd8:	33c12d83          	lw	s11,828(sp)
        return FILE_NONE;
42006ddc:	557d                	li	a0,-1
42006dde:	ba65                	j	42006796 <fs_open+0x40c>
    while (len > 1 && path[len - 1] == '/') {
42006de0:	4685                	li	a3,1
    bool      found = ent.inode;
42006de2:	5412                	lw	s0,36(sp)
                begin = -1;
42006de4:	5d7d                	li	s10,-1
    while (len > 1 && path[len - 1] == '/') {
42006de6:	84d999e3          	bne	s3,a3,42006638 <fs_open+0x2ae>
42006dea:	bcf5                	j	420068e6 <fs_open+0x55c>
            badge_err_set_ok(ec);
42006dec:	56f1                	li	a3,-4
42006dee:	46d4fd63          	bgeu	s1,a3,42007268 <fs_open+0xede>
42006df2:	0004a223          	sw	zero,4(s1)
42006df6:	0004a023          	sw	zero,0(s1)
                ent->inode = 0;
42006dfa:	d202                	sw	zero,36(sp)
42006dfc:	4401                	li	s0,0
42006dfe:	835ff06f          	j	42006632 <fs_open+0x2a8>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
42006e02:	420175b7          	lui	a1,0x42017
42006e06:	46e9                	li	a3,26
42006e08:	4635                	li	a2,13
42006e0a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006e0e:	4511                	li	a0,4
42006e10:	00000717          	auipc	a4,0x0
42006e14:	c86fc0ef          	jal	4200329a <logkf>
42006e18:	57f1                	li	a5,-4
42006e1a:	52f4fb63          	bgeu	s1,a5,42007350 <fs_open+0xfc6>
42006e1e:	47b5                	li	a5,13
42006e20:	c0dc                	sw	a5,4(s1)
42006e22:	47e9                	li	a5,26
42006e24:	c09c                	sw	a5,0(s1)
            mutex_release(NULL, &vfs_handle_mtx);
42006e26:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006e2a:	4501                	li	a0,0
42006e2c:	9d9fc0ef          	jal	42003804 <mutex_release>
            goto error;
42006e30:	bf91                	j	42006d84 <fs_open+0x9fa>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42006e32:	420175b7          	lui	a1,0x42017
42006e36:	4689                	li	a3,2
42006e38:	4635                	li	a2,13
42006e3a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006e3e:	4511                	li	a0,4
42006e40:	00000717          	auipc	a4,0x0
42006e44:	c56fc0ef          	jal	4200329a <logkf>
42006e48:	58048d63          	beqz	s1,420073e2 <fs_open+0x1058>
42006e4c:	0034f793          	and	a5,s1,3
42006e50:	58079963          	bnez	a5,420073e2 <fs_open+0x1058>
42006e54:	57f1                	li	a5,-4
42006e56:	baf4e9e3          	bltu	s1,a5,42006a08 <fs_open+0x67e>
42006e5a:	37212023          	sw	s2,864(sp)
42006e5e:	35312e23          	sw	s3,860(sp)
42006e62:	35412c23          	sw	s4,856(sp)
42006e66:	35512a23          	sw	s5,852(sp)
42006e6a:	35612823          	sw	s6,848(sp)
42006e6e:	35712623          	sw	s7,844(sp)
42006e72:	35812423          	sw	s8,840(sp)
42006e76:	35912223          	sw	s9,836(sp)
42006e7a:	35a12023          	sw	s10,832(sp)
42006e7e:	33b12e23          	sw	s11,828(sp)
42006e82:	9002                	ebreak
        bool is_int = path[end] == '/' && path[end + 1] != 0;
42006e84:	019b86b3          	add	a3,s7,s9
42006e88:	f976e963          	bltu	a3,s7,4200661a <fs_open+0x290>
42006e8c:	9002                	ebreak
        vfs_file_close(ec, old);
42006e8e:	85d2                	mv	a1,s4
42006e90:	8526                	mv	a0,s1
42006e92:	495030ef          	jal	4200ab26 <vfs_file_close>
        badge_err_assert_dev(ec);
42006e96:	4080                	lw	s0,0(s1)
42006e98:	22041063          	bnez	s0,420070b8 <fs_open+0xd2e>
        vfs_file_destroy_shared(old->index);
42006e9c:	5771                	li	a4,-4
42006e9e:	3aea7063          	bgeu	s4,a4,4200723e <fs_open+0xeb4>
42006ea2:	004a2503          	lw	a0,4(s4)
42006ea6:	7a8030ef          	jal	4200a64e <vfs_file_destroy_shared>
42006eaa:	b351                	j	42006c2e <fs_open+0x8a4>
    assert_always(mutex_acquire(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42006eac:	420185b7          	lui	a1,0x42018
42006eb0:	8fc58593          	add	a1,a1,-1796 # 420178fc <hextab+0xc30>
42006eb4:	35712623          	sw	s7,844(sp)
42006eb8:	b9cfc0ef          	jal	42003254 <logk>
42006ebc:	9002                	ebreak
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
42006ebe:	420175b7          	lui	a1,0x42017
42006ec2:	4699                	li	a3,6
42006ec4:	4635                	li	a2,13
42006ec6:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006eca:	4511                	li	a0,4
42006ecc:	00000717          	auipc	a4,0x0
42006ed0:	bcafc0ef          	jal	4200329a <logkf>
42006ed4:	57f1                	li	a5,-4
42006ed6:	4ef4f963          	bgeu	s1,a5,420073c8 <fs_open+0x103e>
42006eda:	47b5                	li	a5,13
42006edc:	c0dc                	sw	a5,4(s1)
42006ede:	4799                	li	a5,6
42006ee0:	c09c                	sw	a5,0(s1)
        mutex_release(NULL, &vfs_handle_mtx);
42006ee2:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006ee6:	4501                	li	a0,0
42006ee8:	91dfc0ef          	jal	42003804 <mutex_release>
        goto error;
42006eec:	bd61                	j	42006d84 <fs_open+0x9fa>
        shared = vfs_file_create_shared();
42006eee:	550030ef          	jal	4200a43e <vfs_file_create_shared>
42006ef2:	8a2a                	mv	s4,a0
        if (shared == -1) {
42006ef4:	18850863          	beq	a0,s0,42007084 <fs_open+0xcfa>
        shptr = vfs_file_shared_list[shared];
42006ef8:	4080a737          	lui	a4,0x4080a
42006efc:	e3872683          	lw	a3,-456(a4) # 40809e38 <vfs_file_shared_list>
42006f00:	00251613          	sll	a2,a0,0x2
42006f04:	00c68733          	add	a4,a3,a2
42006f08:	06064463          	bltz	a2,42006f70 <fs_open+0xbe6>
42006f0c:	06d76463          	bltu	a4,a3,42006f74 <fs_open+0xbea>
42006f10:	3a070763          	beqz	a4,420072be <fs_open+0xf34>
42006f14:	00377693          	and	a3,a4,3
42006f18:	3a069363          	bnez	a3,420072be <fs_open+0xf34>
42006f1c:	4300                	lw	s0,0(a4)
        vfs_root_open(ec, shptr);
42006f1e:	8526                	mv	a0,s1
42006f20:	85a2                	mv	a1,s0
42006f22:	11f030ef          	jal	4200a840 <vfs_root_open>
        if (!badge_err_is_ok(ec)) {
42006f26:	4098                	lw	a4,0(s1)
42006f28:	1c071563          	bnez	a4,420070f2 <fs_open+0xd68>
        shptr->refcount = 0;
42006f2c:	38040563          	beqz	s0,420072b6 <fs_open+0xf2c>
42006f30:	00347713          	and	a4,s0,3
42006f34:	38071163          	bnez	a4,420072b6 <fs_open+0xf2c>
42006f38:	00042023          	sw	zero,0(s0)
42006f3c:	b16d                	j	42006be6 <fs_open+0x85c>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTFOUND);
42006f3e:	420175b7          	lui	a1,0x42017
42006f42:	46e1                	li	a3,24
42006f44:	4635                	li	a2,13
42006f46:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006f4a:	4511                	li	a0,4
42006f4c:	00000717          	auipc	a4,0x0
42006f50:	b4afc0ef          	jal	4200329a <logkf>
42006f54:	5771                	li	a4,-4
42006f56:	4ae4fb63          	bgeu	s1,a4,4200740c <fs_open+0x1082>
42006f5a:	4735                	li	a4,13
42006f5c:	c0d8                	sw	a4,4(s1)
42006f5e:	4761                	li	a4,24
42006f60:	c098                	sw	a4,0(s1)
    while (len > 1 && path[len - 1] == '/') {
42006f62:	4705                	li	a4,1
42006f64:	98e981e3          	beq	s3,a4,420068e6 <fs_open+0x55c>
    bool      found = ent.inode;
42006f68:	5412                	lw	s0,36(sp)
                begin = -1;
42006f6a:	5d7d                	li	s10,-1
42006f6c:	eccff06f          	j	42006638 <fs_open+0x2ae>
        shptr = vfs_file_shared_list[shared];
42006f70:	fae6f0e3          	bgeu	a3,a4,42006f10 <fs_open+0xb86>
42006f74:	35712623          	sw	s7,844(sp)
42006f78:	9002                	ebreak
                badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
42006f7a:	420175b7          	lui	a1,0x42017
42006f7e:	46e9                	li	a3,26
42006f80:	4635                	li	a2,13
42006f82:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006f86:	4511                	li	a0,4
42006f88:	00000717          	auipc	a4,0x0
42006f8c:	b0efc0ef          	jal	4200329a <logkf>
42006f90:	57f1                	li	a5,-4
42006f92:	32f4f563          	bgeu	s1,a5,420072bc <fs_open+0xf32>
42006f96:	47b5                	li	a5,13
42006f98:	c0dc                	sw	a5,4(s1)
42006f9a:	47e9                	li	a5,26
42006f9c:	c09c                	sw	a5,0(s1)
    if (!badge_err_is_ok(ec)) {
42006f9e:	b2a1                	j	420068e6 <fs_open+0x55c>
42006fa0:	36012903          	lw	s2,864(sp)
42006fa4:	35c12983          	lw	s3,860(sp)
42006fa8:	35812a03          	lw	s4,856(sp)
42006fac:	35412a83          	lw	s5,852(sp)
42006fb0:	35012b03          	lw	s6,848(sp)
42006fb4:	34812c03          	lw	s8,840(sp)
42006fb8:	33c12d83          	lw	s11,828(sp)
        return FILE_NONE;
42006fbc:	557d                	li	a0,-1
42006fbe:	fd8ff06f          	j	42006796 <fs_open+0x40c>
            vfs_file_destroy_handle(handle);
42006fc2:	855a                	mv	a0,s6
42006fc4:	68e030ef          	jal	4200a652 <vfs_file_destroy_handle>
            mutex_release(NULL, &vfs_handle_mtx);
42006fc8:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42006fcc:	4501                	li	a0,0
42006fce:	837fc0ef          	jal	42003804 <mutex_release>
            goto error;
42006fd2:	bb4d                	j	42006d84 <fs_open+0x9fa>
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42006fd4:	420175b7          	lui	a1,0x42017
42006fd8:	77458593          	add	a1,a1,1908 # 42017774 <hextab+0xaa8>
42006fdc:	35712623          	sw	s7,844(sp)
42006fe0:	a74fc0ef          	jal	42003254 <logk>
42006fe4:	9002                	ebreak
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_TOOLONG);
42006fe6:	420175b7          	lui	a1,0x42017
42006fea:	4691                	li	a3,4
42006fec:	4635                	li	a2,13
42006fee:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42006ff2:	4511                	li	a0,4
42006ff4:	00000717          	auipc	a4,0x0
42006ff8:	aa2fc0ef          	jal	4200329a <logkf>
42006ffc:	28048a63          	beqz	s1,42007290 <fs_open+0xf06>
42007000:	0034f793          	and	a5,s1,3
42007004:	28079663          	bnez	a5,42007290 <fs_open+0xf06>
42007008:	57f1                	li	a5,-4
4200700a:	26f4f063          	bgeu	s1,a5,4200726a <fs_open+0xee0>
4200700e:	47b5                	li	a5,13
42007010:	c0dc                	sw	a5,4(s1)
42007012:	4791                	li	a5,4
        return FILE_NONE;
42007014:	33c12d83          	lw	s11,828(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_TOOLONG);
42007018:	c09c                	sw	a5,0(s1)
        return FILE_NONE;
4200701a:	557d                	li	a0,-1
4200701c:	f7aff06f          	j	42006796 <fs_open+0x40c>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42007020:	420175b7          	lui	a1,0x42017
42007024:	4689                	li	a3,2
42007026:	4635                	li	a2,13
42007028:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200702c:	4511                	li	a0,4
4200702e:	00000717          	auipc	a4,0x0
42007032:	a68fc0ef          	jal	4200329a <logkf>
42007036:	2a048763          	beqz	s1,420072e4 <fs_open+0xf5a>
4200703a:	0034f793          	and	a5,s1,3
4200703e:	2a079363          	bnez	a5,420072e4 <fs_open+0xf5a>
42007042:	57f1                	li	a5,-4
42007044:	9cf4e2e3          	bltu	s1,a5,42006a08 <fs_open+0x67e>
42007048:	37212023          	sw	s2,864(sp)
4200704c:	35312e23          	sw	s3,860(sp)
42007050:	35412c23          	sw	s4,856(sp)
42007054:	35512a23          	sw	s5,852(sp)
42007058:	35612823          	sw	s6,848(sp)
4200705c:	35712623          	sw	s7,844(sp)
42007060:	35812423          	sw	s8,840(sp)
42007064:	35912223          	sw	s9,836(sp)
42007068:	35a12023          	sw	s10,832(sp)
4200706c:	33b12e23          	sw	s11,828(sp)
42007070:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42007072:	420185b7          	lui	a1,0x42018
42007076:	99c58593          	add	a1,a1,-1636 # 4201799c <hextab+0xcd0>
4200707a:	35712623          	sw	s7,844(sp)
4200707e:	9d6fc0ef          	jal	42003254 <logk>
42007082:	9002                	ebreak
            mutex_release(NULL, &vfs_handle_mtx);
42007084:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42007088:	4501                	li	a0,0
4200708a:	f7afc0ef          	jal	42003804 <mutex_release>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
4200708e:	420175b7          	lui	a1,0x42017
42007092:	4699                	li	a3,6
42007094:	4635                	li	a2,13
42007096:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200709a:	4511                	li	a0,4
4200709c:	00000717          	auipc	a4,0x0
420070a0:	9fafc0ef          	jal	4200329a <logkf>
420070a4:	5771                	li	a4,-4
420070a6:	36e4f463          	bgeu	s1,a4,4200740e <fs_open+0x1084>
420070aa:	4735                	li	a4,13
420070ac:	c0d8                	sw	a4,4(s1)
420070ae:	4719                	li	a4,6
420070b0:	c098                	sw	a4,0(s1)
            return;
420070b2:	b659                	j	42006c38 <fs_open+0x8ae>
    bool      found = ent.inode;
420070b4:	5412                	lw	s0,36(sp)
420070b6:	b999                	j	42006d0c <fs_open+0x982>
        badge_err_assert_dev(ec);
420070b8:	57f1                	li	a5,-4
420070ba:	35712623          	sw	s7,844(sp)
420070be:	20f4f363          	bgeu	s1,a5,420072c4 <fs_open+0xf3a>
420070c2:	40c8                	lw	a0,4(s1)
420070c4:	c8df90ef          	jal	42000d50 <badge_eloc_get_name>
420070c8:	87aa                	mv	a5,a0
420070ca:	8522                	mv	a0,s0
420070cc:	843e                	mv	s0,a5
420070ce:	cc1f90ef          	jal	42000d8e <badge_ecause_get_name>
420070d2:	42018637          	lui	a2,0x42018
420070d6:	420175b7          	lui	a1,0x42017
420070da:	87aa                	mv	a5,a0
420070dc:	8722                	mv	a4,s0
420070de:	03800693          	li	a3,56
420070e2:	81460613          	add	a2,a2,-2028 # 42017814 <hextab+0xb48>
420070e6:	df058593          	add	a1,a1,-528 # 42016df0 <hextab+0x124>
420070ea:	4501                	li	a0,0
420070ec:	9aefc0ef          	jal	4200329a <logkf>
420070f0:	9002                	ebreak
            vfs_file_destroy_shared(shared);
420070f2:	8552                	mv	a0,s4
420070f4:	55a030ef          	jal	4200a64e <vfs_file_destroy_shared>
            mutex_release(NULL, &vfs_handle_mtx);
420070f8:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420070fc:	4501                	li	a0,0
420070fe:	f06fc0ef          	jal	42003804 <mutex_release>
            return;
42007102:	be1d                	j	42006c38 <fs_open+0x8ae>
        if (path[begin] == '/') {
42007104:	9002                	ebreak
        if (path[i] == '/' && path[i + 1] == '/') {
42007106:	00e68633          	add	a2,a3,a4
4200710a:	c4d66363          	bltu	a2,a3,42006550 <fs_open+0x1c6>
4200710e:	35712623          	sw	s7,844(sp)
42007112:	9002                	ebreak
42007114:	35712623          	sw	s7,844(sp)
42007118:	9002                	ebreak
        if (path[begin] == '/') {
4200711a:	00c685b3          	add	a1,a3,a2
4200711e:	c6d5ed63          	bltu	a1,a3,42006598 <fs_open+0x20e>
42007122:	9002                	ebreak
    shptr->refcount++;
42007124:	9002                	ebreak
        path[len - 1] = 0;
42007126:	99b2                	add	s3,s3,a2
42007128:	d2c9e863          	bltu	s3,a2,42006658 <fs_open+0x2ce>
4200712c:	9002                	ebreak
    while (len > 1 && path[len - 1] == '/') {
4200712e:	01360533          	add	a0,a2,s3
42007132:	d4c56263          	bltu	a0,a2,42006676 <fs_open+0x2ec>
42007136:	9002                	ebreak
        path[len - 1] = 0;
42007138:	9002                	ebreak
        path[end]   = 0;
4200713a:	9002                	ebreak
        char tmp    = path[end];
4200713c:	019b8633          	add	a2,s7,s9
42007140:	c9766663          	bltu	a2,s7,420065cc <fs_open+0x242>
42007144:	9002                	ebreak
42007146:	9002                	ebreak
        if (path[i] == '/' && path[i + 1] == '/') {
42007148:	00c506b3          	add	a3,a0,a2
4200714c:	e6a6ec63          	bltu	a3,a0,420067c4 <fs_open+0x43a>
42007150:	35712623          	sw	s7,844(sp)
42007154:	9002                	ebreak
    old->refcount--;
42007156:	9002                	ebreak
            badge_err_set_ok(ec);
42007158:	9002                	ebreak
    ptrdiff_t          shared = vfs_shared_by_inode(dir->shared->vfs, ent->inode);
4200715a:	9002                	ebreak
4200715c:	35712623          	sw	s7,844(sp)
        if (path[i] == '/' && path[i + 1] == '/') {
42007160:	9002                	ebreak
        bool is_int = path[end] == '/' && path[end + 1] != 0;
42007162:	9002                	ebreak
        path[end]   = tmp;
42007164:	019b86b3          	add	a3,s7,s9
42007168:	cb76e163          	bltu	a3,s7,4200660a <fs_open+0x280>
4200716c:	9002                	ebreak
4200716e:	9002                	ebreak
    while (len > 1 && path[len - 1] == '/') {
42007170:	9002                	ebreak
42007172:	9002                	ebreak
        char tmp    = path[end];
42007174:	9002                	ebreak
        found       = vfs_dir_find_ent(ec, dir->shared, ent, path + begin);
42007176:	9002                	ebreak
    ptrdiff_t          shared = vfs_shared_by_inode(dir->shared->vfs, ent->inode);
42007178:	9002                	ebreak
        shptr = vfs_file_shared_list[shared];
4200717a:	9002                	ebreak
        path[end]   = 0;
4200717c:	019b8633          	add	a2,s7,s9
42007180:	c5766e63          	bltu	a2,s7,420065dc <fs_open+0x252>
42007184:	9002                	ebreak
    ptrdiff_t          existing = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
42007186:	962e                	add	a2,a2,a1
42007188:	acb66f63          	bltu	a2,a1,42006466 <fs_open+0xdc>
4200718c:	35712623          	sw	s7,844(sp)
42007190:	35912223          	sw	s9,836(sp)
42007194:	35a12023          	sw	s10,832(sp)
42007198:	9002                	ebreak
        bool is_int = path[end] == '/' && path[end + 1] != 0;
4200719a:	96c2                	add	a3,a3,a6
4200719c:	e706eb63          	bltu	a3,a6,42006812 <fs_open+0x488>
420071a0:	9002                	ebreak
420071a2:	35712623          	sw	s7,844(sp)
420071a6:	35912223          	sw	s9,836(sp)
420071aa:	35a12023          	sw	s10,832(sp)
    ptr->dir_cache      = NULL;
420071ae:	9002                	ebreak
420071b0:	35712623          	sw	s7,844(sp)
420071b4:	35912223          	sw	s9,836(sp)
420071b8:	35a12023          	sw	s10,832(sp)
    ptr->is_dir         = true;
420071bc:	9002                	ebreak
420071be:	35712623          	sw	s7,844(sp)
420071c2:	35912223          	sw	s9,836(sp)
420071c6:	35a12023          	sw	s10,832(sp)
    ptr->read           = true;
420071ca:	9002                	ebreak
420071cc:	35712623          	sw	s7,844(sp)
420071d0:	35912223          	sw	s9,836(sp)
420071d4:	35a12023          	sw	s10,832(sp)
    ptrdiff_t          existing = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
420071d8:	9002                	ebreak
420071da:	35712623          	sw	s7,844(sp)
420071de:	35912223          	sw	s9,836(sp)
420071e2:	35a12023          	sw	s10,832(sp)
420071e6:	9002                	ebreak
420071e8:	37212023          	sw	s2,864(sp)
420071ec:	35312e23          	sw	s3,860(sp)
420071f0:	35412c23          	sw	s4,856(sp)
420071f4:	35512a23          	sw	s5,852(sp)
420071f8:	35612823          	sw	s6,848(sp)
420071fc:	35712623          	sw	s7,844(sp)
42007200:	35812423          	sw	s8,840(sp)
42007204:	35912223          	sw	s9,836(sp)
42007208:	35a12023          	sw	s10,832(sp)
    if (path[cstr_copy(canon_path, sizeof(canon_path), path)] != 0) {
4200720c:	9002                	ebreak
        bool is_int = path[end] == '/' && path[end + 1] != 0;
4200720e:	9002                	ebreak
        vfs_file_destroy_shared(old->index);
42007210:	9002                	ebreak
42007212:	35712623          	sw	s7,844(sp)
42007216:	35912223          	sw	s9,836(sp)
4200721a:	35a12023          	sw	s10,832(sp)
    if (!badge_err_is_ok(ec)) {
4200721e:	9002                	ebreak
        badge_err_set_ok(ec);
42007220:	9002                	ebreak
42007222:	35712623          	sw	s7,844(sp)
42007226:	35912223          	sw	s9,836(sp)
4200722a:	35a12023          	sw	s10,832(sp)
    ptr->write          = false;
4200722e:	9002                	ebreak
42007230:	35712623          	sw	s7,844(sp)
42007234:	35912223          	sw	s9,836(sp)
42007238:	35a12023          	sw	s10,832(sp)
    ptr->offset         = 0;
4200723c:	9002                	ebreak
4200723e:	35712623          	sw	s7,844(sp)
        vfs_file_destroy_shared(old->index);
42007242:	9002                	ebreak
        shptr = vfs_file_shared_list[shared];
42007244:	9002                	ebreak
42007246:	35712623          	sw	s7,844(sp)
4200724a:	35912223          	sw	s9,836(sp)
4200724e:	35a12023          	sw	s10,832(sp)
        vfs_root_open(ec, ptr->shared);
42007252:	9002                	ebreak
42007254:	35712623          	sw	s7,844(sp)
42007258:	35912223          	sw	s9,836(sp)
4200725c:	35a12023          	sw	s10,832(sp)
42007260:	9002                	ebreak
42007262:	35712623          	sw	s7,844(sp)
    return ptr->fileno;
42007266:	9002                	ebreak
            badge_err_set_ok(ec);
42007268:	9002                	ebreak
4200726a:	37212023          	sw	s2,864(sp)
4200726e:	35312e23          	sw	s3,860(sp)
42007272:	35412c23          	sw	s4,856(sp)
42007276:	35512a23          	sw	s5,852(sp)
4200727a:	35612823          	sw	s6,848(sp)
4200727e:	35712623          	sw	s7,844(sp)
42007282:	35812423          	sw	s8,840(sp)
42007286:	35912223          	sw	s9,836(sp)
4200728a:	35a12023          	sw	s10,832(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_TOOLONG);
4200728e:	9002                	ebreak
42007290:	37212023          	sw	s2,864(sp)
42007294:	35312e23          	sw	s3,860(sp)
42007298:	35412c23          	sw	s4,856(sp)
4200729c:	35512a23          	sw	s5,852(sp)
420072a0:	35612823          	sw	s6,848(sp)
420072a4:	35712623          	sw	s7,844(sp)
420072a8:	35812423          	sw	s8,840(sp)
420072ac:	35912223          	sw	s9,836(sp)
420072b0:	35a12023          	sw	s10,832(sp)
420072b4:	9002                	ebreak
420072b6:	35712623          	sw	s7,844(sp)
        shptr->refcount = 0;
420072ba:	9002                	ebreak
                badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
420072bc:	9002                	ebreak
420072be:	35712623          	sw	s7,844(sp)
        shptr = vfs_file_shared_list[shared];
420072c2:	9002                	ebreak
        badge_err_assert_dev(ec);
420072c4:	9002                	ebreak
        shptr->refcount = 0;
420072c6:	9002                	ebreak
420072c8:	35712623          	sw	s7,844(sp)
420072cc:	35912223          	sw	s9,836(sp)
420072d0:	35a12023          	sw	s10,832(sp)
        if (!badge_err_is_ok(ec)) {
420072d4:	9002                	ebreak
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
420072d6:	9002                	ebreak
420072d8:	35712623          	sw	s7,844(sp)
    ptrdiff_t index = vfs_file_by_handle(parent->fileno);
420072dc:	9002                	ebreak
420072de:	35712623          	sw	s7,844(sp)
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_DIR);
420072e2:	9002                	ebreak
420072e4:	37212023          	sw	s2,864(sp)
420072e8:	35312e23          	sw	s3,860(sp)
420072ec:	35412c23          	sw	s4,856(sp)
420072f0:	35512a23          	sw	s5,852(sp)
420072f4:	35612823          	sw	s6,848(sp)
420072f8:	35712623          	sw	s7,844(sp)
420072fc:	35812423          	sw	s8,840(sp)
42007300:	35912223          	sw	s9,836(sp)
42007304:	35a12023          	sw	s10,832(sp)
42007308:	33b12e23          	sw	s11,828(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
4200730c:	9002                	ebreak
4200730e:	35712623          	sw	s7,844(sp)
        existing = vfs_shared_by_inode(parent->shared->vfs, ent.inode);
42007312:	9002                	ebreak
42007314:	35712623          	sw	s7,844(sp)
42007318:	9002                	ebreak
4200731a:	35712623          	sw	s7,844(sp)
    ptr->is_dir = is_dir;
4200731e:	9002                	ebreak
42007320:	35712623          	sw	s7,844(sp)
    ptr->read   = oflags & OFLAGS_READONLY;
42007324:	9002                	ebreak
42007326:	35712623          	sw	s7,844(sp)
        filename = canon_path + slash;
4200732a:	9002                	ebreak
4200732c:	35712623          	sw	s7,844(sp)
        existing = vfs_shared_by_inode(parent->shared->vfs, ent.inode);
42007330:	9002                	ebreak
42007332:	35712623          	sw	s7,844(sp)
    ptr->read   = oflags & OFLAGS_READONLY;
42007336:	9002                	ebreak
42007338:	35712623          	sw	s7,844(sp)
    ptrdiff_t          shared = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
4200733c:	9002                	ebreak
4200733e:	35712623          	sw	s7,844(sp)
        shared->refcount = 1;
42007342:	9002                	ebreak
42007344:	35712623          	sw	s7,844(sp)
        vfs_file_open(ec, parent->shared, shared, filename, oflags);
42007348:	9002                	ebreak
4200734a:	35712623          	sw	s7,844(sp)
        vfs_file_shared_t *shared = ptr->shared;
4200734e:	9002                	ebreak
42007350:	35712623          	sw	s7,844(sp)
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
42007354:	9002                	ebreak
42007356:	37212023          	sw	s2,864(sp)
4200735a:	35312e23          	sw	s3,860(sp)
4200735e:	35412c23          	sw	s4,856(sp)
42007362:	35512a23          	sw	s5,852(sp)
42007366:	35612823          	sw	s6,848(sp)
4200736a:	35712623          	sw	s7,844(sp)
4200736e:	35812423          	sw	s8,840(sp)
42007372:	35912223          	sw	s9,836(sp)
42007376:	35a12023          	sw	s10,832(sp)
4200737a:	33b12e23          	sw	s11,828(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
4200737e:	9002                	ebreak
42007380:	37212023          	sw	s2,864(sp)
42007384:	35312e23          	sw	s3,860(sp)
42007388:	35412c23          	sw	s4,856(sp)
4200738c:	35512a23          	sw	s5,852(sp)
42007390:	35612823          	sw	s6,848(sp)
42007394:	35712623          	sw	s7,844(sp)
42007398:	35812423          	sw	s8,840(sp)
4200739c:	35912223          	sw	s9,836(sp)
420073a0:	35a12023          	sw	s10,832(sp)
420073a4:	33b12e23          	sw	s11,828(sp)
420073a8:	9002                	ebreak
    ptrdiff_t          shared = vfs_shared_by_inode(&vfs_table[vfs_root_index], vfs_table[vfs_root_index].inode_root);
420073aa:	9a32                	add	s4,s4,a2
420073ac:	feca6763          	bltu	s4,a2,42006b9a <fs_open+0x810>
420073b0:	35712623          	sw	s7,844(sp)
420073b4:	9002                	ebreak
420073b6:	35712623          	sw	s7,844(sp)
420073ba:	9002                	ebreak
420073bc:	35712623          	sw	s7,844(sp)
    vfs_file_shared_t *old = dir->shared;
420073c0:	9002                	ebreak
420073c2:	35712623          	sw	s7,844(sp)
        shptr = vfs_file_shared_list[shared];
420073c6:	9002                	ebreak
420073c8:	35712623          	sw	s7,844(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
420073cc:	9002                	ebreak
        badge_err_assert_dev(ec);
420073ce:	9002                	ebreak
420073d0:	35712623          	sw	s7,844(sp)
        badge_err_set_ok(ec);
420073d4:	9002                	ebreak
420073d6:	35712623          	sw	s7,844(sp)
    old->refcount--;
420073da:	9002                	ebreak
420073dc:	35712623          	sw	s7,844(sp)
    shptr->refcount++;
420073e0:	9002                	ebreak
420073e2:	37212023          	sw	s2,864(sp)
420073e6:	35312e23          	sw	s3,860(sp)
420073ea:	35412c23          	sw	s4,856(sp)
420073ee:	35512a23          	sw	s5,852(sp)
420073f2:	35612823          	sw	s6,848(sp)
420073f6:	35712623          	sw	s7,844(sp)
420073fa:	35812423          	sw	s8,840(sp)
420073fe:	35912223          	sw	s9,836(sp)
42007402:	35a12023          	sw	s10,832(sp)
42007406:	33b12e23          	sw	s11,828(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
4200740a:	9002                	ebreak
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTFOUND);
4200740c:	9002                	ebreak
4200740e:	35712623          	sw	s7,844(sp)
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
42007412:	9002                	ebreak
42007414:	35712623          	sw	s7,844(sp)
            if (!dir->is_dir) {
42007418:	9002                	ebreak

4200741a <fs_dir_open>:
    return fs_open(ec, path, oflags | OFLAGS_DIRECTORY | OFLAGS_READONLY);
4200741a:	08166613          	or	a2,a2,129
4200741e:	f6dfe06f          	j	4200638a <fs_open>

42007422 <fs_close>:

// Close a file opened by `fs_open`.
// Only raises an error if `file` is an invalid file descriptor.
void fs_close(badge_err_t *ec, file_t file) {
42007422:	1141                	add	sp,sp,-16
42007424:	c04a                	sw	s2,0(sp)
    assert_always(mutex_acquire(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42007426:	0016e637          	lui	a2,0x16e
void fs_close(badge_err_t *ec, file_t file) {
4200742a:	c226                	sw	s1,4(sp)
    assert_always(mutex_acquire(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
4200742c:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
void fs_close(badge_err_t *ec, file_t file) {
42007430:	84ae                	mv	s1,a1
    assert_always(mutex_acquire(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42007432:	4681                	li	a3,0
42007434:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
void fs_close(badge_err_t *ec, file_t file) {
42007438:	c422                	sw	s0,8(sp)
4200743a:	c606                	sw	ra,12(sp)
4200743c:	842a                	mv	s0,a0
    assert_always(mutex_acquire(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
4200743e:	a34fc0ef          	jal	42003672 <mutex_acquire>
42007442:	c52d                	beqz	a0,420074ac <fs_close+0x8a>

    ptrdiff_t index = vfs_file_by_handle(file);
42007444:	8526                	mv	a0,s1
42007446:	7a3020ef          	jal	4200a3e8 <vfs_file_by_handle>
    if (index == -1) {
4200744a:	57fd                	li	a5,-1
4200744c:	02f50963          	beq	a0,a5,4200747e <fs_close+0x5c>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
    } else {
        badge_err_set_ok(ec);
42007450:	c819                	beqz	s0,42007466 <fs_close+0x44>
42007452:	00347793          	and	a5,s0,3
42007456:	e3b5                	bnez	a5,420074ba <fs_close+0x98>
42007458:	57f1                	li	a5,-4
4200745a:	06f47063          	bgeu	s0,a5,420074ba <fs_close+0x98>
4200745e:	00042223          	sw	zero,4(s0)
42007462:	00042023          	sw	zero,0(s0)
        vfs_file_destroy_handle(index);
42007466:	1ec030ef          	jal	4200a652 <vfs_file_destroy_handle>
    }

    mutex_release(NULL, &vfs_handle_mtx);
}
4200746a:	4422                	lw	s0,8(sp)
4200746c:	40b2                	lw	ra,12(sp)
4200746e:	4492                	lw	s1,4(sp)
    mutex_release(NULL, &vfs_handle_mtx);
42007470:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
}
42007474:	4902                	lw	s2,0(sp)
    mutex_release(NULL, &vfs_handle_mtx);
42007476:	4501                	li	a0,0
}
42007478:	0141                	add	sp,sp,16
    mutex_release(NULL, &vfs_handle_mtx);
4200747a:	b8afc06f          	j	42003804 <mutex_release>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
4200747e:	d475                	beqz	s0,4200746a <fs_close+0x48>
42007480:	420175b7          	lui	a1,0x42017
42007484:	4689                	li	a3,2
42007486:	4635                	li	a2,13
42007488:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200748c:	4511                	li	a0,4
4200748e:	00000717          	auipc	a4,0x0
42007492:	e09fb0ef          	jal	4200329a <logkf>
42007496:	00347793          	and	a5,s0,3
4200749a:	e385                	bnez	a5,420074ba <fs_close+0x98>
4200749c:	57f1                	li	a5,-4
4200749e:	00f47e63          	bgeu	s0,a5,420074ba <fs_close+0x98>
420074a2:	47b5                	li	a5,13
420074a4:	c05c                	sw	a5,4(s0)
420074a6:	4789                	li	a5,2
420074a8:	c01c                	sw	a5,0(s0)
420074aa:	b7c1                	j	4200746a <fs_close+0x48>
    assert_always(mutex_acquire(ec, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
420074ac:	420185b7          	lui	a1,0x42018
420074b0:	a4058593          	add	a1,a1,-1472 # 42017a40 <hextab+0xd74>
420074b4:	da1fb0ef          	jal	42003254 <logk>
420074b8:	9002                	ebreak
        badge_err_set_ok(ec);
420074ba:	9002                	ebreak

420074bc <fs_umount>:
void fs_umount(badge_err_t *ec, char const *mountpoint) {
420074bc:	7139                	add	sp,sp,-64
420074be:	dc22                	sw	s0,56(sp)
420074c0:	d84a                	sw	s2,48(sp)
420074c2:	d452                	sw	s4,40(sp)
420074c4:	33018913          	add	s2,gp,816 # 40800330 <vfs_table>
420074c8:	4a11                	li	s4,4
420074ca:	da26                	sw	s1,52(sp)
420074cc:	d64e                	sw	s3,44(sp)
420074ce:	d256                	sw	s5,36(sp)
420074d0:	d05a                	sw	s6,32(sp)
420074d2:	ce5e                	sw	s7,28(sp)
420074d4:	cc62                	sw	s8,24(sp)
420074d6:	de06                	sw	ra,60(sp)
420074d8:	8baa                	mv	s7,a0
420074da:	8b2e                	mv	s6,a1
420074dc:	33018413          	add	s0,gp,816 # 40800330 <vfs_table>
420074e0:	412a0a33          	sub	s4,s4,s2
420074e4:	4981                	li	s3,0
    for (vfs_index = 0; vfs_index < FILESYSTEM_MOUNT_MAX; vfs_index++) {
420074e6:	4481                	li	s1,0
        if (cstr_equals(vfs_table[vfs_index].mountpoint, mountpoint)) {
420074e8:	4a91                	li	s5,4
420074ea:	0d000c13          	li	s8,208
420074ee:	1d54f163          	bgeu	s1,s5,420076b0 <fs_umount+0x1f4>
420074f2:	014407b3          	add	a5,s0,s4
420074f6:	1afc6a63          	bltu	s8,a5,420076aa <fs_umount+0x1ee>
420074fa:	013907b3          	add	a5,s2,s3
420074fe:	1b27e963          	bltu	a5,s2,420076b0 <fs_umount+0x1f4>
42007502:	4008                	lw	a0,0(s0)
42007504:	85da                	mv	a1,s6
42007506:	a07fa0ef          	jal	42001f0c <cstr_equals>
4200750a:	e939                	bnez	a0,42007560 <fs_umount+0xa4>
    for (vfs_index = 0; vfs_index < FILESYSTEM_MOUNT_MAX; vfs_index++) {
4200750c:	0485                	add	s1,s1,1
4200750e:	03440413          	add	s0,s0,52
42007512:	03498993          	add	s3,s3,52
42007516:	fd549ce3          	bne	s1,s5,420074ee <fs_umount+0x32>
        logkf(LOG_ERROR, "fs_umount: %{cs}: Not mounted.", mountpoint);
4200751a:	420185b7          	lui	a1,0x42018
4200751e:	865a                	mv	a2,s6
42007520:	ae058593          	add	a1,a1,-1312 # 42017ae0 <hextab+0xe14>
42007524:	4505                	li	a0,1
42007526:	d75fb0ef          	jal	4200329a <logkf>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTFOUND);
4200752a:	140b8063          	beqz	s7,4200766a <fs_umount+0x1ae>
4200752e:	420175b7          	lui	a1,0x42017
42007532:	46e1                	li	a3,24
42007534:	4635                	li	a2,13
42007536:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200753a:	4511                	li	a0,4
4200753c:	00000717          	auipc	a4,0x0
42007540:	d5bfb0ef          	jal	4200329a <logkf>
42007544:	003bf793          	and	a5,s7,3
42007548:	16079463          	bnez	a5,420076b0 <fs_umount+0x1f4>
4200754c:	57f1                	li	a5,-4
4200754e:	16fbf163          	bgeu	s7,a5,420076b0 <fs_umount+0x1f4>
42007552:	47b5                	li	a5,13
42007554:	00fba223          	sw	a5,4(s7)
42007558:	47e1                	li	a5,24
4200755a:	00fba023          	sw	a5,0(s7)
4200755e:	a231                	j	4200766a <fs_umount+0x1ae>
    for (size_t i = 0; i < vfs_file_handle_list_len; i++) {
42007560:	4080abb7          	lui	s7,0x4080a
42007564:	e28ba783          	lw	a5,-472(s7) # 40809e28 <vfs_file_handle_list_len>
42007568:	03400a93          	li	s5,52
4200756c:	03548ab3          	mul	s5,s1,s5
42007570:	c7ad                	beqz	a5,420075da <fs_umount+0x11e>
        if (vfs_file_handle_list[i].shared->vfs == &vfs_table[vfs_index]) {
42007572:	01590c33          	add	s8,s2,s5
42007576:	ca66                	sw	s9,20(sp)
42007578:	c86a                	sw	s10,16(sp)
4200757a:	c66e                	sw	s11,12(sp)
4200757c:	4401                	li	s0,0
    for (size_t i = 0; i < vfs_file_handle_list_len; i++) {
4200757e:	4981                	li	s3,0
42007580:	4080a8b7          	lui	a7,0x4080a
        if (vfs_file_handle_list[i].shared->vfs == &vfs_table[vfs_index]) {
42007584:	5b11                	li	s6,-28
42007586:	fdc00d93          	li	s11,-36
4200758a:	4d15                	li	s10,5
4200758c:	8ce2                	mv	s9,s8
4200758e:	e2c8a683          	lw	a3,-468(a7) # 40809e2c <vfs_file_handle_list>
42007592:	008687b3          	add	a5,a3,s0
42007596:	0e044663          	bltz	s0,42007682 <fs_umount+0x1c6>
4200759a:	0ed7e663          	bltu	a5,a3,42007686 <fs_umount+0x1ca>
4200759e:	c7e5                	beqz	a5,42007686 <fs_umount+0x1ca>
420075a0:	0037f713          	and	a4,a5,3
420075a4:	e36d                	bnez	a4,42007686 <fs_umount+0x1ca>
420075a6:	0f67f063          	bgeu	a5,s6,42007686 <fs_umount+0x1ca>
420075aa:	4fd8                	lw	a4,28(a5)
420075ac:	cf69                	beqz	a4,42007686 <fs_umount+0x1ca>
420075ae:	00377613          	and	a2,a4,3
420075b2:	ea71                	bnez	a2,42007686 <fs_umount+0x1ca>
420075b4:	0db77963          	bgeu	a4,s11,42007686 <fs_umount+0x1ca>
420075b8:	5358                	lw	a4,36(a4)
420075ba:	0da4f663          	bgeu	s1,s10,42007686 <fs_umount+0x1ca>
420075be:	0d2ce463          	bltu	s9,s2,42007686 <fs_umount+0x1ca>
420075c2:	0d870363          	beq	a4,s8,42007688 <fs_umount+0x1cc>
    for (size_t i = 0; i < vfs_file_handle_list_len; i++) {
420075c6:	e28ba783          	lw	a5,-472(s7)
420075ca:	0985                	add	s3,s3,1
420075cc:	02440413          	add	s0,s0,36
420075d0:	faf9efe3          	bltu	s3,a5,4200758e <fs_umount+0xd2>
420075d4:	4cd2                	lw	s9,20(sp)
420075d6:	4d42                	lw	s10,16(sp)
420075d8:	4db2                	lw	s11,12(sp)
    switch (vfs_table[vfs_index].type) {
420075da:	4791                	li	a5,4
420075dc:	0cf4fa63          	bgeu	s1,a5,420076b0 <fs_umount+0x1f4>
420075e0:	00ca8793          	add	a5,s5,12
420075e4:	00f906b3          	add	a3,s2,a5
420075e8:	01468733          	add	a4,a3,s4
420075ec:	0d000613          	li	a2,208
420075f0:	0ce66d63          	bltu	a2,a4,420076ca <fs_umount+0x20e>
420075f4:	97ca                	add	a5,a5,s2
420075f6:	0b27ed63          	bltu	a5,s2,420076b0 <fs_umount+0x1f4>
420075fa:	03400793          	li	a5,52
420075fe:	02f487b3          	mul	a5,s1,a5
42007602:	4709                	li	a4,2
42007604:	97ca                	add	a5,a5,s2
42007606:	47dc                	lw	a5,12(a5)
42007608:	0ae79463          	bne	a5,a4,420076b0 <fs_umount+0x1f4>
        case FS_TYPE_RAMFS: vfs_ramfs_umount(&vfs_table[vfs_index]); break;
4200760c:	4795                	li	a5,5
4200760e:	0af4f163          	bgeu	s1,a5,420076b0 <fs_umount+0x1f4>
42007612:	01590433          	add	s0,s2,s5
42007616:	09246d63          	bltu	s0,s2,420076b0 <fs_umount+0x1f4>
4200761a:	8522                	mv	a0,s0
4200761c:	5b3010ef          	jal	420093ce <vfs_ramfs_umount>
    free(vfs_table[vfs_index].mountpoint);
42007620:	4791                	li	a5,4
42007622:	08f4f763          	bgeu	s1,a5,420076b0 <fs_umount+0x1f4>
42007626:	9a22                	add	s4,s4,s0
42007628:	0d000793          	li	a5,208
4200762c:	0947ea63          	bltu	a5,s4,420076c0 <fs_umount+0x204>
42007630:	015907b3          	add	a5,s2,s5
42007634:	0727ee63          	bltu	a5,s2,420076b0 <fs_umount+0x1f4>
42007638:	03400793          	li	a5,52
4200763c:	02f487b3          	mul	a5,s1,a5
42007640:	97ca                	add	a5,a5,s2
42007642:	4388                	lw	a0,0(a5)
42007644:	518060ef          	jal	4200db5c <free>
    vfs_table[vfs_index].mountpoint = NULL;
42007648:	4791                	li	a5,4
4200764a:	06f4f363          	bgeu	s1,a5,420076b0 <fs_umount+0x1f4>
4200764e:	0d000793          	li	a5,208
42007652:	0747e363          	bltu	a5,s4,420076b8 <fs_umount+0x1fc>
42007656:	9aca                	add	s5,s5,s2
42007658:	052aec63          	bltu	s5,s2,420076b0 <fs_umount+0x1f4>
4200765c:	03400793          	li	a5,52
42007660:	02f487b3          	mul	a5,s1,a5
42007664:	97ca                	add	a5,a5,s2
42007666:	0007a023          	sw	zero,0(a5)
}
4200766a:	50f2                	lw	ra,60(sp)
4200766c:	5462                	lw	s0,56(sp)
4200766e:	54d2                	lw	s1,52(sp)
42007670:	5942                	lw	s2,48(sp)
42007672:	59b2                	lw	s3,44(sp)
42007674:	5a22                	lw	s4,40(sp)
42007676:	5a92                	lw	s5,36(sp)
42007678:	5b02                	lw	s6,32(sp)
4200767a:	4bf2                	lw	s7,28(sp)
4200767c:	4c62                	lw	s8,24(sp)
4200767e:	6121                	add	sp,sp,64
42007680:	8082                	ret
        if (vfs_file_handle_list[i].shared->vfs == &vfs_table[vfs_index]) {
42007682:	f0f6fee3          	bgeu	a3,a5,4200759e <fs_umount+0xe2>
    vfs_table[vfs_index].mountpoint = NULL;
42007686:	9002                	ebreak
            fs_close(NULL, vfs_file_handle_list[i].fileno);
42007688:	00044e63          	bltz	s0,420076a4 <fs_umount+0x1e8>
4200768c:	fed7ede3          	bltu	a5,a3,42007686 <fs_umount+0x1ca>
42007690:	5701                	li	a4,-32
42007692:	fee7fae3          	bgeu	a5,a4,42007686 <fs_umount+0x1ca>
42007696:	538c                	lw	a1,32(a5)
42007698:	4501                	li	a0,0
4200769a:	d89ff0ef          	jal	42007422 <fs_close>
4200769e:	4080a8b7          	lui	a7,0x4080a
420076a2:	b715                	j	420075c6 <fs_umount+0x10a>
420076a4:	fef6f6e3          	bgeu	a3,a5,42007690 <fs_umount+0x1d4>
    vfs_table[vfs_index].mountpoint = NULL;
420076a8:	9002                	ebreak
        if (cstr_equals(vfs_table[vfs_index].mountpoint, mountpoint)) {
420076aa:	97a2                	add	a5,a5,s0
420076ac:	e487e7e3          	bltu	a5,s0,420074fa <fs_umount+0x3e>
420076b0:	ca66                	sw	s9,20(sp)
420076b2:	c86a                	sw	s10,16(sp)
420076b4:	c66e                	sw	s11,12(sp)
    vfs_table[vfs_index].mountpoint = NULL;
420076b6:	9002                	ebreak
420076b8:	9a22                	add	s4,s4,s0
420076ba:	f88a6ee3          	bltu	s4,s0,42007656 <fs_umount+0x19a>
420076be:	bfcd                	j	420076b0 <fs_umount+0x1f4>
    free(vfs_table[vfs_index].mountpoint);
420076c0:	014407b3          	add	a5,s0,s4
420076c4:	f687e6e3          	bltu	a5,s0,42007630 <fs_umount+0x174>
420076c8:	b7e5                	j	420076b0 <fs_umount+0x1f4>
    switch (vfs_table[vfs_index].type) {
420076ca:	9736                	add	a4,a4,a3
420076cc:	f2d764e3          	bltu	a4,a3,420075f4 <fs_umount+0x138>
420076d0:	b7c5                	j	420076b0 <fs_umount+0x1f4>

420076d2 <fs_dir_create>:
bool fs_dir_create(badge_err_t *ec, char const *path) {
420076d2:	1141                	add	sp,sp,-16
    file_t fd = fs_open(ec, path, OFLAGS_DIRECTORY | OFLAGS_READONLY | OFLAGS_CREATE);
420076d4:	09100613          	li	a2,145
bool fs_dir_create(badge_err_t *ec, char const *path) {
420076d8:	c422                	sw	s0,8(sp)
420076da:	c226                	sw	s1,4(sp)
420076dc:	c606                	sw	ra,12(sp)
420076de:	84aa                	mv	s1,a0
    file_t fd = fs_open(ec, path, OFLAGS_DIRECTORY | OFLAGS_READONLY | OFLAGS_CREATE);
420076e0:	cabfe0ef          	jal	4200638a <fs_open>
420076e4:	842a                	mv	s0,a0
    if (fd >= 0) {
420076e6:	02055063          	bgez	a0,42007706 <fs_dir_create+0x34>
    } else if (ec && badge_err_is_ok(ec)) {
420076ea:	c491                	beqz	s1,420076f6 <fs_dir_create+0x24>
420076ec:	0034f793          	and	a5,s1,3
420076f0:	e3ad                	bnez	a5,42007752 <fs_dir_create+0x80>
420076f2:	409c                	lw	a5,0(s1)
420076f4:	c78d                	beqz	a5,4200771e <fs_dir_create+0x4c>
}
420076f6:	40b2                	lw	ra,12(sp)
    return fd >= 0;
420076f8:	fff44513          	not	a0,s0
}
420076fc:	4422                	lw	s0,8(sp)
420076fe:	4492                	lw	s1,4(sp)
42007700:	817d                	srl	a0,a0,0x1f
42007702:	0141                	add	sp,sp,16
42007704:	8082                	ret
        fs_close(ec, fd);
42007706:	85aa                	mv	a1,a0
42007708:	8526                	mv	a0,s1
4200770a:	d19ff0ef          	jal	42007422 <fs_close>
}
4200770e:	40b2                	lw	ra,12(sp)
    return fd >= 0;
42007710:	fff44513          	not	a0,s0
}
42007714:	4422                	lw	s0,8(sp)
42007716:	4492                	lw	s1,4(sp)
42007718:	817d                	srl	a0,a0,0x1f
4200771a:	0141                	add	sp,sp,16
4200771c:	8082                	ret
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
4200771e:	420175b7          	lui	a1,0x42017
42007722:	46e9                	li	a3,26
42007724:	4635                	li	a2,13
42007726:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200772a:	4511                	li	a0,4
4200772c:	00000717          	auipc	a4,0x0
42007730:	b6bfb0ef          	jal	4200329a <logkf>
42007734:	57f1                	li	a5,-4
42007736:	00f4fe63          	bgeu	s1,a5,42007752 <fs_dir_create+0x80>
}
4200773a:	40b2                	lw	ra,12(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
4200773c:	47b5                	li	a5,13
    return fd >= 0;
4200773e:	fff44513          	not	a0,s0
}
42007742:	4422                	lw	s0,8(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
42007744:	c0dc                	sw	a5,4(s1)
42007746:	47e9                	li	a5,26
42007748:	c09c                	sw	a5,0(s1)
}
4200774a:	817d                	srl	a0,a0,0x1f
4200774c:	4492                	lw	s1,4(sp)
4200774e:	0141                	add	sp,sp,16
42007750:	8082                	ret
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_IS_FILE);
42007752:	9002                	ebreak

42007754 <fs_dir_close>:
void fs_dir_close(badge_err_t *ec, file_t dir) {
42007754:	1141                	add	sp,sp,-16
42007756:	c422                	sw	s0,8(sp)
42007758:	c226                	sw	s1,4(sp)
4200775a:	c606                	sw	ra,12(sp)
4200775c:	842a                	mv	s0,a0
4200775e:	84ae                	mv	s1,a1
    if (!is_dir_handle(ec, dir))
42007760:	a35fe0ef          	jal	42006194 <is_dir_handle>
42007764:	e511                	bnez	a0,42007770 <fs_dir_close+0x1c>
}
42007766:	40b2                	lw	ra,12(sp)
42007768:	4422                	lw	s0,8(sp)
4200776a:	4492                	lw	s1,4(sp)
4200776c:	0141                	add	sp,sp,16
4200776e:	8082                	ret
    fs_close(ec, dir);
42007770:	8522                	mv	a0,s0
}
42007772:	4422                	lw	s0,8(sp)
42007774:	40b2                	lw	ra,12(sp)
    fs_close(ec, dir);
42007776:	85a6                	mv	a1,s1
}
42007778:	4492                	lw	s1,4(sp)
4200777a:	0141                	add	sp,sp,16
    fs_close(ec, dir);
4200777c:	ca7ff06f          	j	42007422 <fs_close>

42007780 <fs_mount>:
void fs_mount(badge_err_t *ec, fs_type_t type, blkdev_t *media, char const *mountpoint, mountflags_t flags) {
42007780:	711d                	add	sp,sp,-96
42007782:	c8ca                	sw	s2,80(sp)
42007784:	c6ce                	sw	s3,76(sp)
42007786:	ce86                	sw	ra,92(sp)
42007788:	dc62                	sw	s8,56(sp)
4200778a:	c22e                	sw	a1,4(sp)
4200778c:	c032                	sw	a2,0(sp)
4200778e:	c63a                	sw	a4,12(sp)
42007790:	89b6                	mv	s3,a3
        ec = &ec0;
42007792:	01010913          	add	s2,sp,16
    if (!ec)
42007796:	c111                	beqz	a0,4200779a <fs_mount+0x1a>
42007798:	892a                	mv	s2,a0
    assert_always(mutex_acquire(NULL, &vfs_mount_mtx, VFS_MUTEX_TIMEOUT));
4200779a:	0016e637          	lui	a2,0x16e
4200779e:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
420077a2:	4681                	li	a3,0
420077a4:	0d018593          	add	a1,gp,208 # 408000d0 <vfs_mount_mtx>
420077a8:	4501                	li	a0,0
420077aa:	ec9fb0ef          	jal	42003672 <mutex_acquire>
420077ae:	50050863          	beqz	a0,42007cbe <fs_mount+0x53e>
    if (type == FS_TYPE_UNKNOWN && !media) {
420077b2:	4792                	lw	a5,4(sp)
420077b4:	e7a5                	bnez	a5,4200781c <fs_mount+0x9c>
420077b6:	4782                	lw	a5,0(sp)
420077b8:	3c078e63          	beqz	a5,42007b94 <fs_mount+0x414>
    badge_err_set_ok(ec);
420077bc:	6a090863          	beqz	s2,42007e6c <fs_mount+0x6ec>
420077c0:	00397793          	and	a5,s2,3
420077c4:	6a079463          	bnez	a5,42007e6c <fs_mount+0x6ec>
420077c8:	57f1                	li	a5,-4
420077ca:	6af97163          	bgeu	s2,a5,42007e6c <fs_mount+0x6ec>
            logk(LOG_ERROR, "fs_mount: Unable to determine filesystem type.");
420077ce:	420185b7          	lui	a1,0x42018
    badge_err_set_ok(ec);
420077d2:	00092223          	sw	zero,4(s2)
420077d6:	00092023          	sw	zero,0(s2)
            logk(LOG_ERROR, "fs_mount: Unable to determine filesystem type.");
420077da:	bcc58593          	add	a1,a1,-1076 # 42017bcc <hextab+0xf00>
420077de:	4505                	li	a0,1
420077e0:	a75fb0ef          	jal	42003254 <logk>
            mutex_release(NULL, &vfs_mount_mtx);
420077e4:	0d018593          	add	a1,gp,208 # 408000d0 <vfs_mount_mtx>
420077e8:	4501                	li	a0,0
420077ea:	81afc0ef          	jal	42003804 <mutex_release>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
420077ee:	420175b7          	lui	a1,0x42017
420077f2:	46c1                	li	a3,16
420077f4:	4635                	li	a2,13
420077f6:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420077fa:	4511                	li	a0,4
420077fc:	00000717          	auipc	a4,0x0
42007800:	a9bfb0ef          	jal	4200329a <logkf>
}
42007804:	40f6                	lw	ra,92(sp)
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007806:	47b5                	li	a5,13
42007808:	00f92223          	sw	a5,4(s2)
4200780c:	47c1                	li	a5,16
4200780e:	00f92023          	sw	a5,0(s2)
}
42007812:	49b6                	lw	s3,76(sp)
42007814:	4946                	lw	s2,80(sp)
42007816:	5c62                	lw	s8,56(sp)
42007818:	6125                	add	sp,sp,96
4200781a:	8082                	ret
4200781c:	cca2                	sw	s0,88(sp)
4200781e:	caa6                	sw	s1,84(sp)
42007820:	c4d2                	sw	s4,72(sp)
42007822:	c2d6                	sw	s5,68(sp)
42007824:	da66                	sw	s9,52(sp)
42007826:	d86a                	sw	s10,48(sp)
42007828:	d66e                	sw	s11,44(sp)
    if (raw[0] != '/') {
4200782a:	62098e63          	beqz	s3,42007e66 <fs_mount+0x6e6>
4200782e:	0009c703          	lbu	a4,0(s3)
42007832:	02f00793          	li	a5,47
42007836:	3ef71363          	bne	a4,a5,42007c1c <fs_mount+0x49c>
    size_t raw_len = cstr_length(raw);
4200783a:	854e                	mv	a0,s3
4200783c:	d1efa0ef          	jal	42001d5a <cstr_length>
    if (raw_len > FILESYSTEM_PATH_MAX) {
42007840:	1ff00793          	li	a5,511
    size_t raw_len = cstr_length(raw);
42007844:	842a                	mv	s0,a0
    if (raw_len > FILESYSTEM_PATH_MAX) {
42007846:	46a7e463          	bltu	a5,a0,42007cae <fs_mount+0x52e>
    if (!fs_is_canonical_path(raw)) {
4200784a:	854e                	mv	a0,s3
4200784c:	a6ffe0ef          	jal	420062ba <fs_is_canonical_path>
42007850:	4e050663          	beqz	a0,42007d3c <fs_mount+0x5bc>
    char *copy = malloc(raw_len + 1);
42007854:	00140493          	add	s1,s0,1
42007858:	8526                	mv	a0,s1
4200785a:	0f6060ef          	jal	4200d950 <malloc>
4200785e:	8aaa                	mv	s5,a0
    if (!copy) {
42007860:	58050663          	beqz	a0,42007dec <fs_mount+0x66c>
    mem_copy(copy, raw, raw_len + 1);
42007864:	8626                	mv	a2,s1
42007866:	85ce                	mv	a1,s3
42007868:	c0da                	sw	s6,64(sp)
4200786a:	de5e                	sw	s7,60(sp)
4200786c:	b01fa0ef          	jal	4200236c <mem_copy>
    if (raw_len > 1 && copy[raw_len] == '/') {
42007870:	4785                	li	a5,1
42007872:	0287f063          	bgeu	a5,s0,42007892 <fs_mount+0x112>
42007876:	008a87b3          	add	a5,s5,s0
4200787a:	36045b63          	bgez	s0,42007bf0 <fs_mount+0x470>
4200787e:	2efae563          	bltu	s5,a5,42007b68 <fs_mount+0x3e8>
42007882:	2e078363          	beqz	a5,42007b68 <fs_mount+0x3e8>
42007886:	0007c683          	lbu	a3,0(a5)
4200788a:	02f00713          	li	a4,47
4200788e:	36e68463          	beq	a3,a4,42007bf6 <fs_mount+0x476>
42007892:	33018413          	add	s0,gp,816 # 40800330 <vfs_table>
42007896:	4d91                	li	s11,4
42007898:	33018493          	add	s1,gp,816 # 40800330 <vfs_table>
4200789c:	408d87b3          	sub	a5,s11,s0
420078a0:	c43e                	sw	a5,8(sp)
        ec = &ec0;
420078a2:	4d01                	li	s10,0
420078a4:	4c81                	li	s9,0
        if (vfs_table[i].mountpoint && cstr_equals(vfs_table[i].mountpoint, copy)) {
420078a6:	0d000a13          	li	s4,208
420078aa:	2bbcff63          	bgeu	s9,s11,42007b68 <fs_mount+0x3e8>
420078ae:	47a2                	lw	a5,8(sp)
420078b0:	00978b33          	add	s6,a5,s1
420078b4:	5d6a6663          	bltu	s4,s6,42007e80 <fs_mount+0x700>
420078b8:	01a406b3          	add	a3,s0,s10
420078bc:	2a86e663          	bltu	a3,s0,42007b68 <fs_mount+0x3e8>
420078c0:	0004ab83          	lw	s7,0(s1)
420078c4:	280b8a63          	beqz	s7,42007b58 <fs_mount+0x3d8>
420078c8:	2bbcf063          	bgeu	s9,s11,42007b68 <fs_mount+0x3e8>
420078cc:	5b6a6f63          	bltu	s4,s6,42007e8a <fs_mount+0x70a>
420078d0:	01a40633          	add	a2,s0,s10
420078d4:	28866a63          	bltu	a2,s0,42007b68 <fs_mount+0x3e8>
420078d8:	85d6                	mv	a1,s5
420078da:	855e                	mv	a0,s7
420078dc:	e30fa0ef          	jal	42001f0c <cstr_equals>
420078e0:	4a051d63          	bnez	a0,42007d9a <fs_mount+0x61a>
        } else if (vfs_table[i].mountpoint && cstr_equals_case(vfs_table[i].mountpoint, copy)) {
420078e4:	29bcf263          	bgeu	s9,s11,42007b68 <fs_mount+0x3e8>
420078e8:	5b6a6663          	bltu	s4,s6,42007e94 <fs_mount+0x714>
420078ec:	01a40633          	add	a2,s0,s10
420078f0:	26866c63          	bltu	a2,s0,42007b68 <fs_mount+0x3e8>
420078f4:	27bcfa63          	bgeu	s9,s11,42007b68 <fs_mount+0x3e8>
420078f8:	5b6a6363          	bltu	s4,s6,42007e9e <fs_mount+0x71e>
420078fc:	01a40633          	add	a2,s0,s10
42007900:	26866463          	bltu	a2,s0,42007b68 <fs_mount+0x3e8>
42007904:	85d6                	mv	a1,s5
42007906:	855e                	mv	a0,s7
42007908:	e72fa0ef          	jal	42001f7a <cstr_equals_case>
4200790c:	24051f63          	bnez	a0,42007b6a <fs_mount+0x3ea>
    for (size_t i = 0; i < FILESYSTEM_MOUNT_MAX; i++) {
42007910:	0c85                	add	s9,s9,1
42007912:	03448493          	add	s1,s1,52
42007916:	034d0d13          	add	s10,s10,52
4200791a:	f9bc98e3          	bne	s9,s11,420078aa <fs_mount+0x12a>
    if (!cstr_equals(copy, "/")) {
4200791e:	420185b7          	lui	a1,0x42018
42007922:	d4458593          	add	a1,a1,-700 # 42017d44 <hextab+0x1078>
42007926:	8556                	mv	a0,s5
42007928:	de4fa0ef          	jal	42001f0c <cstr_equals>
4200792c:	32050c63          	beqz	a0,42007c64 <fs_mount+0x4e4>
42007930:	4b06                	lw	s6,64(sp)
42007932:	5bf2                	lw	s7,60(sp)
    if (!badge_err_is_ok(ec)) {
42007934:	52090963          	beqz	s2,42007e66 <fs_mount+0x6e6>
42007938:	00397793          	and	a5,s2,3
4200793c:	52079563          	bnez	a5,42007e66 <fs_mount+0x6e6>
42007940:	00092483          	lw	s1,0(s2)
42007944:	ecb5                	bnez	s1,420079c0 <fs_mount+0x240>
42007946:	33018593          	add	a1,gp,816 # 40800330 <vfs_table>
4200794a:	4691                	li	a3,4
4200794c:	33018413          	add	s0,gp,816 # 40800330 <vfs_table>
42007950:	8e8d                	sub	a3,a3,a1
42007952:	4701                	li	a4,0
42007954:	33018793          	add	a5,gp,816 # 40800330 <vfs_table>
        if (!vfs_table[vfs_index].mountpoint) {
42007958:	4611                	li	a2,4
4200795a:	0d000813          	li	a6,208
4200795e:	50c4f463          	bgeu	s1,a2,42007e66 <fs_mount+0x6e6>
42007962:	00d78533          	add	a0,a5,a3
42007966:	4ea86d63          	bltu	a6,a0,42007e60 <fs_mount+0x6e0>
4200796a:	00e40533          	add	a0,s0,a4
4200796e:	4e856c63          	bltu	a0,s0,42007e66 <fs_mount+0x6e6>
42007972:	4388                	lw	a0,0(a5)
42007974:	c925                	beqz	a0,420079e4 <fs_mount+0x264>
    for (vfs_index = 0; vfs_index < FILESYSTEM_MOUNT_MAX; vfs_index++) {
42007976:	0485                	add	s1,s1,1
42007978:	03478793          	add	a5,a5,52
4200797c:	03470713          	add	a4,a4,52 # 42007830 <fs_mount+0xb0>
42007980:	fcc49fe3          	bne	s1,a2,4200795e <fs_mount+0x1de>
        logk(LOG_ERROR, "fs_mount: Mounted filesystem limit (" comptime_stringify(FILESYSTEM_MOUNT_MAX) ") reached.");
42007984:	420185b7          	lui	a1,0x42018
42007988:	e1058593          	add	a1,a1,-496 # 42017e10 <hextab+0x1144>
4200798c:	4505                	li	a0,1
4200798e:	8c7fb0ef          	jal	42003254 <logk>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007992:	420175b7          	lui	a1,0x42017
42007996:	46c1                	li	a3,16
42007998:	4635                	li	a2,13
4200799a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200799e:	4511                	li	a0,4
420079a0:	00000717          	auipc	a4,0x0
420079a4:	8f7fb0ef          	jal	4200329a <logkf>
420079a8:	57f1                	li	a5,-4
420079aa:	4af97e63          	bgeu	s2,a5,42007e66 <fs_mount+0x6e6>
420079ae:	47b5                	li	a5,13
420079b0:	00f92223          	sw	a5,4(s2)
420079b4:	47c1                	li	a5,16
420079b6:	00f92023          	sw	a5,0(s2)
        free(mountpoint_copy);
420079ba:	8556                	mv	a0,s5
420079bc:	1a0060ef          	jal	4200db5c <free>
        mutex_release(NULL, &vfs_mount_mtx);
420079c0:	0d018593          	add	a1,gp,208 # 408000d0 <vfs_mount_mtx>
420079c4:	4501                	li	a0,0
420079c6:	e3ffb0ef          	jal	42003804 <mutex_release>
}
420079ca:	40f6                	lw	ra,92(sp)
        return;
420079cc:	4466                	lw	s0,88(sp)
420079ce:	44d6                	lw	s1,84(sp)
420079d0:	4a26                	lw	s4,72(sp)
420079d2:	4a96                	lw	s5,68(sp)
420079d4:	5cd2                	lw	s9,52(sp)
420079d6:	5d42                	lw	s10,48(sp)
420079d8:	5db2                	lw	s11,44(sp)
}
420079da:	4946                	lw	s2,80(sp)
420079dc:	49b6                	lw	s3,76(sp)
420079de:	5c62                	lw	s8,56(sp)
420079e0:	6125                	add	sp,sp,96
420079e2:	8082                	ret
    if (!(flags & MOUNTFLAGS_READONLY) && media && media->readonly) {
420079e4:	47b2                	lw	a5,12(sp)
420079e6:	0017fa13          	and	s4,a5,1
420079ea:	020a1063          	bnez	s4,42007a0a <fs_mount+0x28a>
420079ee:	4782                	lw	a5,0(sp)
420079f0:	cf89                	beqz	a5,42007a0a <fs_mount+0x28a>
420079f2:	8b8d                	and	a5,a5,3
420079f4:	46079963          	bnez	a5,42007e66 <fs_mount+0x6e6>
420079f8:	4782                	lw	a5,0(sp)
420079fa:	4705                	li	a4,1
420079fc:	0107c783          	lbu	a5,16(a5)
42007a00:	46f76363          	bltu	a4,a5,42007e66 <fs_mount+0x6e6>
42007a04:	8b85                	and	a5,a5,1
42007a06:	34079663          	bnez	a5,42007d52 <fs_mount+0x5d2>
    vfs_table[vfs_index] = (vfs_t){
42007a0a:	4791                	li	a5,4
42007a0c:	44f4fd63          	bgeu	s1,a5,42007e66 <fs_mount+0x6e6>
42007a10:	03400793          	li	a5,52
42007a14:	02f48d33          	mul	s10,s1,a5
42007a18:	8f8d                	sub	a5,a5,a1
42007a1a:	0d000713          	li	a4,208
        .readonly   = flags & MOUNTFLAGS_READONLY,
42007a1e:	0ffa7a13          	zext.b	s4,s4
42007a22:	01a40db3          	add	s11,s0,s10
42007a26:	97ee                	add	a5,a5,s11
    vfs_table[vfs_index] = (vfs_t){
42007a28:	48f76063          	bltu	a4,a5,42007ea8 <fs_mount+0x728>
42007a2c:	01a407b3          	add	a5,s0,s10
42007a30:	4287eb63          	bltu	a5,s0,42007e66 <fs_mount+0x6e6>
42007a34:	03400793          	li	a5,52
42007a38:	02f487b3          	mul	a5,s1,a5
42007a3c:	00dd8cb3          	add	s9,s11,a3
42007a40:	0d000713          	li	a4,208
42007a44:	97a2                	add	a5,a5,s0
42007a46:	0007a023          	sw	zero,0(a5)
42007a4a:	0007a223          	sw	zero,4(a5)
42007a4e:	0007a423          	sw	zero,8(a5)
42007a52:	0007a623          	sw	zero,12(a5)
42007a56:	0007a823          	sw	zero,16(a5)
42007a5a:	0007aa23          	sw	zero,20(a5)
42007a5e:	0007ac23          	sw	zero,24(a5)
42007a62:	0007ae23          	sw	zero,28(a5)
42007a66:	0207a023          	sw	zero,32(a5)
42007a6a:	0207a223          	sw	zero,36(a5)
42007a6e:	0207a423          	sw	zero,40(a5)
42007a72:	0207a623          	sw	zero,44(a5)
42007a76:	0207a823          	sw	zero,48(a5)
42007a7a:	45976d63          	bltu	a4,s9,42007ed4 <fs_mount+0x754>
42007a7e:	01a407b3          	add	a5,s0,s10
42007a82:	3e87e263          	bltu	a5,s0,42007e66 <fs_mount+0x6e6>
42007a86:	03400793          	li	a5,52
42007a8a:	02f487b3          	mul	a5,s1,a5
42007a8e:	004d0713          	add	a4,s10,4
42007a92:	00e40633          	add	a2,s0,a4
42007a96:	40b605b3          	sub	a1,a2,a1
42007a9a:	0585                	add	a1,a1,1
42007a9c:	0d000513          	li	a0,208
42007aa0:	97a2                	add	a5,a5,s0
42007aa2:	0157a023          	sw	s5,0(a5)
42007aa6:	42b56c63          	bltu	a0,a1,42007ede <fs_mount+0x75e>
42007aaa:	9722                	add	a4,a4,s0
42007aac:	3a876d63          	bltu	a4,s0,42007e66 <fs_mount+0x6e6>
42007ab0:	03400793          	li	a5,52
42007ab4:	02f487b3          	mul	a5,s1,a5
42007ab8:	008d0713          	add	a4,s10,8
42007abc:	00e405b3          	add	a1,s0,a4
42007ac0:	00d58633          	add	a2,a1,a3
42007ac4:	0d000513          	li	a0,208
42007ac8:	97a2                	add	a5,a5,s0
42007aca:	01478223          	sb	s4,4(a5)
42007ace:	3ec56163          	bltu	a0,a2,42007eb0 <fs_mount+0x730>
42007ad2:	9722                	add	a4,a4,s0
42007ad4:	38876963          	bltu	a4,s0,42007e66 <fs_mount+0x6e6>
42007ad8:	03400793          	li	a5,52
42007adc:	02f487b3          	mul	a5,s1,a5
42007ae0:	4502                	lw	a0,0(sp)
42007ae2:	00cd0713          	add	a4,s10,12
42007ae6:	00e40633          	add	a2,s0,a4
42007aea:	96b2                	add	a3,a3,a2
42007aec:	0d000593          	li	a1,208
42007af0:	97a2                	add	a5,a5,s0
42007af2:	c788                	sw	a0,8(a5)
42007af4:	3cd5e263          	bltu	a1,a3,42007eb8 <fs_mount+0x738>
42007af8:	9722                	add	a4,a4,s0
42007afa:	36876663          	bltu	a4,s0,42007e66 <fs_mount+0x6e6>
42007afe:	03400793          	li	a5,52
42007b02:	02f487b3          	mul	a5,s1,a5
42007b06:	4712                	lw	a4,4(sp)
    switch (type) {
42007b08:	4a09                	li	s4,2
    vfs_table[vfs_index] = (vfs_t){
42007b0a:	97a2                	add	a5,a5,s0
42007b0c:	c7d8                	sw	a4,12(a5)
    switch (type) {
42007b0e:	0f470b63          	beq	a4,s4,42007c04 <fs_mount+0x484>
        default: badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM); break;
42007b12:	420175b7          	lui	a1,0x42017
42007b16:	4689                	li	a3,2
42007b18:	4635                	li	a2,13
42007b1a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42007b1e:	4511                	li	a0,4
42007b20:	00000717          	auipc	a4,0x0
42007b24:	f76fb0ef          	jal	4200329a <logkf>
42007b28:	57f1                	li	a5,-4
42007b2a:	32f97e63          	bgeu	s2,a5,42007e66 <fs_mount+0x6e6>
42007b2e:	47b5                	li	a5,13
42007b30:	00f92223          	sw	a5,4(s2)
42007b34:	01492023          	sw	s4,0(s2)
    if (!badge_err_is_ok(ec)) {
42007b38:	00092783          	lw	a5,0(s2)
42007b3c:	1a079163          	bnez	a5,42007cde <fs_mount+0x55e>
    if (cstr_equals(mountpoint, "/")) {
42007b40:	420185b7          	lui	a1,0x42018
42007b44:	d4458593          	add	a1,a1,-700 # 42017d44 <hextab+0x1078>
42007b48:	854e                	mv	a0,s3
42007b4a:	bc2fa0ef          	jal	42001f0c <cstr_equals>
42007b4e:	e60509e3          	beqz	a0,420079c0 <fs_mount+0x240>
        vfs_root_index = (ptrdiff_t)vfs_index;
42007b52:	3291a023          	sw	s1,800(gp) # 40800320 <vfs_root_index>
42007b56:	b5ad                	j	420079c0 <fs_mount+0x240>
        } else if (vfs_table[i].mountpoint && cstr_equals_case(vfs_table[i].mountpoint, copy)) {
42007b58:	01bcf863          	bgeu	s9,s11,42007b68 <fs_mount+0x3e8>
42007b5c:	376a6763          	bltu	s4,s6,42007eca <fs_mount+0x74a>
42007b60:	01a407b3          	add	a5,s0,s10
42007b64:	da87f6e3          	bgeu	a5,s0,42007910 <fs_mount+0x190>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007b68:	9002                	ebreak
            logkf(LOG_WARN, "check_mountpoint: %{cs}: Very similar to %{cs}", copy, vfs_table[i].mountpoint);
42007b6a:	4611                	li	a2,4
42007b6c:	feccfee3          	bgeu	s9,a2,42007b68 <fs_mount+0x3e8>
42007b70:	0d000613          	li	a2,208
42007b74:	35666663          	bltu	a2,s6,42007ec0 <fs_mount+0x740>
42007b78:	01a407b3          	add	a5,s0,s10
42007b7c:	fe87e6e3          	bltu	a5,s0,42007b68 <fs_mount+0x3e8>
42007b80:	420185b7          	lui	a1,0x42018
42007b84:	86de                	mv	a3,s7
42007b86:	8656                	mv	a2,s5
42007b88:	d1458593          	add	a1,a1,-748 # 42017d14 <hextab+0x1048>
42007b8c:	4509                	li	a0,2
42007b8e:	f0cfb0ef          	jal	4200329a <logkf>
42007b92:	bbbd                	j	42007910 <fs_mount+0x190>
        logk(LOG_ERROR, "fs_mount: Neither media nor type specified.");
42007b94:	420185b7          	lui	a1,0x42018
42007b98:	ba058593          	add	a1,a1,-1120 # 42017ba0 <hextab+0xed4>
42007b9c:	4505                	li	a0,1
42007b9e:	eb6fb0ef          	jal	42003254 <logk>
        mutex_release(NULL, &vfs_mount_mtx);
42007ba2:	0d018593          	add	a1,gp,208 # 408000d0 <vfs_mount_mtx>
42007ba6:	4501                	li	a0,0
42007ba8:	c5dfb0ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42007bac:	420175b7          	lui	a1,0x42017
42007bb0:	4689                	li	a3,2
42007bb2:	4635                	li	a2,13
42007bb4:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42007bb8:	4511                	li	a0,4
42007bba:	00000717          	auipc	a4,0x0
42007bbe:	edcfb0ef          	jal	4200329a <logkf>
42007bc2:	2a090563          	beqz	s2,42007e6c <fs_mount+0x6ec>
42007bc6:	00397793          	and	a5,s2,3
42007bca:	2a079163          	bnez	a5,42007e6c <fs_mount+0x6ec>
42007bce:	57f1                	li	a5,-4
42007bd0:	cca2                	sw	s0,88(sp)
42007bd2:	caa6                	sw	s1,84(sp)
42007bd4:	c4d2                	sw	s4,72(sp)
42007bd6:	c2d6                	sw	s5,68(sp)
42007bd8:	28f97e63          	bgeu	s2,a5,42007e74 <fs_mount+0x6f4>
42007bdc:	da66                	sw	s9,52(sp)
42007bde:	d86a                	sw	s10,48(sp)
42007be0:	d66e                	sw	s11,44(sp)
42007be2:	47b5                	li	a5,13
42007be4:	00f92223          	sw	a5,4(s2)
42007be8:	4789                	li	a5,2
42007bea:	00f92023          	sw	a5,0(s2)
42007bee:	b935                	j	4200782a <fs_mount+0xaa>
    if (raw_len > 1 && copy[raw_len] == '/') {
42007bf0:	c957f9e3          	bgeu	a5,s5,42007882 <fs_mount+0x102>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007bf4:	9002                	ebreak
        copy[raw_len] = 0;
42007bf6:	14045963          	bgez	s0,42007d48 <fs_mount+0x5c8>
42007bfa:	f6fae7e3          	bltu	s5,a5,42007b68 <fs_mount+0x3e8>
42007bfe:	00078023          	sb	zero,0(a5)
    for (size_t i = 0; i < FILESYSTEM_MOUNT_MAX; i++) {
42007c02:	b941                	j	42007892 <fs_mount+0x112>
        case FS_TYPE_RAMFS: vfs_ramfs_mount(ec, &vfs_table[vfs_index]); break;
42007c04:	4795                	li	a5,5
42007c06:	26f4f063          	bgeu	s1,a5,42007e66 <fs_mount+0x6e6>
42007c0a:	01a407b3          	add	a5,s0,s10
42007c0e:	2487ec63          	bltu	a5,s0,42007e66 <fs_mount+0x6e6>
42007c12:	85ee                	mv	a1,s11
42007c14:	854a                	mv	a0,s2
42007c16:	48a010ef          	jal	420090a0 <vfs_ramfs_mount>
42007c1a:	bf39                	j	42007b38 <fs_mount+0x3b8>
        logkf(LOG_ERROR, "check_mountpoint: %{cs}: Mount point is relative path", raw);
42007c1c:	420185b7          	lui	a1,0x42018
42007c20:	864e                	mv	a2,s3
42007c22:	bfc58593          	add	a1,a1,-1028 # 42017bfc <hextab+0xf30>
        logkf(LOG_ERROR, "check_mountpoint: %{cs}: Mount point is not a canonical path", raw);
42007c26:	4505                	li	a0,1
42007c28:	e72fb0ef          	jal	4200329a <logkf>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42007c2c:	420175b7          	lui	a1,0x42017
42007c30:	4689                	li	a3,2
42007c32:	4635                	li	a2,13
42007c34:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42007c38:	4511                	li	a0,4
42007c3a:	00000717          	auipc	a4,0x0
42007c3e:	e5cfb0ef          	jal	4200329a <logkf>
42007c42:	22090263          	beqz	s2,42007e66 <fs_mount+0x6e6>
42007c46:	00397793          	and	a5,s2,3
42007c4a:	20079e63          	bnez	a5,42007e66 <fs_mount+0x6e6>
42007c4e:	57f1                	li	a5,-4
42007c50:	20f97b63          	bgeu	s2,a5,42007e66 <fs_mount+0x6e6>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42007c54:	47b5                	li	a5,13
42007c56:	00f92223          	sw	a5,4(s2)
42007c5a:	4789                	li	a5,2
42007c5c:	00f92023          	sw	a5,0(s2)
        return NULL;
42007c60:	4a81                	li	s5,0
42007c62:	b9c9                	j	42007934 <fs_mount+0x1b4>
    return fs_open(ec, path, oflags | OFLAGS_DIRECTORY | OFLAGS_READONLY);
42007c64:	08100613          	li	a2,129
42007c68:	85d6                	mv	a1,s5
42007c6a:	854a                	mv	a0,s2
42007c6c:	f1efe0ef          	jal	4200638a <fs_open>
42007c70:	842a                	mv	s0,a0
        if (ec->cause == ECAUSE_NOTFOUND) {
42007c72:	ee090be3          	beqz	s2,42007b68 <fs_mount+0x3e8>
42007c76:	00397793          	and	a5,s2,3
42007c7a:	ee0797e3          	bnez	a5,42007b68 <fs_mount+0x3e8>
42007c7e:	00092783          	lw	a5,0(s2)
42007c82:	4761                	li	a4,24
42007c84:	1ae78763          	beq	a5,a4,42007e32 <fs_mount+0x6b2>
        } else if (ec->cause == ECAUSE_IS_FILE) {
42007c88:	4769                	li	a4,26
42007c8a:	1ae78c63          	beq	a5,a4,42007e42 <fs_mount+0x6c2>
        if (dir == FILE_NONE) {
42007c8e:	57fd                	li	a5,-1
42007c90:	1cf40163          	beq	s0,a5,42007e52 <fs_mount+0x6d2>
    if (!is_dir_handle(ec, dir))
42007c94:	85a2                	mv	a1,s0
42007c96:	4501                	li	a0,0
42007c98:	cfcfe0ef          	jal	42006194 <is_dir_handle>
42007c9c:	c8050ae3          	beqz	a0,42007930 <fs_mount+0x1b0>
    fs_close(ec, dir);
42007ca0:	85a2                	mv	a1,s0
42007ca2:	4501                	li	a0,0
42007ca4:	f7eff0ef          	jal	42007422 <fs_close>
42007ca8:	4b06                	lw	s6,64(sp)
42007caa:	5bf2                	lw	s7,60(sp)
42007cac:	b161                	j	42007934 <fs_mount+0x1b4>
        logkf(LOG_ERROR, "check_mountpoint: %{cs}: Mount path too long");
42007cae:	420185b7          	lui	a1,0x42018
42007cb2:	c3458593          	add	a1,a1,-972 # 42017c34 <hextab+0xf68>
42007cb6:	4505                	li	a0,1
42007cb8:	de2fb0ef          	jal	4200329a <logkf>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42007cbc:	bf85                	j	42007c2c <fs_mount+0x4ac>
    assert_always(mutex_acquire(NULL, &vfs_mount_mtx, VFS_MUTEX_TIMEOUT));
42007cbe:	420185b7          	lui	a1,0x42018
42007cc2:	b0058593          	add	a1,a1,-1280 # 42017b00 <hextab+0xe34>
42007cc6:	cca2                	sw	s0,88(sp)
42007cc8:	caa6                	sw	s1,84(sp)
42007cca:	c4d2                	sw	s4,72(sp)
42007ccc:	c2d6                	sw	s5,68(sp)
42007cce:	c0da                	sw	s6,64(sp)
42007cd0:	de5e                	sw	s7,60(sp)
42007cd2:	da66                	sw	s9,52(sp)
42007cd4:	d86a                	sw	s10,48(sp)
42007cd6:	d66e                	sw	s11,44(sp)
42007cd8:	d7cfb0ef          	jal	42003254 <logk>
42007cdc:	9002                	ebreak
        logk(LOG_ERROR, "fs_mount: Mount error reported by VFS.");
42007cde:	420185b7          	lui	a1,0x42018
42007ce2:	de858593          	add	a1,a1,-536 # 42017de8 <hextab+0x111c>
42007ce6:	4505                	li	a0,1
42007ce8:	d6cfb0ef          	jal	42003254 <logk>
    free(vfs_table[vfs_index].mountpoint);
42007cec:	4791                	li	a5,4
42007cee:	16f4fc63          	bgeu	s1,a5,42007e66 <fs_mount+0x6e6>
42007cf2:	0d000793          	li	a5,208
42007cf6:	1f97ec63          	bltu	a5,s9,42007eee <fs_mount+0x76e>
42007cfa:	01a407b3          	add	a5,s0,s10
42007cfe:	1687e463          	bltu	a5,s0,42007e66 <fs_mount+0x6e6>
42007d02:	03400793          	li	a5,52
42007d06:	02f487b3          	mul	a5,s1,a5
42007d0a:	97a2                	add	a5,a5,s0
42007d0c:	4388                	lw	a0,0(a5)
42007d0e:	64f050ef          	jal	4200db5c <free>
    vfs_table[vfs_index].mountpoint = NULL;
42007d12:	4791                	li	a5,4
42007d14:	14f4f963          	bgeu	s1,a5,42007e66 <fs_mount+0x6e6>
42007d18:	0d000793          	li	a5,208
42007d1c:	1d97e563          	bltu	a5,s9,42007ee6 <fs_mount+0x766>
42007d20:	9d22                	add	s10,s10,s0
42007d22:	148d6263          	bltu	s10,s0,42007e66 <fs_mount+0x6e6>
42007d26:	03400793          	li	a5,52
42007d2a:	02f487b3          	mul	a5,s1,a5
    mutex_release(NULL, &vfs_mount_mtx);
42007d2e:	0d018593          	add	a1,gp,208 # 408000d0 <vfs_mount_mtx>
42007d32:	4501                	li	a0,0
    vfs_table[vfs_index].mountpoint = NULL;
42007d34:	97a2                	add	a5,a5,s0
42007d36:	0007a023          	sw	zero,0(a5)
    mutex_release(NULL, &vfs_mount_mtx);
42007d3a:	b171                	j	420079c6 <fs_mount+0x246>
        logkf(LOG_ERROR, "check_mountpoint: %{cs}: Mount point is not a canonical path", raw);
42007d3c:	420185b7          	lui	a1,0x42018
42007d40:	864e                	mv	a2,s3
42007d42:	c6458593          	add	a1,a1,-924 # 42017c64 <hextab+0xf98>
42007d46:	b5c5                	j	42007c26 <fs_mount+0x4a6>
        copy[raw_len] = 0;
42007d48:	e357e0e3          	bltu	a5,s5,42007b68 <fs_mount+0x3e8>
42007d4c:	00078023          	sb	zero,0(a5)
    for (size_t i = 0; i < FILESYSTEM_MOUNT_MAX; i++) {
42007d50:	b689                	j	42007892 <fs_mount+0x112>
42007d52:	03400d13          	li	s10,52
42007d56:	03a48d33          	mul	s10,s1,s10
        logk(LOG_ERROR, "fs_mount: Writeable filesystem on readonly media.");
42007d5a:	420185b7          	lui	a1,0x42018
42007d5e:	db458593          	add	a1,a1,-588 # 42017db4 <hextab+0x10e8>
42007d62:	4505                	li	a0,1
42007d64:	01a40db3          	add	s11,s0,s10
42007d68:	00dd8cb3          	add	s9,s11,a3
42007d6c:	ce8fb0ef          	jal	42003254 <logk>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_READONLY);
42007d70:	420175b7          	lui	a1,0x42017
42007d74:	46dd                	li	a3,23
42007d76:	4635                	li	a2,13
42007d78:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42007d7c:	4511                	li	a0,4
42007d7e:	00000717          	auipc	a4,0x0
42007d82:	d18fb0ef          	jal	4200329a <logkf>
42007d86:	57f1                	li	a5,-4
42007d88:	0cf97f63          	bgeu	s2,a5,42007e66 <fs_mount+0x6e6>
42007d8c:	47b5                	li	a5,13
42007d8e:	00f92223          	sw	a5,4(s2)
42007d92:	47dd                	li	a5,23
42007d94:	00f92023          	sw	a5,0(s2)
        goto error_cleanup;
42007d98:	bf91                	j	42007cec <fs_mount+0x56c>
            logkf(LOG_ERROR, "check_mountpoint: %{cs}: Mount point is in use", copy);
42007d9a:	420185b7          	lui	a1,0x42018
42007d9e:	8656                	mv	a2,s5
42007da0:	ce458593          	add	a1,a1,-796 # 42017ce4 <hextab+0x1018>
42007da4:	4505                	li	a0,1
42007da6:	cf4fb0ef          	jal	4200329a <logkf>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_INUSE);
42007daa:	420175b7          	lui	a1,0x42017
42007dae:	46b9                	li	a3,14
42007db0:	4635                	li	a2,13
42007db2:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42007db6:	4511                	li	a0,4
42007db8:	00000717          	auipc	a4,0x0
42007dbc:	cdefb0ef          	jal	4200329a <logkf>
42007dc0:	da0904e3          	beqz	s2,42007b68 <fs_mount+0x3e8>
42007dc4:	00397793          	and	a5,s2,3
42007dc8:	da0790e3          	bnez	a5,42007b68 <fs_mount+0x3e8>
42007dcc:	57f1                	li	a5,-4
42007dce:	d8f97de3          	bgeu	s2,a5,42007b68 <fs_mount+0x3e8>
42007dd2:	47b5                	li	a5,13
42007dd4:	00f92223          	sw	a5,4(s2)
42007dd8:	47b9                	li	a5,14
            free(copy);
42007dda:	8556                	mv	a0,s5
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_INUSE);
42007ddc:	00f92023          	sw	a5,0(s2)
            free(copy);
42007de0:	57d050ef          	jal	4200db5c <free>
        return NULL;
42007de4:	4a81                	li	s5,0
            return NULL;
42007de6:	4b06                	lw	s6,64(sp)
42007de8:	5bf2                	lw	s7,60(sp)
42007dea:	b6a9                	j	42007934 <fs_mount+0x1b4>
        logkf(LOG_ERROR, "check_mountpoint: Out of memory (allocating %{size;d} bytes)", raw_len + 1);
42007dec:	420185b7          	lui	a1,0x42018
42007df0:	8626                	mv	a2,s1
42007df2:	ca458593          	add	a1,a1,-860 # 42017ca4 <hextab+0xfd8>
42007df6:	4505                	li	a0,1
42007df8:	ca2fb0ef          	jal	4200329a <logkf>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
42007dfc:	420175b7          	lui	a1,0x42017
42007e00:	4699                	li	a3,6
42007e02:	4635                	li	a2,13
42007e04:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42007e08:	4511                	li	a0,4
42007e0a:	00000717          	auipc	a4,0x0
42007e0e:	c8cfb0ef          	jal	4200329a <logkf>
42007e12:	04090a63          	beqz	s2,42007e66 <fs_mount+0x6e6>
42007e16:	00397793          	and	a5,s2,3
42007e1a:	e7b1                	bnez	a5,42007e66 <fs_mount+0x6e6>
42007e1c:	57f1                	li	a5,-4
42007e1e:	04f97463          	bgeu	s2,a5,42007e66 <fs_mount+0x6e6>
42007e22:	47b5                	li	a5,13
42007e24:	00f92223          	sw	a5,4(s2)
42007e28:	4799                	li	a5,6
42007e2a:	00f92023          	sw	a5,0(s2)
        return NULL;
42007e2e:	4a81                	li	s5,0
42007e30:	b611                	j	42007934 <fs_mount+0x1b4>
            logkf(LOG_ERROR, "check_mountpoint: %{cs}: Mount point does not exist");
42007e32:	420185b7          	lui	a1,0x42018
42007e36:	d4858593          	add	a1,a1,-696 # 42017d48 <hextab+0x107c>
42007e3a:	4505                	li	a0,1
42007e3c:	c5efb0ef          	jal	4200329a <logkf>
42007e40:	b5b9                	j	42007c8e <fs_mount+0x50e>
            logkf(LOG_ERROR, "check_mountpoint: %{cs}: Mount point is not a directory");
42007e42:	420185b7          	lui	a1,0x42018
42007e46:	d7c58593          	add	a1,a1,-644 # 42017d7c <hextab+0x10b0>
42007e4a:	4505                	li	a0,1
42007e4c:	c4efb0ef          	jal	4200329a <logkf>
42007e50:	bd3d                	j	42007c8e <fs_mount+0x50e>
            free(copy);
42007e52:	8556                	mv	a0,s5
42007e54:	509050ef          	jal	4200db5c <free>
        return NULL;
42007e58:	4a81                	li	s5,0
            return NULL;
42007e5a:	4b06                	lw	s6,64(sp)
42007e5c:	5bf2                	lw	s7,60(sp)
42007e5e:	bcd9                	j	42007934 <fs_mount+0x1b4>
        if (!vfs_table[vfs_index].mountpoint) {
42007e60:	953e                	add	a0,a0,a5
42007e62:	b0f564e3          	bltu	a0,a5,4200796a <fs_mount+0x1ea>
42007e66:	c0da                	sw	s6,64(sp)
42007e68:	de5e                	sw	s7,60(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007e6a:	9002                	ebreak
42007e6c:	cca2                	sw	s0,88(sp)
42007e6e:	caa6                	sw	s1,84(sp)
42007e70:	c4d2                	sw	s4,72(sp)
42007e72:	c2d6                	sw	s5,68(sp)
42007e74:	c0da                	sw	s6,64(sp)
42007e76:	de5e                	sw	s7,60(sp)
42007e78:	da66                	sw	s9,52(sp)
42007e7a:	d86a                	sw	s10,48(sp)
42007e7c:	d66e                	sw	s11,44(sp)
    badge_err_set_ok(ec);
42007e7e:	9002                	ebreak
        if (vfs_table[i].mountpoint && cstr_equals(vfs_table[i].mountpoint, copy)) {
42007e80:	016486b3          	add	a3,s1,s6
42007e84:	a296eae3          	bltu	a3,s1,420078b8 <fs_mount+0x138>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007e88:	9002                	ebreak
        if (vfs_table[i].mountpoint && cstr_equals(vfs_table[i].mountpoint, copy)) {
42007e8a:	01648633          	add	a2,s1,s6
42007e8e:	a49661e3          	bltu	a2,s1,420078d0 <fs_mount+0x150>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007e92:	9002                	ebreak
        } else if (vfs_table[i].mountpoint && cstr_equals_case(vfs_table[i].mountpoint, copy)) {
42007e94:	01648633          	add	a2,s1,s6
42007e98:	a4966ae3          	bltu	a2,s1,420078ec <fs_mount+0x16c>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007e9c:	9002                	ebreak
        } else if (vfs_table[i].mountpoint && cstr_equals_case(vfs_table[i].mountpoint, copy)) {
42007e9e:	01648633          	add	a2,s1,s6
42007ea2:	a4966de3          	bltu	a2,s1,420078fc <fs_mount+0x17c>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007ea6:	9002                	ebreak
    vfs_table[vfs_index] = (vfs_t){
42007ea8:	97ee                	add	a5,a5,s11
42007eaa:	b9b7e1e3          	bltu	a5,s11,42007a2c <fs_mount+0x2ac>
42007eae:	bf65                	j	42007e66 <fs_mount+0x6e6>
42007eb0:	962e                	add	a2,a2,a1
42007eb2:	c2b660e3          	bltu	a2,a1,42007ad2 <fs_mount+0x352>
42007eb6:	bf45                	j	42007e66 <fs_mount+0x6e6>
42007eb8:	96b2                	add	a3,a3,a2
42007eba:	c2c6efe3          	bltu	a3,a2,42007af8 <fs_mount+0x378>
42007ebe:	b765                	j	42007e66 <fs_mount+0x6e6>
            logkf(LOG_WARN, "check_mountpoint: %{cs}: Very similar to %{cs}", copy, vfs_table[i].mountpoint);
42007ec0:	016487b3          	add	a5,s1,s6
42007ec4:	ca97eae3          	bltu	a5,s1,42007b78 <fs_mount+0x3f8>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007ec8:	9002                	ebreak
        } else if (vfs_table[i].mountpoint && cstr_equals_case(vfs_table[i].mountpoint, copy)) {
42007eca:	016487b3          	add	a5,s1,s6
42007ece:	c897e9e3          	bltu	a5,s1,42007b60 <fs_mount+0x3e0>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNAVAIL);
42007ed2:	9002                	ebreak
    vfs_table[vfs_index] = (vfs_t){
42007ed4:	019d87b3          	add	a5,s11,s9
42007ed8:	bbb7e3e3          	bltu	a5,s11,42007a7e <fs_mount+0x2fe>
42007edc:	b769                	j	42007e66 <fs_mount+0x6e6>
42007ede:	95b2                	add	a1,a1,a2
42007ee0:	bcc5e5e3          	bltu	a1,a2,42007aaa <fs_mount+0x32a>
42007ee4:	b749                	j	42007e66 <fs_mount+0x6e6>
    vfs_table[vfs_index].mountpoint = NULL;
42007ee6:	9cee                	add	s9,s9,s11
42007ee8:	e3bcece3          	bltu	s9,s11,42007d20 <fs_mount+0x5a0>
42007eec:	bfad                	j	42007e66 <fs_mount+0x6e6>
    free(vfs_table[vfs_index].mountpoint);
42007eee:	019d87b3          	add	a5,s11,s9
42007ef2:	e1b7e4e3          	bltu	a5,s11,42007cfa <fs_mount+0x57a>
42007ef6:	bf85                	j	42007e66 <fs_mount+0x6e6>

42007ef8 <fs_read>:

// Read bytes from a file.
// Returns the amount of data successfully read.
fileoff_t fs_read(badge_err_t *ec, file_t file, void *readbuf, fileoff_t readlen) {
42007ef8:	1101                	add	sp,sp,-32
42007efa:	ca26                	sw	s1,20(sp)
42007efc:	ce06                	sw	ra,28(sp)
42007efe:	cc22                	sw	s0,24(sp)
42007f00:	c452                	sw	s4,8(sp)
42007f02:	84aa                	mv	s1,a0
    if (readlen < 0) {
42007f04:	0806cf63          	bltz	a3,42007fa2 <fs_read+0xaa>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
        mutex_release_shared(NULL, &vfs_handle_mtx);
        return 0;
    }
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42007f08:	c64e                	sw	s3,12(sp)
42007f0a:	89b2                	mv	s3,a2
42007f0c:	0016e637          	lui	a2,0x16e
42007f10:	c84a                	sw	s2,16(sp)
42007f12:	8436                	mv	s0,a3
42007f14:	892e                	mv	s2,a1
42007f16:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42007f1a:	4681                	li	a3,0
42007f1c:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42007f20:	4501                	li	a0,0
42007f22:	a09fb0ef          	jal	4200392a <mutex_acquire_shared>
42007f26:	22050e63          	beqz	a0,42008162 <fs_read+0x26a>

    // Look up the handle.
    ptrdiff_t index = vfs_file_by_handle(file);
42007f2a:	854a                	mv	a0,s2
42007f2c:	4bc020ef          	jal	4200a3e8 <vfs_file_by_handle>
    if (index == -1) {
42007f30:	57fd                	li	a5,-1
42007f32:	14f50263          	beq	a0,a5,42008076 <fs_read+0x17e>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
        mutex_release_shared(NULL, &vfs_handle_mtx);
        return 0;
    }
    vfs_file_handle_t *ptr = &vfs_file_handle_list[index];
42007f36:	4080a7b7          	lui	a5,0x4080a
42007f3a:	e2c7a703          	lw	a4,-468(a5) # 40809e2c <vfs_file_handle_list>
42007f3e:	00351793          	sll	a5,a0,0x3
42007f42:	97aa                	add	a5,a5,a0
42007f44:	078a                	sll	a5,a5,0x2
42007f46:	c256                	sw	s5,4(sp)
42007f48:	00f70933          	add	s2,a4,a5
42007f4c:	0807cf63          	bltz	a5,42007fea <fs_read+0xf2>
42007f50:	08e96f63          	bltu	s2,a4,42007fee <fs_read+0xf6>

    // Check permission.
    if (!ptr->read) {
42007f54:	08090d63          	beqz	s2,42007fee <fs_read+0xf6>
42007f58:	00397793          	and	a5,s2,3
42007f5c:	ebc9                	bnez	a5,42007fee <fs_read+0xf6>
42007f5e:	00594783          	lbu	a5,5(s2)
42007f62:	4a85                	li	s5,1
42007f64:	26fae163          	bltu	s5,a5,420081c6 <fs_read+0x2ce>
42007f68:	8b85                	and	a5,a5,1
42007f6a:	e7c1                	bnez	a5,42007ff2 <fs_read+0xfa>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PERM);
42007f6c:	12048f63          	beqz	s1,420080aa <fs_read+0x1b2>
42007f70:	420175b7          	lui	a1,0x42017
42007f74:	469d                	li	a3,7
42007f76:	4635                	li	a2,13
42007f78:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42007f7c:	4511                	li	a0,4
42007f7e:	00000717          	auipc	a4,0x0
42007f82:	b18fb0ef          	jal	4200329a <logkf>
42007f86:	0034f793          	and	a5,s1,3
42007f8a:	e3b5                	bnez	a5,42007fee <fs_read+0xf6>
42007f8c:	57f1                	li	a5,-4
42007f8e:	06f4f063          	bgeu	s1,a5,42007fee <fs_read+0xf6>
42007f92:	47b5                	li	a5,13
42007f94:	c0dc                	sw	a5,4(s1)
42007f96:	479d                	li	a5,7
42007f98:	4942                	lw	s2,16(sp)
42007f9a:	49b2                	lw	s3,12(sp)
42007f9c:	4a92                	lw	s5,4(sp)
42007f9e:	c09c                	sw	a5,0(s1)
42007fa0:	a805                	j	42007fd0 <fs_read+0xd8>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42007fa2:	c51d                	beqz	a0,42007fd0 <fs_read+0xd8>
42007fa4:	420175b7          	lui	a1,0x42017
42007fa8:	4689                	li	a3,2
42007faa:	4635                	li	a2,13
42007fac:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42007fb0:	4511                	li	a0,4
42007fb2:	00000717          	auipc	a4,0x0
42007fb6:	ae4fb0ef          	jal	4200329a <logkf>
42007fba:	0034f793          	and	a5,s1,3
42007fbe:	1e079c63          	bnez	a5,420081b6 <fs_read+0x2be>
42007fc2:	57f1                	li	a5,-4
42007fc4:	1ef4f963          	bgeu	s1,a5,420081b6 <fs_read+0x2be>
42007fc8:	47b5                	li	a5,13
42007fca:	c0dc                	sw	a5,4(s1)
42007fcc:	4789                	li	a5,2
42007fce:	c09c                	sw	a5,0(s1)
        mutex_release_shared(NULL, &vfs_handle_mtx);
42007fd0:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42007fd4:	4501                	li	a0,0
42007fd6:	b7ffb0ef          	jal	42003b54 <mutex_release_shared>
        return 0;
42007fda:	4401                	li	s0,0
    }
    mutex_release(NULL, &ptr->mutex);

    mutex_release_shared(NULL, &vfs_handle_mtx);
    return readlen;
}
42007fdc:	40f2                	lw	ra,28(sp)
42007fde:	8522                	mv	a0,s0
42007fe0:	4462                	lw	s0,24(sp)
42007fe2:	44d2                	lw	s1,20(sp)
42007fe4:	4a22                	lw	s4,8(sp)
42007fe6:	6105                	add	sp,sp,32
42007fe8:	8082                	ret
    vfs_file_handle_t *ptr = &vfs_file_handle_list[index];
42007fea:	f72775e3          	bgeu	a4,s2,42007f54 <fs_read+0x5c>
42007fee:	c05a                	sw	s6,0(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PERM);
42007ff0:	9002                	ebreak
42007ff2:	c05a                	sw	s6,0(sp)
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
42007ff4:	57e1                	li	a5,-8
42007ff6:	18f97863          	bgeu	s2,a5,42008186 <fs_read+0x28e>
42007ffa:	00890b13          	add	s6,s2,8
42007ffe:	0016e637          	lui	a2,0x16e
42008002:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42008006:	4681                	li	a3,0
42008008:	85da                	mv	a1,s6
4200800a:	4501                	li	a0,0
4200800c:	e66fb0ef          	jal	42003672 <mutex_acquire>
42008010:	16050263          	beqz	a0,42008174 <fs_read+0x27c>
    if (ptr->is_dir) {
42008014:	00694783          	lbu	a5,6(s2)
42008018:	16fae763          	bltu	s5,a5,42008186 <fs_read+0x28e>
4200801c:	8b85                	and	a5,a5,1
4200801e:	cbd1                	beqz	a5,420080b2 <fs_read+0x1ba>
        if (ptr->offset == 0) {
42008020:	00092783          	lw	a5,0(s2)
42008024:	16078263          	beqz	a5,42008188 <fs_read+0x290>
            if (readlen + ptr->offset < 0 || readlen + ptr->offset > ptr->dir_cache_size) {
42008028:	00878733          	add	a4,a5,s0
4200802c:	00042693          	slti	a3,s0,0
42008030:	00f72633          	slt	a2,a4,a5
42008034:	14c69963          	bne	a3,a2,42008186 <fs_read+0x28e>
42008038:	16075763          	bgez	a4,420081a6 <fs_read+0x2ae>
                readlen = ptr->dir_cache_size - ptr->offset;
4200803c:	5731                	li	a4,-20
4200803e:	14e97463          	bgeu	s2,a4,42008186 <fs_read+0x28e>
42008042:	01492703          	lw	a4,20(s2)
42008046:	0007a693          	slti	a3,a5,0
4200804a:	40f70433          	sub	s0,a4,a5
4200804e:	00872733          	slt	a4,a4,s0
42008052:	12e69a63          	bne	a3,a4,42008186 <fs_read+0x28e>
            mem_copy(readbuf, ptr->dir_cache + ptr->offset, readlen);
42008056:	5721                	li	a4,-24
42008058:	12e97763          	bgeu	s2,a4,42008186 <fs_read+0x28e>
4200805c:	01892703          	lw	a4,24(s2)
42008060:	00f705b3          	add	a1,a4,a5
42008064:	1007cf63          	bltz	a5,42008182 <fs_read+0x28a>
42008068:	10e5ef63          	bltu	a1,a4,42008186 <fs_read+0x28e>
4200806c:	8622                	mv	a2,s0
4200806e:	854e                	mv	a0,s3
42008070:	afcfa0ef          	jal	4200236c <mem_copy>
            ptr->offset += readlen;
42008074:	a07d                	j	42008122 <fs_read+0x22a>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42008076:	c49d                	beqz	s1,420080a4 <fs_read+0x1ac>
42008078:	420175b7          	lui	a1,0x42017
4200807c:	4689                	li	a3,2
4200807e:	4635                	li	a2,13
42008080:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42008084:	4511                	li	a0,4
42008086:	00000717          	auipc	a4,0x0
4200808a:	a10fb0ef          	jal	4200329a <logkf>
4200808e:	0034f793          	and	a5,s1,3
42008092:	12079763          	bnez	a5,420081c0 <fs_read+0x2c8>
42008096:	57f1                	li	a5,-4
42008098:	12f4f463          	bgeu	s1,a5,420081c0 <fs_read+0x2c8>
4200809c:	47b5                	li	a5,13
4200809e:	c0dc                	sw	a5,4(s1)
420080a0:	4789                	li	a5,2
420080a2:	c09c                	sw	a5,0(s1)
420080a4:	4942                	lw	s2,16(sp)
420080a6:	49b2                	lw	s3,12(sp)
420080a8:	b725                	j	42007fd0 <fs_read+0xd8>
420080aa:	4942                	lw	s2,16(sp)
420080ac:	49b2                	lw	s3,12(sp)
420080ae:	4a92                	lw	s5,4(sp)
420080b0:	b705                	j	42007fd0 <fs_read+0xd8>
        if (readlen + ptr->offset < 0 || readlen + ptr->offset > ptr->shared->size) {
420080b2:	00092603          	lw	a2,0(s2)
420080b6:	00042793          	slti	a5,s0,0
420080ba:	00860733          	add	a4,a2,s0
420080be:	00c726b3          	slt	a3,a4,a2
420080c2:	0cd79263          	bne	a5,a3,42008186 <fs_read+0x28e>
420080c6:	02074163          	bltz	a4,420080e8 <fs_read+0x1f0>
420080ca:	5791                	li	a5,-28
420080cc:	0af97d63          	bgeu	s2,a5,42008186 <fs_read+0x28e>
420080d0:	01c92583          	lw	a1,28(s2)
420080d4:	c9cd                	beqz	a1,42008186 <fs_read+0x28e>
420080d6:	0035f793          	and	a5,a1,3
420080da:	e7d5                	bnez	a5,42008186 <fs_read+0x28e>
420080dc:	57e1                	li	a5,-8
420080de:	0af5f463          	bgeu	a1,a5,42008186 <fs_read+0x28e>
420080e2:	459c                	lw	a5,8(a1)
420080e4:	02e7d763          	bge	a5,a4,42008112 <fs_read+0x21a>
            readlen = ptr->shared->size - ptr->offset;
420080e8:	5791                	li	a5,-28
420080ea:	08f97e63          	bgeu	s2,a5,42008186 <fs_read+0x28e>
420080ee:	01c92583          	lw	a1,28(s2)
420080f2:	c9d1                	beqz	a1,42008186 <fs_read+0x28e>
420080f4:	0035f793          	and	a5,a1,3
420080f8:	e7d9                	bnez	a5,42008186 <fs_read+0x28e>
420080fa:	57e1                	li	a5,-8
420080fc:	08f5f563          	bgeu	a1,a5,42008186 <fs_read+0x28e>
42008100:	459c                	lw	a5,8(a1)
42008102:	00062713          	slti	a4,a2,0
42008106:	40c78433          	sub	s0,a5,a2
4200810a:	0087a7b3          	slt	a5,a5,s0
4200810e:	06f71c63          	bne	a4,a5,42008186 <fs_read+0x28e>
        vfs_file_read(ec, ptr->shared, ptr->offset, readbuf, readlen);
42008112:	5791                	li	a5,-28
42008114:	06f97963          	bgeu	s2,a5,42008186 <fs_read+0x28e>
42008118:	8722                	mv	a4,s0
4200811a:	86ce                	mv	a3,s3
4200811c:	8526                	mv	a0,s1
4200811e:	239020ef          	jal	4200ab56 <vfs_file_read>
        ptr->offset += readlen;
42008122:	00092783          	lw	a5,0(s2)
42008126:	00042713          	slti	a4,s0,0
4200812a:	008786b3          	add	a3,a5,s0
4200812e:	00f6a7b3          	slt	a5,a3,a5
42008132:	04f71a63          	bne	a4,a5,42008186 <fs_read+0x28e>
42008136:	00d92023          	sw	a3,0(s2)
    mutex_release(NULL, &ptr->mutex);
4200813a:	85da                	mv	a1,s6
4200813c:	4501                	li	a0,0
4200813e:	ec6fb0ef          	jal	42003804 <mutex_release>
    mutex_release_shared(NULL, &vfs_handle_mtx);
42008142:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42008146:	4501                	li	a0,0
42008148:	a0dfb0ef          	jal	42003b54 <mutex_release_shared>
}
4200814c:	40f2                	lw	ra,28(sp)
4200814e:	8522                	mv	a0,s0
42008150:	4462                	lw	s0,24(sp)
    mutex_release_shared(NULL, &vfs_handle_mtx);
42008152:	4942                	lw	s2,16(sp)
42008154:	49b2                	lw	s3,12(sp)
42008156:	4a92                	lw	s5,4(sp)
42008158:	4b02                	lw	s6,0(sp)
}
4200815a:	44d2                	lw	s1,20(sp)
4200815c:	4a22                	lw	s4,8(sp)
4200815e:	6105                	add	sp,sp,32
42008160:	8082                	ret
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42008162:	420185b7          	lui	a1,0x42018
42008166:	e5458593          	add	a1,a1,-428 # 42017e54 <hextab+0x1188>
4200816a:	c256                	sw	s5,4(sp)
4200816c:	c05a                	sw	s6,0(sp)
4200816e:	8e6fb0ef          	jal	42003254 <logk>
42008172:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
42008174:	420185b7          	lui	a1,0x42018
42008178:	efc58593          	add	a1,a1,-260 # 42017efc <hextab+0x1230>
4200817c:	8d8fb0ef          	jal	42003254 <logk>
42008180:	9002                	ebreak
            mem_copy(readbuf, ptr->dir_cache + ptr->offset, readlen);
42008182:	eeb775e3          	bgeu	a4,a1,4200806c <fs_read+0x174>
        ptr->offset += readlen;
42008186:	9002                	ebreak
            vfs_dir_read(ec, ptr);
42008188:	85ca                	mv	a1,s2
4200818a:	8526                	mv	a0,s1
4200818c:	7b4020ef          	jal	4200a940 <vfs_dir_read>
42008190:	00092783          	lw	a5,0(s2)
        if (ptr->offset != 0 || badge_err_is_ok(ec)) {
42008194:	e8079ae3          	bnez	a5,42008028 <fs_read+0x130>
42008198:	c491                	beqz	s1,420081a4 <fs_read+0x2ac>
4200819a:	0034f713          	and	a4,s1,3
4200819e:	f765                	bnez	a4,42008186 <fs_read+0x28e>
420081a0:	4098                	lw	a4,0(s1)
420081a2:	ff41                	bnez	a4,4200813a <fs_read+0x242>
            if (readlen + ptr->offset < 0 || readlen + ptr->offset > ptr->dir_cache_size) {
420081a4:	8722                	mv	a4,s0
420081a6:	56b1                	li	a3,-20
420081a8:	fcd97fe3          	bgeu	s2,a3,42008186 <fs_read+0x28e>
420081ac:	01492683          	lw	a3,20(s2)
420081b0:	e8e6c6e3          	blt	a3,a4,4200803c <fs_read+0x144>
420081b4:	b54d                	j	42008056 <fs_read+0x15e>
420081b6:	c84a                	sw	s2,16(sp)
420081b8:	c64e                	sw	s3,12(sp)
420081ba:	c256                	sw	s5,4(sp)
420081bc:	c05a                	sw	s6,0(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
420081be:	9002                	ebreak
420081c0:	c256                	sw	s5,4(sp)
420081c2:	c05a                	sw	s6,0(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
420081c4:	9002                	ebreak
420081c6:	c05a                	sw	s6,0(sp)
        ptr->offset += readlen;
420081c8:	9002                	ebreak

420081ca <fs_write>:

// Write bytes to a file.
// Returns the amount of data successfully written.
fileoff_t fs_write(badge_err_t *ec, file_t file, void const *writebuf, fileoff_t writelen) {
420081ca:	1101                	add	sp,sp,-32
420081cc:	ca26                	sw	s1,20(sp)
420081ce:	ce06                	sw	ra,28(sp)
420081d0:	c452                	sw	s4,8(sp)
420081d2:	84aa                	mv	s1,a0
    if (writelen < 0) {
420081d4:	0a06c563          	bltz	a3,4200827e <fs_write+0xb4>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
        mutex_release_shared(NULL, &vfs_handle_mtx);
        return 0;
    }
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
420081d8:	c64e                	sw	s3,12(sp)
420081da:	89b2                	mv	s3,a2
420081dc:	0016e637          	lui	a2,0x16e
420081e0:	cc22                	sw	s0,24(sp)
420081e2:	c84a                	sw	s2,16(sp)
420081e4:	8436                	mv	s0,a3
420081e6:	892e                	mv	s2,a1
420081e8:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
420081ec:	4681                	li	a3,0
420081ee:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420081f2:	4501                	li	a0,0
420081f4:	f36fb0ef          	jal	4200392a <mutex_acquire_shared>
420081f8:	18050863          	beqz	a0,42008388 <fs_write+0x1be>

    // Look up the handle.
    ptrdiff_t index = vfs_file_by_handle(file);
420081fc:	854a                	mv	a0,s2
420081fe:	1ea020ef          	jal	4200a3e8 <vfs_file_by_handle>
    if (index == -1) {
42008202:	57fd                	li	a5,-1
42008204:	14f50463          	beq	a0,a5,4200834c <fs_write+0x182>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
        mutex_release_shared(NULL, &vfs_handle_mtx);
        return 0;
    }
    vfs_file_handle_t *ptr = &vfs_file_handle_list[index];
42008208:	4080a7b7          	lui	a5,0x4080a
4200820c:	e2c7a703          	lw	a4,-468(a5) # 40809e2c <vfs_file_handle_list>
42008210:	00351793          	sll	a5,a0,0x3
42008214:	97aa                	add	a5,a5,a0
42008216:	078a                	sll	a5,a5,0x2
42008218:	00f70933          	add	s2,a4,a5
4200821c:	0807cf63          	bltz	a5,420082ba <fs_write+0xf0>
42008220:	08e96f63          	bltu	s2,a4,420082be <fs_write+0xf4>

    // Check permission.
    if (!ptr->write) {
42008224:	08090d63          	beqz	s2,420082be <fs_write+0xf4>
42008228:	00397793          	and	a5,s2,3
4200822c:	ebc9                	bnez	a5,420082be <fs_write+0xf4>
4200822e:	00494783          	lbu	a5,4(s2)
42008232:	4705                	li	a4,1
42008234:	08f76563          	bltu	a4,a5,420082be <fs_write+0xf4>
42008238:	8b85                	and	a5,a5,1
4200823a:	e7c1                	bnez	a5,420082c2 <fs_write+0xf8>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PERM);
4200823c:	14048263          	beqz	s1,42008380 <fs_write+0x1b6>
42008240:	420175b7          	lui	a1,0x42017
42008244:	469d                	li	a3,7
42008246:	4635                	li	a2,13
42008248:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200824c:	4511                	li	a0,4
4200824e:	00000717          	auipc	a4,0x0
42008252:	848fb0ef          	jal	4200329a <logkf>
42008256:	0034f793          	and	a5,s1,3
4200825a:	e3b5                	bnez	a5,420082be <fs_write+0xf4>
4200825c:	57f1                	li	a5,-4
4200825e:	06f4f063          	bgeu	s1,a5,420082be <fs_write+0xf4>
42008262:	47b5                	li	a5,13
42008264:	c0dc                	sw	a5,4(s1)
42008266:	479d                	li	a5,7
42008268:	c09c                	sw	a5,0(s1)
        mutex_release_shared(NULL, &vfs_handle_mtx);
4200826a:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
4200826e:	4501                	li	a0,0
42008270:	4462                	lw	s0,24(sp)
42008272:	4942                	lw	s2,16(sp)
42008274:	49b2                	lw	s3,12(sp)
42008276:	8dffb0ef          	jal	42003b54 <mutex_release_shared>
        return 0;
4200827a:	4501                	li	a0,0
4200827c:	a0d9                	j	42008342 <fs_write+0x178>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
4200827e:	c51d                	beqz	a0,420082ac <fs_write+0xe2>
42008280:	420175b7          	lui	a1,0x42017
42008284:	4689                	li	a3,2
42008286:	4635                	li	a2,13
42008288:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200828c:	4511                	li	a0,4
4200828e:	00000717          	auipc	a4,0x0
42008292:	808fb0ef          	jal	4200329a <logkf>
42008296:	0034f793          	and	a5,s1,3
4200829a:	16079563          	bnez	a5,42008404 <fs_write+0x23a>
4200829e:	57f1                	li	a5,-4
420082a0:	16f4f263          	bgeu	s1,a5,42008404 <fs_write+0x23a>
420082a4:	47b5                	li	a5,13
420082a6:	c0dc                	sw	a5,4(s1)
420082a8:	4789                	li	a5,2
420082aa:	c09c                	sw	a5,0(s1)
        mutex_release_shared(NULL, &vfs_handle_mtx);
420082ac:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420082b0:	4501                	li	a0,0
420082b2:	8a3fb0ef          	jal	42003b54 <mutex_release_shared>
        return 0;
420082b6:	4501                	li	a0,0
420082b8:	a069                	j	42008342 <fs_write+0x178>
    vfs_file_handle_t *ptr = &vfs_file_handle_list[index];
420082ba:	f72775e3          	bgeu	a4,s2,42008224 <fs_write+0x5a>
420082be:	c256                	sw	s5,4(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PERM);
420082c0:	9002                	ebreak
420082c2:	c256                	sw	s5,4(sp)
        mutex_release_shared(NULL, &vfs_handle_mtx);
        return 0;
    }

    // Read data from the handle.
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
420082c4:	57e1                	li	a5,-8
420082c6:	12f97e63          	bgeu	s2,a5,42008402 <fs_write+0x238>
420082ca:	00890a93          	add	s5,s2,8
420082ce:	0016e637          	lui	a2,0x16e
420082d2:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
420082d6:	4681                	li	a3,0
420082d8:	85d6                	mv	a1,s5
420082da:	4501                	li	a0,0
420082dc:	b96fb0ef          	jal	42003672 <mutex_acquire>
420082e0:	cd45                	beqz	a0,42008398 <fs_write+0x1ce>
    // File writes go through VFS.
    if (writelen + ptr->offset < 0) {
420082e2:	00092603          	lw	a2,0(s2)
420082e6:	00042793          	slti	a5,s0,0
420082ea:	00860733          	add	a4,a2,s0
420082ee:	00c726b3          	slt	a3,a4,a2
420082f2:	10d79863          	bne	a5,a3,42008402 <fs_write+0x238>
420082f6:	0a074863          	bltz	a4,420083a6 <fs_write+0x1dc>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOSPACE);
        mutex_release(NULL, &ptr->mutex);
        mutex_release_shared(NULL, &vfs_handle_mtx);
        return 0;
    }
    if (ptr->offset + writelen > ptr->shared->size) {
420082fa:	5791                	li	a5,-28
420082fc:	10f97363          	bgeu	s2,a5,42008402 <fs_write+0x238>
42008300:	01c92583          	lw	a1,28(s2)
42008304:	0e058f63          	beqz	a1,42008402 <fs_write+0x238>
42008308:	0035f793          	and	a5,a1,3
4200830c:	0e079b63          	bnez	a5,42008402 <fs_write+0x238>
42008310:	57e1                	li	a5,-8
42008312:	0ef5f863          	bgeu	a1,a5,42008402 <fs_write+0x238>
42008316:	459c                	lw	a5,8(a1)
42008318:	0ce7cc63          	blt	a5,a4,420083f0 <fs_write+0x226>
        vfs_file_resize(ec, ptr->shared, ptr->offset + writelen);
    }
    vfs_file_write(ec, ptr->shared, ptr->offset, writebuf, writelen);
4200831c:	8722                	mv	a4,s0
4200831e:	86ce                	mv	a3,s3
42008320:	8526                	mv	a0,s1
42008322:	06f020ef          	jal	4200ab90 <vfs_file_write>
    mutex_release(NULL, &ptr->mutex);
42008326:	85d6                	mv	a1,s5
42008328:	4501                	li	a0,0
4200832a:	cdafb0ef          	jal	42003804 <mutex_release>

    mutex_release_shared(NULL, &vfs_handle_mtx);
4200832e:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42008332:	4501                	li	a0,0
42008334:	821fb0ef          	jal	42003b54 <mutex_release_shared>
    return writelen;
42008338:	8522                	mv	a0,s0
4200833a:	4942                	lw	s2,16(sp)
4200833c:	4462                	lw	s0,24(sp)
4200833e:	49b2                	lw	s3,12(sp)
42008340:	4a92                	lw	s5,4(sp)
}
42008342:	40f2                	lw	ra,28(sp)
42008344:	44d2                	lw	s1,20(sp)
42008346:	4a22                	lw	s4,8(sp)
42008348:	6105                	add	sp,sp,32
4200834a:	8082                	ret
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
4200834c:	c895                	beqz	s1,42008380 <fs_write+0x1b6>
4200834e:	420175b7          	lui	a1,0x42017
42008352:	4689                	li	a3,2
42008354:	4635                	li	a2,13
42008356:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200835a:	4511                	li	a0,4
4200835c:	00000717          	auipc	a4,0x0
42008360:	f3bfa0ef          	jal	4200329a <logkf>
42008364:	0034f793          	and	a5,s1,3
42008368:	fbb9                	bnez	a5,420082be <fs_write+0xf4>
4200836a:	57f1                	li	a5,-4
4200836c:	f4f4f9e3          	bgeu	s1,a5,420082be <fs_write+0xf4>
42008370:	47b5                	li	a5,13
42008372:	c0dc                	sw	a5,4(s1)
42008374:	4789                	li	a5,2
42008376:	4462                	lw	s0,24(sp)
42008378:	4942                	lw	s2,16(sp)
4200837a:	49b2                	lw	s3,12(sp)
4200837c:	c09c                	sw	a5,0(s1)
4200837e:	b73d                	j	420082ac <fs_write+0xe2>
42008380:	4462                	lw	s0,24(sp)
42008382:	4942                	lw	s2,16(sp)
42008384:	49b2                	lw	s3,12(sp)
42008386:	b71d                	j	420082ac <fs_write+0xe2>
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42008388:	420185b7          	lui	a1,0x42018
4200838c:	f9c58593          	add	a1,a1,-100 # 42017f9c <hextab+0x12d0>
42008390:	c256                	sw	s5,4(sp)
42008392:	ec3fa0ef          	jal	42003254 <logk>
42008396:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
42008398:	420185b7          	lui	a1,0x42018
4200839c:	04458593          	add	a1,a1,68 # 42018044 <hextab+0x1378>
420083a0:	eb5fa0ef          	jal	42003254 <logk>
420083a4:	9002                	ebreak
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOSPACE);
420083a6:	c495                	beqz	s1,420083d2 <fs_write+0x208>
420083a8:	420175b7          	lui	a1,0x42017
420083ac:	46f1                	li	a3,28
420083ae:	4635                	li	a2,13
420083b0:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420083b4:	4511                	li	a0,4
420083b6:	00000717          	auipc	a4,0x0
420083ba:	ee1fa0ef          	jal	4200329a <logkf>
420083be:	0034f793          	and	a5,s1,3
420083c2:	e3a1                	bnez	a5,42008402 <fs_write+0x238>
420083c4:	57f1                	li	a5,-4
420083c6:	02f4fe63          	bgeu	s1,a5,42008402 <fs_write+0x238>
420083ca:	47b5                	li	a5,13
420083cc:	c0dc                	sw	a5,4(s1)
420083ce:	47f1                	li	a5,28
420083d0:	c09c                	sw	a5,0(s1)
        mutex_release(NULL, &ptr->mutex);
420083d2:	85d6                	mv	a1,s5
420083d4:	4501                	li	a0,0
420083d6:	c2efb0ef          	jal	42003804 <mutex_release>
        mutex_release_shared(NULL, &vfs_handle_mtx);
420083da:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420083de:	4501                	li	a0,0
420083e0:	f74fb0ef          	jal	42003b54 <mutex_release_shared>
        return 0;
420083e4:	4501                	li	a0,0
        mutex_release_shared(NULL, &vfs_handle_mtx);
420083e6:	4462                	lw	s0,24(sp)
420083e8:	4942                	lw	s2,16(sp)
420083ea:	49b2                	lw	s3,12(sp)
420083ec:	4a92                	lw	s5,4(sp)
420083ee:	bf91                	j	42008342 <fs_write+0x178>
        vfs_file_resize(ec, ptr->shared, ptr->offset + writelen);
420083f0:	863a                	mv	a2,a4
420083f2:	8526                	mv	a0,s1
420083f4:	7d6020ef          	jal	4200abca <vfs_file_resize>
420083f8:	00092603          	lw	a2,0(s2)
420083fc:	01c92583          	lw	a1,28(s2)
42008400:	bf31                	j	4200831c <fs_write+0x152>
    if (ptr->offset + writelen > ptr->shared->size) {
42008402:	9002                	ebreak
42008404:	cc22                	sw	s0,24(sp)
42008406:	c84a                	sw	s2,16(sp)
42008408:	c64e                	sw	s3,12(sp)
4200840a:	c256                	sw	s5,4(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
4200840c:	9002                	ebreak

4200840e <fs_tell>:

// Get the current offset in the file.
fileoff_t fs_tell(badge_err_t *ec, file_t file) {
4200840e:	1141                	add	sp,sp,-16
42008410:	c226                	sw	s1,4(sp)
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42008412:	0016e637          	lui	a2,0x16e
fileoff_t fs_tell(badge_err_t *ec, file_t file) {
42008416:	c422                	sw	s0,8(sp)
42008418:	c04a                	sw	s2,0(sp)
4200841a:	842e                	mv	s0,a1
4200841c:	892a                	mv	s2,a0
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
4200841e:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42008422:	4681                	li	a3,0
42008424:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42008428:	4501                	li	a0,0
fileoff_t fs_tell(badge_err_t *ec, file_t file) {
4200842a:	c606                	sw	ra,12(sp)
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
4200842c:	cfefb0ef          	jal	4200392a <mutex_acquire_shared>
42008430:	c171                	beqz	a0,420084f4 <fs_tell+0xe6>

    // Look up the handle.
    ptrdiff_t index = vfs_file_by_handle(file);
42008432:	8522                	mv	a0,s0
42008434:	7b5010ef          	jal	4200a3e8 <vfs_file_by_handle>
    if (index == -1) {
42008438:	57fd                	li	a5,-1
4200843a:	06f50763          	beq	a0,a5,420084a8 <fs_tell+0x9a>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
        mutex_release_shared(NULL, &vfs_handle_mtx);
        return 0;
    }
    vfs_file_handle_t *ptr = &vfs_file_handle_list[index];
4200843e:	4080a7b7          	lui	a5,0x4080a
42008442:	e2c7a703          	lw	a4,-468(a5) # 40809e2c <vfs_file_handle_list>
42008446:	00351793          	sll	a5,a0,0x3
4200844a:	97aa                	add	a5,a5,a0
4200844c:	078a                	sll	a5,a5,0x2
4200844e:	00f70433          	add	s0,a4,a5
42008452:	0407d863          	bgez	a5,420084a2 <fs_tell+0x94>
42008456:	04876863          	bltu	a4,s0,420084a6 <fs_tell+0x98>

    // Get the position atomically.
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
4200845a:	c431                	beqz	s0,420084a6 <fs_tell+0x98>
4200845c:	00347793          	and	a5,s0,3
42008460:	e3b9                	bnez	a5,420084a6 <fs_tell+0x98>
42008462:	57e1                	li	a5,-8
42008464:	04f47163          	bgeu	s0,a5,420084a6 <fs_tell+0x98>
42008468:	00840913          	add	s2,s0,8
4200846c:	0016e637          	lui	a2,0x16e
42008470:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42008474:	4681                	li	a3,0
42008476:	85ca                	mv	a1,s2
42008478:	4501                	li	a0,0
4200847a:	9f8fb0ef          	jal	42003672 <mutex_acquire>
4200847e:	c151                	beqz	a0,42008502 <fs_tell+0xf4>
    fileoff_t ret = ptr->offset;
    mutex_release(NULL, &ptr->mutex);
42008480:	85ca                	mv	a1,s2
42008482:	4501                	li	a0,0
    fileoff_t ret = ptr->offset;
42008484:	4000                	lw	s0,0(s0)
    mutex_release(NULL, &ptr->mutex);
42008486:	b7efb0ef          	jal	42003804 <mutex_release>

    mutex_release_shared(NULL, &vfs_handle_mtx);
4200848a:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
4200848e:	4501                	li	a0,0
42008490:	ec4fb0ef          	jal	42003b54 <mutex_release_shared>
    return ret;
}
42008494:	40b2                	lw	ra,12(sp)
42008496:	8522                	mv	a0,s0
42008498:	4422                	lw	s0,8(sp)
4200849a:	4492                	lw	s1,4(sp)
4200849c:	4902                	lw	s2,0(sp)
4200849e:	0141                	add	sp,sp,16
420084a0:	8082                	ret
    vfs_file_handle_t *ptr = &vfs_file_handle_list[index];
420084a2:	fae47ce3          	bgeu	s0,a4,4200845a <fs_tell+0x4c>
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
420084a6:	9002                	ebreak
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
420084a8:	02090963          	beqz	s2,420084da <fs_tell+0xcc>
420084ac:	420175b7          	lui	a1,0x42017
420084b0:	4689                	li	a3,2
420084b2:	4635                	li	a2,13
420084b4:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420084b8:	4511                	li	a0,4
420084ba:	00000717          	auipc	a4,0x0
420084be:	dddfa0ef          	jal	4200329a <logkf>
420084c2:	00397793          	and	a5,s2,3
420084c6:	f3e5                	bnez	a5,420084a6 <fs_tell+0x98>
420084c8:	57f1                	li	a5,-4
420084ca:	fcf97ee3          	bgeu	s2,a5,420084a6 <fs_tell+0x98>
420084ce:	47b5                	li	a5,13
420084d0:	00f92223          	sw	a5,4(s2)
420084d4:	4789                	li	a5,2
420084d6:	00f92023          	sw	a5,0(s2)
        mutex_release_shared(NULL, &vfs_handle_mtx);
420084da:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420084de:	4501                	li	a0,0
420084e0:	e74fb0ef          	jal	42003b54 <mutex_release_shared>
        return 0;
420084e4:	4401                	li	s0,0
}
420084e6:	40b2                	lw	ra,12(sp)
420084e8:	8522                	mv	a0,s0
420084ea:	4422                	lw	s0,8(sp)
420084ec:	4492                	lw	s1,4(sp)
420084ee:	4902                	lw	s2,0(sp)
420084f0:	0141                	add	sp,sp,16
420084f2:	8082                	ret
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
420084f4:	420185b7          	lui	a1,0x42018
420084f8:	0e458593          	add	a1,a1,228 # 420180e4 <hextab+0x1418>
420084fc:	d59fa0ef          	jal	42003254 <logk>
42008500:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
42008502:	420185b7          	lui	a1,0x42018
42008506:	18c58593          	add	a1,a1,396 # 4201818c <hextab+0x14c0>
4200850a:	d4bfa0ef          	jal	42003254 <logk>
4200850e:	9002                	ebreak

42008510 <fs_seek>:

// Set the current offset in the file.
// Returns the new offset in the file.
fileoff_t fs_seek(badge_err_t *ec, file_t file, fileoff_t off, fs_seek_t seekmode) {
42008510:	1101                	add	sp,sp,-32
42008512:	c84a                	sw	s2,16(sp)
42008514:	c452                	sw	s4,8(sp)
42008516:	8932                	mv	s2,a2
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42008518:	0016e637          	lui	a2,0x16e
fileoff_t fs_seek(badge_err_t *ec, file_t file, fileoff_t off, fs_seek_t seekmode) {
4200851c:	cc22                	sw	s0,24(sp)
4200851e:	ca26                	sw	s1,20(sp)
42008520:	c64e                	sw	s3,12(sp)
42008522:	84aa                	mv	s1,a0
42008524:	842e                	mv	s0,a1
42008526:	89b6                	mv	s3,a3
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42008528:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
4200852c:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42008530:	4681                	li	a3,0
42008532:	4501                	li	a0,0
fileoff_t fs_seek(badge_err_t *ec, file_t file, fileoff_t off, fs_seek_t seekmode) {
42008534:	ce06                	sw	ra,28(sp)
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
42008536:	bf4fb0ef          	jal	4200392a <mutex_acquire_shared>
4200853a:	1a050b63          	beqz	a0,420086f0 <fs_seek+0x1e0>

    // Look up the handle.
    ptrdiff_t index = vfs_file_by_handle(file);
4200853e:	8522                	mv	a0,s0
42008540:	6a9010ef          	jal	4200a3e8 <vfs_file_by_handle>
    if (index == -1) {
42008544:	57fd                	li	a5,-1
42008546:	0af50563          	beq	a0,a5,420085f0 <fs_seek+0xe0>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
        mutex_release_shared(NULL, &vfs_handle_mtx);
        return 0;
    }
    vfs_file_handle_t *ptr = &vfs_file_handle_list[index];
4200854a:	4080a7b7          	lui	a5,0x4080a
4200854e:	e2c7a703          	lw	a4,-468(a5) # 40809e2c <vfs_file_handle_list>
42008552:	00351793          	sll	a5,a0,0x3
42008556:	97aa                	add	a5,a5,a0
42008558:	078a                	sll	a5,a5,0x2
4200855a:	c256                	sw	s5,4(sp)
4200855c:	00f70433          	add	s0,a4,a5
42008560:	0807d563          	bgez	a5,420085ea <fs_seek+0xda>
42008564:	08876563          	bltu	a4,s0,420085ee <fs_seek+0xde>

    // Update the position atomically.
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
42008568:	c059                	beqz	s0,420085ee <fs_seek+0xde>
4200856a:	00347793          	and	a5,s0,3
4200856e:	e3c1                	bnez	a5,420085ee <fs_seek+0xde>
42008570:	57e1                	li	a5,-8
42008572:	06f47e63          	bgeu	s0,a5,420085ee <fs_seek+0xde>
42008576:	00840a93          	add	s5,s0,8
4200857a:	0016e637          	lui	a2,0x16e
4200857e:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42008582:	4681                	li	a3,0
42008584:	85d6                	mv	a1,s5
42008586:	4501                	li	a0,0
42008588:	8eafb0ef          	jal	42003672 <mutex_acquire>
4200858c:	16050a63          	beqz	a0,42008700 <fs_seek+0x1f0>
    badge_err_set_ok(ec);
42008590:	c4cd                	beqz	s1,4200863a <fs_seek+0x12a>
42008592:	0034f793          	and	a5,s1,3
42008596:	efa1                	bnez	a5,420085ee <fs_seek+0xde>
42008598:	57f1                	li	a5,-4
4200859a:	04f4fa63          	bgeu	s1,a5,420085ee <fs_seek+0xde>
4200859e:	0004a223          	sw	zero,4(s1)
420085a2:	0004a023          	sw	zero,0(s1)
    switch (seekmode) {
420085a6:	12098a63          	beqz	s3,420086da <fs_seek+0x1ca>
420085aa:	4785                	li	a5,1
420085ac:	0cf98963          	beq	s3,a5,4200867e <fs_seek+0x16e>
420085b0:	57fd                	li	a5,-1
420085b2:	0ef99c63          	bne	s3,a5,420086aa <fs_seek+0x19a>
        case SEEK_ABS: ptr->offset = off; break;
        case SEEK_CUR: ptr->offset += off; break;
        case SEEK_END: ptr->offset = ptr->shared->size + off; break;
420085b6:	01242023          	sw	s2,0(s0)
        default: badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM); break;
    }
    // Clamp offset.
    if (ptr->offset < 0) {
420085ba:	4018                	lw	a4,0(s0)
420085bc:	08075a63          	bgez	a4,42008650 <fs_seek+0x140>
        ptr->offset = 0;
420085c0:	00042023          	sw	zero,0(s0)
    } else if (!ptr->is_dir && ptr->offset > ptr->shared->size) {
        ptr->offset = ptr->shared->size;
    } else if (ptr->is_dir && ptr->offset > ptr->dir_cache_size) {
        ptr->offset = ptr->dir_cache_size;
    }
    mutex_release(NULL, &ptr->mutex);
420085c4:	85d6                	mv	a1,s5
420085c6:	4501                	li	a0,0
420085c8:	a3cfb0ef          	jal	42003804 <mutex_release>

    mutex_release_shared(NULL, &vfs_handle_mtx);
420085cc:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
420085d0:	4501                	li	a0,0
420085d2:	d82fb0ef          	jal	42003b54 <mutex_release_shared>
    return ptr->offset;
420085d6:	4008                	lw	a0,0(s0)
}
420085d8:	40f2                	lw	ra,28(sp)
420085da:	4462                	lw	s0,24(sp)
    return ptr->offset;
420085dc:	4a92                	lw	s5,4(sp)
}
420085de:	44d2                	lw	s1,20(sp)
420085e0:	4942                	lw	s2,16(sp)
420085e2:	49b2                	lw	s3,12(sp)
420085e4:	4a22                	lw	s4,8(sp)
420085e6:	6105                	add	sp,sp,32
420085e8:	8082                	ret
    vfs_file_handle_t *ptr = &vfs_file_handle_list[index];
420085ea:	f6e47fe3          	bgeu	s0,a4,42008568 <fs_seek+0x58>
    } else if (ptr->is_dir && ptr->offset > ptr->dir_cache_size) {
420085ee:	9002                	ebreak
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
420085f0:	c49d                	beqz	s1,4200861e <fs_seek+0x10e>
420085f2:	420175b7          	lui	a1,0x42017
420085f6:	4689                	li	a3,2
420085f8:	4635                	li	a2,13
420085fa:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420085fe:	4511                	li	a0,4
42008600:	00000717          	auipc	a4,0x0
42008604:	c97fa0ef          	jal	4200329a <logkf>
42008608:	0034f793          	and	a5,s1,3
4200860c:	10079163          	bnez	a5,4200870e <fs_seek+0x1fe>
42008610:	57f1                	li	a5,-4
42008612:	0ef4fe63          	bgeu	s1,a5,4200870e <fs_seek+0x1fe>
42008616:	47b5                	li	a5,13
42008618:	c0dc                	sw	a5,4(s1)
4200861a:	4789                	li	a5,2
4200861c:	c09c                	sw	a5,0(s1)
        mutex_release_shared(NULL, &vfs_handle_mtx);
4200861e:	0c418593          	add	a1,gp,196 # 408000c4 <vfs_handle_mtx>
42008622:	4501                	li	a0,0
42008624:	d30fb0ef          	jal	42003b54 <mutex_release_shared>
}
42008628:	40f2                	lw	ra,28(sp)
4200862a:	4462                	lw	s0,24(sp)
4200862c:	44d2                	lw	s1,20(sp)
4200862e:	4942                	lw	s2,16(sp)
42008630:	49b2                	lw	s3,12(sp)
42008632:	4a22                	lw	s4,8(sp)
        return 0;
42008634:	4501                	li	a0,0
}
42008636:	6105                	add	sp,sp,32
42008638:	8082                	ret
    switch (seekmode) {
4200863a:	0a098063          	beqz	s3,420086da <fs_seek+0x1ca>
4200863e:	4785                	li	a5,1
42008640:	02f98f63          	beq	s3,a5,4200867e <fs_seek+0x16e>
42008644:	57fd                	li	a5,-1
42008646:	f6f988e3          	beq	s3,a5,420085b6 <fs_seek+0xa6>
    if (ptr->offset < 0) {
4200864a:	4018                	lw	a4,0(s0)
4200864c:	f6074ae3          	bltz	a4,420085c0 <fs_seek+0xb0>
    } else if (!ptr->is_dir && ptr->offset > ptr->shared->size) {
42008650:	00644783          	lbu	a5,6(s0)
42008654:	4685                	li	a3,1
42008656:	f8f6ece3          	bltu	a3,a5,420085ee <fs_seek+0xde>
4200865a:	8b85                	and	a5,a5,1
4200865c:	e7bd                	bnez	a5,420086ca <fs_seek+0x1ba>
4200865e:	5791                	li	a5,-28
42008660:	f8f477e3          	bgeu	s0,a5,420085ee <fs_seek+0xde>
42008664:	4c5c                	lw	a5,28(s0)
42008666:	d7c1                	beqz	a5,420085ee <fs_seek+0xde>
42008668:	0037f693          	and	a3,a5,3
4200866c:	f2c9                	bnez	a3,420085ee <fs_seek+0xde>
4200866e:	56e1                	li	a3,-8
42008670:	f6d7ffe3          	bgeu	a5,a3,420085ee <fs_seek+0xde>
42008674:	479c                	lw	a5,8(a5)
42008676:	f4e7d7e3          	bge	a5,a4,420085c4 <fs_seek+0xb4>
        ptr->offset = ptr->dir_cache_size;
4200867a:	c01c                	sw	a5,0(s0)
4200867c:	b7a1                	j	420085c4 <fs_seek+0xb4>
        case SEEK_END: ptr->offset = ptr->shared->size + off; break;
4200867e:	5791                	li	a5,-28
42008680:	f6f477e3          	bgeu	s0,a5,420085ee <fs_seek+0xde>
42008684:	4c5c                	lw	a5,28(s0)
42008686:	d7a5                	beqz	a5,420085ee <fs_seek+0xde>
42008688:	0037f713          	and	a4,a5,3
4200868c:	f32d                	bnez	a4,420085ee <fs_seek+0xde>
4200868e:	5761                	li	a4,-8
42008690:	f4e7ffe3          	bgeu	a5,a4,420085ee <fs_seek+0xde>
42008694:	479c                	lw	a5,8(a5)
42008696:	00092713          	slti	a4,s2,0
4200869a:	993e                	add	s2,s2,a5
4200869c:	00f927b3          	slt	a5,s2,a5
420086a0:	f4f717e3          	bne	a4,a5,420085ee <fs_seek+0xde>
420086a4:	01242023          	sw	s2,0(s0)
420086a8:	bf09                	j	420085ba <fs_seek+0xaa>
        default: badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM); break;
420086aa:	420175b7          	lui	a1,0x42017
420086ae:	4689                	li	a3,2
420086b0:	4635                	li	a2,13
420086b2:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420086b6:	4511                	li	a0,4
420086b8:	00000717          	auipc	a4,0x0
420086bc:	bdffa0ef          	jal	4200329a <logkf>
420086c0:	47b5                	li	a5,13
420086c2:	c0dc                	sw	a5,4(s1)
420086c4:	4789                	li	a5,2
420086c6:	c09c                	sw	a5,0(s1)
420086c8:	b749                	j	4200864a <fs_seek+0x13a>
    } else if (ptr->is_dir && ptr->offset > ptr->dir_cache_size) {
420086ca:	57b1                	li	a5,-20
420086cc:	f2f471e3          	bgeu	s0,a5,420085ee <fs_seek+0xde>
420086d0:	485c                	lw	a5,20(s0)
420086d2:	eee7d9e3          	bge	a5,a4,420085c4 <fs_seek+0xb4>
        ptr->offset = ptr->dir_cache_size;
420086d6:	c01c                	sw	a5,0(s0)
420086d8:	b5f5                	j	420085c4 <fs_seek+0xb4>
        case SEEK_CUR: ptr->offset += off; break;
420086da:	401c                	lw	a5,0(s0)
420086dc:	00092713          	slti	a4,s2,0
420086e0:	993e                	add	s2,s2,a5
420086e2:	00f927b3          	slt	a5,s2,a5
420086e6:	f0f714e3          	bne	a4,a5,420085ee <fs_seek+0xde>
        case SEEK_END: ptr->offset = ptr->shared->size + off; break;
420086ea:	01242023          	sw	s2,0(s0)
420086ee:	b5f1                	j	420085ba <fs_seek+0xaa>
    assert_always(mutex_acquire_shared(NULL, &vfs_handle_mtx, VFS_MUTEX_TIMEOUT));
420086f0:	420185b7          	lui	a1,0x42018
420086f4:	22c58593          	add	a1,a1,556 # 4201822c <hextab+0x1560>
420086f8:	c256                	sw	s5,4(sp)
420086fa:	b5bfa0ef          	jal	42003254 <logk>
420086fe:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &ptr->mutex, VFS_MUTEX_TIMEOUT));
42008700:	420185b7          	lui	a1,0x42018
42008704:	2d458593          	add	a1,a1,724 # 420182d4 <hextab+0x1608>
42008708:	b4dfa0ef          	jal	42003254 <logk>
4200870c:	9002                	ebreak
4200870e:	c256                	sw	s5,4(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42008710:	9002                	ebreak

42008712 <fs_dir_read>:
bool fs_dir_read(badge_err_t *ec, dirent_t *dirent_out, file_t dir) {
42008712:	7179                	add	sp,sp,-48
42008714:	ce4e                	sw	s3,28(sp)
42008716:	89ae                	mv	s3,a1
    if (!is_dir_handle(ec, dir))
42008718:	85b2                	mv	a1,a2
bool fs_dir_read(badge_err_t *ec, dirent_t *dirent_out, file_t dir) {
4200871a:	d422                	sw	s0,40(sp)
4200871c:	d04a                	sw	s2,32(sp)
4200871e:	d606                	sw	ra,44(sp)
42008720:	d226                	sw	s1,36(sp)
42008722:	8932                	mv	s2,a2
42008724:	842a                	mv	s0,a0
    if (!is_dir_handle(ec, dir))
42008726:	a6ffd0ef          	jal	42006194 <is_dir_handle>
4200872a:	c51d                	beqz	a0,42008758 <fs_dir_read+0x46>
4200872c:	cc52                	sw	s4,24(sp)
    badge_err_t ec0 = {.cause = ECAUSE_OK};
4200872e:	c002                	sw	zero,0(sp)
42008730:	c202                	sw	zero,4(sp)
42008732:	c402                	sw	zero,8(sp)
42008734:	c602                	sw	zero,12(sp)
42008736:	84aa                	mv	s1,a0
    if (!ec)
42008738:	0e040a63          	beqz	s0,4200882c <fs_dir_read+0x11a>
    fileoff_t pos = fs_tell(ec, dir);
4200873c:	85ca                	mv	a1,s2
4200873e:	8522                	mv	a0,s0
42008740:	ccfff0ef          	jal	4200840e <fs_tell>
42008744:	8a2a                	mv	s4,a0
    if (!badge_err_is_ok(ec))
42008746:	14040e63          	beqz	s0,420088a2 <fs_dir_read+0x190>
4200874a:	00347793          	and	a5,s0,3
4200874e:	14079a63          	bnez	a5,420088a2 <fs_dir_read+0x190>
42008752:	401c                	lw	a5,0(s0)
42008754:	cb99                	beqz	a5,4200876a <fs_dir_read+0x58>
42008756:	4a62                	lw	s4,24(sp)
        return false;
42008758:	4481                	li	s1,0
}
4200875a:	50b2                	lw	ra,44(sp)
4200875c:	5422                	lw	s0,40(sp)
4200875e:	5902                	lw	s2,32(sp)
42008760:	49f2                	lw	s3,28(sp)
42008762:	8526                	mv	a0,s1
42008764:	5492                	lw	s1,36(sp)
42008766:	6145                	add	sp,sp,48
42008768:	8082                	ret
    fileoff_t len      = fs_read(ec, dir, dirent_out, read_len);
4200876a:	46c1                	li	a3,16
4200876c:	864e                	mv	a2,s3
4200876e:	85ca                	mv	a1,s2
42008770:	8522                	mv	a0,s0
42008772:	f86ff0ef          	jal	42007ef8 <fs_read>
    if (len == 0 && badge_err_is_ok(ec)) {
42008776:	d165                	beqz	a0,42008756 <fs_dir_read+0x44>
42008778:	401c                	lw	a5,0(s0)
    if (!badge_err_is_ok(ec)) {
4200877a:	fff1                	bnez	a5,42008756 <fs_dir_read+0x44>
    if (dirent_out->name_len > FILESYSTEM_NAME_MAX || dirent_out->record_len < read_len + dirent_out->name_len) {
4200877c:	12098363          	beqz	s3,420088a2 <fs_dir_read+0x190>
42008780:	0039f793          	and	a5,s3,3
42008784:	10079f63          	bnez	a5,420088a2 <fs_dir_read+0x190>
42008788:	57d1                	li	a5,-12
4200878a:	10f9fc63          	bgeu	s3,a5,420088a2 <fs_dir_read+0x190>
4200878e:	00c9a683          	lw	a3,12(s3)
42008792:	0ff00793          	li	a5,255
42008796:	0cd7c963          	blt	a5,a3,42008868 <fs_dir_read+0x156>
4200879a:	0009a703          	lw	a4,0(s3)
4200879e:	01068793          	add	a5,a3,16
420087a2:	0cf74363          	blt	a4,a5,42008868 <fs_dir_read+0x156>
420087a6:	ca56                	sw	s5,20(sp)
420087a8:	c85a                	sw	s6,16(sp)
    fileoff_t name_len = fs_read(ec, dir, dirent_out->name, dirent_out->name_len);
420087aa:	57c1                	li	a5,-16
420087ac:	0ef9fa63          	bgeu	s3,a5,420088a0 <fs_dir_read+0x18e>
420087b0:	01098b13          	add	s6,s3,16
420087b4:	865a                	mv	a2,s6
420087b6:	85ca                	mv	a1,s2
420087b8:	8522                	mv	a0,s0
420087ba:	f3eff0ef          	jal	42007ef8 <fs_read>
    if (!badge_err_is_ok(ec) || name_len != dirent_out->name_len || mem_index(dirent_out->name, name_len, '/') != -1 ||
420087be:	401c                	lw	a5,0(s0)
    fileoff_t name_len = fs_read(ec, dir, dirent_out->name, dirent_out->name_len);
420087c0:	8aaa                	mv	s5,a0
    if (!badge_err_is_ok(ec) || name_len != dirent_out->name_len || mem_index(dirent_out->name, name_len, '/') != -1 ||
420087c2:	e7bd                	bnez	a5,42008830 <fs_dir_read+0x11e>
420087c4:	00c9a783          	lw	a5,12(s3)
420087c8:	06a79463          	bne	a5,a0,42008830 <fs_dir_read+0x11e>
420087cc:	85aa                	mv	a1,a0
420087ce:	02f00613          	li	a2,47
420087d2:	855a                	mv	a0,s6
420087d4:	99df90ef          	jal	42002170 <mem_index>
420087d8:	57fd                	li	a5,-1
420087da:	04f51b63          	bne	a0,a5,42008830 <fs_dir_read+0x11e>
        mem_index(dirent_out->name, name_len, 0) != -1) {
420087de:	4601                	li	a2,0
420087e0:	85d6                	mv	a1,s5
420087e2:	855a                	mv	a0,s6
420087e4:	98df90ef          	jal	42002170 <mem_index>
    if (!badge_err_is_ok(ec) || name_len != dirent_out->name_len || mem_index(dirent_out->name, name_len, '/') != -1 ||
420087e8:	57fd                	li	a5,-1
420087ea:	04f51363          	bne	a0,a5,42008830 <fs_dir_read+0x11e>
    fs_seek(ec, dir, pos + dirent_out->record_len, SEEK_ABS);
420087ee:	0009a783          	lw	a5,0(s3)
420087f2:	000a2713          	slti	a4,s4,0
420087f6:	01478633          	add	a2,a5,s4
420087fa:	00f627b3          	slt	a5,a2,a5
420087fe:	0af71163          	bne	a4,a5,420088a0 <fs_dir_read+0x18e>
42008802:	56fd                	li	a3,-1
42008804:	85ca                	mv	a1,s2
42008806:	8522                	mv	a0,s0
42008808:	d09ff0ef          	jal	42008510 <fs_seek>
    dirent_out->name[name_len] = 0;
4200880c:	010a8793          	add	a5,s5,16
42008810:	00f98733          	add	a4,s3,a5
42008814:	0807c463          	bltz	a5,4200889c <fs_dir_read+0x18a>
42008818:	09376463          	bltu	a4,s3,420088a0 <fs_dir_read+0x18e>
4200881c:	015987b3          	add	a5,s3,s5
42008820:	00078823          	sb	zero,16(a5)
42008824:	4a62                	lw	s4,24(sp)
42008826:	4ad2                	lw	s5,20(sp)
42008828:	4b42                	lw	s6,16(sp)
    return true;
4200882a:	bf05                	j	4200875a <fs_dir_read+0x48>
        ec = &ec0;
4200882c:	840a                	mv	s0,sp
4200882e:	b739                	j	4200873c <fs_dir_read+0x2a>
        fs_seek(NULL, dir, pos, SEEK_ABS);
42008830:	56fd                	li	a3,-1
42008832:	8652                	mv	a2,s4
42008834:	85ca                	mv	a1,s2
42008836:	4501                	li	a0,0
42008838:	cd9ff0ef          	jal	42008510 <fs_seek>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNKNOWN);
4200883c:	420175b7          	lui	a1,0x42017
42008840:	4685                	li	a3,1
42008842:	4635                	li	a2,13
42008844:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42008848:	4511                	li	a0,4
4200884a:	00000717          	auipc	a4,0x0
4200884e:	a4dfa0ef          	jal	4200329a <logkf>
42008852:	57f1                	li	a5,-4
42008854:	04f47663          	bgeu	s0,a5,420088a0 <fs_dir_read+0x18e>
42008858:	47b5                	li	a5,13
4200885a:	c05c                	sw	a5,4(s0)
4200885c:	4785                	li	a5,1
        return false;
4200885e:	4a62                	lw	s4,24(sp)
42008860:	4ad2                	lw	s5,20(sp)
42008862:	4b42                	lw	s6,16(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNKNOWN);
42008864:	c01c                	sw	a5,0(s0)
        return false;
42008866:	bdcd                	j	42008758 <fs_dir_read+0x46>
        fs_seek(NULL, dir, pos, SEEK_ABS);
42008868:	56fd                	li	a3,-1
4200886a:	8652                	mv	a2,s4
4200886c:	85ca                	mv	a1,s2
4200886e:	4501                	li	a0,0
42008870:	ca1ff0ef          	jal	42008510 <fs_seek>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNKNOWN);
42008874:	420175b7          	lui	a1,0x42017
42008878:	4685                	li	a3,1
4200887a:	4635                	li	a2,13
4200887c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42008880:	4511                	li	a0,4
42008882:	00000717          	auipc	a4,0x0
42008886:	a15fa0ef          	jal	4200329a <logkf>
4200888a:	57f1                	li	a5,-4
4200888c:	00f47b63          	bgeu	s0,a5,420088a2 <fs_dir_read+0x190>
42008890:	47b5                	li	a5,13
42008892:	c05c                	sw	a5,4(s0)
42008894:	4785                	li	a5,1
42008896:	4a62                	lw	s4,24(sp)
42008898:	c01c                	sw	a5,0(s0)
        return false;
4200889a:	bd7d                	j	42008758 <fs_dir_read+0x46>
    dirent_out->name[name_len] = 0;
4200889c:	f8e9f0e3          	bgeu	s3,a4,4200881c <fs_dir_read+0x10a>
420088a0:	9002                	ebreak
420088a2:	ca56                	sw	s5,20(sp)
420088a4:	c85a                	sw	s6,16(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNKNOWN);
420088a6:	9002                	ebreak

420088a8 <fs_flush>:

// Force any write caches to be flushed for a given file.
// If the file is `FILE_NONE`, all open files are flushed.
void fs_flush(badge_err_t *ec, file_t file) {
    (void)file;
    badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNSUPPORTED);
420088a8:	cd15                	beqz	a0,420088e4 <fs_flush+0x3c>
void fs_flush(badge_err_t *ec, file_t file) {
420088aa:	1141                	add	sp,sp,-16
    badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNSUPPORTED);
420088ac:	420175b7          	lui	a1,0x42017
void fs_flush(badge_err_t *ec, file_t file) {
420088b0:	c422                	sw	s0,8(sp)
    badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNSUPPORTED);
420088b2:	46cd                	li	a3,19
420088b4:	842a                	mv	s0,a0
420088b6:	4635                	li	a2,13
420088b8:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420088bc:	4511                	li	a0,4
void fs_flush(badge_err_t *ec, file_t file) {
420088be:	c606                	sw	ra,12(sp)
    badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNSUPPORTED);
420088c0:	00000717          	auipc	a4,0x0
420088c4:	9d7fa0ef          	jal	4200329a <logkf>
420088c8:	00347793          	and	a5,s0,3
420088cc:	ef91                	bnez	a5,420088e8 <fs_flush+0x40>
420088ce:	57f1                	li	a5,-4
420088d0:	00f47b63          	bgeu	s0,a5,420088e6 <fs_flush+0x3e>
420088d4:	47b5                	li	a5,13
420088d6:	c05c                	sw	a5,4(s0)
420088d8:	47cd                	li	a5,19
}
420088da:	40b2                	lw	ra,12(sp)
    badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNSUPPORTED);
420088dc:	c01c                	sw	a5,0(s0)
}
420088de:	4422                	lw	s0,8(sp)
420088e0:	0141                	add	sp,sp,16
420088e2:	8082                	ret
420088e4:	8082                	ret
    badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_UNSUPPORTED);
420088e6:	9002                	ebreak
420088e8:	9002                	ebreak

420088ea <syscall_fs_open>:



// Open a file, optionally relative to a directory.
// Returns <= -1 on error, file descriptor number of success.
int syscall_fs_open(char const *path, int relative_to, int oflags) {
420088ea:	1101                	add	sp,sp,-32
420088ec:	cc22                	sw	s0,24(sp)
420088ee:	ca26                	sw	s1,20(sp)
420088f0:	ce06                	sw	ra,28(sp)
420088f2:	84b2                	mv	s1,a2
420088f4:	842a                	mv	s0,a0
    (void)relative_to;
    process_t *const proc = proc_current();
420088f6:	48b020ef          	jal	4200b580 <proc_current>
420088fa:	87aa                	mv	a5,a0
    file_t           fd   = fs_open(NULL, path, oflags);
420088fc:	8626                	mv	a2,s1
420088fe:	85a2                	mv	a1,s0
42008900:	4501                	li	a0,0
    process_t *const proc = proc_current();
42008902:	84be                	mv	s1,a5
    file_t           fd   = fs_open(NULL, path, oflags);
42008904:	a87fd0ef          	jal	4200638a <fs_open>
    int              virt = -1;
    if (fd >= 0) {
42008908:	02054963          	bltz	a0,4200893a <syscall_fs_open+0x50>
        badge_err_t ec;
        virt = proc_add_fd_raw(&ec, proc, fd);
4200890c:	862a                	mv	a2,a0
4200890e:	842a                	mv	s0,a0
42008910:	85a6                	mv	a1,s1
42008912:	850a                	mv	a0,sp
42008914:	334030ef          	jal	4200bc48 <proc_add_fd_raw>
        if (!badge_err_is_ok(&ec)) {
42008918:	4782                	lw	a5,0(sp)
4200891a:	e791                	bnez	a5,42008926 <syscall_fs_open+0x3c>
            fs_close(NULL, fd);
            virt = -1;
        }
    }
    return virt;
}
4200891c:	40f2                	lw	ra,28(sp)
4200891e:	4462                	lw	s0,24(sp)
42008920:	44d2                	lw	s1,20(sp)
42008922:	6105                	add	sp,sp,32
42008924:	8082                	ret
            fs_close(NULL, fd);
42008926:	85a2                	mv	a1,s0
42008928:	4501                	li	a0,0
4200892a:	af9fe0ef          	jal	42007422 <fs_close>
}
4200892e:	40f2                	lw	ra,28(sp)
42008930:	4462                	lw	s0,24(sp)
42008932:	44d2                	lw	s1,20(sp)
            virt = -1;
42008934:	557d                	li	a0,-1
}
42008936:	6105                	add	sp,sp,32
42008938:	8082                	ret
    int              virt = -1;
4200893a:	557d                	li	a0,-1
    return virt;
4200893c:	b7c5                	j	4200891c <syscall_fs_open+0x32>

4200893e <syscall_fs_close>:

// Flush and close a file.
bool syscall_fs_close(int virt) {
4200893e:	1101                	add	sp,sp,-32
42008940:	ce06                	sw	ra,28(sp)
42008942:	cc22                	sw	s0,24(sp)
42008944:	ca26                	sw	s1,20(sp)
42008946:	842a                	mv	s0,a0
    process_t *const proc = proc_current();
42008948:	439020ef          	jal	4200b580 <proc_current>
4200894c:	84aa                	mv	s1,a0
    badge_err_t      ec;
    file_t           fd = proc_find_fd_raw(NULL, proc_current(), virt);
4200894e:	433020ef          	jal	4200b580 <proc_current>
42008952:	85aa                	mv	a1,a0
42008954:	8622                	mv	a2,s0
42008956:	4501                	li	a0,0
42008958:	458030ef          	jal	4200bdb0 <proc_find_fd_raw>
4200895c:	87aa                	mv	a5,a0
    proc_remove_fd_raw(&ec, proc, virt);
4200895e:	8622                	mv	a2,s0
42008960:	850a                	mv	a0,sp
42008962:	85a6                	mv	a1,s1
    file_t           fd = proc_find_fd_raw(NULL, proc_current(), virt);
42008964:	843e                	mv	s0,a5
    proc_remove_fd_raw(&ec, proc, virt);
42008966:	51c030ef          	jal	4200be82 <proc_remove_fd_raw>
    if (!badge_err_is_ok(&ec)) {
4200896a:	4782                	lw	a5,0(sp)
        return false;
4200896c:	4501                	li	a0,0
    if (!badge_err_is_ok(&ec)) {
4200896e:	c791                	beqz	a5,4200897a <syscall_fs_close+0x3c>
    } else {
        fs_close(NULL, fd);
        return true;
    }
}
42008970:	40f2                	lw	ra,28(sp)
42008972:	4462                	lw	s0,24(sp)
42008974:	44d2                	lw	s1,20(sp)
42008976:	6105                	add	sp,sp,32
42008978:	8082                	ret
        fs_close(NULL, fd);
4200897a:	85a2                	mv	a1,s0
4200897c:	4501                	li	a0,0
4200897e:	aa5fe0ef          	jal	42007422 <fs_close>
}
42008982:	40f2                	lw	ra,28(sp)
42008984:	4462                	lw	s0,24(sp)
42008986:	44d2                	lw	s1,20(sp)
        return true;
42008988:	4505                	li	a0,1
}
4200898a:	6105                	add	sp,sp,32
4200898c:	8082                	ret

4200898e <syscall_fs_read>:

// Read bytes from a file.
// Returns -1 on EOF, <= -2 on error, read count on success.
long syscall_fs_read(int virt, void *read_buf, long read_len) {
4200898e:	1141                	add	sp,sp,-16
42008990:	c606                	sw	ra,12(sp)
42008992:	c422                	sw	s0,8(sp)
42008994:	c226                	sw	s1,4(sp)
42008996:	c04a                	sw	s2,0(sp)
42008998:	842a                	mv	s0,a0
4200899a:	84ae                	mv	s1,a1
4200899c:	8932                	mv	s2,a2
    file_t fd = proc_find_fd_raw(NULL, proc_current(), virt);
4200899e:	3e3020ef          	jal	4200b580 <proc_current>
420089a2:	85aa                	mv	a1,a0
420089a4:	8622                	mv	a2,s0
420089a6:	4501                	li	a0,0
420089a8:	408030ef          	jal	4200bdb0 <proc_find_fd_raw>
    if (fd != -1) {
420089ac:	57fd                	li	a5,-1
420089ae:	00f50d63          	beq	a0,a5,420089c8 <syscall_fs_read+0x3a>
        return fs_read(NULL, fd, read_buf, read_len);
    }
    return -1;
}
420089b2:	4422                	lw	s0,8(sp)
420089b4:	40b2                	lw	ra,12(sp)
        return fs_read(NULL, fd, read_buf, read_len);
420089b6:	86ca                	mv	a3,s2
420089b8:	8626                	mv	a2,s1
}
420089ba:	4902                	lw	s2,0(sp)
420089bc:	4492                	lw	s1,4(sp)
420089be:	85aa                	mv	a1,a0
        return fs_read(NULL, fd, read_buf, read_len);
420089c0:	4501                	li	a0,0
}
420089c2:	0141                	add	sp,sp,16
        return fs_read(NULL, fd, read_buf, read_len);
420089c4:	d34ff06f          	j	42007ef8 <fs_read>
}
420089c8:	40b2                	lw	ra,12(sp)
420089ca:	4422                	lw	s0,8(sp)
420089cc:	4492                	lw	s1,4(sp)
420089ce:	4902                	lw	s2,0(sp)
420089d0:	0141                	add	sp,sp,16
420089d2:	8082                	ret

420089d4 <syscall_fs_write>:

// Write bytes to a file.
// Returns <= -1 on error, write count on success.
long syscall_fs_write(int virt, void const *write_buf, long write_len) {
420089d4:	1141                	add	sp,sp,-16
420089d6:	c606                	sw	ra,12(sp)
420089d8:	c422                	sw	s0,8(sp)
420089da:	c226                	sw	s1,4(sp)
420089dc:	c04a                	sw	s2,0(sp)
420089de:	842a                	mv	s0,a0
420089e0:	84ae                	mv	s1,a1
420089e2:	8932                	mv	s2,a2
    file_t fd = proc_find_fd_raw(NULL, proc_current(), virt);
420089e4:	39d020ef          	jal	4200b580 <proc_current>
420089e8:	85aa                	mv	a1,a0
420089ea:	8622                	mv	a2,s0
420089ec:	4501                	li	a0,0
420089ee:	3c2030ef          	jal	4200bdb0 <proc_find_fd_raw>
    if (fd != -1) {
420089f2:	57fd                	li	a5,-1
420089f4:	00f50d63          	beq	a0,a5,42008a0e <syscall_fs_write+0x3a>
        return fs_write(NULL, fd, write_buf, write_len);
    }
    return -1;
}
420089f8:	4422                	lw	s0,8(sp)
420089fa:	40b2                	lw	ra,12(sp)
        return fs_write(NULL, fd, write_buf, write_len);
420089fc:	86ca                	mv	a3,s2
420089fe:	8626                	mv	a2,s1
}
42008a00:	4902                	lw	s2,0(sp)
42008a02:	4492                	lw	s1,4(sp)
42008a04:	85aa                	mv	a1,a0
        return fs_write(NULL, fd, write_buf, write_len);
42008a06:	4501                	li	a0,0
}
42008a08:	0141                	add	sp,sp,16
        return fs_write(NULL, fd, write_buf, write_len);
42008a0a:	fc0ff06f          	j	420081ca <fs_write>
}
42008a0e:	40b2                	lw	ra,12(sp)
42008a10:	4422                	lw	s0,8(sp)
42008a12:	4492                	lw	s1,4(sp)
42008a14:	4902                	lw	s2,0(sp)
42008a16:	0141                	add	sp,sp,16
42008a18:	8082                	ret

42008a1a <syscall_fs_getdents>:

// Read directory entries from a directory handle.
// See `dirent_t` for the format.
// Returns <= -1 on error, read count on success.
long syscall_fs_getdents(int virt, void *read_buf, long read_len) {
42008a1a:	1141                	add	sp,sp,-16
42008a1c:	c606                	sw	ra,12(sp)
42008a1e:	c422                	sw	s0,8(sp)
42008a20:	c226                	sw	s1,4(sp)
42008a22:	c04a                	sw	s2,0(sp)
42008a24:	84ae                	mv	s1,a1
42008a26:	8932                	mv	s2,a2
42008a28:	842a                	mv	s0,a0
    file_t fd = proc_find_fd_raw(NULL, proc_current(), virt);
42008a2a:	357020ef          	jal	4200b580 <proc_current>
42008a2e:	85aa                	mv	a1,a0
42008a30:	8622                	mv	a2,s0
42008a32:	4501                	li	a0,0
42008a34:	37c030ef          	jal	4200bdb0 <proc_find_fd_raw>
42008a38:	842a                	mv	s0,a0
    fs_seek(NULL, fd, 0, SEEK_ABS);
42008a3a:	85aa                	mv	a1,a0
42008a3c:	56fd                	li	a3,-1
42008a3e:	4601                	li	a2,0
42008a40:	4501                	li	a0,0
42008a42:	acfff0ef          	jal	42008510 <fs_seek>
    return fs_read(NULL, fd, read_buf, read_len);
42008a46:	85a2                	mv	a1,s0
}
42008a48:	4422                	lw	s0,8(sp)
42008a4a:	40b2                	lw	ra,12(sp)
    return fs_read(NULL, fd, read_buf, read_len);
42008a4c:	86ca                	mv	a3,s2
42008a4e:	8626                	mv	a2,s1
}
42008a50:	4902                	lw	s2,0(sp)
42008a52:	4492                	lw	s1,4(sp)
    return fs_read(NULL, fd, read_buf, read_len);
42008a54:	4501                	li	a0,0
}
42008a56:	0141                	add	sp,sp,16
    return fs_read(NULL, fd, read_buf, read_len);
42008a58:	ca0ff06f          	j	42007ef8 <fs_read>

42008a5c <pop_inode_refcount>:
    return -1;
}

// Decrease the refcount of an inode and delete it if it reaches 0.
static void pop_inode_refcount(vfs_t *vfs, vfs_ramfs_inode_t *inode) {
    inode->links--;
42008a5c:	c9ad                	beqz	a1,42008ace <pop_inode_refcount+0x72>
static void pop_inode_refcount(vfs_t *vfs, vfs_ramfs_inode_t *inode) {
42008a5e:	1141                	add	sp,sp,-16
42008a60:	c422                	sw	s0,8(sp)
42008a62:	c606                	sw	ra,12(sp)
    inode->links--;
42008a64:	0035f793          	and	a5,a1,3
42008a68:	842e                	mv	s0,a1
42008a6a:	efa9                	bnez	a5,42008ac4 <pop_inode_refcount+0x68>
42008a6c:	57b1                	li	a5,-20
42008a6e:	04f5f963          	bgeu	a1,a5,42008ac0 <pop_inode_refcount+0x64>
42008a72:	49dc                	lw	a5,20(a1)
42008a74:	17fd                	add	a5,a5,-1
42008a76:	c9dc                	sw	a5,20(a1)
    if (inode->links == 0) {
42008a78:	c789                	beqz	a5,42008a82 <pop_inode_refcount+0x26>
        // Free inode.
        free(inode->buf);
        vfs->ramfs.inode_usage[inode->inode] = false;
    }
}
42008a7a:	40b2                	lw	ra,12(sp)
42008a7c:	4422                	lw	s0,8(sp)
42008a7e:	0141                	add	sp,sp,16
42008a80:	8082                	ret
42008a82:	c226                	sw	s1,4(sp)
42008a84:	84aa                	mv	s1,a0
        free(inode->buf);
42008a86:	4588                	lw	a0,8(a1)
42008a88:	0d4050ef          	jal	4200db5c <free>
        vfs->ramfs.inode_usage[inode->inode] = false;
42008a8c:	c0a1                	beqz	s1,42008acc <pop_inode_refcount+0x70>
42008a8e:	0034f793          	and	a5,s1,3
42008a92:	ef8d                	bnez	a5,42008acc <pop_inode_refcount+0x70>
42008a94:	5781                	li	a5,-32
42008a96:	02f4fa63          	bgeu	s1,a5,42008aca <pop_inode_refcount+0x6e>
42008a9a:	5098                	lw	a4,32(s1)
42008a9c:	4454                	lw	a3,12(s0)
42008a9e:	00d707b3          	add	a5,a4,a3
42008aa2:	0006dc63          	bgez	a3,42008aba <pop_inode_refcount+0x5e>
42008aa6:	00f76c63          	bltu	a4,a5,42008abe <pop_inode_refcount+0x62>
42008aaa:	cf99                	beqz	a5,42008ac8 <pop_inode_refcount+0x6c>
}
42008aac:	40b2                	lw	ra,12(sp)
42008aae:	4422                	lw	s0,8(sp)
        vfs->ramfs.inode_usage[inode->inode] = false;
42008ab0:	00078023          	sb	zero,0(a5)
42008ab4:	4492                	lw	s1,4(sp)
}
42008ab6:	0141                	add	sp,sp,16
42008ab8:	8082                	ret
        vfs->ramfs.inode_usage[inode->inode] = false;
42008aba:	fee7f8e3          	bgeu	a5,a4,42008aaa <pop_inode_refcount+0x4e>
42008abe:	9002                	ebreak
42008ac0:	c226                	sw	s1,4(sp)
    inode->links--;
42008ac2:	9002                	ebreak
42008ac4:	c226                	sw	s1,4(sp)
42008ac6:	9002                	ebreak
        vfs->ramfs.inode_usage[inode->inode] = false;
42008ac8:	9002                	ebreak
42008aca:	9002                	ebreak
42008acc:	9002                	ebreak
    inode->links--;
42008ace:	9002                	ebreak

42008ad0 <convert_dirent.isra.0>:
}

// Convert a RAMFS dirent to a BadgerOS dirent.
// Returns the record length for a matching `dirent_t`.
static inline size_t convert_dirent(vfs_t *vfs, dirent_t *out, vfs_ramfs_dirent_t *in) {
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[in->inode];
42008ad0:	cd61                	beqz	a0,42008ba8 <convert_dirent.isra.0+0xd8>
42008ad2:	00357713          	and	a4,a0,3
42008ad6:	eb69                	bnez	a4,42008ba8 <convert_dirent.isra.0+0xd8>
42008ad8:	5711                	li	a4,-28
42008ada:	0ce57663          	bgeu	a0,a4,42008ba6 <convert_dirent.isra.0+0xd6>
42008ade:	4d58                	lw	a4,28(a0)
42008ae0:	87b2                	mv	a5,a2
42008ae2:	c269                	beqz	a2,42008ba4 <convert_dirent.isra.0+0xd4>
42008ae4:	00367693          	and	a3,a2,3
42008ae8:	eed5                	bnez	a3,42008ba4 <convert_dirent.isra.0+0xd4>
42008aea:	56f1                	li	a3,-4
42008aec:	0ad67b63          	bgeu	a2,a3,42008ba2 <convert_dirent.isra.0+0xd2>
42008af0:	00462883          	lw	a7,4(a2)
42008af4:	00589613          	sll	a2,a7,0x5
42008af8:	00c706b3          	add	a3,a4,a2
42008afc:	0a064063          	bltz	a2,42008b9c <convert_dirent.isra.0+0xcc>
42008b00:	0ae6e063          	bltu	a3,a4,42008ba0 <convert_dirent.isra.0+0xd0>

    out->record_len  = offsetof(dirent_t, name) + in->name_len + 1;
42008b04:	5861                	li	a6,-8
42008b06:	0b07fd63          	bgeu	a5,a6,42008bc0 <convert_dirent.isra.0+0xf0>
42008b0a:	4790                	lw	a2,8(a5)
42008b0c:	01160513          	add	a0,a2,17
42008b10:	c5dd                	beqz	a1,42008bbe <convert_dirent.isra.0+0xee>
42008b12:	0035f713          	and	a4,a1,3
42008b16:	e745                	bnez	a4,42008bbe <convert_dirent.isra.0+0xee>
42008b18:	c188                	sw	a0,0(a1)
    out->record_len += (fileoff_t)((size_t)(~out->record_len + 1) % sizeof(size_t));
42008b1a:	80000337          	lui	t1,0x80000
42008b1e:	40a00733          	neg	a4,a0
42008b22:	08650d63          	beq	a0,t1,42008bbc <convert_dirent.isra.0+0xec>
42008b26:	8b0d                	and	a4,a4,3
42008b28:	972a                	add	a4,a4,a0
42008b2a:	08a74863          	blt	a4,a0,42008bba <convert_dirent.isra.0+0xea>
42008b2e:	c198                	sw	a4,0(a1)
    out->inode       = in->inode;
42008b30:	5771                	li	a4,-4
42008b32:	08e5f363          	bgeu	a1,a4,42008bb8 <convert_dirent.isra.0+0xe8>
42008b36:	0115a223          	sw	a7,4(a1)
    out->is_dir      = (iptr->mode & VFS_RAMFS_MODE_MASK) == FILETYPE_DIR << VFS_RAMFS_MODE_BIT;
42008b3a:	ceb5                	beqz	a3,42008bb6 <convert_dirent.isra.0+0xe6>
42008b3c:	0036f713          	and	a4,a3,3
42008b40:	eb3d                	bnez	a4,42008bb6 <convert_dirent.isra.0+0xe6>
42008b42:	5741                	li	a4,-16
42008b44:	06e6f863          	bgeu	a3,a4,42008bb4 <convert_dirent.isra.0+0xe4>
42008b48:	0106d703          	lhu	a4,16(a3)
42008b4c:	76fd                	lui	a3,0xfffff
42008b4e:	8f75                	and	a4,a4,a3
42008b50:	76f1                	lui	a3,0xffffc
42008b52:	96ba                	add	a3,a3,a4
42008b54:	0016b693          	seqz	a3,a3
42008b58:	0505fd63          	bgeu	a1,a6,42008bb2 <convert_dirent.isra.0+0xe2>
    out->is_symlink  = (iptr->mode & VFS_RAMFS_MODE_MASK) == FILETYPE_LINK << VFS_RAMFS_MODE_BIT;
42008b5c:	7559                	lui	a0,0xffff6
42008b5e:	972a                	add	a4,a4,a0
    out->is_dir      = (iptr->mode & VFS_RAMFS_MODE_MASK) == FILETYPE_DIR << VFS_RAMFS_MODE_BIT;
42008b60:	00d58423          	sb	a3,8(a1)
    out->is_symlink  = (iptr->mode & VFS_RAMFS_MODE_MASK) == FILETYPE_LINK << VFS_RAMFS_MODE_BIT;
42008b64:	56dd                	li	a3,-9
42008b66:	00173713          	seqz	a4,a4
42008b6a:	04d5f363          	bgeu	a1,a3,42008bb0 <convert_dirent.isra.0+0xe0>
42008b6e:	00e584a3          	sb	a4,9(a1)
    out->name_len    = (fileoff_t)in->name_len;
42008b72:	5751                	li	a4,-12
42008b74:	02e5fd63          	bgeu	a1,a4,42008bae <convert_dirent.isra.0+0xde>
42008b78:	c5d0                	sw	a2,12(a1)
    mem_copy(out->name, in->name, in->name_len + 1);
42008b7a:	56c1                	li	a3,-16
42008b7c:	02d5f863          	bgeu	a1,a3,42008bac <convert_dirent.isra.0+0xdc>
42008b80:	01058513          	add	a0,a1,16
42008b84:	02e7f363          	bgeu	a5,a4,42008baa <convert_dirent.isra.0+0xda>
static inline size_t convert_dirent(vfs_t *vfs, dirent_t *out, vfs_ramfs_dirent_t *in) {
42008b88:	1141                	add	sp,sp,-16
    mem_copy(out->name, in->name, in->name_len + 1);
42008b8a:	0605                	add	a2,a2,1
42008b8c:	00c78593          	add	a1,a5,12
static inline size_t convert_dirent(vfs_t *vfs, dirent_t *out, vfs_ramfs_dirent_t *in) {
42008b90:	c606                	sw	ra,12(sp)
    mem_copy(out->name, in->name, in->name_len + 1);
42008b92:	fdaf90ef          	jal	4200236c <mem_copy>

    return out->record_len;
}
42008b96:	40b2                	lw	ra,12(sp)
42008b98:	0141                	add	sp,sp,16
42008b9a:	8082                	ret
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[in->inode];
42008b9c:	f6d774e3          	bgeu	a4,a3,42008b04 <convert_dirent.isra.0+0x34>
42008ba0:	9002                	ebreak
42008ba2:	9002                	ebreak
42008ba4:	9002                	ebreak
42008ba6:	9002                	ebreak
42008ba8:	9002                	ebreak
    mem_copy(out->name, in->name, in->name_len + 1);
42008baa:	9002                	ebreak
42008bac:	9002                	ebreak
    out->name_len    = (fileoff_t)in->name_len;
42008bae:	9002                	ebreak
    out->is_symlink  = (iptr->mode & VFS_RAMFS_MODE_MASK) == FILETYPE_LINK << VFS_RAMFS_MODE_BIT;
42008bb0:	9002                	ebreak
    out->is_dir      = (iptr->mode & VFS_RAMFS_MODE_MASK) == FILETYPE_DIR << VFS_RAMFS_MODE_BIT;
42008bb2:	9002                	ebreak
42008bb4:	9002                	ebreak
42008bb6:	9002                	ebreak
    out->inode       = in->inode;
42008bb8:	9002                	ebreak
    out->record_len += (fileoff_t)((size_t)(~out->record_len + 1) % sizeof(size_t));
42008bba:	9002                	ebreak
42008bbc:	9002                	ebreak
    out->record_len  = offsetof(dirent_t, name) + in->name_len + 1;
42008bbe:	9002                	ebreak
42008bc0:	9002                	ebreak

42008bc2 <find_dirent.isra.0>:
static vfs_ramfs_dirent_t *find_dirent(badge_err_t *ec, vfs_t *vfs, vfs_ramfs_inode_t *dir, char const *name) {
42008bc2:	7179                	add	sp,sp,-48
42008bc4:	d04a                	sw	s2,32(sp)
42008bc6:	ce4e                	sw	s3,28(sp)
42008bc8:	d606                	sw	ra,44(sp)
42008bca:	892e                	mv	s2,a1
42008bcc:	89b2                	mv	s3,a2
    badge_err_set_ok(ec);
42008bce:	c545                	beqz	a0,42008c76 <find_dirent.isra.0+0xb4>
42008bd0:	00357793          	and	a5,a0,3
42008bd4:	ebcd                	bnez	a5,42008c86 <find_dirent.isra.0+0xc4>
42008bd6:	57f1                	li	a5,-4
42008bd8:	0af57763          	bgeu	a0,a5,42008c86 <find_dirent.isra.0+0xc4>
42008bdc:	cc52                	sw	s4,24(sp)
42008bde:	ca56                	sw	s5,20(sp)
42008be0:	00052223          	sw	zero,4(a0) # ffff6004 <__stop_free_lpsram+0xafff2004>
42008be4:	00052023          	sw	zero,0(a0)
    while (off < dir->len) {
42008be8:	08090a63          	beqz	s2,42008c7c <find_dirent.isra.0+0xba>
42008bec:	00397793          	and	a5,s2,3
42008bf0:	e7d1                	bnez	a5,42008c7c <find_dirent.isra.0+0xba>
42008bf2:	00092a83          	lw	s5,0(s2)
42008bf6:	040a8863          	beqz	s5,42008c46 <find_dirent.isra.0+0x84>
42008bfa:	d226                	sw	s1,36(sp)
42008bfc:	c85a                	sw	s6,16(sp)
42008bfe:	c65e                	sw	s7,12(sp)
42008c00:	d422                	sw	s0,40(sp)
42008c02:	4481                	li	s1,0
        vfs_ramfs_dirent_t *ent = (vfs_ramfs_dirent_t *)(dir->buf + off);
42008c04:	5be1                	li	s7,-8
        if (cstr_equals(name, ent->name)) {
42008c06:	5b51                	li	s6,-12
        vfs_ramfs_dirent_t *ent = (vfs_ramfs_dirent_t *)(dir->buf + off);
42008c08:	05797a63          	bgeu	s2,s7,42008c5c <find_dirent.isra.0+0x9a>
42008c0c:	00892783          	lw	a5,8(s2)
42008c10:	00978433          	add	s0,a5,s1
42008c14:	0404c263          	bltz	s1,42008c58 <find_dirent.isra.0+0x96>
42008c18:	04f46263          	bltu	s0,a5,42008c5c <find_dirent.isra.0+0x9a>
42008c1c:	8a22                	mv	s4,s0
        if (cstr_equals(name, ent->name)) {
42008c1e:	cc1d                	beqz	s0,42008c5c <find_dirent.isra.0+0x9a>
42008c20:	00347793          	and	a5,s0,3
42008c24:	ef85                	bnez	a5,42008c5c <find_dirent.isra.0+0x9a>
42008c26:	03647b63          	bgeu	s0,s6,42008c5c <find_dirent.isra.0+0x9a>
42008c2a:	00c40593          	add	a1,s0,12
42008c2e:	854e                	mv	a0,s3
42008c30:	adcf90ef          	jal	42001f0c <cstr_equals>
42008c34:	e50d                	bnez	a0,42008c5e <find_dirent.isra.0+0x9c>
        off += ent->size;
42008c36:	401c                	lw	a5,0(s0)
42008c38:	94be                	add	s1,s1,a5
    while (off < dir->len) {
42008c3a:	fd54e7e3          	bltu	s1,s5,42008c08 <find_dirent.isra.0+0x46>
42008c3e:	5422                	lw	s0,40(sp)
42008c40:	5492                	lw	s1,36(sp)
42008c42:	4b42                	lw	s6,16(sp)
42008c44:	4bb2                	lw	s7,12(sp)
}
42008c46:	50b2                	lw	ra,44(sp)
    return NULL;
42008c48:	4a01                	li	s4,0
}
42008c4a:	4ad2                	lw	s5,20(sp)
42008c4c:	5902                	lw	s2,32(sp)
42008c4e:	49f2                	lw	s3,28(sp)
42008c50:	8552                	mv	a0,s4
42008c52:	4a62                	lw	s4,24(sp)
42008c54:	6145                	add	sp,sp,48
42008c56:	8082                	ret
        vfs_ramfs_dirent_t *ent = (vfs_ramfs_dirent_t *)(dir->buf + off);
42008c58:	fc87f2e3          	bgeu	a5,s0,42008c1c <find_dirent.isra.0+0x5a>
        if (cstr_equals(name, ent->name)) {
42008c5c:	9002                	ebreak
42008c5e:	5422                	lw	s0,40(sp)
}
42008c60:	50b2                	lw	ra,44(sp)
42008c62:	5492                	lw	s1,36(sp)
42008c64:	4b42                	lw	s6,16(sp)
42008c66:	4bb2                	lw	s7,12(sp)
42008c68:	4ad2                	lw	s5,20(sp)
42008c6a:	5902                	lw	s2,32(sp)
42008c6c:	49f2                	lw	s3,28(sp)
42008c6e:	8552                	mv	a0,s4
42008c70:	4a62                	lw	s4,24(sp)
42008c72:	6145                	add	sp,sp,48
42008c74:	8082                	ret
42008c76:	cc52                	sw	s4,24(sp)
42008c78:	ca56                	sw	s5,20(sp)
42008c7a:	b7bd                	j	42008be8 <find_dirent.isra.0+0x26>
42008c7c:	d422                	sw	s0,40(sp)
42008c7e:	d226                	sw	s1,36(sp)
42008c80:	c85a                	sw	s6,16(sp)
42008c82:	c65e                	sw	s7,12(sp)
    while (off < dir->len) {
42008c84:	9002                	ebreak
42008c86:	d422                	sw	s0,40(sp)
42008c88:	d226                	sw	s1,36(sp)
42008c8a:	cc52                	sw	s4,24(sp)
42008c8c:	ca56                	sw	s5,20(sp)
42008c8e:	c85a                	sw	s6,16(sp)
42008c90:	c65e                	sw	s7,12(sp)
    badge_err_set_ok(ec);
42008c92:	9002                	ebreak

42008c94 <resize_inode.isra.0>:
    if (inode->cap >= 2 * size) {
42008c94:	c9c5                	beqz	a1,42008d44 <resize_inode.isra.0+0xb0>
static bool resize_inode(badge_err_t *ec, vfs_t *vfs, vfs_ramfs_inode_t *inode, size_t size) {
42008c96:	1141                	add	sp,sp,-16
42008c98:	c226                	sw	s1,4(sp)
42008c9a:	c606                	sw	ra,12(sp)
42008c9c:	c422                	sw	s0,8(sp)
42008c9e:	c04a                	sw	s2,0(sp)
    if (inode->cap >= 2 * size) {
42008ca0:	0035f793          	and	a5,a1,3
42008ca4:	84ae                	mv	s1,a1
42008ca6:	ebd1                	bnez	a5,42008d3a <resize_inode.isra.0+0xa6>
42008ca8:	57f1                	li	a5,-4
42008caa:	08f5fa63          	bgeu	a1,a5,42008d3e <resize_inode.isra.0+0xaa>
42008cae:	41c0                	lw	s0,4(a1)
42008cb0:	00161713          	sll	a4,a2,0x1
42008cb4:	8932                	mv	s2,a2
42008cb6:	04e47c63          	bgeu	s0,a4,42008d0e <resize_inode.isra.0+0x7a>
    } else if (inode->cap >= size) {
42008cba:	02c47d63          	bgeu	s0,a2,42008cf4 <resize_inode.isra.0+0x60>
        size_t cap = 1;
42008cbe:	4405                	li	s0,1
        while (cap < size) {
42008cc0:	00860563          	beq	a2,s0,42008cca <resize_inode.isra.0+0x36>
            cap *= 2;
42008cc4:	0406                	sll	s0,s0,0x1
        while (cap < size) {
42008cc6:	ff246fe3          	bltu	s0,s2,42008cc4 <resize_inode.isra.0+0x30>
        void *mem = realloc(inode->buf, cap);
42008cca:	57e1                	li	a5,-8
42008ccc:	06f4f863          	bgeu	s1,a5,42008d3c <resize_inode.isra.0+0xa8>
42008cd0:	4488                	lw	a0,8(s1)
42008cd2:	85a2                	mv	a1,s0
42008cd4:	6ff040ef          	jal	4200dbd2 <realloc>
42008cd8:	87aa                	mv	a5,a0
            return false;
42008cda:	4501                	li	a0,0
        if (mem) {
42008cdc:	c791                	beqz	a5,42008ce8 <resize_inode.isra.0+0x54>
            inode->cap = cap;
42008cde:	c0c0                	sw	s0,4(s1)
            inode->buf = mem;
42008ce0:	c49c                	sw	a5,8(s1)
            inode->len = size;
42008ce2:	0124a023          	sw	s2,0(s1)
        return true;
42008ce6:	4505                	li	a0,1
}
42008ce8:	40b2                	lw	ra,12(sp)
42008cea:	4422                	lw	s0,8(sp)
42008cec:	4492                	lw	s1,4(sp)
42008cee:	4902                	lw	s2,0(sp)
42008cf0:	0141                	add	sp,sp,16
42008cf2:	8082                	ret
        inode->len = size;
42008cf4:	c190                	sw	a2,0(a1)
        badge_err_set_ok(ec);
42008cf6:	d965                	beqz	a0,42008ce6 <resize_inode.isra.0+0x52>
42008cf8:	00357713          	and	a4,a0,3
42008cfc:	e339                	bnez	a4,42008d42 <resize_inode.isra.0+0xae>
42008cfe:	04f57163          	bgeu	a0,a5,42008d40 <resize_inode.isra.0+0xac>
42008d02:	00052223          	sw	zero,4(a0)
42008d06:	00052023          	sw	zero,0(a0)
        return true;
42008d0a:	4505                	li	a0,1
42008d0c:	bff1                	j	42008ce8 <resize_inode.isra.0+0x54>
        void  *mem = realloc(inode->buf, inode->cap / 2);
42008d0e:	57e1                	li	a5,-8
42008d10:	02f5fb63          	bgeu	a1,a5,42008d46 <resize_inode.isra.0+0xb2>
42008d14:	4588                	lw	a0,8(a1)
42008d16:	00145593          	srl	a1,s0,0x1
42008d1a:	6b9040ef          	jal	4200dbd2 <realloc>
        if (mem || cap == 0) {
42008d1e:	c901                	beqz	a0,42008d2e <resize_inode.isra.0+0x9a>
            inode->cap /= 2;
42008d20:	40dc                	lw	a5,4(s1)
            inode->buf  = mem;
42008d22:	c488                	sw	a0,8(s1)
            inode->len = size;
42008d24:	0124a023          	sw	s2,0(s1)
            inode->cap /= 2;
42008d28:	8385                	srl	a5,a5,0x1
42008d2a:	c0dc                	sw	a5,4(s1)
            return true;
42008d2c:	bf6d                	j	42008ce6 <resize_inode.isra.0+0x52>
        if (mem || cap == 0) {
42008d2e:	4785                	li	a5,1
42008d30:	fe87f8e3          	bgeu	a5,s0,42008d20 <resize_inode.isra.0+0x8c>
            inode->len = size;
42008d34:	0124a023          	sw	s2,0(s1)
            return true;
42008d38:	b77d                	j	42008ce6 <resize_inode.isra.0+0x52>
    if (inode->cap >= 2 * size) {
42008d3a:	9002                	ebreak
        void *mem = realloc(inode->buf, cap);
42008d3c:	9002                	ebreak
    if (inode->cap >= 2 * size) {
42008d3e:	9002                	ebreak
        badge_err_set_ok(ec);
42008d40:	9002                	ebreak
42008d42:	9002                	ebreak
    if (inode->cap >= 2 * size) {
42008d44:	9002                	ebreak
        void  *mem = realloc(inode->buf, inode->cap / 2);
42008d46:	9002                	ebreak

42008d48 <insert_dirent.isra.0>:
    size_t pre_size = dir->len;
42008d48:	c9ad                	beqz	a1,42008dba <insert_dirent.isra.0+0x72>
static bool insert_dirent(badge_err_t *ec, vfs_t *vfs, vfs_ramfs_inode_t *dir, vfs_ramfs_dirent_t *ent) {
42008d4a:	1101                	add	sp,sp,-32
42008d4c:	cc22                	sw	s0,24(sp)
42008d4e:	ce06                	sw	ra,28(sp)
42008d50:	ca26                	sw	s1,20(sp)
42008d52:	c84a                	sw	s2,16(sp)
42008d54:	c64e                	sw	s3,12(sp)
    size_t pre_size = dir->len;
42008d56:	0035f793          	and	a5,a1,3
42008d5a:	842e                	mv	s0,a1
42008d5c:	efa9                	bnez	a5,42008db6 <insert_dirent.isra.0+0x6e>
42008d5e:	0005a983          	lw	s3,0(a1)
    if (!resize_inode(ec, vfs, dir, pre_size + ent->size)) {
42008d62:	84b2                	mv	s1,a2
42008d64:	ca21                	beqz	a2,42008db4 <insert_dirent.isra.0+0x6c>
42008d66:	4210                	lw	a2,0(a2)
42008d68:	964e                	add	a2,a2,s3
42008d6a:	f2bff0ef          	jal	42008c94 <resize_inode.isra.0>
42008d6e:	892a                	mv	s2,a0
42008d70:	e909                	bnez	a0,42008d82 <insert_dirent.isra.0+0x3a>
}
42008d72:	40f2                	lw	ra,28(sp)
42008d74:	4462                	lw	s0,24(sp)
42008d76:	44d2                	lw	s1,20(sp)
42008d78:	49b2                	lw	s3,12(sp)
42008d7a:	854a                	mv	a0,s2
42008d7c:	4942                	lw	s2,16(sp)
42008d7e:	6105                	add	sp,sp,32
42008d80:	8082                	ret
    mem_copy(dir->buf + pre_size, ent, ent->size);
42008d82:	57e1                	li	a5,-8
42008d84:	02f47a63          	bgeu	s0,a5,42008db8 <insert_dirent.isra.0+0x70>
42008d88:	441c                	lw	a5,8(s0)
42008d8a:	01378533          	add	a0,a5,s3
42008d8e:	0209c063          	bltz	s3,42008dae <insert_dirent.isra.0+0x66>
42008d92:	02f56063          	bltu	a0,a5,42008db2 <insert_dirent.isra.0+0x6a>
42008d96:	4090                	lw	a2,0(s1)
42008d98:	85a6                	mv	a1,s1
42008d9a:	dd2f90ef          	jal	4200236c <mem_copy>
}
42008d9e:	40f2                	lw	ra,28(sp)
42008da0:	4462                	lw	s0,24(sp)
42008da2:	44d2                	lw	s1,20(sp)
42008da4:	49b2                	lw	s3,12(sp)
42008da6:	854a                	mv	a0,s2
42008da8:	4942                	lw	s2,16(sp)
42008daa:	6105                	add	sp,sp,32
42008dac:	8082                	ret
    mem_copy(dir->buf + pre_size, ent, ent->size);
42008dae:	fea7f4e3          	bgeu	a5,a0,42008d96 <insert_dirent.isra.0+0x4e>
42008db2:	9002                	ebreak
    if (!resize_inode(ec, vfs, dir, pre_size + ent->size)) {
42008db4:	9002                	ebreak
    size_t pre_size = dir->len;
42008db6:	9002                	ebreak
    mem_copy(dir->buf + pre_size, ent, ent->size);
42008db8:	9002                	ebreak
    size_t pre_size = dir->len;
42008dba:	9002                	ebreak

42008dbc <create_file>:
    create_file(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, char const *name, filetype_t type) {
42008dbc:	7129                	add	sp,sp,-320
42008dbe:	12912a23          	sw	s1,308(sp)
42008dc2:	13212823          	sw	s2,304(sp)
42008dc6:	84ae                	mv	s1,a1
42008dc8:	892a                	mv	s2,a0
    size_t name_len = cstr_length_upto(name, VFS_RAMFS_NAME_MAX + 1);
42008dca:	10000593          	li	a1,256
42008dce:	8536                	mv	a0,a3
    create_file(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, char const *name, filetype_t type) {
42008dd0:	12812c23          	sw	s0,312(sp)
42008dd4:	13312623          	sw	s3,300(sp)
42008dd8:	13412423          	sw	s4,296(sp)
42008ddc:	11712e23          	sw	s7,284(sp)
42008de0:	12112e23          	sw	ra,316(sp)
42008de4:	13512223          	sw	s5,292(sp)
42008de8:	13612023          	sw	s6,288(sp)
42008dec:	8bb6                	mv	s7,a3
42008dee:	8432                	mv	s0,a2
42008df0:	89ba                	mv	s3,a4
    size_t name_len = cstr_length_upto(name, VFS_RAMFS_NAME_MAX + 1);
42008df2:	f8ff80ef          	jal	42001d80 <cstr_length_upto>
    if (name_len > VFS_RAMFS_NAME_MAX) {
42008df6:	0ff00793          	li	a5,255
    size_t name_len = cstr_length_upto(name, VFS_RAMFS_NAME_MAX + 1);
42008dfa:	8a2a                	mv	s4,a0
    if (name_len > VFS_RAMFS_NAME_MAX) {
42008dfc:	02a7fb63          	bgeu	a5,a0,42008e32 <create_file+0x76>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_TOOLONG);
42008e00:	02090963          	beqz	s2,42008e32 <create_file+0x76>
42008e04:	420175b7          	lui	a1,0x42017
42008e08:	4691                	li	a3,4
42008e0a:	4635                	li	a2,13
42008e0c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42008e10:	4511                	li	a0,4
42008e12:	00000717          	auipc	a4,0x0
42008e16:	c84fa0ef          	jal	4200329a <logkf>
42008e1a:	00397793          	and	a5,s2,3
42008e1e:	ebe1                	bnez	a5,42008eee <create_file+0x132>
42008e20:	57f1                	li	a5,-4
42008e22:	0cf97663          	bgeu	s2,a5,42008eee <create_file+0x132>
42008e26:	47b5                	li	a5,13
42008e28:	00f92223          	sw	a5,4(s2)
42008e2c:	4791                	li	a5,4
42008e2e:	00f92023          	sw	a5,0(s2)
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42008e32:	ccd5                	beqz	s1,42008eee <create_file+0x132>
42008e34:	0034f793          	and	a5,s1,3
42008e38:	ebdd                	bnez	a5,42008eee <create_file+0x132>
42008e3a:	fd800793          	li	a5,-40
42008e3e:	0af4f863          	bgeu	s1,a5,42008eee <create_file+0x132>
42008e42:	02848a93          	add	s5,s1,40
42008e46:	0016e637          	lui	a2,0x16e
42008e4a:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42008e4e:	4681                	li	a3,0
42008e50:	85d6                	mv	a1,s5
42008e52:	4501                	li	a0,0
42008e54:	81ffa0ef          	jal	42003672 <mutex_acquire>
42008e58:	1c050763          	beqz	a0,42009026 <create_file+0x26a>
    vfs_ramfs_inode_t  *dirptr   = dir->ramfs_file;
42008e5c:	c849                	beqz	s0,42008eee <create_file+0x132>
42008e5e:	00347793          	and	a5,s0,3
42008e62:	e7d1                	bnez	a5,42008eee <create_file+0x132>
42008e64:	57d1                	li	a5,-12
42008e66:	08f47463          	bgeu	s0,a5,42008eee <create_file+0x132>
42008e6a:	00c42b03          	lw	s6,12(s0)
    vfs_ramfs_dirent_t *existing = find_dirent(ec, vfs, dirptr, name);
42008e6e:	865e                	mv	a2,s7
42008e70:	854a                	mv	a0,s2
42008e72:	85da                	mv	a1,s6
42008e74:	d4fff0ef          	jal	42008bc2 <find_dirent.isra.0>
    if (existing) {
42008e78:	16051463          	bnez	a0,42008fe0 <create_file+0x224>
    for (size_t i = VFS_RAMFS_INODE_FIRST; i < vfs->ramfs.inode_list_len; i++) {
42008e7c:	50d8                	lw	a4,36(s1)
42008e7e:	4789                	li	a5,2
42008e80:	02e7f663          	bgeu	a5,a4,42008eac <create_file+0xf0>
42008e84:	0204a803          	lw	a6,32(s1)
42008e88:	4409                	li	s0,2
        if (!vfs->ramfs.inode_usage[i])
42008e8a:	4685                	li	a3,1
42008e8c:	008807b3          	add	a5,a6,s0
42008e90:	04044d63          	bltz	s0,42008eea <create_file+0x12e>
42008e94:	0507ed63          	bltu	a5,a6,42008eee <create_file+0x132>
42008e98:	cbb9                	beqz	a5,42008eee <create_file+0x132>
42008e9a:	0007c783          	lbu	a5,0(a5)
42008e9e:	04f6e863          	bltu	a3,a5,42008eee <create_file+0x132>
42008ea2:	8b85                	and	a5,a5,1
42008ea4:	c7b1                	beqz	a5,42008ef0 <create_file+0x134>
    for (size_t i = VFS_RAMFS_INODE_FIRST; i < vfs->ramfs.inode_list_len; i++) {
42008ea6:	0405                	add	s0,s0,1
42008ea8:	fe8712e3          	bne	a4,s0,42008e8c <create_file+0xd0>
        mutex_release(NULL, &vfs->ramfs.mtx);
42008eac:	85d6                	mv	a1,s5
42008eae:	4501                	li	a0,0
42008eb0:	955fa0ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOSPACE);
42008eb4:	02090963          	beqz	s2,42008ee6 <create_file+0x12a>
42008eb8:	420175b7          	lui	a1,0x42017
42008ebc:	46f1                	li	a3,28
42008ebe:	4635                	li	a2,13
42008ec0:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42008ec4:	4511                	li	a0,4
42008ec6:	00000717          	auipc	a4,0x0
42008eca:	bd0fa0ef          	jal	4200329a <logkf>
42008ece:	00397793          	and	a5,s2,3
42008ed2:	ef91                	bnez	a5,42008eee <create_file+0x132>
42008ed4:	57f1                	li	a5,-4
42008ed6:	00f97c63          	bgeu	s2,a5,42008eee <create_file+0x132>
42008eda:	47b5                	li	a5,13
42008edc:	00f92223          	sw	a5,4(s2)
42008ee0:	47f1                	li	a5,28
42008ee2:	00f92023          	sw	a5,0(s2)
        return NULL;
42008ee6:	4a01                	li	s4,0
42008ee8:	a845                	j	42008f98 <create_file+0x1dc>
        if (!vfs->ramfs.inode_usage[i])
42008eea:	faf877e3          	bgeu	a6,a5,42008e98 <create_file+0xdc>
        vfs->ramfs.inode_usage[inum] = true;
42008eee:	9002                	ebreak
    vfs_ramfs_dirent_t ent = {
42008ef0:	10c00613          	li	a2,268
42008ef4:	4581                	li	a1,0
42008ef6:	0048                	add	a0,sp,4
42008ef8:	a1ff90ef          	jal	42002916 <memset>
    ent.size += (~ent.size + 1) % sizeof(size_t);
42008efc:	fffa4793          	not	a5,s4
        .size     = offsetof(vfs_ramfs_dirent_t, name) + name_len + 1,
42008f00:	00da0713          	add	a4,s4,13
    ent.size += (~ent.size + 1) % sizeof(size_t);
42008f04:	8b8d                	and	a5,a5,3
42008f06:	97ba                	add	a5,a5,a4
    mem_copy(ent.name, name, name_len + 1);
42008f08:	001a0613          	add	a2,s4,1
42008f0c:	85de                	mv	a1,s7
42008f0e:	0808                	add	a0,sp,16
    ent.size += (~ent.size + 1) % sizeof(size_t);
42008f10:	c23e                	sw	a5,4(sp)
    vfs_ramfs_dirent_t ent = {
42008f12:	c422                	sw	s0,8(sp)
42008f14:	c652                	sw	s4,12(sp)
    mem_copy(ent.name, name, name_len + 1);
42008f16:	c56f90ef          	jal	4200236c <mem_copy>
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[inum];
42008f1a:	4cd8                	lw	a4,28(s1)
42008f1c:	00541693          	sll	a3,s0,0x5
42008f20:	00d707b3          	add	a5,a4,a3
42008f24:	0a06db63          	bgez	a3,42008fda <create_file+0x21e>
42008f28:	fcf763e3          	bltu	a4,a5,42008eee <create_file+0x132>
42008f2c:	8a3e                	mv	s4,a5
    iptr->buf   = NULL;
42008f2e:	d3e1                	beqz	a5,42008eee <create_file+0x132>
42008f30:	0037f713          	and	a4,a5,3
42008f34:	ff4d                	bnez	a4,42008eee <create_file+0x132>
42008f36:	5761                	li	a4,-8
42008f38:	fae7fbe3          	bgeu	a5,a4,42008eee <create_file+0x132>
42008f3c:	0007a423          	sw	zero,8(a5)
    iptr->len   = 0;
42008f40:	0007a023          	sw	zero,0(a5)
    iptr->cap   = 0;
42008f44:	0007a223          	sw	zero,4(a5)
    iptr->inode = inum;
42008f48:	5751                	li	a4,-12
42008f4a:	fae7f2e3          	bgeu	a5,a4,42008eee <create_file+0x132>
    iptr->mode  = (type << VFS_RAMFS_MODE_BIT) | 0777; /* TODO. */
42008f4e:	09b2                	sll	s3,s3,0xc
42008f50:	1ff9e993          	or	s3,s3,511
42008f54:	09c2                	sll	s3,s3,0x10
    iptr->inode = inum;
42008f56:	c7c0                	sw	s0,12(a5)
    iptr->mode  = (type << VFS_RAMFS_MODE_BIT) | 0777; /* TODO. */
42008f58:	5741                	li	a4,-16
42008f5a:	0109d993          	srl	s3,s3,0x10
42008f5e:	f8e7f8e3          	bgeu	a5,a4,42008eee <create_file+0x132>
42008f62:	01379823          	sh	s3,16(a5)
    iptr->links = 1;
42008f66:	5731                	li	a4,-20
42008f68:	f8e7f3e3          	bgeu	a5,a4,42008eee <create_file+0x132>
42008f6c:	4705                	li	a4,1
42008f6e:	cbd8                	sw	a4,20(a5)
    iptr->uid   = 0; /* TODO. */
42008f70:	5721                	li	a4,-24
42008f72:	f6e7fee3          	bgeu	a5,a4,42008eee <create_file+0x132>
42008f76:	0007ac23          	sw	zero,24(a5)
    iptr->gid   = 0; /* TODO. */
42008f7a:	5711                	li	a4,-28
42008f7c:	f6e7f9e3          	bgeu	a5,a4,42008eee <create_file+0x132>
42008f80:	0007ae23          	sw	zero,28(a5)
    if (insert_dirent(ec, vfs, dirptr, &ent)) {
42008f84:	0050                	add	a2,sp,4
42008f86:	85da                	mv	a1,s6
42008f88:	854a                	mv	a0,s2
42008f8a:	dbfff0ef          	jal	42008d48 <insert_dirent.isra.0>
42008f8e:	e915                	bnez	a0,42008fc2 <create_file+0x206>
    mutex_release(NULL, &vfs->ramfs.mtx);
42008f90:	85d6                	mv	a1,s5
42008f92:	4501                	li	a0,0
42008f94:	871fa0ef          	jal	42003804 <mutex_release>
}
42008f98:	13c12083          	lw	ra,316(sp)
42008f9c:	13812403          	lw	s0,312(sp)
42008fa0:	13412483          	lw	s1,308(sp)
42008fa4:	13012903          	lw	s2,304(sp)
42008fa8:	12c12983          	lw	s3,300(sp)
42008fac:	12412a83          	lw	s5,292(sp)
42008fb0:	12012b03          	lw	s6,288(sp)
42008fb4:	11c12b83          	lw	s7,284(sp)
42008fb8:	8552                	mv	a0,s4
42008fba:	12812a03          	lw	s4,296(sp)
42008fbe:	6131                	add	sp,sp,320
42008fc0:	8082                	ret
        vfs->ramfs.inode_usage[inum] = true;
42008fc2:	5098                	lw	a4,32(s1)
42008fc4:	008707b3          	add	a5,a4,s0
42008fc8:	04045c63          	bgez	s0,42009020 <create_file+0x264>
42008fcc:	f2f761e3          	bltu	a4,a5,42008eee <create_file+0x132>
42008fd0:	df99                	beqz	a5,42008eee <create_file+0x132>
42008fd2:	4705                	li	a4,1
42008fd4:	00e78023          	sb	a4,0(a5)
42008fd8:	bf65                	j	42008f90 <create_file+0x1d4>
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[inum];
42008fda:	f4e7f9e3          	bgeu	a5,a4,42008f2c <create_file+0x170>
        vfs->ramfs.inode_usage[inum] = true;
42008fde:	9002                	ebreak
        mutex_release(NULL, &vfs->ramfs.mtx);
42008fe0:	85d6                	mv	a1,s5
42008fe2:	4501                	li	a0,0
42008fe4:	821fa0ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_EXISTS);
42008fe8:	ee090fe3          	beqz	s2,42008ee6 <create_file+0x12a>
42008fec:	420175b7          	lui	a1,0x42017
42008ff0:	46ed                	li	a3,27
42008ff2:	4635                	li	a2,13
42008ff4:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42008ff8:	4511                	li	a0,4
42008ffa:	00000717          	auipc	a4,0x0
42008ffe:	a9cfa0ef          	jal	4200329a <logkf>
42009002:	00397793          	and	a5,s2,3
42009006:	ee0794e3          	bnez	a5,42008eee <create_file+0x132>
4200900a:	57f1                	li	a5,-4
4200900c:	eef971e3          	bgeu	s2,a5,42008eee <create_file+0x132>
42009010:	47b5                	li	a5,13
42009012:	00f92223          	sw	a5,4(s2)
42009016:	47ed                	li	a5,27
42009018:	00f92023          	sw	a5,0(s2)
        return NULL;
4200901c:	4a01                	li	s4,0
4200901e:	bfad                	j	42008f98 <create_file+0x1dc>
        vfs->ramfs.inode_usage[inum] = true;
42009020:	fae7f8e3          	bgeu	a5,a4,42008fd0 <create_file+0x214>
42009024:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009026:	420185b7          	lui	a1,0x42018
4200902a:	37458593          	add	a1,a1,884 # 42018374 <hextab+0x16a8>
4200902e:	a26fa0ef          	jal	42003254 <logk>
42009032:	9002                	ebreak

42009034 <remove_dirent.isra.0>:
static void remove_dirent(vfs_t *vfs, vfs_ramfs_inode_t *dir, vfs_ramfs_dirent_t *ent) {
42009034:	1141                	add	sp,sp,-16
42009036:	c422                	sw	s0,8(sp)
42009038:	c606                	sw	ra,12(sp)
4200903a:	c226                	sw	s1,4(sp)
4200903c:	842a                	mv	s0,a0
    size_t off      = (size_t)ent - (size_t)dir->buf;
4200903e:	cd29                	beqz	a0,42009098 <remove_dirent.isra.0+0x64>
42009040:	00357793          	and	a5,a0,3
42009044:	ebb1                	bnez	a5,42009098 <remove_dirent.isra.0+0x64>
42009046:	57e1                	li	a5,-8
42009048:	04f57863          	bgeu	a0,a5,42009098 <remove_dirent.isra.0+0x64>
4200904c:	441c                	lw	a5,8(s0)
4200904e:	852e                	mv	a0,a1
42009050:	40f58733          	sub	a4,a1,a5
    size_t ent_size = ent->size;
42009054:	c1b1                	beqz	a1,42009098 <remove_dirent.isra.0+0x64>
42009056:	0035f693          	and	a3,a1,3
4200905a:	ee9d                	bnez	a3,42009098 <remove_dirent.isra.0+0x64>
4200905c:	4184                	lw	s1,0(a1)
    mem_copy(dir->buf + off, dir->buf + off + ent_size, dir->len - ent_size);
4200905e:	00e786b3          	add	a3,a5,a4
42009062:	02074c63          	bltz	a4,4200909a <remove_dirent.isra.0+0x66>
42009066:	02f6e963          	bltu	a3,a5,42009098 <remove_dirent.isra.0+0x64>
4200906a:	9726                	add	a4,a4,s1
4200906c:	00e785b3          	add	a1,a5,a4
42009070:	02074263          	bltz	a4,42009094 <remove_dirent.isra.0+0x60>
42009074:	02f5e263          	bltu	a1,a5,42009098 <remove_dirent.isra.0+0x64>
42009078:	4010                	lw	a2,0(s0)
4200907a:	8e05                	sub	a2,a2,s1
4200907c:	af0f90ef          	jal	4200236c <mem_copy>
    resize_inode(NULL, vfs, dir, dir->len - ent_size);
42009080:	4010                	lw	a2,0(s0)
42009082:	85a2                	mv	a1,s0
}
42009084:	4422                	lw	s0,8(sp)
42009086:	40b2                	lw	ra,12(sp)
    resize_inode(NULL, vfs, dir, dir->len - ent_size);
42009088:	8e05                	sub	a2,a2,s1
}
4200908a:	4492                	lw	s1,4(sp)
    resize_inode(NULL, vfs, dir, dir->len - ent_size);
4200908c:	4501                	li	a0,0
}
4200908e:	0141                	add	sp,sp,16
    resize_inode(NULL, vfs, dir, dir->len - ent_size);
42009090:	c05ff06f          	j	42008c94 <resize_inode.isra.0>
    mem_copy(dir->buf + off, dir->buf + off + ent_size, dir->len - ent_size);
42009094:	feb7f2e3          	bgeu	a5,a1,42009078 <remove_dirent.isra.0+0x44>
42009098:	9002                	ebreak
4200909a:	fcd7f8e3          	bgeu	a5,a3,4200906a <remove_dirent.isra.0+0x36>
4200909e:	9002                	ebreak

420090a0 <vfs_ramfs_mount>:
    if (vfs->media) {
420090a0:	32058663          	beqz	a1,420093cc <vfs_ramfs_mount+0x32c>
void vfs_ramfs_mount(badge_err_t *ec, vfs_t *vfs) {
420090a4:	7169                	add	sp,sp,-304
420090a6:	12812423          	sw	s0,296(sp)
420090aa:	12112623          	sw	ra,300(sp)
420090ae:	12912223          	sw	s1,292(sp)
    if (vfs->media) {
420090b2:	0035f793          	and	a5,a1,3
420090b6:	842e                	mv	s0,a1
420090b8:	26079f63          	bnez	a5,42009336 <vfs_ramfs_mount+0x296>
420090bc:	57e1                	li	a5,-8
420090be:	28f5f563          	bgeu	a1,a5,42009348 <vfs_ramfs_mount+0x2a8>
420090c2:	459c                	lw	a5,8(a1)
420090c4:	84aa                	mv	s1,a0
420090c6:	c3a1                	beqz	a5,42009106 <vfs_ramfs_mount+0x66>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
420090c8:	c51d                	beqz	a0,420090f6 <vfs_ramfs_mount+0x56>
420090ca:	420175b7          	lui	a1,0x42017
420090ce:	4689                	li	a3,2
420090d0:	4635                	li	a2,13
420090d2:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420090d6:	4511                	li	a0,4
420090d8:	00000717          	auipc	a4,0x0
420090dc:	9befa0ef          	jal	4200329a <logkf>
420090e0:	0034f793          	and	a5,s1,3
420090e4:	26079b63          	bnez	a5,4200935a <vfs_ramfs_mount+0x2ba>
420090e8:	57f1                	li	a5,-4
420090ea:	28f4f163          	bgeu	s1,a5,4200936c <vfs_ramfs_mount+0x2cc>
420090ee:	47b5                	li	a5,13
420090f0:	c0dc                	sw	a5,4(s1)
420090f2:	4789                	li	a5,2
420090f4:	c09c                	sw	a5,0(s1)
}
420090f6:	12c12083          	lw	ra,300(sp)
420090fa:	12812403          	lw	s0,296(sp)
420090fe:	12412483          	lw	s1,292(sp)
42009102:	6155                	add	sp,sp,304
42009104:	8082                	ret
    atomic_store_explicit(&vfs->ramfs.ram_usage, 0, memory_order_relaxed);
42009106:	57a1                	li	a5,-24
42009108:	26f5fb63          	bgeu	a1,a5,4200937e <vfs_ramfs_mount+0x2de>
4200910c:	01858793          	add	a5,a1,24
42009110:	0807a02f          	amoswap.w	zero,zero,(a5)
    vfs->type                 = FS_TYPE_RAMFS;
42009114:	4789                	li	a5,2
42009116:	c5dc                	sw	a5,12(a1)
    vfs->ramfs.ram_limit      = 65536;
42009118:	67c1                	lui	a5,0x10
4200911a:	c9dc                	sw	a5,20(a1)
    vfs->ramfs.inode_list_len = 32;
4200911c:	fdc00793          	li	a5,-36
42009120:	26f5f863          	bgeu	a1,a5,42009390 <vfs_ramfs_mount+0x2f0>
42009124:	02000793          	li	a5,32
42009128:	d1dc                	sw	a5,36(a1)
    vfs->ramfs.inode_list     = malloc(sizeof(*vfs->ramfs.inode_list) * vfs->ramfs.inode_list_len);
4200912a:	40000513          	li	a0,1024
4200912e:	023040ef          	jal	4200d950 <malloc>
42009132:	cc48                	sw	a0,28(s0)
    if (!badge_err_is_ok(ec))
42009134:	18048463          	beqz	s1,420092bc <vfs_ramfs_mount+0x21c>
42009138:	0034f793          	and	a5,s1,3
4200913c:	26079363          	bnez	a5,420093a2 <vfs_ramfs_mount+0x302>
42009140:	409c                	lw	a5,0(s1)
42009142:	fbd5                	bnez	a5,420090f6 <vfs_ramfs_mount+0x56>
    vfs->ramfs.inode_usage = malloc(sizeof(*vfs->ramfs.inode_usage) * vfs->ramfs.inode_list_len);
42009144:	5048                	lw	a0,36(s0)
42009146:	00b040ef          	jal	4200d950 <malloc>
    if (!badge_err_is_ok(ec)) {
4200914a:	409c                	lw	a5,0(s1)
    vfs->ramfs.inode_usage = malloc(sizeof(*vfs->ramfs.inode_usage) * vfs->ramfs.inode_list_len);
4200914c:	d008                	sw	a0,32(s0)
    if (!badge_err_is_ok(ec)) {
4200914e:	1c079a63          	bnez	a5,42009322 <vfs_ramfs_mount+0x282>
42009152:	13212023          	sw	s2,288(sp)
42009156:	11312e23          	sw	s3,284(sp)
4200915a:	11412c23          	sw	s4,280(sp)
4200915e:	11512a23          	sw	s5,276(sp)
    vfs->inode_root = VFS_RAMFS_INODE_ROOT;
42009162:	4a85                	li	s5,1
42009164:	01542823          	sw	s5,16(s0)
    mutex_init_shared(ec, &vfs->ramfs.mtx);
42009168:	fd800793          	li	a5,-40
4200916c:	24f47563          	bgeu	s0,a5,420093b6 <vfs_ramfs_mount+0x316>
42009170:	02840a13          	add	s4,s0,40
42009174:	85d2                	mv	a1,s4
42009176:	8526                	mv	a0,s1
42009178:	beafa0ef          	jal	42003562 <mutex_init_shared>
    mem_set(vfs->ramfs.inode_list, 0, sizeof(*vfs->ramfs.inode_list) * vfs->ramfs.inode_list_len);
4200917c:	5050                	lw	a2,36(s0)
4200917e:	4c48                	lw	a0,28(s0)
42009180:	4581                	li	a1,0
42009182:	0616                	sll	a2,a2,0x5
42009184:	ec8f90ef          	jal	4200284c <mem_set>
    mem_set(vfs->ramfs.inode_usage, false, vfs->ramfs.inode_list_len - 2);
42009188:	5050                	lw	a2,36(s0)
4200918a:	5008                	lw	a0,32(s0)
4200918c:	4581                	li	a1,0
4200918e:	1679                	add	a2,a2,-2
42009190:	ebcf90ef          	jal	4200284c <mem_set>
    vfs->ramfs.inode_usage[VFS_RAMFS_INODE_ROOT] = true;
42009194:	501c                	lw	a5,32(s0)
42009196:	577d                	li	a4,-1
42009198:	20e7fe63          	bgeu	a5,a4,420093b4 <vfs_ramfs_mount+0x314>
4200919c:	00178713          	add	a4,a5,1 # 10001 <__stack_size+0xe001>
420091a0:	22070563          	beqz	a4,420093ca <vfs_ramfs_mount+0x32a>
420091a4:	015780a3          	sb	s5,1(a5)
    vfs_ramfs_inode_t *iptr                      = &vfs->ramfs.inode_list[VFS_RAMFS_INODE_ROOT];
420091a8:	01c42903          	lw	s2,28(s0)
420091ac:	5781                	li	a5,-32
420091ae:	20f97d63          	bgeu	s2,a5,420093c8 <vfs_ramfs_mount+0x328>
420091b2:	02090993          	add	s3,s2,32
    iptr->buf   = NULL;
420091b6:	20098863          	beqz	s3,420093c6 <vfs_ramfs_mount+0x326>
420091ba:	0039f793          	and	a5,s3,3
420091be:	20079463          	bnez	a5,420093c6 <vfs_ramfs_mount+0x326>
420091c2:	57e1                	li	a5,-8
420091c4:	20f9f063          	bgeu	s3,a5,420093c4 <vfs_ramfs_mount+0x324>
420091c8:	02092423          	sw	zero,40(s2)
    iptr->len   = 0;
420091cc:	02092023          	sw	zero,32(s2)
    iptr->cap   = 0;
420091d0:	02092223          	sw	zero,36(s2)
    iptr->inode = VFS_RAMFS_INODE_ROOT;
420091d4:	57d1                	li	a5,-12
420091d6:	1ef9f663          	bgeu	s3,a5,420093c2 <vfs_ramfs_mount+0x322>
420091da:	03592623          	sw	s5,44(s2)
    iptr->mode  = (FILETYPE_DIR << VFS_RAMFS_MODE_BIT) | 0777; /* TODO. */
420091de:	57c1                	li	a5,-16
420091e0:	1ef9f063          	bgeu	s3,a5,420093c0 <vfs_ramfs_mount+0x320>
420091e4:	6791                	lui	a5,0x4
420091e6:	1ff78793          	add	a5,a5,511 # 41ff <__stack_size+0x21ff>
420091ea:	02f91823          	sh	a5,48(s2)
    iptr->links = 1;
420091ee:	57b1                	li	a5,-20
420091f0:	1cf9f763          	bgeu	s3,a5,420093be <vfs_ramfs_mount+0x31e>
420091f4:	4785                	li	a5,1
420091f6:	02f92a23          	sw	a5,52(s2)
    iptr->uid   = 0; /* TODO. */
420091fa:	57a1                	li	a5,-24
420091fc:	1cf9f063          	bgeu	s3,a5,420093bc <vfs_ramfs_mount+0x31c>
42009200:	02092c23          	sw	zero,56(s2)
    iptr->gid   = 0; /* TODO. */
42009204:	5791                	li	a5,-28
42009206:	1af9fa63          	bgeu	s3,a5,420093ba <vfs_ramfs_mount+0x31a>
    vfs_ramfs_dirent_t ent = {
4200920a:	420177b7          	lui	a5,0x42017
4200920e:	ac478793          	add	a5,a5,-1340 # 42016ac4 <hexadecimal_table+0x10>
    iptr->gid   = 0; /* TODO. */
42009212:	02092e23          	sw	zero,60(s2)
    vfs_ramfs_dirent_t ent = {
42009216:	0058                	add	a4,sp,4
42009218:	10878313          	add	t1,a5,264
4200921c:	0007a883          	lw	a7,0(a5)
42009220:	0047a803          	lw	a6,4(a5)
42009224:	4788                	lw	a0,8(a5)
42009226:	47cc                	lw	a1,12(a5)
42009228:	4b90                	lw	a2,16(a5)
4200922a:	4bd4                	lw	a3,20(a5)
4200922c:	01172023          	sw	a7,0(a4) # 420090d8 <vfs_ramfs_mount+0x38>
42009230:	01072223          	sw	a6,4(a4)
42009234:	c708                	sw	a0,8(a4)
42009236:	c74c                	sw	a1,12(a4)
42009238:	cb10                	sw	a2,16(a4)
4200923a:	cb54                	sw	a3,20(a4)
4200923c:	07e1                	add	a5,a5,24
4200923e:	0761                	add	a4,a4,24
42009240:	fc679ee3          	bne	a5,t1,4200921c <vfs_ramfs_mount+0x17c>
42009244:	439c                	lw	a5,0(a5)
    insert_dirent(ec, vfs, iptr, &ent);
42009246:	0050                	add	a2,sp,4
42009248:	85ce                	mv	a1,s3
4200924a:	8526                	mv	a0,s1
    vfs_ramfs_dirent_t ent = {
4200924c:	c31c                	sw	a5,0(a4)
    insert_dirent(ec, vfs, iptr, &ent);
4200924e:	afbff0ef          	jal	42008d48 <insert_dirent.isra.0>
    if (!badge_err_is_ok(ec)) {
42009252:	cc9d                	beqz	s1,42009290 <vfs_ramfs_mount+0x1f0>
42009254:	0034f793          	and	a5,s1,3
42009258:	16079063          	bnez	a5,420093b8 <vfs_ramfs_mount+0x318>
4200925c:	409c                	lw	a5,0(s1)
4200925e:	efa5                	bnez	a5,420092d6 <vfs_ramfs_mount+0x236>
    ent.name_len = 2;
42009260:	4789                	li	a5,2
42009262:	c63e                	sw	a5,12(sp)
    insert_dirent(ec, vfs, iptr, &ent);
42009264:	0050                	add	a2,sp,4
    ent.name[1]  = '.';
42009266:	02e00793          	li	a5,46
    insert_dirent(ec, vfs, iptr, &ent);
4200926a:	85ce                	mv	a1,s3
4200926c:	8526                	mv	a0,s1
    ent.name[1]  = '.';
4200926e:	00f108a3          	sb	a5,17(sp)
    ent.name[2]  = 0;
42009272:	00010923          	sb	zero,18(sp)
    insert_dirent(ec, vfs, iptr, &ent);
42009276:	ad3ff0ef          	jal	42008d48 <insert_dirent.isra.0>
    if (!badge_err_is_ok(ec)) {
4200927a:	409c                	lw	a5,0(s1)
4200927c:	efa5                	bnez	a5,420092f4 <vfs_ramfs_mount+0x254>
4200927e:	12012903          	lw	s2,288(sp)
42009282:	11c12983          	lw	s3,284(sp)
42009286:	11812a03          	lw	s4,280(sp)
4200928a:	11412a83          	lw	s5,276(sp)
4200928e:	b5a5                	j	420090f6 <vfs_ramfs_mount+0x56>
    ent.name_len = 2;
42009290:	4789                	li	a5,2
    insert_dirent(ec, vfs, iptr, &ent);
42009292:	85ce                	mv	a1,s3
    ent.name_len = 2;
42009294:	c63e                	sw	a5,12(sp)
    insert_dirent(ec, vfs, iptr, &ent);
42009296:	0050                	add	a2,sp,4
    ent.name[1]  = '.';
42009298:	02e00793          	li	a5,46
    insert_dirent(ec, vfs, iptr, &ent);
4200929c:	4501                	li	a0,0
    ent.name[1]  = '.';
4200929e:	00f108a3          	sb	a5,17(sp)
    ent.name[2]  = 0;
420092a2:	00010923          	sb	zero,18(sp)
    insert_dirent(ec, vfs, iptr, &ent);
420092a6:	aa3ff0ef          	jal	42008d48 <insert_dirent.isra.0>
    if (!badge_err_is_ok(ec)) {
420092aa:	12012903          	lw	s2,288(sp)
420092ae:	11c12983          	lw	s3,284(sp)
420092b2:	11812a03          	lw	s4,280(sp)
420092b6:	11412a83          	lw	s5,276(sp)
420092ba:	bd35                	j	420090f6 <vfs_ramfs_mount+0x56>
    vfs->ramfs.inode_usage = malloc(sizeof(*vfs->ramfs.inode_usage) * vfs->ramfs.inode_list_len);
420092bc:	5048                	lw	a0,36(s0)
420092be:	13212023          	sw	s2,288(sp)
420092c2:	11312e23          	sw	s3,284(sp)
420092c6:	11412c23          	sw	s4,280(sp)
420092ca:	11512a23          	sw	s5,276(sp)
420092ce:	682040ef          	jal	4200d950 <malloc>
420092d2:	d008                	sw	a0,32(s0)
    if (!badge_err_is_ok(ec)) {
420092d4:	b579                	j	42009162 <vfs_ramfs_mount+0xc2>
        free(iptr->buf);
420092d6:	02892503          	lw	a0,40(s2)
420092da:	083040ef          	jal	4200db5c <free>
        free(vfs->ramfs.inode_list);
420092de:	4c48                	lw	a0,28(s0)
420092e0:	07d040ef          	jal	4200db5c <free>
        free(vfs->ramfs.inode_usage);
420092e4:	5008                	lw	a0,32(s0)
420092e6:	077040ef          	jal	4200db5c <free>
        mutex_destroy(NULL, &vfs->ramfs.mtx);
420092ea:	85d2                	mv	a1,s4
420092ec:	4501                	li	a0,0
420092ee:	b1cfa0ef          	jal	4200360a <mutex_destroy>
    ent.name_len = 2;
420092f2:	b7bd                	j	42009260 <vfs_ramfs_mount+0x1c0>
        free(iptr->buf);
420092f4:	02892503          	lw	a0,40(s2)
420092f8:	065040ef          	jal	4200db5c <free>
        free(vfs->ramfs.inode_list);
420092fc:	4c48                	lw	a0,28(s0)
420092fe:	05f040ef          	jal	4200db5c <free>
        free(vfs->ramfs.inode_usage);
42009302:	5008                	lw	a0,32(s0)
42009304:	059040ef          	jal	4200db5c <free>
        mutex_destroy(NULL, &vfs->ramfs.mtx);
42009308:	85d2                	mv	a1,s4
4200930a:	4501                	li	a0,0
4200930c:	afefa0ef          	jal	4200360a <mutex_destroy>
42009310:	12012903          	lw	s2,288(sp)
42009314:	11c12983          	lw	s3,284(sp)
42009318:	11812a03          	lw	s4,280(sp)
4200931c:	11412a83          	lw	s5,276(sp)
42009320:	bbd9                	j	420090f6 <vfs_ramfs_mount+0x56>
        free(vfs->ramfs.inode_list);
42009322:	4c48                	lw	a0,28(s0)
}
42009324:	12812403          	lw	s0,296(sp)
42009328:	12c12083          	lw	ra,300(sp)
4200932c:	12412483          	lw	s1,292(sp)
42009330:	6155                	add	sp,sp,304
        free(vfs->ramfs.inode_list);
42009332:	02b0406f          	j	4200db5c <free>
42009336:	13212023          	sw	s2,288(sp)
4200933a:	11312e23          	sw	s3,284(sp)
4200933e:	11412c23          	sw	s4,280(sp)
42009342:	11512a23          	sw	s5,276(sp)
    if (vfs->media) {
42009346:	9002                	ebreak
42009348:	13212023          	sw	s2,288(sp)
4200934c:	11312e23          	sw	s3,284(sp)
42009350:	11412c23          	sw	s4,280(sp)
42009354:	11512a23          	sw	s5,276(sp)
42009358:	9002                	ebreak
4200935a:	13212023          	sw	s2,288(sp)
4200935e:	11312e23          	sw	s3,284(sp)
42009362:	11412c23          	sw	s4,280(sp)
42009366:	11512a23          	sw	s5,276(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
4200936a:	9002                	ebreak
4200936c:	13212023          	sw	s2,288(sp)
42009370:	11312e23          	sw	s3,284(sp)
42009374:	11412c23          	sw	s4,280(sp)
42009378:	11512a23          	sw	s5,276(sp)
4200937c:	9002                	ebreak
4200937e:	13212023          	sw	s2,288(sp)
42009382:	11312e23          	sw	s3,284(sp)
42009386:	11412c23          	sw	s4,280(sp)
4200938a:	11512a23          	sw	s5,276(sp)
    atomic_store_explicit(&vfs->ramfs.ram_usage, 0, memory_order_relaxed);
4200938e:	9002                	ebreak
42009390:	13212023          	sw	s2,288(sp)
42009394:	11312e23          	sw	s3,284(sp)
42009398:	11412c23          	sw	s4,280(sp)
4200939c:	11512a23          	sw	s5,276(sp)
    vfs->ramfs.inode_list_len = 32;
420093a0:	9002                	ebreak
420093a2:	13212023          	sw	s2,288(sp)
420093a6:	11312e23          	sw	s3,284(sp)
420093aa:	11412c23          	sw	s4,280(sp)
420093ae:	11512a23          	sw	s5,276(sp)
    if (!badge_err_is_ok(ec))
420093b2:	9002                	ebreak
    vfs->ramfs.inode_usage[VFS_RAMFS_INODE_ROOT] = true;
420093b4:	9002                	ebreak
    mutex_init_shared(ec, &vfs->ramfs.mtx);
420093b6:	9002                	ebreak
    if (!badge_err_is_ok(ec)) {
420093b8:	9002                	ebreak
    iptr->gid   = 0; /* TODO. */
420093ba:	9002                	ebreak
    iptr->uid   = 0; /* TODO. */
420093bc:	9002                	ebreak
    iptr->links = 1;
420093be:	9002                	ebreak
    iptr->mode  = (FILETYPE_DIR << VFS_RAMFS_MODE_BIT) | 0777; /* TODO. */
420093c0:	9002                	ebreak
    iptr->inode = VFS_RAMFS_INODE_ROOT;
420093c2:	9002                	ebreak
    iptr->buf   = NULL;
420093c4:	9002                	ebreak
420093c6:	9002                	ebreak
    vfs_ramfs_inode_t *iptr                      = &vfs->ramfs.inode_list[VFS_RAMFS_INODE_ROOT];
420093c8:	9002                	ebreak
    vfs->ramfs.inode_usage[VFS_RAMFS_INODE_ROOT] = true;
420093ca:	9002                	ebreak
    if (vfs->media) {
420093cc:	9002                	ebreak

420093ce <vfs_ramfs_umount>:
    mutex_destroy(NULL, &vfs->ramfs.mtx);
420093ce:	cd05                	beqz	a0,42009406 <vfs_ramfs_umount+0x38>
void vfs_ramfs_umount(vfs_t *vfs) {
420093d0:	1141                	add	sp,sp,-16
420093d2:	c422                	sw	s0,8(sp)
420093d4:	c606                	sw	ra,12(sp)
    mutex_destroy(NULL, &vfs->ramfs.mtx);
420093d6:	00357793          	and	a5,a0,3
420093da:	842a                	mv	s0,a0
420093dc:	e39d                	bnez	a5,42009402 <vfs_ramfs_umount+0x34>
420093de:	fd800793          	li	a5,-40
420093e2:	02f57163          	bgeu	a0,a5,42009404 <vfs_ramfs_umount+0x36>
420093e6:	02850593          	add	a1,a0,40
420093ea:	4501                	li	a0,0
420093ec:	a1efa0ef          	jal	4200360a <mutex_destroy>
    free(vfs->ramfs.inode_list);
420093f0:	4c48                	lw	a0,28(s0)
420093f2:	76a040ef          	jal	4200db5c <free>
    free(vfs->ramfs.inode_usage);
420093f6:	5008                	lw	a0,32(s0)
}
420093f8:	4422                	lw	s0,8(sp)
420093fa:	40b2                	lw	ra,12(sp)
420093fc:	0141                	add	sp,sp,16
    free(vfs->ramfs.inode_usage);
420093fe:	75e0406f          	j	4200db5c <free>
    mutex_destroy(NULL, &vfs->ramfs.mtx);
42009402:	9002                	ebreak
42009404:	9002                	ebreak
42009406:	9002                	ebreak

42009408 <vfs_ramfs_create_file>:
    create_file(ec, vfs, dir, name, FILETYPE_REG);
42009408:	4721                	li	a4,8
4200940a:	9b3ff06f          	j	42008dbc <create_file>

4200940e <vfs_ramfs_create_dir>:
void vfs_ramfs_create_dir(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, char const *name) {
4200940e:	7129                	add	sp,sp,-320
42009410:	12812c23          	sw	s0,312(sp)
42009414:	13212823          	sw	s2,304(sp)
42009418:	13312623          	sw	s3,300(sp)
4200941c:	13412423          	sw	s4,296(sp)
42009420:	12112e23          	sw	ra,316(sp)
42009424:	12912a23          	sw	s1,308(sp)
42009428:	8a2e                	mv	s4,a1
4200942a:	8932                	mv	s2,a2
4200942c:	89b6                	mv	s3,a3
        ec = &ec0;
4200942e:	0040                	add	s0,sp,4
    if (!ec)
42009430:	c111                	beqz	a0,42009434 <vfs_ramfs_create_dir+0x26>
42009432:	842a                	mv	s0,a0
    vfs_ramfs_inode_t *iptr = create_file(ec, vfs, dir, name, FILETYPE_DIR);
42009434:	4711                	li	a4,4
42009436:	86ce                	mv	a3,s3
42009438:	864a                	mv	a2,s2
4200943a:	85d2                	mv	a1,s4
4200943c:	8522                	mv	a0,s0
4200943e:	97fff0ef          	jal	42008dbc <create_file>
42009442:	84aa                	mv	s1,a0
    if (!badge_err_is_ok(ec))
42009444:	14040663          	beqz	s0,42009590 <vfs_ramfs_create_dir+0x182>
42009448:	00347793          	and	a5,s0,3
4200944c:	14079263          	bnez	a5,42009590 <vfs_ramfs_create_dir+0x182>
42009450:	401c                	lw	a5,0(s0)
42009452:	cf99                	beqz	a5,42009470 <vfs_ramfs_create_dir+0x62>
}
42009454:	13c12083          	lw	ra,316(sp)
42009458:	13812403          	lw	s0,312(sp)
4200945c:	13412483          	lw	s1,308(sp)
42009460:	13012903          	lw	s2,304(sp)
42009464:	12c12983          	lw	s3,300(sp)
42009468:	12812a03          	lw	s4,296(sp)
4200946c:	6131                	add	sp,sp,320
4200946e:	8082                	ret
    vfs_ramfs_dirent_t ent = {
42009470:	47c1                	li	a5,16
42009472:	13512223          	sw	s5,292(sp)
42009476:	13612023          	sw	s6,288(sp)
4200947a:	ca3e                	sw	a5,20(sp)
        .inode    = iptr->inode,
4200947c:	10050263          	beqz	a0,42009580 <vfs_ramfs_create_dir+0x172>
42009480:	00357793          	and	a5,a0,3
42009484:	0e079e63          	bnez	a5,42009580 <vfs_ramfs_create_dir+0x172>
42009488:	5b51                	li	s6,-12
4200948a:	0f657b63          	bgeu	a0,s6,42009580 <vfs_ramfs_create_dir+0x172>
    vfs_ramfs_dirent_t ent = {
4200948e:	455c                	lw	a5,12(a0)
42009490:	0fc00613          	li	a2,252
42009494:	4581                	li	a1,0
42009496:	cc3e                	sw	a5,24(sp)
42009498:	02e00a93          	li	s5,46
4200949c:	4785                	li	a5,1
4200949e:	1048                	add	a0,sp,36
420094a0:	ce3e                	sw	a5,28(sp)
420094a2:	d056                	sw	s5,32(sp)
420094a4:	c72f90ef          	jal	42002916 <memset>
    insert_dirent(ec, vfs, iptr, &ent);
420094a8:	0850                	add	a2,sp,20
420094aa:	85a6                	mv	a1,s1
420094ac:	8522                	mv	a0,s0
420094ae:	89bff0ef          	jal	42008d48 <insert_dirent.isra.0>
    if (!badge_err_is_ok(ec)) {
420094b2:	401c                	lw	a5,0(s0)
420094b4:	cbb1                	beqz	a5,42009508 <vfs_ramfs_create_dir+0xfa>
        pop_inode_refcount(vfs, iptr);
420094b6:	85a6                	mv	a1,s1
420094b8:	8552                	mv	a0,s4
420094ba:	da2ff0ef          	jal	42008a5c <pop_inode_refcount>
        vfs_ramfs_dirent_t *ent = find_dirent(ec, vfs, dir->ramfs_file, name);
420094be:	0c090163          	beqz	s2,42009580 <vfs_ramfs_create_dir+0x172>
420094c2:	00397793          	and	a5,s2,3
420094c6:	efcd                	bnez	a5,42009580 <vfs_ramfs_create_dir+0x172>
420094c8:	0b697c63          	bgeu	s2,s6,42009580 <vfs_ramfs_create_dir+0x172>
420094cc:	00c92583          	lw	a1,12(s2)
420094d0:	864e                	mv	a2,s3
420094d2:	8522                	mv	a0,s0
420094d4:	eeeff0ef          	jal	42008bc2 <find_dirent.isra.0>
420094d8:	85aa                	mv	a1,a0
        assert_dev_drop(ent != NULL);
420094da:	c545                	beqz	a0,42009582 <vfs_ramfs_create_dir+0x174>
        remove_dirent(vfs, dir->ramfs_file, ent);
420094dc:	00c92503          	lw	a0,12(s2)
420094e0:	b55ff0ef          	jal	42009034 <remove_dirent.isra.0>
}
420094e4:	13c12083          	lw	ra,316(sp)
420094e8:	13812403          	lw	s0,312(sp)
        remove_dirent(vfs, dir->ramfs_file, ent);
420094ec:	12412a83          	lw	s5,292(sp)
420094f0:	12012b03          	lw	s6,288(sp)
}
420094f4:	13412483          	lw	s1,308(sp)
420094f8:	13012903          	lw	s2,304(sp)
420094fc:	12c12983          	lw	s3,300(sp)
42009500:	12812a03          	lw	s4,296(sp)
42009504:	6131                	add	sp,sp,320
42009506:	8082                	ret
    ent.name_len = 2;
42009508:	4789                	li	a5,2
4200950a:	ce3e                	sw	a5,28(sp)
    ent.name[1]  = '.';
4200950c:	035100a3          	sb	s5,33(sp)
    ent.name[2]  = 0;
42009510:	02010123          	sb	zero,34(sp)
    ent.inode    = dir->inode;
42009514:	06090663          	beqz	s2,42009580 <vfs_ramfs_create_dir+0x172>
42009518:	00397793          	and	a5,s2,3
4200951c:	e3b5                	bnez	a5,42009580 <vfs_ramfs_create_dir+0x172>
4200951e:	5781                	li	a5,-32
42009520:	06f97063          	bgeu	s2,a5,42009580 <vfs_ramfs_create_dir+0x172>
42009524:	02092783          	lw	a5,32(s2)
    insert_dirent(ec, vfs, iptr, &ent);
42009528:	0850                	add	a2,sp,20
4200952a:	85a6                	mv	a1,s1
4200952c:	8522                	mv	a0,s0
    ent.inode    = dir->inode;
4200952e:	cc3e                	sw	a5,24(sp)
    insert_dirent(ec, vfs, iptr, &ent);
42009530:	819ff0ef          	jal	42008d48 <insert_dirent.isra.0>
    if (!badge_err_is_ok(ec)) {
42009534:	401c                	lw	a5,0(s0)
42009536:	e39d                	bnez	a5,4200955c <vfs_ramfs_create_dir+0x14e>
}
42009538:	13c12083          	lw	ra,316(sp)
4200953c:	13812403          	lw	s0,312(sp)
42009540:	12412a83          	lw	s5,292(sp)
42009544:	12012b03          	lw	s6,288(sp)
42009548:	13412483          	lw	s1,308(sp)
4200954c:	13012903          	lw	s2,304(sp)
42009550:	12c12983          	lw	s3,300(sp)
42009554:	12812a03          	lw	s4,296(sp)
42009558:	6131                	add	sp,sp,320
4200955a:	8082                	ret
        pop_inode_refcount(vfs, iptr);
4200955c:	85a6                	mv	a1,s1
4200955e:	8552                	mv	a0,s4
42009560:	cfcff0ef          	jal	42008a5c <pop_inode_refcount>
        vfs_ramfs_dirent_t *ent = find_dirent(ec, vfs, dir->ramfs_file, name);
42009564:	00c92583          	lw	a1,12(s2)
42009568:	864e                	mv	a2,s3
4200956a:	8522                	mv	a0,s0
4200956c:	e56ff0ef          	jal	42008bc2 <find_dirent.isra.0>
42009570:	85aa                	mv	a1,a0
        assert_dev_drop(ent != NULL);
42009572:	f52d                	bnez	a0,420094dc <vfs_ramfs_create_dir+0xce>
42009574:	420185b7          	lui	a1,0x42018
42009578:	49058593          	add	a1,a1,1168 # 42018490 <hextab+0x17c4>
4200957c:	cd9f90ef          	jal	42003254 <logk>
42009580:	9002                	ebreak
        assert_dev_drop(ent != NULL);
42009582:	420185b7          	lui	a1,0x42018
42009586:	41458593          	add	a1,a1,1044 # 42018414 <hextab+0x1748>
4200958a:	ccbf90ef          	jal	42003254 <logk>
4200958e:	9002                	ebreak
42009590:	13512223          	sw	s5,292(sp)
42009594:	13612023          	sw	s6,288(sp)
    if (!badge_err_is_ok(ec))
42009598:	9002                	ebreak

4200959a <vfs_ramfs_unlink>:
void vfs_ramfs_unlink(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, char const *name) {
4200959a:	715d                	add	sp,sp,-80
4200959c:	c2a6                	sw	s1,68(sp)
4200959e:	c0ca                	sw	s2,64(sp)
420095a0:	84aa                	mv	s1,a0
420095a2:	892e                	mv	s2,a1
    size_t name_len = cstr_length_upto(name, VFS_RAMFS_NAME_MAX + 1);
420095a4:	8536                	mv	a0,a3
420095a6:	10000593          	li	a1,256
void vfs_ramfs_unlink(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, char const *name) {
420095aa:	c4a2                	sw	s0,72(sp)
420095ac:	dc52                	sw	s4,56(sp)
420095ae:	c686                	sw	ra,76(sp)
420095b0:	de4e                	sw	s3,60(sp)
420095b2:	da56                	sw	s5,52(sp)
420095b4:	8436                	mv	s0,a3
420095b6:	8a32                	mv	s4,a2
    size_t name_len = cstr_length_upto(name, VFS_RAMFS_NAME_MAX + 1);
420095b8:	fc8f80ef          	jal	42001d80 <cstr_length_upto>
    if (name_len > VFS_RAMFS_NAME_MAX) {
420095bc:	0ff00793          	li	a5,255
420095c0:	08a7fa63          	bgeu	a5,a0,42009654 <vfs_ramfs_unlink+0xba>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_TOOLONG);
420095c4:	ccd5                	beqz	s1,42009680 <vfs_ramfs_unlink+0xe6>
420095c6:	42017ab7          	lui	s5,0x42017
420095ca:	4691                	li	a3,4
420095cc:	4635                	li	a2,13
420095ce:	204a8593          	add	a1,s5,516 # 42017204 <hextab+0x538>
420095d2:	4511                	li	a0,4
420095d4:	00000717          	auipc	a4,0x0
420095d8:	cc3f90ef          	jal	4200329a <logkf>
420095dc:	0034f793          	and	a5,s1,3
420095e0:	28079763          	bnez	a5,4200986e <vfs_ramfs_unlink+0x2d4>
420095e4:	57f1                	li	a5,-4
420095e6:	28f4f463          	bgeu	s1,a5,4200986e <vfs_ramfs_unlink+0x2d4>
420095ea:	47b5                	li	a5,13
    if (cstr_equals(name, ".") || cstr_equals(name, "..")) {
420095ec:	420179b7          	lui	s3,0x42017
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_TOOLONG);
420095f0:	c0dc                	sw	a5,4(s1)
420095f2:	4791                	li	a5,4
420095f4:	c09c                	sw	a5,0(s1)
    if (cstr_equals(name, ".") || cstr_equals(name, "..")) {
420095f6:	65098593          	add	a1,s3,1616 # 42017650 <hextab+0x984>
420095fa:	8522                	mv	a0,s0
420095fc:	911f80ef          	jal	42001f0c <cstr_equals>
42009600:	e919                	bnez	a0,42009616 <vfs_ramfs_unlink+0x7c>
42009602:	d65e                	sw	s7,44(sp)
42009604:	42018bb7          	lui	s7,0x42018
42009608:	50cb8593          	add	a1,s7,1292 # 4201850c <hextab+0x1840>
4200960c:	8522                	mv	a0,s0
4200960e:	8fff80ef          	jal	42001f0c <cstr_equals>
42009612:	c951                	beqz	a0,420096a6 <vfs_ramfs_unlink+0x10c>
42009614:	5bb2                	lw	s7,44(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42009616:	4689                	li	a3,2
42009618:	4635                	li	a2,13
4200961a:	204a8593          	add	a1,s5,516
4200961e:	4511                	li	a0,4
42009620:	00000717          	auipc	a4,0x0
42009624:	c77f90ef          	jal	4200329a <logkf>
42009628:	24048363          	beqz	s1,4200986e <vfs_ramfs_unlink+0x2d4>
4200962c:	0034f793          	and	a5,s1,3
42009630:	22079f63          	bnez	a5,4200986e <vfs_ramfs_unlink+0x2d4>
42009634:	57f1                	li	a5,-4
42009636:	22f4fc63          	bgeu	s1,a5,4200986e <vfs_ramfs_unlink+0x2d4>
4200963a:	47b5                	li	a5,13
4200963c:	c0dc                	sw	a5,4(s1)
4200963e:	4789                	li	a5,2
42009640:	c09c                	sw	a5,0(s1)
}
42009642:	40b6                	lw	ra,76(sp)
42009644:	4426                	lw	s0,72(sp)
42009646:	4496                	lw	s1,68(sp)
42009648:	4906                	lw	s2,64(sp)
4200964a:	59f2                	lw	s3,60(sp)
4200964c:	5a62                	lw	s4,56(sp)
4200964e:	5ad2                	lw	s5,52(sp)
42009650:	6161                	add	sp,sp,80
42009652:	8082                	ret
    if (cstr_equals(name, ".") || cstr_equals(name, "..")) {
42009654:	420179b7          	lui	s3,0x42017
42009658:	65098593          	add	a1,s3,1616 # 42017650 <hextab+0x984>
4200965c:	8522                	mv	a0,s0
4200965e:	8aff80ef          	jal	42001f0c <cstr_equals>
42009662:	e919                	bnez	a0,42009678 <vfs_ramfs_unlink+0xde>
42009664:	d65e                	sw	s7,44(sp)
42009666:	42018bb7          	lui	s7,0x42018
4200966a:	50cb8593          	add	a1,s7,1292 # 4201850c <hextab+0x1840>
4200966e:	8522                	mv	a0,s0
42009670:	89df80ef          	jal	42001f0c <cstr_equals>
42009674:	c90d                	beqz	a0,420096a6 <vfs_ramfs_unlink+0x10c>
42009676:	5bb2                	lw	s7,44(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_PARAM);
42009678:	d4e9                	beqz	s1,42009642 <vfs_ramfs_unlink+0xa8>
4200967a:	42017ab7          	lui	s5,0x42017
4200967e:	bf61                	j	42009616 <vfs_ramfs_unlink+0x7c>
    if (cstr_equals(name, ".") || cstr_equals(name, "..")) {
42009680:	420179b7          	lui	s3,0x42017
42009684:	65098593          	add	a1,s3,1616 # 42017650 <hextab+0x984>
42009688:	8522                	mv	a0,s0
4200968a:	883f80ef          	jal	42001f0c <cstr_equals>
4200968e:	f955                	bnez	a0,42009642 <vfs_ramfs_unlink+0xa8>
42009690:	d65e                	sw	s7,44(sp)
42009692:	42018bb7          	lui	s7,0x42018
42009696:	50cb8593          	add	a1,s7,1292 # 4201850c <hextab+0x1840>
4200969a:	8522                	mv	a0,s0
4200969c:	871f80ef          	jal	42001f0c <cstr_equals>
420096a0:	c119                	beqz	a0,420096a6 <vfs_ramfs_unlink+0x10c>
420096a2:	5bb2                	lw	s7,44(sp)
420096a4:	bf79                	j	42009642 <vfs_ramfs_unlink+0xa8>
    assert_always(mutex_acquire(ec, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
420096a6:	1c090763          	beqz	s2,42009874 <vfs_ramfs_unlink+0x2da>
420096aa:	00397793          	and	a5,s2,3
420096ae:	1c079363          	bnez	a5,42009874 <vfs_ramfs_unlink+0x2da>
420096b2:	fd800793          	li	a5,-40
420096b6:	1af97f63          	bgeu	s2,a5,42009874 <vfs_ramfs_unlink+0x2da>
420096ba:	02890793          	add	a5,s2,40
420096be:	0016e637          	lui	a2,0x16e
420096c2:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
420096c6:	4681                	li	a3,0
420096c8:	85be                	mv	a1,a5
420096ca:	8526                	mv	a0,s1
420096cc:	c43e                	sw	a5,8(sp)
420096ce:	fa5f90ef          	jal	42003672 <mutex_acquire>
420096d2:	10050563          	beqz	a0,420097dc <vfs_ramfs_unlink+0x242>
    vfs_ramfs_inode_t  *dirptr = dir->ramfs_file;
420096d6:	180a0f63          	beqz	s4,42009874 <vfs_ramfs_unlink+0x2da>
420096da:	003a7793          	and	a5,s4,3
420096de:	18079b63          	bnez	a5,42009874 <vfs_ramfs_unlink+0x2da>
420096e2:	57d1                	li	a5,-12
420096e4:	18fa7863          	bgeu	s4,a5,42009874 <vfs_ramfs_unlink+0x2da>
420096e8:	00ca2783          	lw	a5,12(s4)
    vfs_ramfs_dirent_t *ent    = find_dirent(ec, vfs, dirptr, name);
420096ec:	8622                	mv	a2,s0
420096ee:	8526                	mv	a0,s1
420096f0:	85be                	mv	a1,a5
    vfs_ramfs_inode_t  *dirptr = dir->ramfs_file;
420096f2:	c63e                	sw	a5,12(sp)
    vfs_ramfs_dirent_t *ent    = find_dirent(ec, vfs, dirptr, name);
420096f4:	cceff0ef          	jal	42008bc2 <find_dirent.isra.0>
420096f8:	8aaa                	mv	s5,a0
    if (!ent) {
420096fa:	12050c63          	beqz	a0,42009832 <vfs_ramfs_unlink+0x298>
420096fe:	d85a                	sw	s6,48(sp)
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[ent->inode];
42009700:	00357793          	and	a5,a0,3
42009704:	01c92703          	lw	a4,28(s2)
42009708:	e3bd                	bnez	a5,4200976e <vfs_ramfs_unlink+0x1d4>
4200970a:	57f1                	li	a5,-4
4200970c:	06f57163          	bgeu	a0,a5,4200976e <vfs_ramfs_unlink+0x1d4>
42009710:	415c                	lw	a5,4(a0)
42009712:	0796                	sll	a5,a5,0x5
42009714:	00f70b33          	add	s6,a4,a5
42009718:	0407d963          	bgez	a5,4200976a <vfs_ramfs_unlink+0x1d0>
4200971c:	05676963          	bltu	a4,s6,4200976e <vfs_ramfs_unlink+0x1d4>
    if ((iptr->mode & VFS_RAMFS_MODE_MASK) == FILETYPE_DIR << VFS_RAMFS_MODE_BIT) {
42009720:	040b0763          	beqz	s6,4200976e <vfs_ramfs_unlink+0x1d4>
42009724:	003b7793          	and	a5,s6,3
42009728:	e3b9                	bnez	a5,4200976e <vfs_ramfs_unlink+0x1d4>
4200972a:	57c1                	li	a5,-16
4200972c:	04fb7163          	bgeu	s6,a5,4200976e <vfs_ramfs_unlink+0x1d4>
42009730:	010b5783          	lhu	a5,16(s6)
42009734:	76fd                	lui	a3,0xfffff
42009736:	6711                	lui	a4,0x4
42009738:	8ff5                	and	a5,a5,a3
4200973a:	02e78f63          	beq	a5,a4,42009778 <vfs_ramfs_unlink+0x1de>
    pop_inode_refcount(vfs, iptr);
4200973e:	85da                	mv	a1,s6
42009740:	854a                	mv	a0,s2
42009742:	b1aff0ef          	jal	42008a5c <pop_inode_refcount>
    remove_dirent(vfs, dirptr, ent);
42009746:	4532                	lw	a0,12(sp)
42009748:	85d6                	mv	a1,s5
4200974a:	8ebff0ef          	jal	42009034 <remove_dirent.isra.0>
    mutex_release(NULL, &vfs->ramfs.mtx);
4200974e:	45a2                	lw	a1,8(sp)
42009750:	5b42                	lw	s6,48(sp)
42009752:	5bb2                	lw	s7,44(sp)
42009754:	4501                	li	a0,0
}
42009756:	4426                	lw	s0,72(sp)
42009758:	40b6                	lw	ra,76(sp)
4200975a:	4496                	lw	s1,68(sp)
4200975c:	4906                	lw	s2,64(sp)
4200975e:	59f2                	lw	s3,60(sp)
42009760:	5a62                	lw	s4,56(sp)
42009762:	5ad2                	lw	s5,52(sp)
42009764:	6161                	add	sp,sp,80
    mutex_release(NULL, &vfs->ramfs.mtx);
42009766:	89efa06f          	j	42003804 <mutex_release>
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[ent->inode];
4200976a:	faeb7be3          	bgeu	s6,a4,42009720 <vfs_ramfs_unlink+0x186>
4200976e:	d462                	sw	s8,40(sp)
42009770:	d266                	sw	s9,36(sp)
42009772:	d06a                	sw	s10,32(sp)
42009774:	ce6e                	sw	s11,28(sp)
    if ((iptr->mode & VFS_RAMFS_MODE_MASK) == FILETYPE_DIR << VFS_RAMFS_MODE_BIT) {
42009776:	9002                	ebreak
42009778:	d462                	sw	s8,40(sp)
    while (off < dir->len) {
4200977a:	000b2c03          	lw	s8,0(s6)
4200977e:	0e0c0663          	beqz	s8,4200986a <vfs_ramfs_unlink+0x2d0>
42009782:	008b2a03          	lw	s4,8(s6)
42009786:	d06a                	sw	s10,32(sp)
42009788:	ce6e                	sw	s11,28(sp)
4200978a:	d266                	sw	s9,36(sp)
    size_t off = 0;
4200978c:	4d01                	li	s10,0
        if (!cstr_equals(".", ent->name) && !cstr_equals("..", ent->name)) {
4200978e:	5dd1                	li	s11,-12
        vfs_ramfs_dirent_t *ent = (vfs_ramfs_dirent_t *)(dir->buf + off);
42009790:	01aa0433          	add	s0,s4,s10
42009794:	040d4163          	bltz	s10,420097d6 <vfs_ramfs_unlink+0x23c>
42009798:	05446163          	bltu	s0,s4,420097da <vfs_ramfs_unlink+0x240>
        if (!cstr_equals(".", ent->name) && !cstr_equals("..", ent->name)) {
4200979c:	cc1d                	beqz	s0,420097da <vfs_ramfs_unlink+0x240>
4200979e:	00347713          	and	a4,s0,3
420097a2:	ef05                	bnez	a4,420097da <vfs_ramfs_unlink+0x240>
420097a4:	03b47b63          	bgeu	s0,s11,420097da <vfs_ramfs_unlink+0x240>
420097a8:	00c40c93          	add	s9,s0,12
420097ac:	85e6                	mv	a1,s9
420097ae:	65098513          	add	a0,s3,1616
420097b2:	f5af80ef          	jal	42001f0c <cstr_equals>
420097b6:	e519                	bnez	a0,420097c4 <vfs_ramfs_unlink+0x22a>
420097b8:	85e6                	mv	a1,s9
420097ba:	50cb8513          	add	a0,s7,1292
420097be:	f4ef80ef          	jal	42001f0c <cstr_equals>
420097c2:	c90d                	beqz	a0,420097f4 <vfs_ramfs_unlink+0x25a>
        off += ent->size;
420097c4:	4018                	lw	a4,0(s0)
420097c6:	9d3a                	add	s10,s10,a4
    while (off < dir->len) {
420097c8:	fd8d64e3          	bltu	s10,s8,42009790 <vfs_ramfs_unlink+0x1f6>
420097cc:	5c22                	lw	s8,40(sp)
420097ce:	5c92                	lw	s9,36(sp)
420097d0:	5d02                	lw	s10,32(sp)
420097d2:	4df2                	lw	s11,28(sp)
420097d4:	b7ad                	j	4200973e <vfs_ramfs_unlink+0x1a4>
        vfs_ramfs_dirent_t *ent = (vfs_ramfs_dirent_t *)(dir->buf + off);
420097d6:	fc8a73e3          	bgeu	s4,s0,4200979c <vfs_ramfs_unlink+0x202>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTEMPTY);
420097da:	9002                	ebreak
    assert_always(mutex_acquire(ec, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
420097dc:	420185b7          	lui	a1,0x42018
420097e0:	51058593          	add	a1,a1,1296 # 42018510 <hextab+0x1844>
420097e4:	d85a                	sw	s6,48(sp)
420097e6:	d462                	sw	s8,40(sp)
420097e8:	d266                	sw	s9,36(sp)
420097ea:	d06a                	sw	s10,32(sp)
420097ec:	ce6e                	sw	s11,28(sp)
420097ee:	a67f90ef          	jal	42003254 <logk>
420097f2:	9002                	ebreak
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTEMPTY);
420097f4:	c495                	beqz	s1,42009820 <vfs_ramfs_unlink+0x286>
420097f6:	420175b7          	lui	a1,0x42017
420097fa:	46f5                	li	a3,29
420097fc:	4635                	li	a2,13
420097fe:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42009802:	4511                	li	a0,4
42009804:	00000717          	auipc	a4,0x0
42009808:	a93f90ef          	jal	4200329a <logkf>
4200980c:	0034f793          	and	a5,s1,3
42009810:	f7e9                	bnez	a5,420097da <vfs_ramfs_unlink+0x240>
42009812:	57f1                	li	a5,-4
42009814:	fcf4f3e3          	bgeu	s1,a5,420097da <vfs_ramfs_unlink+0x240>
42009818:	47b5                	li	a5,13
4200981a:	c0dc                	sw	a5,4(s1)
4200981c:	47f5                	li	a5,29
4200981e:	c09c                	sw	a5,0(s1)
            mutex_release(NULL, &vfs->ramfs.mtx);
42009820:	45a2                	lw	a1,8(sp)
42009822:	5b42                	lw	s6,48(sp)
42009824:	5bb2                	lw	s7,44(sp)
42009826:	5c22                	lw	s8,40(sp)
42009828:	5c92                	lw	s9,36(sp)
4200982a:	5d02                	lw	s10,32(sp)
4200982c:	4df2                	lw	s11,28(sp)
4200982e:	4501                	li	a0,0
42009830:	b71d                	j	42009756 <vfs_ramfs_unlink+0x1bc>
        mutex_release(NULL, &vfs->ramfs.mtx);
42009832:	45a2                	lw	a1,8(sp)
42009834:	fd1f90ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTFOUND);
42009838:	e60485e3          	beqz	s1,420096a2 <vfs_ramfs_unlink+0x108>
4200983c:	420175b7          	lui	a1,0x42017
42009840:	46e1                	li	a3,24
42009842:	4635                	li	a2,13
42009844:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42009848:	4511                	li	a0,4
4200984a:	00000717          	auipc	a4,0x0
4200984e:	a4df90ef          	jal	4200329a <logkf>
42009852:	0034f793          	and	a5,s1,3
42009856:	ef99                	bnez	a5,42009874 <vfs_ramfs_unlink+0x2da>
42009858:	57f1                	li	a5,-4
4200985a:	00f4fd63          	bgeu	s1,a5,42009874 <vfs_ramfs_unlink+0x2da>
4200985e:	47b5                	li	a5,13
42009860:	c0dc                	sw	a5,4(s1)
42009862:	47e1                	li	a5,24
42009864:	5bb2                	lw	s7,44(sp)
42009866:	c09c                	sw	a5,0(s1)
42009868:	bbe9                	j	42009642 <vfs_ramfs_unlink+0xa8>
4200986a:	5c22                	lw	s8,40(sp)
4200986c:	bdc9                	j	4200973e <vfs_ramfs_unlink+0x1a4>
4200986e:	d85a                	sw	s6,48(sp)
42009870:	d65e                	sw	s7,44(sp)
42009872:	bdf5                	j	4200976e <vfs_ramfs_unlink+0x1d4>
42009874:	d85a                	sw	s6,48(sp)
42009876:	bde5                	j	4200976e <vfs_ramfs_unlink+0x1d4>

42009878 <vfs_ramfs_exists>:
bool vfs_ramfs_exists(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, char const *name) {
42009878:	1101                	add	sp,sp,-32
4200987a:	cc22                	sw	s0,24(sp)
4200987c:	c84a                	sw	s2,16(sp)
4200987e:	842e                	mv	s0,a1
42009880:	892a                	mv	s2,a0
    size_t name_len = cstr_length_upto(name, VFS_RAMFS_NAME_MAX + 1);
42009882:	10000593          	li	a1,256
42009886:	8536                	mv	a0,a3
bool vfs_ramfs_exists(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, char const *name) {
42009888:	ca26                	sw	s1,20(sp)
4200988a:	c64e                	sw	s3,12(sp)
4200988c:	ce06                	sw	ra,28(sp)
4200988e:	89b6                	mv	s3,a3
42009890:	84b2                	mv	s1,a2
    size_t name_len = cstr_length_upto(name, VFS_RAMFS_NAME_MAX + 1);
42009892:	ceef80ef          	jal	42001d80 <cstr_length_upto>
    if (name_len > VFS_RAMFS_NAME_MAX) {
42009896:	0ff00793          	li	a5,255
4200989a:	02a7fb63          	bgeu	a5,a0,420098d0 <vfs_ramfs_exists+0x58>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_TOOLONG);
4200989e:	02090963          	beqz	s2,420098d0 <vfs_ramfs_exists+0x58>
420098a2:	420175b7          	lui	a1,0x42017
420098a6:	4691                	li	a3,4
420098a8:	4635                	li	a2,13
420098aa:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
420098ae:	4511                	li	a0,4
420098b0:	00000717          	auipc	a4,0x0
420098b4:	9e7f90ef          	jal	4200329a <logkf>
420098b8:	00397793          	and	a5,s2,3
420098bc:	e3c1                	bnez	a5,4200993c <vfs_ramfs_exists+0xc4>
420098be:	57f1                	li	a5,-4
420098c0:	06f97e63          	bgeu	s2,a5,4200993c <vfs_ramfs_exists+0xc4>
420098c4:	47b5                	li	a5,13
420098c6:	00f92223          	sw	a5,4(s2)
420098ca:	4791                	li	a5,4
420098cc:	00f92023          	sw	a5,0(s2)
    assert_always(mutex_acquire_shared(ec, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
420098d0:	c435                	beqz	s0,4200993c <vfs_ramfs_exists+0xc4>
420098d2:	00347793          	and	a5,s0,3
420098d6:	e3bd                	bnez	a5,4200993c <vfs_ramfs_exists+0xc4>
420098d8:	fd800793          	li	a5,-40
420098dc:	06f47063          	bgeu	s0,a5,4200993c <vfs_ramfs_exists+0xc4>
420098e0:	02840413          	add	s0,s0,40
420098e4:	0016e637          	lui	a2,0x16e
420098e8:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
420098ec:	4681                	li	a3,0
420098ee:	85a2                	mv	a1,s0
420098f0:	854a                	mv	a0,s2
420098f2:	838fa0ef          	jal	4200392a <mutex_acquire_shared>
420098f6:	cd05                	beqz	a0,4200992e <vfs_ramfs_exists+0xb6>
    vfs_ramfs_inode_t  *dirptr = dir->ramfs_file;
420098f8:	c0b1                	beqz	s1,4200993c <vfs_ramfs_exists+0xc4>
420098fa:	0034f793          	and	a5,s1,3
420098fe:	ef9d                	bnez	a5,4200993c <vfs_ramfs_exists+0xc4>
42009900:	57d1                	li	a5,-12
42009902:	02f4fd63          	bgeu	s1,a5,4200993c <vfs_ramfs_exists+0xc4>
    vfs_ramfs_dirent_t *ent    = find_dirent(ec, vfs, dirptr, name);
42009906:	44cc                	lw	a1,12(s1)
42009908:	864e                	mv	a2,s3
4200990a:	854a                	mv	a0,s2
4200990c:	ab6ff0ef          	jal	42008bc2 <find_dirent.isra.0>
42009910:	87aa                	mv	a5,a0
    mutex_release_shared(NULL, &vfs->ramfs.mtx);
42009912:	85a2                	mv	a1,s0
42009914:	4501                	li	a0,0
    vfs_ramfs_dirent_t *ent    = find_dirent(ec, vfs, dirptr, name);
42009916:	843e                	mv	s0,a5
    mutex_release_shared(NULL, &vfs->ramfs.mtx);
42009918:	a3cfa0ef          	jal	42003b54 <mutex_release_shared>
}
4200991c:	40f2                	lw	ra,28(sp)
4200991e:	00803533          	snez	a0,s0
42009922:	4462                	lw	s0,24(sp)
42009924:	44d2                	lw	s1,20(sp)
42009926:	4942                	lw	s2,16(sp)
42009928:	49b2                	lw	s3,12(sp)
4200992a:	6105                	add	sp,sp,32
4200992c:	8082                	ret
    assert_always(mutex_acquire_shared(ec, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
4200992e:	420185b7          	lui	a1,0x42018
42009932:	5b058593          	add	a1,a1,1456 # 420185b0 <hextab+0x18e4>
42009936:	91ff90ef          	jal	42003254 <logk>
4200993a:	9002                	ebreak
    vfs_ramfs_inode_t  *dirptr = dir->ramfs_file;
4200993c:	9002                	ebreak

4200993e <vfs_ramfs_dir_read>:

// Atomically read all directory entries and cache them into the directory handle.
// Refer to `dirent_t` for the structure of the cache.
void vfs_ramfs_dir_read(badge_err_t *ec, vfs_t *vfs, vfs_file_handle_t *dir) {
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
4200993e:	26058463          	beqz	a1,42009ba6 <vfs_ramfs_dir_read+0x268>
void vfs_ramfs_dir_read(badge_err_t *ec, vfs_t *vfs, vfs_file_handle_t *dir) {
42009942:	7179                	add	sp,sp,-48
42009944:	cc52                	sw	s4,24(sp)
42009946:	d606                	sw	ra,44(sp)
42009948:	d422                	sw	s0,40(sp)
4200994a:	d04a                	sw	s2,32(sp)
4200994c:	ce4e                	sw	s3,28(sp)
4200994e:	ca56                	sw	s5,20(sp)
42009950:	c85a                	sw	s6,16(sp)
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009952:	0035f793          	and	a5,a1,3
42009956:	8a2e                	mv	s4,a1
42009958:	22079363          	bnez	a5,42009b7e <vfs_ramfs_dir_read+0x240>
4200995c:	fd800793          	li	a5,-40
42009960:	20f5fa63          	bgeu	a1,a5,42009b74 <vfs_ramfs_dir_read+0x236>
42009964:	89b2                	mv	s3,a2
42009966:	02858b13          	add	s6,a1,40
4200996a:	0016e637          	lui	a2,0x16e
4200996e:	8aaa                	mv	s5,a0
42009970:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42009974:	4681                	li	a3,0
42009976:	85da                	mv	a1,s6
42009978:	4501                	li	a0,0
4200997a:	fb1f90ef          	jal	4200392a <mutex_acquire_shared>
4200997e:	14050863          	beqz	a0,42009ace <vfs_ramfs_dir_read+0x190>
    size_t             off  = 0;
    vfs_ramfs_inode_t *iptr = dir->shared->ramfs_file;
42009982:	1c098063          	beqz	s3,42009b42 <vfs_ramfs_dir_read+0x204>
42009986:	0039f793          	and	a5,s3,3
4200998a:	1a079c63          	bnez	a5,42009b42 <vfs_ramfs_dir_read+0x204>
4200998e:	5791                	li	a5,-28
42009990:	1cf9fd63          	bgeu	s3,a5,42009b6a <vfs_ramfs_dir_read+0x22c>
42009994:	01c9a783          	lw	a5,28(s3)
42009998:	1c078463          	beqz	a5,42009b60 <vfs_ramfs_dir_read+0x222>
4200999c:	0037f713          	and	a4,a5,3
420099a0:	1c071063          	bnez	a4,42009b60 <vfs_ramfs_dir_read+0x222>
420099a4:	5751                	li	a4,-12
420099a6:	1ae7f863          	bgeu	a5,a4,42009b56 <vfs_ramfs_dir_read+0x218>
420099aa:	00c7a903          	lw	s2,12(a5)

    // Measure required memory.
    size_t cap = 0;
    while (off < iptr->len) {
420099ae:	18090f63          	beqz	s2,42009b4c <vfs_ramfs_dir_read+0x20e>
420099b2:	00397793          	and	a5,s2,3
420099b6:	18079b63          	bnez	a5,42009b4c <vfs_ramfs_dir_read+0x20e>
420099ba:	00092503          	lw	a0,0(s2)
    size_t cap = 0;
420099be:	4401                	li	s0,0
    while (off < iptr->len) {
420099c0:	c129                	beqz	a0,42009a02 <vfs_ramfs_dir_read+0xc4>
    size_t             off  = 0;
420099c2:	4701                	li	a4,0
        vfs_ramfs_dirent_t *ent  = (vfs_ramfs_dirent_t *)(iptr->buf + off);
420099c4:	5661                	li	a2,-8
    ent_size        += (~ent_size + 1) % sizeof(size_t);
420099c6:	583d                	li	a6,-17
        vfs_ramfs_dirent_t *ent  = (vfs_ramfs_dirent_t *)(iptr->buf + off);
420099c8:	16c97863          	bgeu	s2,a2,42009b38 <vfs_ramfs_dir_read+0x1fa>
420099cc:	00892683          	lw	a3,8(s2)
420099d0:	00e687b3          	add	a5,a3,a4
420099d4:	0e074063          	bltz	a4,42009ab4 <vfs_ramfs_dir_read+0x176>
420099d8:	0ed7e063          	bltu	a5,a3,42009ab8 <vfs_ramfs_dir_read+0x17a>
    size_t ent_size  = offsetof(dirent_t, name) + ent->name_len + 1;
420099dc:	14078963          	beqz	a5,42009b2e <vfs_ramfs_dir_read+0x1f0>
420099e0:	0037f693          	and	a3,a5,3
420099e4:	14069563          	bnez	a3,42009b2e <vfs_ramfs_dir_read+0x1f0>
420099e8:	12c7fe63          	bgeu	a5,a2,42009b24 <vfs_ramfs_dir_read+0x1e6>
420099ec:	4794                	lw	a3,8(a5)
        cap                     += measure_dirent(ent);
        off                     += ent->size;
420099ee:	438c                	lw	a1,0(a5)
    ent_size        += (~ent_size + 1) % sizeof(size_t);
420099f0:	40d807b3          	sub	a5,a6,a3
420099f4:	8b8d                	and	a5,a5,3
        cap                     += measure_dirent(ent);
420099f6:	06c5                	add	a3,a3,17 # fffff011 <__stop_free_lpsram+0xafffb011>
420099f8:	97b6                	add	a5,a5,a3
        off                     += ent->size;
420099fa:	972e                	add	a4,a4,a1
        cap                     += measure_dirent(ent);
420099fc:	943e                	add	s0,s0,a5
    while (off < iptr->len) {
420099fe:	fca765e3          	bltu	a4,a0,420099c8 <vfs_ramfs_dir_read+0x8a>
    }

    // Allocate memory.
    void *mem = realloc(dir->dir_cache, cap); // NOLINT
42009a02:	0189a503          	lw	a0,24(s3)
42009a06:	85a2                	mv	a1,s0
42009a08:	1ca040ef          	jal	4200dbd2 <realloc>
    if (!mem) {
42009a0c:	cd61                	beqz	a0,42009ae4 <vfs_ramfs_dir_read+0x1a6>
    dir->dir_cache_size = (fileoff_t)cap;

    // Generate entries.
    size_t out_off = 0;
    off            = 0;
    while (off < iptr->len) {
42009a0e:	00092703          	lw	a4,0(s2)
    dir->dir_cache      = mem;
42009a12:	00a9ac23          	sw	a0,24(s3)
    dir->dir_cache_size = (fileoff_t)cap;
42009a16:	0089aa23          	sw	s0,20(s3)
    while (off < iptr->len) {
42009a1a:	c33d                	beqz	a4,42009a80 <vfs_ramfs_dir_read+0x142>
42009a1c:	c65e                	sw	s7,12(sp)
42009a1e:	c462                	sw	s8,8(sp)
42009a20:	c266                	sw	s9,4(sp)
42009a22:	d226                	sw	s1,36(sp)
    size_t out_off = 0;
42009a24:	4c01                	li	s8,0
    off            = 0;
42009a26:	4b81                	li	s7,0
        vfs_ramfs_dirent_t *in  = (vfs_ramfs_dirent_t *)(iptr->buf + off);
42009a28:	5ce1                	li	s9,-8
42009a2a:	0f997c63          	bgeu	s2,s9,42009b22 <vfs_ramfs_dir_read+0x1e4>
42009a2e:	00892783          	lw	a5,8(s2)
42009a32:	017784b3          	add	s1,a5,s7
42009a36:	080bc963          	bltz	s7,42009ac8 <vfs_ramfs_dir_read+0x18a>
42009a3a:	08f4e963          	bltu	s1,a5,42009acc <vfs_ramfs_dir_read+0x18e>
        dirent_t           *out = (dirent_t *)(dir->dir_cache + out_off);
42009a3e:	0189a783          	lw	a5,24(s3)
42009a42:	01878433          	add	s0,a5,s8
42009a46:	060c4e63          	bltz	s8,42009ac2 <vfs_ramfs_dir_read+0x184>
42009a4a:	06f46e63          	bltu	s0,a5,42009ac6 <vfs_ramfs_dir_read+0x188>
        convert_dirent(vfs, out, in);
42009a4e:	8626                	mv	a2,s1
42009a50:	85a2                	mv	a1,s0
42009a52:	8552                	mv	a0,s4
42009a54:	87cff0ef          	jal	42008ad0 <convert_dirent.isra.0>
        off     += in->size;
42009a58:	c0f9                	beqz	s1,42009b1e <vfs_ramfs_dir_read+0x1e0>
42009a5a:	0034f793          	and	a5,s1,3
42009a5e:	e3e1                	bnez	a5,42009b1e <vfs_ramfs_dir_read+0x1e0>
42009a60:	409c                	lw	a5,0(s1)
42009a62:	9bbe                	add	s7,s7,a5
        out_off += out->record_len;
42009a64:	cc55                	beqz	s0,42009b20 <vfs_ramfs_dir_read+0x1e2>
42009a66:	00347793          	and	a5,s0,3
42009a6a:	ebdd                	bnez	a5,42009b20 <vfs_ramfs_dir_read+0x1e2>
42009a6c:	4018                	lw	a4,0(s0)
    while (off < iptr->len) {
42009a6e:	00092783          	lw	a5,0(s2)
        out_off += out->record_len;
42009a72:	9c3a                	add	s8,s8,a4
    while (off < iptr->len) {
42009a74:	fafbebe3          	bltu	s7,a5,42009a2a <vfs_ramfs_dir_read+0xec>
42009a78:	5492                	lw	s1,36(sp)
42009a7a:	4bb2                	lw	s7,12(sp)
42009a7c:	4c22                	lw	s8,8(sp)
42009a7e:	4c92                	lw	s9,4(sp)
    }

    mutex_release_shared(NULL, &vfs->ramfs.mtx);
42009a80:	85da                	mv	a1,s6
42009a82:	4501                	li	a0,0
42009a84:	8d0fa0ef          	jal	42003b54 <mutex_release_shared>
    badge_err_set_ok(ec);
42009a88:	000a8d63          	beqz	s5,42009aa2 <vfs_ramfs_dir_read+0x164>
42009a8c:	003af793          	and	a5,s5,3
42009a90:	0e079c63          	bnez	a5,42009b88 <vfs_ramfs_dir_read+0x24a>
42009a94:	57f1                	li	a5,-4
42009a96:	10faf963          	bgeu	s5,a5,42009ba8 <vfs_ramfs_dir_read+0x26a>
42009a9a:	000aa223          	sw	zero,4(s5) # 42017004 <hextab+0x338>
42009a9e:	000aa023          	sw	zero,0(s5)
}
42009aa2:	50b2                	lw	ra,44(sp)
42009aa4:	5422                	lw	s0,40(sp)
42009aa6:	5902                	lw	s2,32(sp)
42009aa8:	49f2                	lw	s3,28(sp)
42009aaa:	4a62                	lw	s4,24(sp)
42009aac:	4ad2                	lw	s5,20(sp)
42009aae:	4b42                	lw	s6,16(sp)
42009ab0:	6145                	add	sp,sp,48
42009ab2:	8082                	ret
        vfs_ramfs_dirent_t *ent  = (vfs_ramfs_dirent_t *)(iptr->buf + off);
42009ab4:	f2f6f4e3          	bgeu	a3,a5,420099dc <vfs_ramfs_dir_read+0x9e>
42009ab8:	d226                	sw	s1,36(sp)
42009aba:	c65e                	sw	s7,12(sp)
42009abc:	c462                	sw	s8,8(sp)
42009abe:	c266                	sw	s9,4(sp)
42009ac0:	9002                	ebreak
        dirent_t           *out = (dirent_t *)(dir->dir_cache + out_off);
42009ac2:	f887f6e3          	bgeu	a5,s0,42009a4e <vfs_ramfs_dir_read+0x110>
42009ac6:	9002                	ebreak
        vfs_ramfs_dirent_t *in  = (vfs_ramfs_dirent_t *)(iptr->buf + off);
42009ac8:	f697fbe3          	bgeu	a5,s1,42009a3e <vfs_ramfs_dir_read+0x100>
42009acc:	9002                	ebreak
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009ace:	420185b7          	lui	a1,0x42018
42009ad2:	65858593          	add	a1,a1,1624 # 42018658 <hextab+0x198c>
42009ad6:	d226                	sw	s1,36(sp)
42009ad8:	c65e                	sw	s7,12(sp)
42009ada:	c462                	sw	s8,8(sp)
42009adc:	c266                	sw	s9,4(sp)
42009ade:	f76f90ef          	jal	42003254 <logk>
42009ae2:	9002                	ebreak
        mutex_release_shared(NULL, &vfs->ramfs.mtx);
42009ae4:	85da                	mv	a1,s6
42009ae6:	86efa0ef          	jal	42003b54 <mutex_release_shared>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
42009aea:	fa0a8ce3          	beqz	s5,42009aa2 <vfs_ramfs_dir_read+0x164>
42009aee:	420175b7          	lui	a1,0x42017
42009af2:	4699                	li	a3,6
42009af4:	4635                	li	a2,13
42009af6:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42009afa:	4511                	li	a0,4
42009afc:	00000717          	auipc	a4,0x0
42009b00:	f9af90ef          	jal	4200329a <logkf>
42009b04:	003af793          	and	a5,s5,3
42009b08:	ebd1                	bnez	a5,42009b9c <vfs_ramfs_dir_read+0x25e>
42009b0a:	57f1                	li	a5,-4
42009b0c:	08faf363          	bgeu	s5,a5,42009b92 <vfs_ramfs_dir_read+0x254>
42009b10:	47b5                	li	a5,13
42009b12:	00faa223          	sw	a5,4(s5)
42009b16:	4799                	li	a5,6
42009b18:	00faa023          	sw	a5,0(s5)
42009b1c:	b759                	j	42009aa2 <vfs_ramfs_dir_read+0x164>
        off     += in->size;
42009b1e:	9002                	ebreak
        out_off += out->record_len;
42009b20:	9002                	ebreak
        vfs_ramfs_dirent_t *in  = (vfs_ramfs_dirent_t *)(iptr->buf + off);
42009b22:	9002                	ebreak
42009b24:	d226                	sw	s1,36(sp)
42009b26:	c65e                	sw	s7,12(sp)
42009b28:	c462                	sw	s8,8(sp)
42009b2a:	c266                	sw	s9,4(sp)
    size_t ent_size  = offsetof(dirent_t, name) + ent->name_len + 1;
42009b2c:	9002                	ebreak
42009b2e:	d226                	sw	s1,36(sp)
42009b30:	c65e                	sw	s7,12(sp)
42009b32:	c462                	sw	s8,8(sp)
42009b34:	c266                	sw	s9,4(sp)
42009b36:	9002                	ebreak
42009b38:	d226                	sw	s1,36(sp)
42009b3a:	c65e                	sw	s7,12(sp)
42009b3c:	c462                	sw	s8,8(sp)
42009b3e:	c266                	sw	s9,4(sp)
        vfs_ramfs_dirent_t *ent  = (vfs_ramfs_dirent_t *)(iptr->buf + off);
42009b40:	9002                	ebreak
42009b42:	d226                	sw	s1,36(sp)
42009b44:	c65e                	sw	s7,12(sp)
42009b46:	c462                	sw	s8,8(sp)
42009b48:	c266                	sw	s9,4(sp)
    vfs_ramfs_inode_t *iptr = dir->shared->ramfs_file;
42009b4a:	9002                	ebreak
42009b4c:	d226                	sw	s1,36(sp)
42009b4e:	c65e                	sw	s7,12(sp)
42009b50:	c462                	sw	s8,8(sp)
42009b52:	c266                	sw	s9,4(sp)
    while (off < iptr->len) {
42009b54:	9002                	ebreak
42009b56:	d226                	sw	s1,36(sp)
42009b58:	c65e                	sw	s7,12(sp)
42009b5a:	c462                	sw	s8,8(sp)
42009b5c:	c266                	sw	s9,4(sp)
    vfs_ramfs_inode_t *iptr = dir->shared->ramfs_file;
42009b5e:	9002                	ebreak
42009b60:	d226                	sw	s1,36(sp)
42009b62:	c65e                	sw	s7,12(sp)
42009b64:	c462                	sw	s8,8(sp)
42009b66:	c266                	sw	s9,4(sp)
42009b68:	9002                	ebreak
42009b6a:	d226                	sw	s1,36(sp)
42009b6c:	c65e                	sw	s7,12(sp)
42009b6e:	c462                	sw	s8,8(sp)
42009b70:	c266                	sw	s9,4(sp)
42009b72:	9002                	ebreak
42009b74:	d226                	sw	s1,36(sp)
42009b76:	c65e                	sw	s7,12(sp)
42009b78:	c462                	sw	s8,8(sp)
42009b7a:	c266                	sw	s9,4(sp)
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009b7c:	9002                	ebreak
42009b7e:	d226                	sw	s1,36(sp)
42009b80:	c65e                	sw	s7,12(sp)
42009b82:	c462                	sw	s8,8(sp)
42009b84:	c266                	sw	s9,4(sp)
42009b86:	9002                	ebreak
42009b88:	d226                	sw	s1,36(sp)
42009b8a:	c65e                	sw	s7,12(sp)
42009b8c:	c462                	sw	s8,8(sp)
42009b8e:	c266                	sw	s9,4(sp)
    badge_err_set_ok(ec);
42009b90:	9002                	ebreak
42009b92:	d226                	sw	s1,36(sp)
42009b94:	c65e                	sw	s7,12(sp)
42009b96:	c462                	sw	s8,8(sp)
42009b98:	c266                	sw	s9,4(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOMEM);
42009b9a:	9002                	ebreak
42009b9c:	d226                	sw	s1,36(sp)
42009b9e:	c65e                	sw	s7,12(sp)
42009ba0:	c462                	sw	s8,8(sp)
42009ba2:	c266                	sw	s9,4(sp)
42009ba4:	9002                	ebreak
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009ba6:	9002                	ebreak
42009ba8:	d226                	sw	s1,36(sp)
42009baa:	c65e                	sw	s7,12(sp)
42009bac:	c462                	sw	s8,8(sp)
42009bae:	c266                	sw	s9,4(sp)
    badge_err_set_ok(ec);
42009bb0:	9002                	ebreak

42009bb2 <vfs_ramfs_dir_find_ent>:

// Atomically read the directory entry with the matching name.
// Returns true if the entry was found.
bool vfs_ramfs_dir_find_ent(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, dirent_t *out, char const *name) {
42009bb2:	87b2                	mv	a5,a2
    vfs_ramfs_inode_t  *iptr = dir->ramfs_file;
42009bb4:	ce15                	beqz	a2,42009bf0 <vfs_ramfs_dir_find_ent+0x3e>
42009bb6:	863a                	mv	a2,a4
42009bb8:	0037f713          	and	a4,a5,3
42009bbc:	eb15                	bnez	a4,42009bf0 <vfs_ramfs_dir_find_ent+0x3e>
42009bbe:	5751                	li	a4,-12
42009bc0:	02e7f963          	bgeu	a5,a4,42009bf2 <vfs_ramfs_dir_find_ent+0x40>
bool vfs_ramfs_dir_find_ent(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, dirent_t *out, char const *name) {
42009bc4:	1141                	add	sp,sp,-16
42009bc6:	c422                	sw	s0,8(sp)
42009bc8:	842e                	mv	s0,a1
    vfs_ramfs_dirent_t *in   = find_dirent(ec, vfs, iptr, name);
42009bca:	47cc                	lw	a1,12(a5)
bool vfs_ramfs_dir_find_ent(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, dirent_t *out, char const *name) {
42009bcc:	c226                	sw	s1,4(sp)
42009bce:	c606                	sw	ra,12(sp)
42009bd0:	84b6                	mv	s1,a3
    vfs_ramfs_dirent_t *in   = find_dirent(ec, vfs, iptr, name);
42009bd2:	ff1fe0ef          	jal	42008bc2 <find_dirent.isra.0>
42009bd6:	862a                	mv	a2,a0
    if (!in) {
        return false;
42009bd8:	4501                	li	a0,0
    if (!in) {
42009bda:	c611                	beqz	a2,42009be6 <vfs_ramfs_dir_find_ent+0x34>
    } else {
        convert_dirent(vfs, out, in);
42009bdc:	8522                	mv	a0,s0
42009bde:	85a6                	mv	a1,s1
42009be0:	ef1fe0ef          	jal	42008ad0 <convert_dirent.isra.0>
        return true;
42009be4:	4505                	li	a0,1
    }
}
42009be6:	40b2                	lw	ra,12(sp)
42009be8:	4422                	lw	s0,8(sp)
42009bea:	4492                	lw	s1,4(sp)
42009bec:	0141                	add	sp,sp,16
42009bee:	8082                	ret
    vfs_ramfs_inode_t  *iptr = dir->ramfs_file;
42009bf0:	9002                	ebreak
42009bf2:	9002                	ebreak

42009bf4 <vfs_ramfs_root_open>:



// Open a file handle for the root directory.
void vfs_ramfs_root_open(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *file) {
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009bf4:	c9e9                	beqz	a1,42009cc6 <vfs_ramfs_root_open+0xd2>
void vfs_ramfs_root_open(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *file) {
42009bf6:	1101                	add	sp,sp,-32
42009bf8:	ca26                	sw	s1,20(sp)
42009bfa:	ce06                	sw	ra,28(sp)
42009bfc:	cc22                	sw	s0,24(sp)
42009bfe:	c84a                	sw	s2,16(sp)
42009c00:	c64e                	sw	s3,12(sp)
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009c02:	0035f793          	and	a5,a1,3
42009c06:	84ae                	mv	s1,a1
42009c08:	e7c5                	bnez	a5,42009cb0 <vfs_ramfs_root_open+0xbc>
42009c0a:	fd800793          	li	a5,-40
42009c0e:	0af5f263          	bgeu	a1,a5,42009cb2 <vfs_ramfs_root_open+0xbe>
42009c12:	8432                	mv	s0,a2
42009c14:	02858993          	add	s3,a1,40
42009c18:	0016e637          	lui	a2,0x16e
42009c1c:	892a                	mv	s2,a0
42009c1e:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42009c22:	4681                	li	a3,0
42009c24:	85ce                	mv	a1,s3
42009c26:	4501                	li	a0,0
42009c28:	d03f90ef          	jal	4200392a <mutex_acquire_shared>
42009c2c:	c93d                	beqz	a0,42009ca2 <vfs_ramfs_root_open+0xae>

    // Install in shared file handle.
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[VFS_RAMFS_INODE_ROOT];
42009c2e:	4cdc                	lw	a5,28(s1)
42009c30:	5681                	li	a3,-32
42009c32:	08d7f263          	bgeu	a5,a3,42009cb6 <vfs_ramfs_root_open+0xc2>
42009c36:	02078713          	add	a4,a5,32
    file->ramfs_file        = iptr;
42009c3a:	c059                	beqz	s0,42009cc0 <vfs_ramfs_root_open+0xcc>
42009c3c:	00347613          	and	a2,s0,3
42009c40:	e241                	bnez	a2,42009cc0 <vfs_ramfs_root_open+0xcc>
42009c42:	5651                	li	a2,-12
42009c44:	06c47d63          	bgeu	s0,a2,42009cbe <vfs_ramfs_root_open+0xca>
42009c48:	c458                	sw	a4,12(s0)
    file->inode             = VFS_RAMFS_INODE_ROOT;
42009c4a:	06d47963          	bgeu	s0,a3,42009cbc <vfs_ramfs_root_open+0xc8>
42009c4e:	4685                	li	a3,1
42009c50:	d014                	sw	a3,32(s0)
    file->vfs               = vfs;
42009c52:	fdc00693          	li	a3,-36
42009c56:	06d47263          	bgeu	s0,a3,42009cba <vfs_ramfs_root_open+0xc6>
    file->refcount          = 1;
42009c5a:	4685                	li	a3,1
    file->vfs               = vfs;
42009c5c:	d044                	sw	s1,36(s0)
    file->refcount          = 1;
42009c5e:	c014                	sw	a3,0(s0)

    iptr->links++;
42009c60:	cb31                	beqz	a4,42009cb4 <vfs_ramfs_root_open+0xc0>
42009c62:	00377693          	and	a3,a4,3
42009c66:	e6b9                	bnez	a3,42009cb4 <vfs_ramfs_root_open+0xc0>
42009c68:	56b1                	li	a3,-20
42009c6a:	04d77763          	bgeu	a4,a3,42009cb8 <vfs_ramfs_root_open+0xc4>
42009c6e:	5bd8                	lw	a4,52(a5)

    mutex_release_shared(NULL, &vfs->ramfs.mtx);
42009c70:	85ce                	mv	a1,s3
42009c72:	4501                	li	a0,0
    iptr->links++;
42009c74:	0705                	add	a4,a4,1 # 42009afd <vfs_ramfs_dir_read+0x1bf>
42009c76:	dbd8                	sw	a4,52(a5)
    mutex_release_shared(NULL, &vfs->ramfs.mtx);
42009c78:	eddf90ef          	jal	42003b54 <mutex_release_shared>
    badge_err_set_ok(ec);
42009c7c:	00090c63          	beqz	s2,42009c94 <vfs_ramfs_root_open+0xa0>
42009c80:	00397793          	and	a5,s2,3
42009c84:	e3a1                	bnez	a5,42009cc4 <vfs_ramfs_root_open+0xd0>
42009c86:	57f1                	li	a5,-4
42009c88:	02f97d63          	bgeu	s2,a5,42009cc2 <vfs_ramfs_root_open+0xce>
42009c8c:	00092223          	sw	zero,4(s2)
42009c90:	00092023          	sw	zero,0(s2)
}
42009c94:	40f2                	lw	ra,28(sp)
42009c96:	4462                	lw	s0,24(sp)
42009c98:	44d2                	lw	s1,20(sp)
42009c9a:	4942                	lw	s2,16(sp)
42009c9c:	49b2                	lw	s3,12(sp)
42009c9e:	6105                	add	sp,sp,32
42009ca0:	8082                	ret
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009ca2:	420185b7          	lui	a1,0x42018
42009ca6:	70058593          	add	a1,a1,1792 # 42018700 <hextab+0x1a34>
42009caa:	daaf90ef          	jal	42003254 <logk>
42009cae:	9002                	ebreak
42009cb0:	9002                	ebreak
42009cb2:	9002                	ebreak
    iptr->links++;
42009cb4:	9002                	ebreak
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[VFS_RAMFS_INODE_ROOT];
42009cb6:	9002                	ebreak
    iptr->links++;
42009cb8:	9002                	ebreak
    file->vfs               = vfs;
42009cba:	9002                	ebreak
    file->inode             = VFS_RAMFS_INODE_ROOT;
42009cbc:	9002                	ebreak
    file->ramfs_file        = iptr;
42009cbe:	9002                	ebreak
42009cc0:	9002                	ebreak
    badge_err_set_ok(ec);
42009cc2:	9002                	ebreak
42009cc4:	9002                	ebreak
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009cc6:	9002                	ebreak

42009cc8 <vfs_ramfs_file_open>:

// Open a file for reading and/or writing.
void vfs_ramfs_file_open(
    badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *dir, vfs_file_shared_t *file, char const *name
) {
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009cc8:	18058163          	beqz	a1,42009e4a <vfs_ramfs_file_open+0x182>
) {
42009ccc:	1101                	add	sp,sp,-32
42009cce:	c256                	sw	s5,4(sp)
42009cd0:	ce06                	sw	ra,28(sp)
42009cd2:	cc22                	sw	s0,24(sp)
42009cd4:	ca26                	sw	s1,20(sp)
42009cd6:	c84a                	sw	s2,16(sp)
42009cd8:	c64e                	sw	s3,12(sp)
42009cda:	c452                	sw	s4,8(sp)
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009cdc:	0035f793          	and	a5,a1,3
42009ce0:	8aae                	mv	s5,a1
42009ce2:	14079563          	bnez	a5,42009e2c <vfs_ramfs_file_open+0x164>
42009ce6:	fd800793          	li	a5,-40
42009cea:	14f5f063          	bgeu	a1,a5,42009e2a <vfs_ramfs_file_open+0x162>
42009cee:	8932                	mv	s2,a2
42009cf0:	02858a13          	add	s4,a1,40
42009cf4:	0016e637          	lui	a2,0x16e
42009cf8:	842a                	mv	s0,a0
42009cfa:	84b6                	mv	s1,a3
42009cfc:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42009d00:	4681                	li	a3,0
42009d02:	85d2                	mv	a1,s4
42009d04:	4501                	li	a0,0
42009d06:	89ba                	mv	s3,a4
42009d08:	96bf90ef          	jal	42003672 <mutex_acquire>
42009d0c:	10050863          	beqz	a0,42009e1c <vfs_ramfs_file_open+0x154>

    // Look up the file in question.
    vfs_ramfs_inode_t  *dirptr = dir->ramfs_file;
42009d10:	12090063          	beqz	s2,42009e30 <vfs_ramfs_file_open+0x168>
42009d14:	00397793          	and	a5,s2,3
42009d18:	10079c63          	bnez	a5,42009e30 <vfs_ramfs_file_open+0x168>
42009d1c:	57d1                	li	a5,-12
42009d1e:	10f97863          	bgeu	s2,a5,42009e2e <vfs_ramfs_file_open+0x166>
    vfs_ramfs_dirent_t *ent    = find_dirent(ec, vfs, dirptr, name);
42009d22:	00c92583          	lw	a1,12(s2)
42009d26:	864e                	mv	a2,s3
42009d28:	8522                	mv	a0,s0
42009d2a:	e99fe0ef          	jal	42008bc2 <find_dirent.isra.0>
    if (!badge_err_is_ok(ec)) {
42009d2e:	c46d                	beqz	s0,42009e18 <vfs_ramfs_file_open+0x150>
42009d30:	00347793          	and	a5,s0,3
42009d34:	10079163          	bnez	a5,42009e36 <vfs_ramfs_file_open+0x16e>
42009d38:	401c                	lw	a5,0(s0)
42009d3a:	e3f9                	bnez	a5,42009e00 <vfs_ramfs_file_open+0x138>
        mutex_release(NULL, &vfs->ramfs.mtx);
        return;
    }
    if (!ent) {
42009d3c:	c145                	beqz	a0,42009ddc <vfs_ramfs_file_open+0x114>
        mutex_release(NULL, &vfs->ramfs.mtx);
        return;
    }

    // Increase refcount.
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[ent->inode];
42009d3e:	01caa683          	lw	a3,28(s5)
42009d42:	0e050e63          	beqz	a0,42009e3e <vfs_ramfs_file_open+0x176>
42009d46:	00357793          	and	a5,a0,3
42009d4a:	0e079a63          	bnez	a5,42009e3e <vfs_ramfs_file_open+0x176>
42009d4e:	57f1                	li	a5,-4
42009d50:	0ef57663          	bgeu	a0,a5,42009e3c <vfs_ramfs_file_open+0x174>
42009d54:	4158                	lw	a4,4(a0)
42009d56:	0716                	sll	a4,a4,0x5
42009d58:	00e687b3          	add	a5,a3,a4
42009d5c:	06075d63          	bgez	a4,42009dd6 <vfs_ramfs_file_open+0x10e>
42009d60:	06f6ed63          	bltu	a3,a5,42009dda <vfs_ramfs_file_open+0x112>
    iptr->links++;
42009d64:	cbf9                	beqz	a5,42009e3a <vfs_ramfs_file_open+0x172>
42009d66:	0037f713          	and	a4,a5,3
42009d6a:	eb61                	bnez	a4,42009e3a <vfs_ramfs_file_open+0x172>
42009d6c:	5731                	li	a4,-20
42009d6e:	0ce7f563          	bgeu	a5,a4,42009e38 <vfs_ramfs_file_open+0x170>
42009d72:	4bd8                	lw	a4,20(a5)
42009d74:	0705                	add	a4,a4,1
42009d76:	cbd8                	sw	a4,20(a5)

    // Install in shared file handle.
    file->ramfs_file = iptr;
42009d78:	ccd5                	beqz	s1,42009e34 <vfs_ramfs_file_open+0x16c>
42009d7a:	0034f713          	and	a4,s1,3
42009d7e:	eb5d                	bnez	a4,42009e34 <vfs_ramfs_file_open+0x16c>
42009d80:	5751                	li	a4,-12
42009d82:	0ae4f863          	bgeu	s1,a4,42009e32 <vfs_ramfs_file_open+0x16a>
42009d86:	c4dc                	sw	a5,12(s1)
    file->inode      = iptr->inode;
42009d88:	5681                	li	a3,-32
42009d8a:	47d8                	lw	a4,12(a5)
42009d8c:	0ad4fb63          	bgeu	s1,a3,42009e42 <vfs_ramfs_file_open+0x17a>
42009d90:	d098                	sw	a4,32(s1)
    file->vfs        = vfs;
42009d92:	fdc00713          	li	a4,-36
42009d96:	0ae4f563          	bgeu	s1,a4,42009e40 <vfs_ramfs_file_open+0x178>
    file->refcount   = 1;
    file->size       = (fileoff_t)iptr->len;
42009d9a:	439c                	lw	a5,0(a5)
    file->refcount   = 1;
42009d9c:	4705                	li	a4,1
    file->vfs        = vfs;
42009d9e:	0354a223          	sw	s5,36(s1)
    file->refcount   = 1;
42009da2:	c098                	sw	a4,0(s1)
    file->size       = (fileoff_t)iptr->len;
42009da4:	c49c                	sw	a5,8(s1)

    mutex_release(NULL, &vfs->ramfs.mtx);
42009da6:	85d2                	mv	a1,s4
42009da8:	4501                	li	a0,0
42009daa:	a5bf90ef          	jal	42003804 <mutex_release>
    badge_err_set_ok(ec);
42009dae:	c819                	beqz	s0,42009dc4 <vfs_ramfs_file_open+0xfc>
42009db0:	00347793          	and	a5,s0,3
42009db4:	ebc9                	bnez	a5,42009e46 <vfs_ramfs_file_open+0x17e>
42009db6:	57f1                	li	a5,-4
42009db8:	08f47663          	bgeu	s0,a5,42009e44 <vfs_ramfs_file_open+0x17c>
42009dbc:	00042223          	sw	zero,4(s0)
42009dc0:	00042023          	sw	zero,0(s0)
}
42009dc4:	40f2                	lw	ra,28(sp)
42009dc6:	4462                	lw	s0,24(sp)
42009dc8:	44d2                	lw	s1,20(sp)
42009dca:	4942                	lw	s2,16(sp)
42009dcc:	49b2                	lw	s3,12(sp)
42009dce:	4a22                	lw	s4,8(sp)
42009dd0:	4a92                	lw	s5,4(sp)
42009dd2:	6105                	add	sp,sp,32
42009dd4:	8082                	ret
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[ent->inode];
42009dd6:	f8d7f7e3          	bgeu	a5,a3,42009d64 <vfs_ramfs_file_open+0x9c>
42009dda:	9002                	ebreak
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTFOUND);
42009ddc:	420175b7          	lui	a1,0x42017
42009de0:	46e1                	li	a3,24
42009de2:	4635                	li	a2,13
42009de4:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42009de8:	4511                	li	a0,4
42009dea:	00000717          	auipc	a4,0x0
42009dee:	cacf90ef          	jal	4200329a <logkf>
42009df2:	57f1                	li	a5,-4
42009df4:	04f47a63          	bgeu	s0,a5,42009e48 <vfs_ramfs_file_open+0x180>
42009df8:	47b5                	li	a5,13
42009dfa:	c05c                	sw	a5,4(s0)
42009dfc:	47e1                	li	a5,24
42009dfe:	c01c                	sw	a5,0(s0)
}
42009e00:	4462                	lw	s0,24(sp)
42009e02:	40f2                	lw	ra,28(sp)
42009e04:	44d2                	lw	s1,20(sp)
42009e06:	4942                	lw	s2,16(sp)
42009e08:	49b2                	lw	s3,12(sp)
42009e0a:	4a92                	lw	s5,4(sp)
        mutex_release(NULL, &vfs->ramfs.mtx);
42009e0c:	85d2                	mv	a1,s4
}
42009e0e:	4a22                	lw	s4,8(sp)
        mutex_release(NULL, &vfs->ramfs.mtx);
42009e10:	4501                	li	a0,0
}
42009e12:	6105                	add	sp,sp,32
        mutex_release(NULL, &vfs->ramfs.mtx);
42009e14:	9f1f906f          	j	42003804 <mutex_release>
    if (!ent) {
42009e18:	f11d                	bnez	a0,42009d3e <vfs_ramfs_file_open+0x76>
42009e1a:	b7dd                	j	42009e00 <vfs_ramfs_file_open+0x138>
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009e1c:	420185b7          	lui	a1,0x42018
42009e20:	7a858593          	add	a1,a1,1960 # 420187a8 <hextab+0x1adc>
42009e24:	c30f90ef          	jal	42003254 <logk>
42009e28:	9002                	ebreak
42009e2a:	9002                	ebreak
42009e2c:	9002                	ebreak
    vfs_ramfs_inode_t  *dirptr = dir->ramfs_file;
42009e2e:	9002                	ebreak
42009e30:	9002                	ebreak
    file->ramfs_file = iptr;
42009e32:	9002                	ebreak
42009e34:	9002                	ebreak
    if (!badge_err_is_ok(ec)) {
42009e36:	9002                	ebreak
    iptr->links++;
42009e38:	9002                	ebreak
42009e3a:	9002                	ebreak
    vfs_ramfs_inode_t *iptr = &vfs->ramfs.inode_list[ent->inode];
42009e3c:	9002                	ebreak
42009e3e:	9002                	ebreak
    file->vfs        = vfs;
42009e40:	9002                	ebreak
    file->inode      = iptr->inode;
42009e42:	9002                	ebreak
    badge_err_set_ok(ec);
42009e44:	9002                	ebreak
42009e46:	9002                	ebreak
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTFOUND);
42009e48:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009e4a:	9002                	ebreak

42009e4c <vfs_ramfs_file_close>:

// Close a file opened by `vfs_ramfs_file_open`.
// Only raises an error if `file` is an invalid file descriptor.
void vfs_ramfs_file_close(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *file) {
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009e4c:	cdd1                	beqz	a1,42009ee8 <vfs_ramfs_file_close+0x9c>
void vfs_ramfs_file_close(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *file) {
42009e4e:	1101                	add	sp,sp,-32
42009e50:	cc22                	sw	s0,24(sp)
42009e52:	ce06                	sw	ra,28(sp)
42009e54:	ca26                	sw	s1,20(sp)
42009e56:	c84a                	sw	s2,16(sp)
42009e58:	c64e                	sw	s3,12(sp)
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009e5a:	0035f793          	and	a5,a1,3
42009e5e:	842e                	mv	s0,a1
42009e60:	efb5                	bnez	a5,42009edc <vfs_ramfs_file_close+0x90>
42009e62:	fd800793          	li	a5,-40
42009e66:	06f5fc63          	bgeu	a1,a5,42009ede <vfs_ramfs_file_close+0x92>
42009e6a:	84b2                	mv	s1,a2
42009e6c:	02858993          	add	s3,a1,40
42009e70:	0016e637          	lui	a2,0x16e
42009e74:	892a                	mv	s2,a0
42009e76:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42009e7a:	4681                	li	a3,0
42009e7c:	85ce                	mv	a1,s3
42009e7e:	4501                	li	a0,0
42009e80:	ff2f90ef          	jal	42003672 <mutex_acquire>
42009e84:	c529                	beqz	a0,42009ece <vfs_ramfs_file_close+0x82>
    pop_inode_refcount(vfs, file->ramfs_file);
42009e86:	cca9                	beqz	s1,42009ee0 <vfs_ramfs_file_close+0x94>
42009e88:	0034f793          	and	a5,s1,3
42009e8c:	ebb1                	bnez	a5,42009ee0 <vfs_ramfs_file_close+0x94>
42009e8e:	57d1                	li	a5,-12
42009e90:	04f4f963          	bgeu	s1,a5,42009ee2 <vfs_ramfs_file_close+0x96>
42009e94:	44cc                	lw	a1,12(s1)
42009e96:	8522                	mv	a0,s0
42009e98:	bc5fe0ef          	jal	42008a5c <pop_inode_refcount>
    mutex_release(NULL, &vfs->ramfs.mtx);
42009e9c:	85ce                	mv	a1,s3
42009e9e:	4501                	li	a0,0
42009ea0:	965f90ef          	jal	42003804 <mutex_release>
    file->ramfs_file = NULL;
42009ea4:	0004a623          	sw	zero,12(s1)
    badge_err_set_ok(ec);
42009ea8:	00090c63          	beqz	s2,42009ec0 <vfs_ramfs_file_close+0x74>
42009eac:	00397793          	and	a5,s2,3
42009eb0:	eb95                	bnez	a5,42009ee4 <vfs_ramfs_file_close+0x98>
42009eb2:	57f1                	li	a5,-4
42009eb4:	02f97963          	bgeu	s2,a5,42009ee6 <vfs_ramfs_file_close+0x9a>
42009eb8:	00092223          	sw	zero,4(s2)
42009ebc:	00092023          	sw	zero,0(s2)
}
42009ec0:	40f2                	lw	ra,28(sp)
42009ec2:	4462                	lw	s0,24(sp)
42009ec4:	44d2                	lw	s1,20(sp)
42009ec6:	4942                	lw	s2,16(sp)
42009ec8:	49b2                	lw	s3,12(sp)
42009eca:	6105                	add	sp,sp,32
42009ecc:	8082                	ret
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009ece:	420195b7          	lui	a1,0x42019
42009ed2:	84858593          	add	a1,a1,-1976 # 42018848 <hextab+0x1b7c>
42009ed6:	b7ef90ef          	jal	42003254 <logk>
42009eda:	9002                	ebreak
42009edc:	9002                	ebreak
42009ede:	9002                	ebreak
    pop_inode_refcount(vfs, file->ramfs_file);
42009ee0:	9002                	ebreak
42009ee2:	9002                	ebreak
    badge_err_set_ok(ec);
42009ee4:	9002                	ebreak
42009ee6:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009ee8:	9002                	ebreak

42009eea <vfs_ramfs_file_read>:

// Read bytes from a file.
void vfs_ramfs_file_read(
    badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *file, fileoff_t offset, uint8_t *readbuf, fileoff_t readlen
) {
42009eea:	1101                	add	sp,sp,-32
42009eec:	c452                	sw	s4,8(sp)
42009eee:	ce06                	sw	ra,28(sp)
42009ef0:	8a2a                	mv	s4,a0
    if (offset < 0) {
42009ef2:	1006c163          	bltz	a3,42009ff4 <vfs_ramfs_file_read+0x10a>
42009ef6:	cc22                	sw	s0,24(sp)
42009ef8:	ca26                	sw	s1,20(sp)
42009efa:	c84a                	sw	s2,16(sp)
42009efc:	c64e                	sw	s3,12(sp)
42009efe:	c256                	sw	s5,4(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
        return;
    }
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
42009f00:	12058d63          	beqz	a1,4200a03a <vfs_ramfs_file_read+0x150>
42009f04:	89be                	mv	s3,a5
42009f06:	0035f793          	and	a5,a1,3
42009f0a:	12079863          	bnez	a5,4200a03a <vfs_ramfs_file_read+0x150>
42009f0e:	fd800793          	li	a5,-40
42009f12:	12f5f463          	bgeu	a1,a5,4200a03a <vfs_ramfs_file_read+0x150>
42009f16:	8932                	mv	s2,a2
42009f18:	02858493          	add	s1,a1,40
42009f1c:	0016e637          	lui	a2,0x16e
42009f20:	8436                	mv	s0,a3
42009f22:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
42009f26:	4681                	li	a3,0
42009f28:	85a6                	mv	a1,s1
42009f2a:	4501                	li	a0,0
42009f2c:	8aba                	mv	s5,a4
42009f2e:	9fdf90ef          	jal	4200392a <mutex_acquire_shared>
42009f32:	0e050d63          	beqz	a0,4200a02c <vfs_ramfs_file_read+0x142>

    vfs_ramfs_inode_t *iptr = file->ramfs_file;
42009f36:	10090263          	beqz	s2,4200a03a <vfs_ramfs_file_read+0x150>
42009f3a:	00397793          	and	a5,s2,3
42009f3e:	0e079e63          	bnez	a5,4200a03a <vfs_ramfs_file_read+0x150>
42009f42:	57d1                	li	a5,-12
42009f44:	0ef97b63          	bgeu	s2,a5,4200a03a <vfs_ramfs_file_read+0x150>

    // Bounds check file and read offsets.
    if (offset + readlen > (ptrdiff_t)iptr->len || offset + readlen < offset) {
42009f48:	01340733          	add	a4,s0,s3
42009f4c:	0009a693          	slti	a3,s3,0
42009f50:	00872633          	slt	a2,a4,s0
    vfs_ramfs_inode_t *iptr = file->ramfs_file;
42009f54:	00c92783          	lw	a5,12(s2)
    if (offset + readlen > (ptrdiff_t)iptr->len || offset + readlen < offset) {
42009f58:	0ec69163          	bne	a3,a2,4200a03a <vfs_ramfs_file_read+0x150>
42009f5c:	cff9                	beqz	a5,4200a03a <vfs_ramfs_file_read+0x150>
42009f5e:	0037f693          	and	a3,a5,3
42009f62:	eee1                	bnez	a3,4200a03a <vfs_ramfs_file_read+0x150>
42009f64:	4394                	lw	a3,0(a5)
42009f66:	04e6c963          	blt	a3,a4,42009fb8 <vfs_ramfs_file_read+0xce>
42009f6a:	04874763          	blt	a4,s0,42009fb8 <vfs_ramfs_file_read+0xce>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
        return;
    }

    // Checks passed, return data.
    mem_copy(readbuf, iptr->buf + offset, readlen);
42009f6e:	5761                	li	a4,-8
42009f70:	0ce7f563          	bgeu	a5,a4,4200a03a <vfs_ramfs_file_read+0x150>
42009f74:	479c                	lw	a5,8(a5)
42009f76:	008785b3          	add	a1,a5,s0
42009f7a:	0cf5e063          	bltu	a1,a5,4200a03a <vfs_ramfs_file_read+0x150>
42009f7e:	8556                	mv	a0,s5
42009f80:	864e                	mv	a2,s3
42009f82:	beaf80ef          	jal	4200236c <mem_copy>
    mutex_release_shared(NULL, &vfs->ramfs.mtx);
42009f86:	85a6                	mv	a1,s1
42009f88:	4501                	li	a0,0
42009f8a:	bcbf90ef          	jal	42003b54 <mutex_release_shared>
    badge_err_set_ok(ec);
42009f8e:	000a0c63          	beqz	s4,42009fa6 <vfs_ramfs_file_read+0xbc>
42009f92:	003a7793          	and	a5,s4,3
42009f96:	e3d5                	bnez	a5,4200a03a <vfs_ramfs_file_read+0x150>
42009f98:	57f1                	li	a5,-4
42009f9a:	0afa7063          	bgeu	s4,a5,4200a03a <vfs_ramfs_file_read+0x150>
42009f9e:	000a2223          	sw	zero,4(s4)
42009fa2:	000a2023          	sw	zero,0(s4)
42009fa6:	4462                	lw	s0,24(sp)
42009fa8:	44d2                	lw	s1,20(sp)
42009faa:	4942                	lw	s2,16(sp)
42009fac:	49b2                	lw	s3,12(sp)
42009fae:	4a92                	lw	s5,4(sp)
}
42009fb0:	40f2                	lw	ra,28(sp)
42009fb2:	4a22                	lw	s4,8(sp)
42009fb4:	6105                	add	sp,sp,32
42009fb6:	8082                	ret
        mutex_release_shared(NULL, &vfs->ramfs.mtx);
42009fb8:	85a6                	mv	a1,s1
42009fba:	4501                	li	a0,0
42009fbc:	b99f90ef          	jal	42003b54 <mutex_release_shared>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
42009fc0:	fe0a03e3          	beqz	s4,42009fa6 <vfs_ramfs_file_read+0xbc>
42009fc4:	420175b7          	lui	a1,0x42017
42009fc8:	468d                	li	a3,3
42009fca:	4635                	li	a2,13
42009fcc:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
42009fd0:	4511                	li	a0,4
42009fd2:	00000717          	auipc	a4,0x0
42009fd6:	ac4f90ef          	jal	4200329a <logkf>
42009fda:	003a7793          	and	a5,s4,3
42009fde:	efb1                	bnez	a5,4200a03a <vfs_ramfs_file_read+0x150>
42009fe0:	57f1                	li	a5,-4
42009fe2:	04fa7c63          	bgeu	s4,a5,4200a03a <vfs_ramfs_file_read+0x150>
42009fe6:	47b5                	li	a5,13
42009fe8:	00fa2223          	sw	a5,4(s4)
42009fec:	478d                	li	a5,3
42009fee:	00fa2023          	sw	a5,0(s4)
42009ff2:	bf55                	j	42009fa6 <vfs_ramfs_file_read+0xbc>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
42009ff4:	dd55                	beqz	a0,42009fb0 <vfs_ramfs_file_read+0xc6>
42009ff6:	420175b7          	lui	a1,0x42017
42009ffa:	468d                	li	a3,3
42009ffc:	4635                	li	a2,13
42009ffe:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200a002:	4511                	li	a0,4
4200a004:	00000717          	auipc	a4,0x0
4200a008:	a92f90ef          	jal	4200329a <logkf>
4200a00c:	003a7793          	and	a5,s4,3
4200a010:	e795                	bnez	a5,4200a03c <vfs_ramfs_file_read+0x152>
4200a012:	57f1                	li	a5,-4
4200a014:	02fa7463          	bgeu	s4,a5,4200a03c <vfs_ramfs_file_read+0x152>
}
4200a018:	40f2                	lw	ra,28(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
4200a01a:	47b5                	li	a5,13
4200a01c:	00fa2223          	sw	a5,4(s4)
4200a020:	478d                	li	a5,3
4200a022:	00fa2023          	sw	a5,0(s4)
}
4200a026:	4a22                	lw	s4,8(sp)
4200a028:	6105                	add	sp,sp,32
4200a02a:	8082                	ret
    assert_always(mutex_acquire_shared(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
4200a02c:	420195b7          	lui	a1,0x42019
4200a030:	8e858593          	add	a1,a1,-1816 # 420188e8 <hextab+0x1c1c>
4200a034:	a20f90ef          	jal	42003254 <logk>
4200a038:	9002                	ebreak
    badge_err_set_ok(ec);
4200a03a:	9002                	ebreak
4200a03c:	cc22                	sw	s0,24(sp)
4200a03e:	ca26                	sw	s1,20(sp)
4200a040:	c84a                	sw	s2,16(sp)
4200a042:	c64e                	sw	s3,12(sp)
4200a044:	c256                	sw	s5,4(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
4200a046:	9002                	ebreak

4200a048 <vfs_ramfs_file_write>:

// Write bytes from a file.
void vfs_ramfs_file_write(
    badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *file, fileoff_t offset, uint8_t const *writebuf, fileoff_t writelen
) {
4200a048:	1101                	add	sp,sp,-32
4200a04a:	c452                	sw	s4,8(sp)
4200a04c:	ce06                	sw	ra,28(sp)
4200a04e:	8a2a                	mv	s4,a0
    if (offset < 0) {
4200a050:	0e06cc63          	bltz	a3,4200a148 <vfs_ramfs_file_write+0x100>
4200a054:	cc22                	sw	s0,24(sp)
4200a056:	ca26                	sw	s1,20(sp)
4200a058:	c84a                	sw	s2,16(sp)
4200a05a:	c64e                	sw	s3,12(sp)
4200a05c:	c256                	sw	s5,4(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
        return;
    }
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
4200a05e:	12058863          	beqz	a1,4200a18e <vfs_ramfs_file_write+0x146>
4200a062:	89be                	mv	s3,a5
4200a064:	0035f793          	and	a5,a1,3
4200a068:	12079363          	bnez	a5,4200a18e <vfs_ramfs_file_write+0x146>
4200a06c:	fd800793          	li	a5,-40
4200a070:	10f5ff63          	bgeu	a1,a5,4200a18e <vfs_ramfs_file_write+0x146>
4200a074:	8932                	mv	s2,a2
4200a076:	02858493          	add	s1,a1,40
4200a07a:	0016e637          	lui	a2,0x16e
4200a07e:	8436                	mv	s0,a3
4200a080:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
4200a084:	4681                	li	a3,0
4200a086:	85a6                	mv	a1,s1
4200a088:	4501                	li	a0,0
4200a08a:	8aba                	mv	s5,a4
4200a08c:	de6f90ef          	jal	42003672 <mutex_acquire>
4200a090:	0e050863          	beqz	a0,4200a180 <vfs_ramfs_file_write+0x138>

    vfs_ramfs_inode_t *iptr = file->ramfs_file;
4200a094:	0e090d63          	beqz	s2,4200a18e <vfs_ramfs_file_write+0x146>
4200a098:	00397793          	and	a5,s2,3
4200a09c:	0e079963          	bnez	a5,4200a18e <vfs_ramfs_file_write+0x146>
4200a0a0:	57d1                	li	a5,-12
4200a0a2:	0ef97663          	bgeu	s2,a5,4200a18e <vfs_ramfs_file_write+0x146>

    // Bounds check file and read offsets.
    if (offset + writelen > (ptrdiff_t)iptr->len || offset + writelen < offset) {
4200a0a6:	01340733          	add	a4,s0,s3
4200a0aa:	0009a693          	slti	a3,s3,0
4200a0ae:	00872633          	slt	a2,a4,s0
    vfs_ramfs_inode_t *iptr = file->ramfs_file;
4200a0b2:	00c92783          	lw	a5,12(s2)
    if (offset + writelen > (ptrdiff_t)iptr->len || offset + writelen < offset) {
4200a0b6:	0cc69c63          	bne	a3,a2,4200a18e <vfs_ramfs_file_write+0x146>
4200a0ba:	cbf1                	beqz	a5,4200a18e <vfs_ramfs_file_write+0x146>
4200a0bc:	0037f693          	and	a3,a5,3
4200a0c0:	e6f9                	bnez	a3,4200a18e <vfs_ramfs_file_write+0x146>
4200a0c2:	4394                	lw	a3,0(a5)
4200a0c4:	02e6cc63          	blt	a3,a4,4200a0fc <vfs_ramfs_file_write+0xb4>
4200a0c8:	02874a63          	blt	a4,s0,4200a0fc <vfs_ramfs_file_write+0xb4>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
        return;
    }

    // Checks passed, update data.
    mem_copy(iptr->buf + offset, writebuf, writelen);
4200a0cc:	5761                	li	a4,-8
4200a0ce:	0ce7f063          	bgeu	a5,a4,4200a18e <vfs_ramfs_file_write+0x146>
4200a0d2:	479c                	lw	a5,8(a5)
4200a0d4:	00878533          	add	a0,a5,s0
4200a0d8:	0af56b63          	bltu	a0,a5,4200a18e <vfs_ramfs_file_write+0x146>
4200a0dc:	85d6                	mv	a1,s5
4200a0de:	864e                	mv	a2,s3
4200a0e0:	a8cf80ef          	jal	4200236c <mem_copy>
    mutex_release(ec, &vfs->ramfs.mtx);
4200a0e4:	4462                	lw	s0,24(sp)
4200a0e6:	4942                	lw	s2,16(sp)
4200a0e8:	49b2                	lw	s3,12(sp)
4200a0ea:	4a92                	lw	s5,4(sp)
}
4200a0ec:	40f2                	lw	ra,28(sp)
    mutex_release(ec, &vfs->ramfs.mtx);
4200a0ee:	85a6                	mv	a1,s1
4200a0f0:	8552                	mv	a0,s4
4200a0f2:	44d2                	lw	s1,20(sp)
}
4200a0f4:	4a22                	lw	s4,8(sp)
4200a0f6:	6105                	add	sp,sp,32
    mutex_release(ec, &vfs->ramfs.mtx);
4200a0f8:	f0cf906f          	j	42003804 <mutex_release>
        mutex_release(ec, &vfs->ramfs.mtx);
4200a0fc:	85a6                	mv	a1,s1
4200a0fe:	8552                	mv	a0,s4
4200a100:	f04f90ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
4200a104:	020a0963          	beqz	s4,4200a136 <vfs_ramfs_file_write+0xee>
4200a108:	420175b7          	lui	a1,0x42017
4200a10c:	468d                	li	a3,3
4200a10e:	4635                	li	a2,13
4200a110:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200a114:	4511                	li	a0,4
4200a116:	00000717          	auipc	a4,0x0
4200a11a:	980f90ef          	jal	4200329a <logkf>
4200a11e:	003a7793          	and	a5,s4,3
4200a122:	e7b5                	bnez	a5,4200a18e <vfs_ramfs_file_write+0x146>
4200a124:	57f1                	li	a5,-4
4200a126:	06fa7463          	bgeu	s4,a5,4200a18e <vfs_ramfs_file_write+0x146>
4200a12a:	47b5                	li	a5,13
4200a12c:	00fa2223          	sw	a5,4(s4)
4200a130:	478d                	li	a5,3
4200a132:	00fa2023          	sw	a5,0(s4)
4200a136:	4462                	lw	s0,24(sp)
4200a138:	44d2                	lw	s1,20(sp)
4200a13a:	4942                	lw	s2,16(sp)
4200a13c:	49b2                	lw	s3,12(sp)
4200a13e:	4a92                	lw	s5,4(sp)
}
4200a140:	40f2                	lw	ra,28(sp)
4200a142:	4a22                	lw	s4,8(sp)
4200a144:	6105                	add	sp,sp,32
4200a146:	8082                	ret
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
4200a148:	dd65                	beqz	a0,4200a140 <vfs_ramfs_file_write+0xf8>
4200a14a:	420175b7          	lui	a1,0x42017
4200a14e:	468d                	li	a3,3
4200a150:	4635                	li	a2,13
4200a152:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200a156:	4511                	li	a0,4
4200a158:	00000717          	auipc	a4,0x0
4200a15c:	93ef90ef          	jal	4200329a <logkf>
4200a160:	003a7793          	and	a5,s4,3
4200a164:	e795                	bnez	a5,4200a190 <vfs_ramfs_file_write+0x148>
4200a166:	57f1                	li	a5,-4
4200a168:	02fa7463          	bgeu	s4,a5,4200a190 <vfs_ramfs_file_write+0x148>
}
4200a16c:	40f2                	lw	ra,28(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
4200a16e:	47b5                	li	a5,13
4200a170:	00fa2223          	sw	a5,4(s4)
4200a174:	478d                	li	a5,3
4200a176:	00fa2023          	sw	a5,0(s4)
}
4200a17a:	4a22                	lw	s4,8(sp)
4200a17c:	6105                	add	sp,sp,32
4200a17e:	8082                	ret
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
4200a180:	420195b7          	lui	a1,0x42019
4200a184:	99058593          	add	a1,a1,-1648 # 42018990 <hextab+0x1cc4>
4200a188:	8ccf90ef          	jal	42003254 <logk>
4200a18c:	9002                	ebreak
    mem_copy(iptr->buf + offset, writebuf, writelen);
4200a18e:	9002                	ebreak
4200a190:	cc22                	sw	s0,24(sp)
4200a192:	ca26                	sw	s1,20(sp)
4200a194:	c84a                	sw	s2,16(sp)
4200a196:	c64e                	sw	s3,12(sp)
4200a198:	c256                	sw	s5,4(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
4200a19a:	9002                	ebreak

4200a19c <vfs_ramfs_file_resize>:

// Change the length of a file opened by `vfs_ramfs_file_open`.
void vfs_ramfs_file_resize(badge_err_t *ec, vfs_t *vfs, vfs_file_shared_t *file, fileoff_t new_size) {
4200a19c:	1101                	add	sp,sp,-32
4200a19e:	c64e                	sw	s3,12(sp)
4200a1a0:	ce06                	sw	ra,28(sp)
4200a1a2:	89aa                	mv	s3,a0
    if (new_size < 0) {
4200a1a4:	0806c163          	bltz	a3,4200a226 <vfs_ramfs_file_resize+0x8a>
4200a1a8:	cc22                	sw	s0,24(sp)
4200a1aa:	ca26                	sw	s1,20(sp)
4200a1ac:	c84a                	sw	s2,16(sp)
4200a1ae:	c452                	sw	s4,8(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
        return;
    }
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
4200a1b0:	0e058763          	beqz	a1,4200a29e <vfs_ramfs_file_resize+0x102>
4200a1b4:	0035f793          	and	a5,a1,3
4200a1b8:	e3fd                	bnez	a5,4200a29e <vfs_ramfs_file_resize+0x102>
4200a1ba:	fd800793          	li	a5,-40
4200a1be:	0ef5f063          	bgeu	a1,a5,4200a29e <vfs_ramfs_file_resize+0x102>
4200a1c2:	84b2                	mv	s1,a2
4200a1c4:	02858913          	add	s2,a1,40
4200a1c8:	0016e637          	lui	a2,0x16e
4200a1cc:	8436                	mv	s0,a3
4200a1ce:	36060613          	add	a2,a2,864 # 16e360 <__stack_size+0x16c360>
4200a1d2:	4681                	li	a3,0
4200a1d4:	85ca                	mv	a1,s2
4200a1d6:	4501                	li	a0,0
4200a1d8:	c9af90ef          	jal	42003672 <mutex_acquire>
4200a1dc:	c945                	beqz	a0,4200a28c <vfs_ramfs_file_resize+0xf0>

    // Attempt to resize the buffer.
    vfs_ramfs_inode_t *iptr     = file->ramfs_file;
4200a1de:	c0e1                	beqz	s1,4200a29e <vfs_ramfs_file_resize+0x102>
4200a1e0:	0034f793          	and	a5,s1,3
4200a1e4:	efcd                	bnez	a5,4200a29e <vfs_ramfs_file_resize+0x102>
4200a1e6:	57d1                	li	a5,-12
4200a1e8:	0af4fb63          	bgeu	s1,a5,4200a29e <vfs_ramfs_file_resize+0x102>
4200a1ec:	00c4aa03          	lw	s4,12(s1)
    fileoff_t          old_size = (fileoff_t)iptr->len;
4200a1f0:	0a0a0763          	beqz	s4,4200a29e <vfs_ramfs_file_resize+0x102>
4200a1f4:	003a7793          	and	a5,s4,3
4200a1f8:	e3dd                	bnez	a5,4200a29e <vfs_ramfs_file_resize+0x102>
    if (resize_inode(ec, vfs, iptr, new_size)) {
4200a1fa:	854e                	mv	a0,s3
4200a1fc:	8622                	mv	a2,s0
4200a1fe:	85d2                	mv	a1,s4
    fileoff_t          old_size = (fileoff_t)iptr->len;
4200a200:	000a2983          	lw	s3,0(s4)
    if (resize_inode(ec, vfs, iptr, new_size)) {
4200a204:	a91fe0ef          	jal	42008c94 <resize_inode.isra.0>
4200a208:	c501                	beqz	a0,4200a210 <vfs_ramfs_file_resize+0x74>
        file->size = new_size;
4200a20a:	c480                	sw	s0,8(s1)
        if (new_size > old_size) {
4200a20c:	0489c963          	blt	s3,s0,4200a25e <vfs_ramfs_file_resize+0xc2>
            // Zero out new bits.
            mem_set(iptr->buf + old_size, 0, new_size - old_size);
        }
    }

    mutex_release(NULL, &vfs->ramfs.mtx);
4200a210:	4462                	lw	s0,24(sp)
4200a212:	44d2                	lw	s1,20(sp)
4200a214:	4a22                	lw	s4,8(sp)
}
4200a216:	40f2                	lw	ra,28(sp)
4200a218:	49b2                	lw	s3,12(sp)
    mutex_release(NULL, &vfs->ramfs.mtx);
4200a21a:	85ca                	mv	a1,s2
4200a21c:	4942                	lw	s2,16(sp)
4200a21e:	4501                	li	a0,0
}
4200a220:	6105                	add	sp,sp,32
    mutex_release(NULL, &vfs->ramfs.mtx);
4200a222:	de2f906f          	j	42003804 <mutex_release>
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
4200a226:	c905                	beqz	a0,4200a256 <vfs_ramfs_file_resize+0xba>
4200a228:	420175b7          	lui	a1,0x42017
4200a22c:	468d                	li	a3,3
4200a22e:	4635                	li	a2,13
4200a230:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200a234:	4511                	li	a0,4
4200a236:	00000717          	auipc	a4,0x0
4200a23a:	860f90ef          	jal	4200329a <logkf>
4200a23e:	0039f793          	and	a5,s3,3
4200a242:	efb9                	bnez	a5,4200a2a0 <vfs_ramfs_file_resize+0x104>
4200a244:	57f1                	li	a5,-4
4200a246:	04f9fd63          	bgeu	s3,a5,4200a2a0 <vfs_ramfs_file_resize+0x104>
4200a24a:	47b5                	li	a5,13
4200a24c:	00f9a223          	sw	a5,4(s3)
4200a250:	478d                	li	a5,3
4200a252:	00f9a023          	sw	a5,0(s3)
}
4200a256:	40f2                	lw	ra,28(sp)
4200a258:	49b2                	lw	s3,12(sp)
4200a25a:	6105                	add	sp,sp,32
4200a25c:	8082                	ret
            mem_set(iptr->buf + old_size, 0, new_size - old_size);
4200a25e:	57e1                	li	a5,-8
4200a260:	02fa7f63          	bgeu	s4,a5,4200a29e <vfs_ramfs_file_resize+0x102>
4200a264:	008a2783          	lw	a5,8(s4)
4200a268:	01378533          	add	a0,a5,s3
4200a26c:	0209d763          	bgez	s3,4200a29a <vfs_ramfs_file_resize+0xfe>
4200a270:	02a7e763          	bltu	a5,a0,4200a29e <vfs_ramfs_file_resize+0x102>
4200a274:	41340633          	sub	a2,s0,s3
4200a278:	00c42433          	slt	s0,s0,a2
4200a27c:	0009a993          	slti	s3,s3,0
4200a280:	00899f63          	bne	s3,s0,4200a29e <vfs_ramfs_file_resize+0x102>
4200a284:	4581                	li	a1,0
4200a286:	dc6f80ef          	jal	4200284c <mem_set>
4200a28a:	b759                	j	4200a210 <vfs_ramfs_file_resize+0x74>
    assert_always(mutex_acquire(NULL, &vfs->ramfs.mtx, VFS_MUTEX_TIMEOUT));
4200a28c:	420195b7          	lui	a1,0x42019
4200a290:	a3058593          	add	a1,a1,-1488 # 42018a30 <hextab+0x1d64>
4200a294:	fc1f80ef          	jal	42003254 <logk>
4200a298:	9002                	ebreak
            mem_set(iptr->buf + old_size, 0, new_size - old_size);
4200a29a:	fcf57de3          	bgeu	a0,a5,4200a274 <vfs_ramfs_file_resize+0xd8>
4200a29e:	9002                	ebreak
4200a2a0:	cc22                	sw	s0,24(sp)
4200a2a2:	ca26                	sw	s1,20(sp)
4200a2a4:	c84a                	sw	s2,16(sp)
4200a2a6:	c452                	sw	s4,8(sp)
        badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_RANGE);
4200a2a8:	9002                	ebreak

4200a2aa <vfs_ramfs_flush>:
// Commit all pending writes to disk.
// The filesystem, if it does caching, must always sync everything to disk at once.
void vfs_ramfs_flush(badge_err_t *ec, vfs_t *vfs) {
    // RAMFS does not do caching, so flush does nothing.
    (void)vfs;
    badge_err_set_ok(ec);
4200a2aa:	c919                	beqz	a0,4200a2c0 <vfs_ramfs_flush+0x16>
4200a2ac:	00357793          	and	a5,a0,3
4200a2b0:	eb89                	bnez	a5,4200a2c2 <vfs_ramfs_flush+0x18>
4200a2b2:	57f1                	li	a5,-4
4200a2b4:	00f57763          	bgeu	a0,a5,4200a2c2 <vfs_ramfs_flush+0x18>
4200a2b8:	00052223          	sw	zero,4(a0)
4200a2bc:	00052023          	sw	zero,0(a0)
}
4200a2c0:	8082                	ret
    badge_err_set_ok(ec);
4200a2c2:	9002                	ebreak

4200a2c4 <vfs_file_shared_splice>:
}

// Splice a shared file handle out of the list.
static void vfs_file_shared_splice(ptrdiff_t i) {
    // Remove an entry.
    vfs_file_shared_list_len--;
4200a2c4:	4080a737          	lui	a4,0x4080a
4200a2c8:	e3472783          	lw	a5,-460(a4) # 40809e34 <vfs_file_shared_list_len>
4200a2cc:	17fd                	add	a5,a5,-1
4200a2ce:	e2f72a23          	sw	a5,-460(a4)
    if (vfs_file_shared_list_len) {
4200a2d2:	cf95                	beqz	a5,4200a30e <vfs_file_shared_splice+0x4a>
        vfs_file_shared_list[i] = vfs_file_shared_list[vfs_file_shared_list_len];
4200a2d4:	4080a737          	lui	a4,0x4080a
4200a2d8:	e3872703          	lw	a4,-456(a4) # 40809e38 <vfs_file_shared_list>
4200a2dc:	00279693          	sll	a3,a5,0x2
4200a2e0:	00d70633          	add	a2,a4,a3
4200a2e4:	0606df63          	bgez	a3,4200a362 <vfs_file_shared_splice+0x9e>
4200a2e8:	06c76f63          	bltu	a4,a2,4200a366 <vfs_file_shared_splice+0xa2>
4200a2ec:	050a                	sll	a0,a0,0x2
4200a2ee:	00a706b3          	add	a3,a4,a0
4200a2f2:	06055563          	bgez	a0,4200a35c <vfs_file_shared_splice+0x98>
4200a2f6:	06d76563          	bltu	a4,a3,4200a360 <vfs_file_shared_splice+0x9c>
4200a2fa:	ca3d                	beqz	a2,4200a370 <vfs_file_shared_splice+0xac>
4200a2fc:	00367713          	and	a4,a2,3
4200a300:	eb25                	bnez	a4,4200a370 <vfs_file_shared_splice+0xac>
4200a302:	4218                	lw	a4,0(a2)
4200a304:	c6ad                	beqz	a3,4200a36e <vfs_file_shared_splice+0xaa>
4200a306:	0036f613          	and	a2,a3,3
4200a30a:	e235                	bnez	a2,4200a36e <vfs_file_shared_splice+0xaa>
4200a30c:	c298                	sw	a4,0(a3)
static void vfs_file_shared_splice(ptrdiff_t i) {
4200a30e:	1141                	add	sp,sp,-16
4200a310:	c226                	sw	s1,4(sp)
    }

    if (vfs_file_shared_list_cap > vfs_file_shared_list_len * 2) {
4200a312:	4080a4b7          	lui	s1,0x4080a
4200a316:	e304a703          	lw	a4,-464(s1) # 40809e30 <vfs_file_shared_list_cap>
static void vfs_file_shared_splice(ptrdiff_t i) {
4200a31a:	c606                	sw	ra,12(sp)
    if (vfs_file_shared_list_cap > vfs_file_shared_list_len * 2) {
4200a31c:	0786                	sll	a5,a5,0x1
4200a31e:	02e7f863          	bgeu	a5,a4,4200a34e <vfs_file_shared_splice+0x8a>
4200a322:	c422                	sw	s0,8(sp)
4200a324:	c04a                	sw	s2,0(sp)
        // Shrink the array.
        size_t new_cap = vfs_file_shared_list_cap / 2;
        if (new_cap < 2)
4200a326:	478d                	li	a5,3
4200a328:	02e7f763          	bgeu	a5,a4,4200a356 <vfs_file_shared_splice+0x92>
        size_t new_cap = vfs_file_shared_list_cap / 2;
4200a32c:	00175413          	srl	s0,a4,0x1
            new_cap = 2;
        void *mem = realloc(vfs_file_shared_list, sizeof(vfs_file_shared_t *) * new_cap);
4200a330:	00241593          	sll	a1,s0,0x2
4200a334:	4080a937          	lui	s2,0x4080a
4200a338:	e3892503          	lw	a0,-456(s2) # 40809e38 <vfs_file_shared_list>
4200a33c:	097030ef          	jal	4200dbd2 <realloc>
        if (!mem)
4200a340:	c505                	beqz	a0,4200a368 <vfs_file_shared_splice+0xa4>
            return;
        vfs_file_shared_list     = mem;
4200a342:	e2a92c23          	sw	a0,-456(s2)
        vfs_file_shared_list_cap = new_cap;
4200a346:	e284a823          	sw	s0,-464(s1)
4200a34a:	4902                	lw	s2,0(sp)
4200a34c:	4422                	lw	s0,8(sp)
    }
}
4200a34e:	40b2                	lw	ra,12(sp)
4200a350:	4492                	lw	s1,4(sp)
4200a352:	0141                	add	sp,sp,16
4200a354:	8082                	ret
4200a356:	45a1                	li	a1,8
            new_cap = 2;
4200a358:	4409                	li	s0,2
4200a35a:	bfe9                	j	4200a334 <vfs_file_shared_splice+0x70>
        vfs_file_shared_list[i] = vfs_file_shared_list[vfs_file_shared_list_len];
4200a35c:	f8e6ffe3          	bgeu	a3,a4,4200a2fa <vfs_file_shared_splice+0x36>
4200a360:	9002                	ebreak
4200a362:	f8e675e3          	bgeu	a2,a4,4200a2ec <vfs_file_shared_splice+0x28>
4200a366:	9002                	ebreak
4200a368:	4422                	lw	s0,8(sp)
4200a36a:	4902                	lw	s2,0(sp)
4200a36c:	b7cd                	j	4200a34e <vfs_file_shared_splice+0x8a>
4200a36e:	9002                	ebreak
4200a370:	9002                	ebreak

4200a372 <vfs_shared_by_inode>:
    }
}

// Find a shared file handle by inode, if any.
ptrdiff_t vfs_shared_by_inode(vfs_t *vfs, inode_t inode) {
    for (size_t i = 0; i < vfs_file_shared_list_len; i++) {
4200a372:	4080a7b7          	lui	a5,0x4080a
4200a376:	e347ae03          	lw	t3,-460(a5) # 40809e34 <vfs_file_shared_list_len>
4200a37a:	040e0663          	beqz	t3,4200a3c6 <vfs_shared_by_inode+0x54>
        if (vfs_file_shared_list[i]->vfs == vfs && vfs_file_shared_list[i]->inode == inode) {
4200a37e:	4080a7b7          	lui	a5,0x4080a
4200a382:	e387a803          	lw	a6,-456(a5) # 40809e38 <vfs_file_shared_list>
    for (size_t i = 0; i < vfs_file_shared_list_len; i++) {
4200a386:	4681                	li	a3,0
        if (vfs_file_shared_list[i]->vfs == vfs && vfs_file_shared_list[i]->inode == inode) {
4200a388:	fdc00e93          	li	t4,-36
4200a38c:	8742                	mv	a4,a6
4200a38e:	00269613          	sll	a2,a3,0x2
4200a392:	00c808b3          	add	a7,a6,a2
4200a396:	02064a63          	bltz	a2,4200a3ca <vfs_shared_by_inode+0x58>
4200a39a:	0308ea63          	bltu	a7,a6,4200a3ce <vfs_shared_by_inode+0x5c>
4200a39e:	cb05                	beqz	a4,4200a3ce <vfs_shared_by_inode+0x5c>
4200a3a0:	00377793          	and	a5,a4,3
4200a3a4:	e78d                	bnez	a5,4200a3ce <vfs_shared_by_inode+0x5c>
4200a3a6:	431c                	lw	a5,0(a4)
4200a3a8:	c39d                	beqz	a5,4200a3ce <vfs_shared_by_inode+0x5c>
4200a3aa:	0037f313          	and	t1,a5,3
4200a3ae:	02031063          	bnez	t1,4200a3ce <vfs_shared_by_inode+0x5c>
4200a3b2:	01d7fe63          	bgeu	a5,t4,4200a3ce <vfs_shared_by_inode+0x5c>
4200a3b6:	0247a303          	lw	t1,36(a5)
4200a3ba:	00a30b63          	beq	t1,a0,4200a3d0 <vfs_shared_by_inode+0x5e>
    for (size_t i = 0; i < vfs_file_shared_list_len; i++) {
4200a3be:	0685                	add	a3,a3,1
4200a3c0:	0711                	add	a4,a4,4
4200a3c2:	fdc696e3          	bne	a3,t3,4200a38e <vfs_shared_by_inode+0x1c>
            return (ptrdiff_t)i;
        }
    }
    return -1;
4200a3c6:	557d                	li	a0,-1
4200a3c8:	8082                	ret
        if (vfs_file_shared_list[i]->vfs == vfs && vfs_file_shared_list[i]->inode == inode) {
4200a3ca:	fd187ae3          	bgeu	a6,a7,4200a39e <vfs_shared_by_inode+0x2c>
4200a3ce:	9002                	ebreak
4200a3d0:	00064963          	bltz	a2,4200a3e2 <vfs_shared_by_inode+0x70>
4200a3d4:	ff08ede3          	bltu	a7,a6,4200a3ce <vfs_shared_by_inode+0x5c>
4200a3d8:	539c                	lw	a5,32(a5)
4200a3da:	feb792e3          	bne	a5,a1,4200a3be <vfs_shared_by_inode+0x4c>
            return (ptrdiff_t)i;
4200a3de:	8536                	mv	a0,a3
}
4200a3e0:	8082                	ret
        if (vfs_file_shared_list[i]->vfs == vfs && vfs_file_shared_list[i]->inode == inode) {
4200a3e2:	ff187be3          	bgeu	a6,a7,4200a3d8 <vfs_shared_by_inode+0x66>
4200a3e6:	9002                	ebreak

4200a3e8 <vfs_file_by_handle>:

// Get a file handle by number.
ptrdiff_t vfs_file_by_handle(file_t fileno) {
    for (size_t i = 0; i < vfs_file_handle_list_len; i++) {
4200a3e8:	4080a7b7          	lui	a5,0x4080a
4200a3ec:	e287a803          	lw	a6,-472(a5) # 40809e28 <vfs_file_handle_list_len>
4200a3f0:	04080063          	beqz	a6,4200a430 <vfs_file_by_handle+0x48>
        if (vfs_file_handle_list[i].fileno == fileno) {
4200a3f4:	4080a7b7          	lui	a5,0x4080a
4200a3f8:	e2c7a603          	lw	a2,-468(a5) # 40809e2c <vfs_file_handle_list>
4200a3fc:	4701                	li	a4,0
    for (size_t i = 0; i < vfs_file_handle_list_len; i++) {
4200a3fe:	4681                	li	a3,0
4200a400:	87b2                	mv	a5,a2
        if (vfs_file_handle_list[i].fileno == fileno) {
4200a402:	5881                	li	a7,-32
4200a404:	00e605b3          	add	a1,a2,a4
4200a408:	02074663          	bltz	a4,4200a434 <vfs_file_by_handle+0x4c>
4200a40c:	02c5e663          	bltu	a1,a2,4200a438 <vfs_file_by_handle+0x50>
4200a410:	c785                	beqz	a5,4200a438 <vfs_file_by_handle+0x50>
4200a412:	0037f593          	and	a1,a5,3
4200a416:	e18d                	bnez	a1,4200a438 <vfs_file_by_handle+0x50>
4200a418:	0317f063          	bgeu	a5,a7,4200a438 <vfs_file_by_handle+0x50>
4200a41c:	538c                	lw	a1,32(a5)
4200a41e:	00a58e63          	beq	a1,a0,4200a43a <vfs_file_by_handle+0x52>
    for (size_t i = 0; i < vfs_file_handle_list_len; i++) {
4200a422:	0685                	add	a3,a3,1
4200a424:	02470713          	add	a4,a4,36
4200a428:	02478793          	add	a5,a5,36
4200a42c:	fd069ce3          	bne	a3,a6,4200a404 <vfs_file_by_handle+0x1c>
            return (ptrdiff_t)i;
        }
    }
    return -1;
4200a430:	557d                	li	a0,-1
4200a432:	8082                	ret
        if (vfs_file_handle_list[i].fileno == fileno) {
4200a434:	fcb67ee3          	bgeu	a2,a1,4200a410 <vfs_file_by_handle+0x28>
4200a438:	9002                	ebreak
            return (ptrdiff_t)i;
4200a43a:	8536                	mv	a0,a3
}
4200a43c:	8082                	ret

4200a43e <vfs_file_create_shared>:

// Create a new empty shared file handle.
ptrdiff_t vfs_file_create_shared() {
4200a43e:	1101                	add	sp,sp,-32
4200a440:	ca26                	sw	s1,20(sp)
4200a442:	c84a                	sw	s2,16(sp)
    if (vfs_file_shared_list_len >= vfs_file_shared_list_cap) {
4200a444:	4080a4b7          	lui	s1,0x4080a
4200a448:	4080a937          	lui	s2,0x4080a
4200a44c:	e344a783          	lw	a5,-460(s1) # 40809e34 <vfs_file_shared_list_len>
4200a450:	e3092703          	lw	a4,-464(s2) # 40809e30 <vfs_file_shared_list_cap>
ptrdiff_t vfs_file_create_shared() {
4200a454:	ce06                	sw	ra,28(sp)
4200a456:	cc22                	sw	s0,24(sp)
    if (vfs_file_shared_list_len >= vfs_file_shared_list_cap) {
4200a458:	02e7e863          	bltu	a5,a4,4200a488 <vfs_file_create_shared+0x4a>
4200a45c:	c64e                	sw	s3,12(sp)
        // Expand list.
        size_t new_cap = vfs_file_shared_list_cap * 2;
4200a45e:	00171413          	sll	s0,a4,0x1
        if (new_cap < 2)
4200a462:	4789                	li	a5,2
4200a464:	0af46463          	bltu	s0,a5,4200a50c <vfs_file_create_shared+0xce>
            new_cap = 2;
        void *mem = realloc(vfs_file_shared_list, sizeof(vfs_file_shared_t *) * new_cap);
4200a468:	4080a9b7          	lui	s3,0x4080a
4200a46c:	e389a503          	lw	a0,-456(s3) # 40809e38 <vfs_file_shared_list>
4200a470:	00241593          	sll	a1,s0,0x2
4200a474:	75e030ef          	jal	4200dbd2 <realloc>
        if (!mem)
4200a478:	c545                	beqz	a0,4200a520 <vfs_file_create_shared+0xe2>
            return -1;
        vfs_file_shared_list     = mem;
4200a47a:	e2a9ac23          	sw	a0,-456(s3)
        vfs_file_shared_list_cap = new_cap;
    }

    // Allocate new shared handle.
    ptrdiff_t          shared = (ptrdiff_t)vfs_file_shared_list_len;
4200a47e:	e344a783          	lw	a5,-460(s1)
        vfs_file_shared_list_cap = new_cap;
4200a482:	49b2                	lw	s3,12(sp)
4200a484:	e2892823          	sw	s0,-464(s2)
    vfs_file_shared_t *shptr  = malloc(sizeof(vfs_file_shared_t));
4200a488:	02800513          	li	a0,40
    ptrdiff_t          shared = (ptrdiff_t)vfs_file_shared_list_len;
4200a48c:	843e                	mv	s0,a5
    vfs_file_shared_t *shptr  = malloc(sizeof(vfs_file_shared_t));
4200a48e:	4c2030ef          	jal	4200d950 <malloc>
    if (!shptr)
4200a492:	c941                	beqz	a0,4200a522 <vfs_file_create_shared+0xe4>
        return -1;
    *shptr = (vfs_file_shared_t){
4200a494:	00357793          	and	a5,a0,3
4200a498:	eba5                	bnez	a5,4200a508 <vfs_file_create_shared+0xca>
4200a49a:	00052023          	sw	zero,0(a0)
4200a49e:	00052223          	sw	zero,4(a0)
4200a4a2:	00052423          	sw	zero,8(a0)
4200a4a6:	00052623          	sw	zero,12(a0)
4200a4aa:	00052823          	sw	zero,16(a0)
4200a4ae:	00052a23          	sw	zero,20(a0)
4200a4b2:	00052c23          	sw	zero,24(a0)
4200a4b6:	00052e23          	sw	zero,28(a0)
4200a4ba:	02052023          	sw	zero,32(a0)
4200a4be:	02052223          	sw	zero,36(a0)
4200a4c2:	57f1                	li	a5,-4
4200a4c4:	04f57263          	bgeu	a0,a5,4200a508 <vfs_file_create_shared+0xca>
        .index    = shared,
        .size     = 0,
        .inode    = 0,
        .vfs      = NULL,
    };
    vfs_file_shared_list[vfs_file_shared_list_len] = shptr;
4200a4c8:	4080a7b7          	lui	a5,0x4080a
4200a4cc:	e344a703          	lw	a4,-460(s1)
4200a4d0:	e387a683          	lw	a3,-456(a5) # 40809e38 <vfs_file_shared_list>
    *shptr = (vfs_file_shared_t){
4200a4d4:	c140                	sw	s0,4(a0)
    vfs_file_shared_list[vfs_file_shared_list_len] = shptr;
4200a4d6:	00271613          	sll	a2,a4,0x2
4200a4da:	00c687b3          	add	a5,a3,a2
4200a4de:	02065363          	bgez	a2,4200a504 <vfs_file_create_shared+0xc6>
4200a4e2:	02f6e363          	bltu	a3,a5,4200a508 <vfs_file_create_shared+0xca>
4200a4e6:	c38d                	beqz	a5,4200a508 <vfs_file_create_shared+0xca>
4200a4e8:	0037f693          	and	a3,a5,3
4200a4ec:	ee91                	bnez	a3,4200a508 <vfs_file_create_shared+0xca>
4200a4ee:	c388                	sw	a0,0(a5)
    vfs_file_shared_list_len++;
4200a4f0:	0705                	add	a4,a4,1
4200a4f2:	e2e4aa23          	sw	a4,-460(s1)

    return shared;
}
4200a4f6:	40f2                	lw	ra,28(sp)
4200a4f8:	8522                	mv	a0,s0
4200a4fa:	4462                	lw	s0,24(sp)
4200a4fc:	44d2                	lw	s1,20(sp)
4200a4fe:	4942                	lw	s2,16(sp)
4200a500:	6105                	add	sp,sp,32
4200a502:	8082                	ret
    vfs_file_shared_list[vfs_file_shared_list_len] = shptr;
4200a504:	fed7f1e3          	bgeu	a5,a3,4200a4e6 <vfs_file_create_shared+0xa8>
4200a508:	c64e                	sw	s3,12(sp)
4200a50a:	9002                	ebreak
        void *mem = realloc(vfs_file_shared_list, sizeof(vfs_file_shared_t *) * new_cap);
4200a50c:	4080a9b7          	lui	s3,0x4080a
4200a510:	e389a503          	lw	a0,-456(s3) # 40809e38 <vfs_file_shared_list>
        if (new_cap < 2)
4200a514:	4409                	li	s0,2
        void *mem = realloc(vfs_file_shared_list, sizeof(vfs_file_shared_t *) * new_cap);
4200a516:	00241593          	sll	a1,s0,0x2
4200a51a:	6b8030ef          	jal	4200dbd2 <realloc>
        if (!mem)
4200a51e:	fd31                	bnez	a0,4200a47a <vfs_file_create_shared+0x3c>
4200a520:	49b2                	lw	s3,12(sp)
            return -1;
4200a522:	547d                	li	s0,-1
4200a524:	bfc9                	j	4200a4f6 <vfs_file_create_shared+0xb8>

4200a526 <vfs_file_create_handle>:

// Create a new file handle.
// If `shared` is -1, a new empty shared handle is created.
ptrdiff_t vfs_file_create_handle(ptrdiff_t shared) {
4200a526:	1101                	add	sp,sp,-32
4200a528:	cc22                	sw	s0,24(sp)
4200a52a:	ce06                	sw	ra,28(sp)
    if (shared == -1) {
4200a52c:	57fd                	li	a5,-1
4200a52e:	842a                	mv	s0,a0
4200a530:	10f50563          	beq	a0,a5,4200a63a <vfs_file_create_handle+0x114>
        // Allocate new shared handle.
        shared = vfs_file_create_shared();
    }
    if (shared < 0) {
4200a534:	10044b63          	bltz	s0,4200a64a <vfs_file_create_handle+0x124>
4200a538:	c84a                	sw	s2,16(sp)
4200a53a:	c64e                	sw	s3,12(sp)
        // Failed to allocate or illegal argument.
        return -1;
    }

    if (vfs_file_handle_list_len >= vfs_file_handle_list_cap) {
4200a53c:	4080a937          	lui	s2,0x4080a
4200a540:	4080a9b7          	lui	s3,0x4080a
4200a544:	ca26                	sw	s1,20(sp)
4200a546:	e2892783          	lw	a5,-472(s2) # 40809e28 <vfs_file_handle_list_len>
4200a54a:	e249a483          	lw	s1,-476(s3) # 40809e24 <vfs_file_handle_list_cap>
4200a54e:	c452                	sw	s4,8(sp)
        // Expand list.
        size_t new_cap = vfs_file_handle_list_cap * 2;
        if (new_cap < 2)
            new_cap = 2;
        void *mem = realloc(vfs_file_handle_list, sizeof(*vfs_file_handle_list) * new_cap);
4200a550:	4080aa37          	lui	s4,0x4080a
4200a554:	e2ca2683          	lw	a3,-468(s4) # 40809e2c <vfs_file_handle_list>
    if (vfs_file_handle_list_len >= vfs_file_handle_list_cap) {
4200a558:	0297e663          	bltu	a5,s1,4200a584 <vfs_file_create_handle+0x5e>
        size_t new_cap = vfs_file_handle_list_cap * 2;
4200a55c:	0486                	sll	s1,s1,0x1
        if (new_cap < 2)
4200a55e:	4789                	li	a5,2
4200a560:	00f4f363          	bgeu	s1,a5,4200a566 <vfs_file_create_handle+0x40>
4200a564:	4489                	li	s1,2
        void *mem = realloc(vfs_file_handle_list, sizeof(*vfs_file_handle_list) * new_cap);
4200a566:	00349593          	sll	a1,s1,0x3
4200a56a:	95a6                	add	a1,a1,s1
4200a56c:	8536                	mv	a0,a3
4200a56e:	058a                	sll	a1,a1,0x2
4200a570:	662030ef          	jal	4200dbd2 <realloc>
4200a574:	86aa                	mv	a3,a0
        if (!mem)
4200a576:	c571                	beqz	a0,4200a642 <vfs_file_create_handle+0x11c>
        vfs_file_handle_list     = mem;
        vfs_file_handle_list_cap = new_cap;
    }

    // Allocate new handle.
    ptrdiff_t handle = (ptrdiff_t)vfs_file_handle_list_len;
4200a578:	e2892783          	lw	a5,-472(s2)
        vfs_file_handle_list     = mem;
4200a57c:	e2aa2623          	sw	a0,-468(s4)
        vfs_file_handle_list_cap = new_cap;
4200a580:	e299a223          	sw	s1,-476(s3)
    ptrdiff_t handle = (ptrdiff_t)vfs_file_handle_list_len;
4200a584:	853e                	mv	a0,a5
    vfs_file_handle_list_len++;
    vfs_file_handle_list[handle] = (vfs_file_handle_t){
4200a586:	00379713          	sll	a4,a5,0x3
4200a58a:	972a                	add	a4,a4,a0
    vfs_file_handle_list_len++;
4200a58c:	0785                	add	a5,a5,1
    vfs_file_handle_list[handle] = (vfs_file_handle_t){
4200a58e:	070a                	sll	a4,a4,0x2
    vfs_file_handle_list_len++;
4200a590:	e2f92423          	sw	a5,-472(s2)
    vfs_file_handle_list[handle] = (vfs_file_handle_t){
4200a594:	00e687b3          	add	a5,a3,a4
4200a598:	08075e63          	bgez	a4,4200a634 <vfs_file_create_handle+0x10e>
4200a59c:	08f6eb63          	bltu	a3,a5,4200a632 <vfs_file_create_handle+0x10c>
        .offset = 0,
        .shared = vfs_file_shared_list[shared],
4200a5a0:	4080a737          	lui	a4,0x4080a
4200a5a4:	e3872683          	lw	a3,-456(a4) # 40809e38 <vfs_file_shared_list>
4200a5a8:	040a                	sll	s0,s0,0x2
4200a5aa:	00868733          	add	a4,a3,s0
4200a5ae:	08045063          	bgez	s0,4200a62e <vfs_file_create_handle+0x108>
4200a5b2:	08e6e063          	bltu	a3,a4,4200a632 <vfs_file_create_handle+0x10c>
4200a5b6:	cf35                	beqz	a4,4200a632 <vfs_file_create_handle+0x10c>
4200a5b8:	00377693          	and	a3,a4,3
4200a5bc:	eabd                	bnez	a3,4200a632 <vfs_file_create_handle+0x10c>
4200a5be:	4310                	lw	a2,0(a4)
    return atomic_fetch_add(&vfs_handle_no, 1);
4200a5c0:	4080a737          	lui	a4,0x4080a
4200a5c4:	4585                	li	a1,1
4200a5c6:	e2070713          	add	a4,a4,-480 # 40809e20 <__stack_top>
4200a5ca:	0f50000f          	fence	iorw,ow
4200a5ce:	04b726af          	amoadd.w.aq	a3,a1,(a4)
    vfs_file_handle_list[handle] = (vfs_file_handle_t){
4200a5d2:	c3a5                	beqz	a5,4200a632 <vfs_file_create_handle+0x10c>
4200a5d4:	0037f713          	and	a4,a5,3
4200a5d8:	ef29                	bnez	a4,4200a632 <vfs_file_create_handle+0x10c>
4200a5da:	0007a023          	sw	zero,0(a5)
4200a5de:	0007a223          	sw	zero,4(a5)
4200a5e2:	0007a423          	sw	zero,8(a5)
4200a5e6:	0007a623          	sw	zero,12(a5)
4200a5ea:	0007a823          	sw	zero,16(a5)
4200a5ee:	0007aa23          	sw	zero,20(a5)
4200a5f2:	0007ac23          	sw	zero,24(a5)
4200a5f6:	0007ae23          	sw	zero,28(a5)
4200a5fa:	0207a023          	sw	zero,32(a5)
4200a5fe:	5761                	li	a4,-8
4200a600:	02e7f963          	bgeu	a5,a4,4200a632 <vfs_file_create_handle+0x10c>
4200a604:	cafec737          	lui	a4,0xcafec
4200a608:	abe70713          	add	a4,a4,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
4200a60c:	c798                	sw	a4,8(a5)
4200a60e:	5711                	li	a4,-28
4200a610:	02e7f163          	bgeu	a5,a4,4200a632 <vfs_file_create_handle+0x10c>
4200a614:	cfd0                	sw	a2,28(a5)
4200a616:	5701                	li	a4,-32
4200a618:	00e7fd63          	bgeu	a5,a4,4200a632 <vfs_file_create_handle+0x10c>
4200a61c:	44d2                	lw	s1,20(sp)
4200a61e:	4942                	lw	s2,16(sp)
4200a620:	49b2                	lw	s3,12(sp)
4200a622:	4a22                	lw	s4,8(sp)
4200a624:	d394                	sw	a3,32(a5)
        .fileno = next_fileno(),
        .mutex  = MUTEX_T_INIT,
    };

    return handle;
}
4200a626:	40f2                	lw	ra,28(sp)
4200a628:	4462                	lw	s0,24(sp)
4200a62a:	6105                	add	sp,sp,32
4200a62c:	8082                	ret
        .shared = vfs_file_shared_list[shared],
4200a62e:	f8d774e3          	bgeu	a4,a3,4200a5b6 <vfs_file_create_handle+0x90>
    vfs_file_handle_list[handle] = (vfs_file_handle_t){
4200a632:	9002                	ebreak
4200a634:	f6d7f6e3          	bgeu	a5,a3,4200a5a0 <vfs_file_create_handle+0x7a>
4200a638:	9002                	ebreak
        shared = vfs_file_create_shared();
4200a63a:	e05ff0ef          	jal	4200a43e <vfs_file_create_shared>
4200a63e:	842a                	mv	s0,a0
4200a640:	bdd5                	j	4200a534 <vfs_file_create_handle+0xe>
4200a642:	44d2                	lw	s1,20(sp)
4200a644:	4942                	lw	s2,16(sp)
4200a646:	49b2                	lw	s3,12(sp)
4200a648:	4a22                	lw	s4,8(sp)
        return -1;
4200a64a:	557d                	li	a0,-1
4200a64c:	bfe9                	j	4200a626 <vfs_file_create_handle+0x100>

4200a64e <vfs_file_destroy_shared>:

// Destroy a shared file handle assuming the underlying file is already closed.
void vfs_file_destroy_shared(ptrdiff_t shared) {
    vfs_file_shared_splice(shared);
4200a64e:	c77ff06f          	j	4200a2c4 <vfs_file_shared_splice>

4200a652 <vfs_file_destroy_handle>:
}

// Delete a file handle.
// If this is the last handle referring to one file, the shared handle is closed too.
void vfs_file_destroy_handle(ptrdiff_t handle) {
4200a652:	1101                	add	sp,sp,-32
4200a654:	ce06                	sw	ra,28(sp)
4200a656:	cc22                	sw	s0,24(sp)
4200a658:	ca26                	sw	s1,20(sp)
4200a65a:	c84a                	sw	s2,16(sp)
4200a65c:	c64e                	sw	s3,12(sp)
    assert_dev_drop(handle >= 0 && handle < (ptrdiff_t)vfs_file_handle_list_len);
4200a65e:	10054463          	bltz	a0,4200a766 <vfs_file_destroy_handle+0x114>
4200a662:	4080a9b7          	lui	s3,0x4080a
4200a666:	e289a783          	lw	a5,-472(s3) # 40809e28 <vfs_file_handle_list_len>
4200a66a:	0ef55e63          	bge	a0,a5,4200a766 <vfs_file_destroy_handle+0x114>

    // Drop refcount.
    vfs_file_handle_list[handle].shared->refcount--;
4200a66e:	4080a937          	lui	s2,0x4080a
4200a672:	e2c92683          	lw	a3,-468(s2) # 40809e2c <vfs_file_handle_list>
4200a676:	00351493          	sll	s1,a0,0x3
4200a67a:	94aa                	add	s1,s1,a0
4200a67c:	048a                	sll	s1,s1,0x2
4200a67e:	00968733          	add	a4,a3,s1
4200a682:	0e04dd63          	bgez	s1,4200a77c <vfs_file_destroy_handle+0x12a>
4200a686:	0ee6ea63          	bltu	a3,a4,4200a77a <vfs_file_destroy_handle+0x128>
4200a68a:	cb65                	beqz	a4,4200a77a <vfs_file_destroy_handle+0x128>
4200a68c:	00377613          	and	a2,a4,3
4200a690:	e66d                	bnez	a2,4200a77a <vfs_file_destroy_handle+0x128>
4200a692:	5611                	li	a2,-28
4200a694:	0ec77363          	bgeu	a4,a2,4200a77a <vfs_file_destroy_handle+0x128>
4200a698:	4f50                	lw	a2,28(a4)
4200a69a:	c265                	beqz	a2,4200a77a <vfs_file_destroy_handle+0x128>
4200a69c:	00367593          	and	a1,a2,3
4200a6a0:	ede9                	bnez	a1,4200a77a <vfs_file_destroy_handle+0x128>
4200a6a2:	4200                	lw	s0,0(a2)
4200a6a4:	147d                	add	s0,s0,-1
4200a6a6:	c200                	sw	s0,0(a2)
    if (vfs_file_handle_list[handle].shared->refcount == 0) {
4200a6a8:	0c04d763          	bgez	s1,4200a776 <vfs_file_destroy_handle+0x124>
4200a6ac:	0ce6e763          	bltu	a3,a4,4200a77a <vfs_file_destroy_handle+0x128>
4200a6b0:	cc79                	beqz	s0,4200a78e <vfs_file_destroy_handle+0x13c>
    vfs_file_handle_list_len--;
4200a6b2:	17fd                	add	a5,a5,-1
4200a6b4:	e2f9a423          	sw	a5,-472(s3)
    if (vfs_file_handle_list_len) {
4200a6b8:	c7bd                	beqz	a5,4200a726 <vfs_file_destroy_handle+0xd4>
        vfs_file_handle_list[i] = vfs_file_handle_list[vfs_file_handle_list_len];
4200a6ba:	e2c92603          	lw	a2,-468(s2)
4200a6be:	00379713          	sll	a4,a5,0x3
4200a6c2:	973e                	add	a4,a4,a5
4200a6c4:	070a                	sll	a4,a4,0x2
4200a6c6:	00e606b3          	add	a3,a2,a4
4200a6ca:	0a074f63          	bltz	a4,4200a788 <vfs_file_destroy_handle+0x136>
4200a6ce:	0ac6e663          	bltu	a3,a2,4200a77a <vfs_file_destroy_handle+0x128>
4200a6d2:	00960733          	add	a4,a2,s1
4200a6d6:	0a04c663          	bltz	s1,4200a782 <vfs_file_destroy_handle+0x130>
4200a6da:	0ac76063          	bltu	a4,a2,4200a77a <vfs_file_destroy_handle+0x128>
4200a6de:	cf51                	beqz	a4,4200a77a <vfs_file_destroy_handle+0x128>
4200a6e0:	00377613          	and	a2,a4,3
4200a6e4:	ea59                	bnez	a2,4200a77a <vfs_file_destroy_handle+0x128>
4200a6e6:	cad1                	beqz	a3,4200a77a <vfs_file_destroy_handle+0x128>
4200a6e8:	0036f613          	and	a2,a3,3
4200a6ec:	e659                	bnez	a2,4200a77a <vfs_file_destroy_handle+0x128>
4200a6ee:	0006ae83          	lw	t4,0(a3)
4200a6f2:	0046ae03          	lw	t3,4(a3)
4200a6f6:	0086a303          	lw	t1,8(a3)
4200a6fa:	00c6a883          	lw	a7,12(a3)
4200a6fe:	0106a803          	lw	a6,16(a3)
4200a702:	4ac8                	lw	a0,20(a3)
4200a704:	4e8c                	lw	a1,24(a3)
4200a706:	4ed0                	lw	a2,28(a3)
4200a708:	5294                	lw	a3,32(a3)
4200a70a:	01d72023          	sw	t4,0(a4)
4200a70e:	01c72223          	sw	t3,4(a4)
4200a712:	00672423          	sw	t1,8(a4)
4200a716:	01172623          	sw	a7,12(a4)
4200a71a:	01072823          	sw	a6,16(a4)
4200a71e:	cb48                	sw	a0,20(a4)
4200a720:	cf0c                	sw	a1,24(a4)
4200a722:	cf50                	sw	a2,28(a4)
4200a724:	d314                	sw	a3,32(a4)
    if (vfs_file_handle_list_cap > vfs_file_handle_list_len * 2) {
4200a726:	4080a4b7          	lui	s1,0x4080a
4200a72a:	e244a703          	lw	a4,-476(s1) # 40809e24 <vfs_file_handle_list_cap>
4200a72e:	0786                	sll	a5,a5,0x1
4200a730:	02e7f463          	bgeu	a5,a4,4200a758 <vfs_file_destroy_handle+0x106>
        if (new_cap < 2)
4200a734:	478d                	li	a5,3
4200a736:	0ee7f963          	bgeu	a5,a4,4200a828 <vfs_file_destroy_handle+0x1d6>
        size_t new_cap = vfs_file_handle_list_cap / 2;
4200a73a:	00175413          	srl	s0,a4,0x1
        void *mem = realloc(vfs_file_handle_list, sizeof(*vfs_file_handle_list) * new_cap);
4200a73e:	00341593          	sll	a1,s0,0x3
4200a742:	95a2                	add	a1,a1,s0
4200a744:	058a                	sll	a1,a1,0x2
4200a746:	e2c92503          	lw	a0,-468(s2)
4200a74a:	488030ef          	jal	4200dbd2 <realloc>
        if (!mem)
4200a74e:	c509                	beqz	a0,4200a758 <vfs_file_destroy_handle+0x106>
        vfs_file_handle_list     = mem;
4200a750:	e2a92623          	sw	a0,-468(s2)
        vfs_file_handle_list_cap = new_cap;
4200a754:	e284a223          	sw	s0,-476(s1)
        vfs_file_shared_splice(shared);
    }

    // Splice the handle out of the list.
    vfs_file_handle_splice(handle);
}
4200a758:	40f2                	lw	ra,28(sp)
4200a75a:	4462                	lw	s0,24(sp)
4200a75c:	44d2                	lw	s1,20(sp)
4200a75e:	4942                	lw	s2,16(sp)
4200a760:	49b2                	lw	s3,12(sp)
4200a762:	6105                	add	sp,sp,32
4200a764:	8082                	ret
    assert_dev_drop(handle >= 0 && handle < (ptrdiff_t)vfs_file_handle_list_len);
4200a766:	420195b7          	lui	a1,0x42019
4200a76a:	ad058593          	add	a1,a1,-1328 # 42018ad0 <hextab+0x1e04>
4200a76e:	4501                	li	a0,0
4200a770:	ae5f80ef          	jal	42003254 <logk>
4200a774:	9002                	ebreak
    if (vfs_file_handle_list[handle].shared->refcount == 0) {
4200a776:	f2d77de3          	bgeu	a4,a3,4200a6b0 <vfs_file_destroy_handle+0x5e>
        vfs_file_handle_list[i] = vfs_file_handle_list[vfs_file_handle_list_len];
4200a77a:	9002                	ebreak
    vfs_file_handle_list[handle].shared->refcount--;
4200a77c:	f0d777e3          	bgeu	a4,a3,4200a68a <vfs_file_destroy_handle+0x38>
        vfs_file_handle_list[i] = vfs_file_handle_list[vfs_file_handle_list_len];
4200a780:	9002                	ebreak
4200a782:	f4e67ee3          	bgeu	a2,a4,4200a6de <vfs_file_destroy_handle+0x8c>
4200a786:	9002                	ebreak
4200a788:	f4d675e3          	bgeu	a2,a3,4200a6d2 <vfs_file_destroy_handle+0x80>
4200a78c:	9002                	ebreak
        vfs_file_close(NULL, vfs_file_handle_list[handle].shared);
4200a78e:	0a04d463          	bgez	s1,4200a836 <vfs_file_destroy_handle+0x1e4>
4200a792:	fee6e4e3          	bltu	a3,a4,4200a77a <vfs_file_destroy_handle+0x128>
}

// Close a file opened by `vfs_file_open`.
// Only raises an error if `file` is an invalid file descriptor.
void vfs_file_close(badge_err_t *ec, vfs_file_shared_t *file) {
    vfs_t *vfs = file->vfs;
4200a796:	fdc00793          	li	a5,-36
4200a79a:	fef670e3          	bgeu	a2,a5,4200a77a <vfs_file_destroy_handle+0x128>
4200a79e:	524c                	lw	a1,36(a2)
    vfs_impl_call_void(vfs->type, file_close, ec, vfs, file);
4200a7a0:	dde9                	beqz	a1,4200a77a <vfs_file_destroy_handle+0x128>
4200a7a2:	0035f793          	and	a5,a1,3
4200a7a6:	fbf1                	bnez	a5,4200a77a <vfs_file_destroy_handle+0x128>
4200a7a8:	57d1                	li	a5,-12
4200a7aa:	fcf5f8e3          	bgeu	a1,a5,4200a77a <vfs_file_destroy_handle+0x128>
4200a7ae:	45d8                	lw	a4,12(a1)
4200a7b0:	4789                	li	a5,2
4200a7b2:	fcf714e3          	bne	a4,a5,4200a77a <vfs_file_destroy_handle+0x128>
4200a7b6:	4501                	li	a0,0
4200a7b8:	e94ff0ef          	jal	42009e4c <vfs_ramfs_file_close>
        ptrdiff_t shared = vfs_file_by_ptr(vfs_file_handle_list[handle].shared);
4200a7bc:	e2c92703          	lw	a4,-468(s2)
4200a7c0:	009707b3          	add	a5,a4,s1
4200a7c4:	0604d663          	bgez	s1,4200a830 <vfs_file_destroy_handle+0x1de>
4200a7c8:	faf769e3          	bltu	a4,a5,4200a77a <vfs_file_destroy_handle+0x128>
4200a7cc:	d7dd                	beqz	a5,4200a77a <vfs_file_destroy_handle+0x128>
4200a7ce:	0037f713          	and	a4,a5,3
4200a7d2:	f745                	bnez	a4,4200a77a <vfs_file_destroy_handle+0x128>
4200a7d4:	5711                	li	a4,-28
4200a7d6:	fae7f2e3          	bgeu	a5,a4,4200a77a <vfs_file_destroy_handle+0x128>
    for (size_t i = 0; i < vfs_file_shared_list_len; i++) {
4200a7da:	4080a737          	lui	a4,0x4080a
4200a7de:	e3472583          	lw	a1,-460(a4) # 40809e34 <vfs_file_shared_list_len>
        ptrdiff_t shared = vfs_file_by_ptr(vfs_file_handle_list[handle].shared);
4200a7e2:	4fc8                	lw	a0,28(a5)
    for (size_t i = 0; i < vfs_file_shared_list_len; i++) {
4200a7e4:	c98d                	beqz	a1,4200a816 <vfs_file_destroy_handle+0x1c4>
        if (vfs_file_shared_list[i] == ptr) {
4200a7e6:	4080a7b7          	lui	a5,0x4080a
4200a7ea:	e387a683          	lw	a3,-456(a5) # 40809e38 <vfs_file_shared_list>
4200a7ee:	87b6                	mv	a5,a3
4200a7f0:	00241713          	sll	a4,s0,0x2
4200a7f4:	00e68633          	add	a2,a3,a4
4200a7f8:	02074563          	bltz	a4,4200a822 <vfs_file_destroy_handle+0x1d0>
4200a7fc:	f6d66fe3          	bltu	a2,a3,4200a77a <vfs_file_destroy_handle+0x128>
4200a800:	dfad                	beqz	a5,4200a77a <vfs_file_destroy_handle+0x128>
4200a802:	0037f713          	and	a4,a5,3
4200a806:	fb35                	bnez	a4,4200a77a <vfs_file_destroy_handle+0x128>
4200a808:	4398                	lw	a4,0(a5)
4200a80a:	02e50963          	beq	a0,a4,4200a83c <vfs_file_destroy_handle+0x1ea>
    for (size_t i = 0; i < vfs_file_shared_list_len; i++) {
4200a80e:	0405                	add	s0,s0,1
4200a810:	0791                	add	a5,a5,4
4200a812:	fc859fe3          	bne	a1,s0,4200a7f0 <vfs_file_destroy_handle+0x19e>
    return -1;
4200a816:	557d                	li	a0,-1
        vfs_file_shared_splice(shared);
4200a818:	aadff0ef          	jal	4200a2c4 <vfs_file_shared_splice>
    vfs_file_handle_list_len--;
4200a81c:	e289a783          	lw	a5,-472(s3)
4200a820:	bd49                	j	4200a6b2 <vfs_file_destroy_handle+0x60>
        if (vfs_file_shared_list[i] == ptr) {
4200a822:	fcc6ffe3          	bgeu	a3,a2,4200a800 <vfs_file_destroy_handle+0x1ae>
        vfs_file_handle_list[i] = vfs_file_handle_list[vfs_file_handle_list_len];
4200a826:	9002                	ebreak
4200a828:	04800593          	li	a1,72
            new_cap = 2;
4200a82c:	4409                	li	s0,2
4200a82e:	bf21                	j	4200a746 <vfs_file_destroy_handle+0xf4>
        ptrdiff_t shared = vfs_file_by_ptr(vfs_file_handle_list[handle].shared);
4200a830:	f8e7fee3          	bgeu	a5,a4,4200a7cc <vfs_file_destroy_handle+0x17a>
        vfs_file_handle_list[i] = vfs_file_handle_list[vfs_file_handle_list_len];
4200a834:	9002                	ebreak
        vfs_file_close(NULL, vfs_file_handle_list[handle].shared);
4200a836:	f6d770e3          	bgeu	a4,a3,4200a796 <vfs_file_destroy_handle+0x144>
        vfs_file_handle_list[i] = vfs_file_handle_list[vfs_file_handle_list_len];
4200a83a:	9002                	ebreak
            return (ptrdiff_t)i;
4200a83c:	8522                	mv	a0,s0
4200a83e:	bfe9                	j	4200a818 <vfs_file_destroy_handle+0x1c6>

4200a840 <vfs_root_open>:
    vfs_t *vfs = &vfs_table[vfs_root_index];
4200a840:	3201a683          	lw	a3,800(gp) # 40800320 <vfs_root_index>
4200a844:	4795                	li	a5,5
void vfs_root_open(badge_err_t *ec, vfs_file_shared_t *dir) {
4200a846:	862e                	mv	a2,a1
    vfs_t *vfs = &vfs_table[vfs_root_index];
4200a848:	04f6fd63          	bgeu	a3,a5,4200a8a2 <vfs_root_open+0x62>
4200a84c:	03400713          	li	a4,52
4200a850:	02e68733          	mul	a4,a3,a4
4200a854:	33018793          	add	a5,gp,816 # 40800330 <vfs_table>
4200a858:	00e785b3          	add	a1,a5,a4
4200a85c:	04074163          	bltz	a4,4200a89e <vfs_root_open+0x5e>
4200a860:	04f5e163          	bltu	a1,a5,4200a8a2 <vfs_root_open+0x62>
4200a864:	0d000593          	li	a1,208
4200a868:	883a                	mv	a6,a4
4200a86a:	00b77463          	bgeu	a4,a1,4200a872 <vfs_root_open+0x32>
4200a86e:	0d000813          	li	a6,208
4200a872:	00e785b3          	add	a1,a5,a4
    vfs_impl_call_void(vfs->type, root_open, ec, vfs, dir);
4200a876:	40e80833          	sub	a6,a6,a4
4200a87a:	c585                	beqz	a1,4200a8a2 <vfs_root_open+0x62>
4200a87c:	4741                	li	a4,16
4200a87e:	02e86263          	bltu	a6,a4,4200a8a2 <vfs_root_open+0x62>
4200a882:	5751                	li	a4,-12
4200a884:	00e5ff63          	bgeu	a1,a4,4200a8a2 <vfs_root_open+0x62>
4200a888:	03400713          	li	a4,52
4200a88c:	02e686b3          	mul	a3,a3,a4
4200a890:	4709                	li	a4,2
4200a892:	97b6                	add	a5,a5,a3
4200a894:	47dc                	lw	a5,12(a5)
4200a896:	00e79663          	bne	a5,a4,4200a8a2 <vfs_root_open+0x62>
4200a89a:	b5aff06f          	j	42009bf4 <vfs_ramfs_root_open>
    vfs_t *vfs = &vfs_table[vfs_root_index];
4200a89e:	fcb7f3e3          	bgeu	a5,a1,4200a864 <vfs_root_open+0x24>
    vfs_impl_call_void(vfs->type, root_open, ec, vfs, dir);
4200a8a2:	9002                	ebreak

4200a8a4 <vfs_create_file>:
void vfs_create_file(badge_err_t *ec, vfs_file_shared_t *dir, char const *name) {
4200a8a4:	87ae                	mv	a5,a1
4200a8a6:	86b2                	mv	a3,a2
    vfs_impl_call_void(dir->vfs->type, create_file, ec, dir->vfs, dir, name);
4200a8a8:	c59d                	beqz	a1,4200a8d6 <vfs_create_file+0x32>
4200a8aa:	0035f713          	and	a4,a1,3
4200a8ae:	e705                	bnez	a4,4200a8d6 <vfs_create_file+0x32>
4200a8b0:	fdc00713          	li	a4,-36
4200a8b4:	02e5f163          	bgeu	a1,a4,4200a8d6 <vfs_create_file+0x32>
4200a8b8:	51cc                	lw	a1,36(a1)
4200a8ba:	cd91                	beqz	a1,4200a8d6 <vfs_create_file+0x32>
4200a8bc:	0035f713          	and	a4,a1,3
4200a8c0:	eb19                	bnez	a4,4200a8d6 <vfs_create_file+0x32>
4200a8c2:	5751                	li	a4,-12
4200a8c4:	00e5f963          	bgeu	a1,a4,4200a8d6 <vfs_create_file+0x32>
4200a8c8:	45d0                	lw	a2,12(a1)
4200a8ca:	4709                	li	a4,2
4200a8cc:	00e61563          	bne	a2,a4,4200a8d6 <vfs_create_file+0x32>
4200a8d0:	863e                	mv	a2,a5
4200a8d2:	b37fe06f          	j	42009408 <vfs_ramfs_create_file>
4200a8d6:	9002                	ebreak

4200a8d8 <vfs_create_dir>:
void vfs_create_dir(badge_err_t *ec, vfs_file_shared_t *dir, char const *name) {
4200a8d8:	87ae                	mv	a5,a1
4200a8da:	86b2                	mv	a3,a2
    vfs_impl_call_void(dir->vfs->type, create_dir, ec, dir->vfs, dir, name);
4200a8dc:	c59d                	beqz	a1,4200a90a <vfs_create_dir+0x32>
4200a8de:	0035f713          	and	a4,a1,3
4200a8e2:	e705                	bnez	a4,4200a90a <vfs_create_dir+0x32>
4200a8e4:	fdc00713          	li	a4,-36
4200a8e8:	02e5f163          	bgeu	a1,a4,4200a90a <vfs_create_dir+0x32>
4200a8ec:	51cc                	lw	a1,36(a1)
4200a8ee:	cd91                	beqz	a1,4200a90a <vfs_create_dir+0x32>
4200a8f0:	0035f713          	and	a4,a1,3
4200a8f4:	eb19                	bnez	a4,4200a90a <vfs_create_dir+0x32>
4200a8f6:	5751                	li	a4,-12
4200a8f8:	00e5f963          	bgeu	a1,a4,4200a90a <vfs_create_dir+0x32>
4200a8fc:	45d0                	lw	a2,12(a1)
4200a8fe:	4709                	li	a4,2
4200a900:	00e61563          	bne	a2,a4,4200a90a <vfs_create_dir+0x32>
4200a904:	863e                	mv	a2,a5
4200a906:	b09fe06f          	j	4200940e <vfs_ramfs_create_dir>
4200a90a:	9002                	ebreak

4200a90c <vfs_unlink>:
void vfs_unlink(badge_err_t *ec, vfs_file_shared_t *dir, char const *name) {
4200a90c:	87ae                	mv	a5,a1
4200a90e:	86b2                	mv	a3,a2
    vfs_impl_call_void(dir->vfs->type, unlink, ec, dir->vfs, dir, name);
4200a910:	c59d                	beqz	a1,4200a93e <vfs_unlink+0x32>
4200a912:	0035f713          	and	a4,a1,3
4200a916:	e705                	bnez	a4,4200a93e <vfs_unlink+0x32>
4200a918:	fdc00713          	li	a4,-36
4200a91c:	02e5f163          	bgeu	a1,a4,4200a93e <vfs_unlink+0x32>
4200a920:	51cc                	lw	a1,36(a1)
4200a922:	cd91                	beqz	a1,4200a93e <vfs_unlink+0x32>
4200a924:	0035f713          	and	a4,a1,3
4200a928:	eb19                	bnez	a4,4200a93e <vfs_unlink+0x32>
4200a92a:	5751                	li	a4,-12
4200a92c:	00e5f963          	bgeu	a1,a4,4200a93e <vfs_unlink+0x32>
4200a930:	45d0                	lw	a2,12(a1)
4200a932:	4709                	li	a4,2
4200a934:	00e61563          	bne	a2,a4,4200a93e <vfs_unlink+0x32>
4200a938:	863e                	mv	a2,a5
4200a93a:	c61fe06f          	j	4200959a <vfs_ramfs_unlink>
4200a93e:	9002                	ebreak

4200a940 <vfs_dir_read>:
void vfs_dir_read(badge_err_t *ec, vfs_file_handle_t *dir) {
4200a940:	862e                	mv	a2,a1
    vfs_impl_call_void(dir->shared->vfs->type, dir_read, ec, dir->shared->vfs, dir);
4200a942:	cd95                	beqz	a1,4200a97e <vfs_dir_read+0x3e>
4200a944:	0035f793          	and	a5,a1,3
4200a948:	eb9d                	bnez	a5,4200a97e <vfs_dir_read+0x3e>
4200a94a:	5791                	li	a5,-28
4200a94c:	02f5f963          	bgeu	a1,a5,4200a97e <vfs_dir_read+0x3e>
4200a950:	4ddc                	lw	a5,28(a1)
4200a952:	c795                	beqz	a5,4200a97e <vfs_dir_read+0x3e>
4200a954:	0037f713          	and	a4,a5,3
4200a958:	e31d                	bnez	a4,4200a97e <vfs_dir_read+0x3e>
4200a95a:	fdc00713          	li	a4,-36
4200a95e:	02e7f063          	bgeu	a5,a4,4200a97e <vfs_dir_read+0x3e>
4200a962:	53cc                	lw	a1,36(a5)
4200a964:	cd89                	beqz	a1,4200a97e <vfs_dir_read+0x3e>
4200a966:	0035f793          	and	a5,a1,3
4200a96a:	eb91                	bnez	a5,4200a97e <vfs_dir_read+0x3e>
4200a96c:	57d1                	li	a5,-12
4200a96e:	00f5f863          	bgeu	a1,a5,4200a97e <vfs_dir_read+0x3e>
4200a972:	45d8                	lw	a4,12(a1)
4200a974:	4789                	li	a5,2
4200a976:	00f71463          	bne	a4,a5,4200a97e <vfs_dir_read+0x3e>
4200a97a:	fc5fe06f          	j	4200993e <vfs_ramfs_dir_read>
4200a97e:	9002                	ebreak

4200a980 <vfs_dir_find_ent>:
bool vfs_dir_find_ent(badge_err_t *ec, vfs_file_shared_t *dir, dirent_t *ent, char const *name) {
4200a980:	87ae                	mv	a5,a1
4200a982:	8736                	mv	a4,a3
    vfs_impl_return(dir->vfs->type, dir_find_ent, ec, dir->vfs, dir, ent, name);
4200a984:	c98d                	beqz	a1,4200a9b6 <vfs_dir_find_ent+0x36>
4200a986:	0035f693          	and	a3,a1,3
4200a98a:	e695                	bnez	a3,4200a9b6 <vfs_dir_find_ent+0x36>
4200a98c:	fdc00693          	li	a3,-36
4200a990:	02d5f363          	bgeu	a1,a3,4200a9b6 <vfs_dir_find_ent+0x36>
4200a994:	51cc                	lw	a1,36(a1)
4200a996:	c185                	beqz	a1,4200a9b6 <vfs_dir_find_ent+0x36>
4200a998:	0035f693          	and	a3,a1,3
4200a99c:	ee89                	bnez	a3,4200a9b6 <vfs_dir_find_ent+0x36>
4200a99e:	56d1                	li	a3,-12
4200a9a0:	00d5fb63          	bgeu	a1,a3,4200a9b6 <vfs_dir_find_ent+0x36>
4200a9a4:	00c5a803          	lw	a6,12(a1)
4200a9a8:	4689                	li	a3,2
4200a9aa:	00d81663          	bne	a6,a3,4200a9b6 <vfs_dir_find_ent+0x36>
4200a9ae:	86b2                	mv	a3,a2
4200a9b0:	863e                	mv	a2,a5
4200a9b2:	a00ff06f          	j	42009bb2 <vfs_ramfs_dir_find_ent>
4200a9b6:	9002                	ebreak

4200a9b8 <vfs_file_open>:
    vfs_t *vfs = dir->vfs;
4200a9b8:	16058163          	beqz	a1,4200ab1a <vfs_file_open+0x162>
) {
4200a9bc:	1101                	add	sp,sp,-32
4200a9be:	cc22                	sw	s0,24(sp)
4200a9c0:	ce06                	sw	ra,28(sp)
4200a9c2:	ca26                	sw	s1,20(sp)
4200a9c4:	c84a                	sw	s2,16(sp)
4200a9c6:	c64e                	sw	s3,12(sp)
4200a9c8:	c452                	sw	s4,8(sp)
4200a9ca:	c256                	sw	s5,4(sp)
    vfs_t *vfs = dir->vfs;
4200a9cc:	0035f793          	and	a5,a1,3
4200a9d0:	842e                	mv	s0,a1
4200a9d2:	12079f63          	bnez	a5,4200ab10 <vfs_file_open+0x158>
4200a9d6:	fdc00793          	li	a5,-36
4200a9da:	12f5fc63          	bgeu	a1,a5,4200ab12 <vfs_file_open+0x15a>
    if (oflags & (OFLAGS_EXCLUSIVE | OFLAGS_CREATE)) {
4200a9de:	03077793          	and	a5,a4,48
    vfs_t *vfs = dir->vfs;
4200a9e2:	51c4                	lw	s1,36(a1)
    if (oflags & (OFLAGS_EXCLUSIVE | OFLAGS_CREATE)) {
4200a9e4:	89aa                	mv	s3,a0
4200a9e6:	8ab2                	mv	s5,a2
4200a9e8:	8a36                	mv	s4,a3
4200a9ea:	893a                	mv	s2,a4
4200a9ec:	cfc1                	beqz	a5,4200aa84 <vfs_file_open+0xcc>
        bool exists = vfs_impl_call(vfs->type, bool, exists, ec, vfs, dir, name);
4200a9ee:	12048063          	beqz	s1,4200ab0e <vfs_file_open+0x156>
4200a9f2:	0034f793          	and	a5,s1,3
4200a9f6:	10079c63          	bnez	a5,4200ab0e <vfs_file_open+0x156>
4200a9fa:	57d1                	li	a5,-12
4200a9fc:	10f4fe63          	bgeu	s1,a5,4200ab18 <vfs_file_open+0x160>
4200aa00:	44d8                	lw	a4,12(s1)
4200aa02:	4789                	li	a5,2
4200aa04:	12f71063          	bne	a4,a5,4200ab24 <vfs_file_open+0x16c>
4200aa08:	862e                	mv	a2,a1
4200aa0a:	85a6                	mv	a1,s1
4200aa0c:	e6dfe0ef          	jal	42009878 <vfs_ramfs_exists>
        if ((oflags & OFLAGS_EXCLUSIVE) && exists) {
4200aa10:	02097793          	and	a5,s2,32
4200aa14:	c7b9                	beqz	a5,4200aa62 <vfs_file_open+0xaa>
4200aa16:	e171                	bnez	a0,4200aada <vfs_file_open+0x122>
        } else if (!(oflags & OFLAGS_CREATE) && !exists) {
4200aa18:	01097793          	and	a5,s2,16
4200aa1c:	e7b1                	bnez	a5,4200aa68 <vfs_file_open+0xb0>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTFOUND);
4200aa1e:	02098963          	beqz	s3,4200aa50 <vfs_file_open+0x98>
4200aa22:	420175b7          	lui	a1,0x42017
4200aa26:	46e1                	li	a3,24
4200aa28:	4635                	li	a2,13
4200aa2a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200aa2e:	4511                	li	a0,4
4200aa30:	00000717          	auipc	a4,0x0
4200aa34:	867f80ef          	jal	4200329a <logkf>
4200aa38:	0039f793          	and	a5,s3,3
4200aa3c:	e3ed                	bnez	a5,4200ab1e <vfs_file_open+0x166>
4200aa3e:	57f1                	li	a5,-4
4200aa40:	0cf9fe63          	bgeu	s3,a5,4200ab1c <vfs_file_open+0x164>
4200aa44:	47b5                	li	a5,13
4200aa46:	00f9a223          	sw	a5,4(s3)
4200aa4a:	47e1                	li	a5,24
4200aa4c:	00f9a023          	sw	a5,0(s3)
}
4200aa50:	40f2                	lw	ra,28(sp)
4200aa52:	4462                	lw	s0,24(sp)
4200aa54:	44d2                	lw	s1,20(sp)
4200aa56:	4942                	lw	s2,16(sp)
4200aa58:	49b2                	lw	s3,12(sp)
4200aa5a:	4a22                	lw	s4,8(sp)
4200aa5c:	4a92                	lw	s5,4(sp)
4200aa5e:	6105                	add	sp,sp,32
4200aa60:	8082                	ret
        } else if (!(oflags & OFLAGS_CREATE) && !exists) {
4200aa62:	01097793          	and	a5,s2,16
4200aa66:	c3b5                	beqz	a5,4200aaca <vfs_file_open+0x112>
        } else if (oflags & OFLAGS_DIRECTORY) {
4200aa68:	08097913          	and	s2,s2,128
            vfs_impl_call_void(vfs->type, create_dir, ec, vfs, dir, name);
4200aa6c:	44d8                	lw	a4,12(s1)
4200aa6e:	4789                	li	a5,2
        } else if (oflags & OFLAGS_DIRECTORY) {
4200aa70:	04091463          	bnez	s2,4200aab8 <vfs_file_open+0x100>
            vfs_impl_call_void(vfs->type, create_file, ec, vfs, dir, name);
4200aa74:	0af71863          	bne	a4,a5,4200ab24 <vfs_file_open+0x16c>
4200aa78:	86d2                	mv	a3,s4
4200aa7a:	8622                	mv	a2,s0
4200aa7c:	85a6                	mv	a1,s1
4200aa7e:	854e                	mv	a0,s3
4200aa80:	989fe0ef          	jal	42009408 <vfs_ramfs_create_file>
    vfs_impl_call_void(vfs->type, file_open, ec, vfs, dir, file, name);
4200aa84:	c8c1                	beqz	s1,4200ab14 <vfs_file_open+0x15c>
4200aa86:	0034f793          	and	a5,s1,3
4200aa8a:	e7c9                	bnez	a5,4200ab14 <vfs_file_open+0x15c>
4200aa8c:	57d1                	li	a5,-12
4200aa8e:	08f4f463          	bgeu	s1,a5,4200ab16 <vfs_file_open+0x15e>
4200aa92:	44d8                	lw	a4,12(s1)
4200aa94:	4789                	li	a5,2
4200aa96:	08f71763          	bne	a4,a5,4200ab24 <vfs_file_open+0x16c>
4200aa9a:	8622                	mv	a2,s0
}
4200aa9c:	4462                	lw	s0,24(sp)
4200aa9e:	40f2                	lw	ra,28(sp)
4200aaa0:	4942                	lw	s2,16(sp)
    vfs_impl_call_void(vfs->type, file_open, ec, vfs, dir, file, name);
4200aaa2:	8752                	mv	a4,s4
4200aaa4:	86d6                	mv	a3,s5
}
4200aaa6:	4a22                	lw	s4,8(sp)
4200aaa8:	4a92                	lw	s5,4(sp)
    vfs_impl_call_void(vfs->type, file_open, ec, vfs, dir, file, name);
4200aaaa:	85a6                	mv	a1,s1
4200aaac:	854e                	mv	a0,s3
}
4200aaae:	44d2                	lw	s1,20(sp)
4200aab0:	49b2                	lw	s3,12(sp)
4200aab2:	6105                	add	sp,sp,32
    vfs_impl_call_void(vfs->type, file_open, ec, vfs, dir, file, name);
4200aab4:	a14ff06f          	j	42009cc8 <vfs_ramfs_file_open>
            vfs_impl_call_void(vfs->type, create_dir, ec, vfs, dir, name);
4200aab8:	06f71663          	bne	a4,a5,4200ab24 <vfs_file_open+0x16c>
4200aabc:	86d2                	mv	a3,s4
4200aabe:	8622                	mv	a2,s0
4200aac0:	85a6                	mv	a1,s1
4200aac2:	854e                	mv	a0,s3
4200aac4:	94bfe0ef          	jal	4200940e <vfs_ramfs_create_dir>
4200aac8:	bf75                	j	4200aa84 <vfs_file_open+0xcc>
        } else if (!(oflags & OFLAGS_CREATE) && !exists) {
4200aaca:	d931                	beqz	a0,4200aa1e <vfs_file_open+0x66>
        } else if (oflags & OFLAGS_DIRECTORY) {
4200aacc:	08097913          	and	s2,s2,128
            vfs_impl_call_void(vfs->type, create_dir, ec, vfs, dir, name);
4200aad0:	44d8                	lw	a4,12(s1)
4200aad2:	4789                	li	a5,2
        } else if (oflags & OFLAGS_DIRECTORY) {
4200aad4:	fa0900e3          	beqz	s2,4200aa74 <vfs_file_open+0xbc>
4200aad8:	b7c5                	j	4200aab8 <vfs_file_open+0x100>
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_EXISTS);
4200aada:	f6098be3          	beqz	s3,4200aa50 <vfs_file_open+0x98>
4200aade:	420175b7          	lui	a1,0x42017
4200aae2:	46ed                	li	a3,27
4200aae4:	4635                	li	a2,13
4200aae6:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200aaea:	4511                	li	a0,4
4200aaec:	00000717          	auipc	a4,0x0
4200aaf0:	faaf80ef          	jal	4200329a <logkf>
4200aaf4:	0039f793          	and	a5,s3,3
4200aaf8:	e78d                	bnez	a5,4200ab22 <vfs_file_open+0x16a>
4200aafa:	57f1                	li	a5,-4
4200aafc:	02f9f263          	bgeu	s3,a5,4200ab20 <vfs_file_open+0x168>
4200ab00:	47b5                	li	a5,13
4200ab02:	00f9a223          	sw	a5,4(s3)
4200ab06:	47ed                	li	a5,27
4200ab08:	00f9a023          	sw	a5,0(s3)
4200ab0c:	b791                	j	4200aa50 <vfs_file_open+0x98>
        bool exists = vfs_impl_call(vfs->type, bool, exists, ec, vfs, dir, name);
4200ab0e:	9002                	ebreak
    vfs_t *vfs = dir->vfs;
4200ab10:	9002                	ebreak
4200ab12:	9002                	ebreak
    vfs_impl_call_void(vfs->type, file_open, ec, vfs, dir, file, name);
4200ab14:	9002                	ebreak
4200ab16:	9002                	ebreak
        bool exists = vfs_impl_call(vfs->type, bool, exists, ec, vfs, dir, name);
4200ab18:	9002                	ebreak
    vfs_t *vfs = dir->vfs;
4200ab1a:	9002                	ebreak
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_NOTFOUND);
4200ab1c:	9002                	ebreak
4200ab1e:	9002                	ebreak
            badge_err_set(ec, ELOC_FILESYSTEM, ECAUSE_EXISTS);
4200ab20:	9002                	ebreak
4200ab22:	9002                	ebreak
        bool exists = vfs_impl_call(vfs->type, bool, exists, ec, vfs, dir, name);
4200ab24:	9002                	ebreak

4200ab26 <vfs_file_close>:
void vfs_file_close(badge_err_t *ec, vfs_file_shared_t *file) {
4200ab26:	862e                	mv	a2,a1
    vfs_t *vfs = file->vfs;
4200ab28:	c595                	beqz	a1,4200ab54 <vfs_file_close+0x2e>
4200ab2a:	0035f793          	and	a5,a1,3
4200ab2e:	e39d                	bnez	a5,4200ab54 <vfs_file_close+0x2e>
4200ab30:	fdc00793          	li	a5,-36
4200ab34:	02f5f063          	bgeu	a1,a5,4200ab54 <vfs_file_close+0x2e>
4200ab38:	51cc                	lw	a1,36(a1)
    vfs_impl_call_void(vfs->type, file_close, ec, vfs, file);
4200ab3a:	cd89                	beqz	a1,4200ab54 <vfs_file_close+0x2e>
4200ab3c:	0035f793          	and	a5,a1,3
4200ab40:	eb91                	bnez	a5,4200ab54 <vfs_file_close+0x2e>
4200ab42:	57d1                	li	a5,-12
4200ab44:	00f5f863          	bgeu	a1,a5,4200ab54 <vfs_file_close+0x2e>
4200ab48:	45d8                	lw	a4,12(a1)
4200ab4a:	4789                	li	a5,2
4200ab4c:	00f71463          	bne	a4,a5,4200ab54 <vfs_file_close+0x2e>
4200ab50:	afcff06f          	j	42009e4c <vfs_ramfs_file_close>
4200ab54:	9002                	ebreak

4200ab56 <vfs_file_read>:
}

// Read bytes from a file.
void vfs_file_read(badge_err_t *ec, vfs_file_shared_t *file, fileoff_t offset, uint8_t *readbuf, fileoff_t readlen) {
4200ab56:	882e                	mv	a6,a1
4200ab58:	87ba                	mv	a5,a4
    vfs_impl_call_void(file->vfs->type, file_read, ec, file->vfs, file, offset, readbuf, readlen);
4200ab5a:	c995                	beqz	a1,4200ab8e <vfs_file_read+0x38>
4200ab5c:	0035f713          	and	a4,a1,3
4200ab60:	e71d                	bnez	a4,4200ab8e <vfs_file_read+0x38>
4200ab62:	fdc00713          	li	a4,-36
4200ab66:	02e5f463          	bgeu	a1,a4,4200ab8e <vfs_file_read+0x38>
4200ab6a:	51cc                	lw	a1,36(a1)
4200ab6c:	c18d                	beqz	a1,4200ab8e <vfs_file_read+0x38>
4200ab6e:	0035f713          	and	a4,a1,3
4200ab72:	ef11                	bnez	a4,4200ab8e <vfs_file_read+0x38>
4200ab74:	5751                	li	a4,-12
4200ab76:	00e5fc63          	bgeu	a1,a4,4200ab8e <vfs_file_read+0x38>
4200ab7a:	00c5a883          	lw	a7,12(a1)
4200ab7e:	4709                	li	a4,2
4200ab80:	00e89763          	bne	a7,a4,4200ab8e <vfs_file_read+0x38>
4200ab84:	8736                	mv	a4,a3
4200ab86:	86b2                	mv	a3,a2
4200ab88:	8642                	mv	a2,a6
4200ab8a:	b60ff06f          	j	42009eea <vfs_ramfs_file_read>
4200ab8e:	9002                	ebreak

4200ab90 <vfs_file_write>:
}

// Write bytes to a file.
void vfs_file_write(
    badge_err_t *ec, vfs_file_shared_t *file, fileoff_t offset, uint8_t const *writebuf, fileoff_t writelen
) {
4200ab90:	882e                	mv	a6,a1
4200ab92:	87ba                	mv	a5,a4
    vfs_impl_call_void(file->vfs->type, file_write, ec, file->vfs, file, offset, writebuf, writelen);
4200ab94:	c995                	beqz	a1,4200abc8 <vfs_file_write+0x38>
4200ab96:	0035f713          	and	a4,a1,3
4200ab9a:	e71d                	bnez	a4,4200abc8 <vfs_file_write+0x38>
4200ab9c:	fdc00713          	li	a4,-36
4200aba0:	02e5f463          	bgeu	a1,a4,4200abc8 <vfs_file_write+0x38>
4200aba4:	51cc                	lw	a1,36(a1)
4200aba6:	c18d                	beqz	a1,4200abc8 <vfs_file_write+0x38>
4200aba8:	0035f713          	and	a4,a1,3
4200abac:	ef11                	bnez	a4,4200abc8 <vfs_file_write+0x38>
4200abae:	5751                	li	a4,-12
4200abb0:	00e5fc63          	bgeu	a1,a4,4200abc8 <vfs_file_write+0x38>
4200abb4:	00c5a883          	lw	a7,12(a1)
4200abb8:	4709                	li	a4,2
4200abba:	00e89763          	bne	a7,a4,4200abc8 <vfs_file_write+0x38>
4200abbe:	8736                	mv	a4,a3
4200abc0:	86b2                	mv	a3,a2
4200abc2:	8642                	mv	a2,a6
4200abc4:	c84ff06f          	j	4200a048 <vfs_ramfs_file_write>
4200abc8:	9002                	ebreak

4200abca <vfs_file_resize>:
}

// Change the length of a file opened by `vfs_file_open`.
void vfs_file_resize(badge_err_t *ec, vfs_file_shared_t *file, fileoff_t new_size) {
4200abca:	87ae                	mv	a5,a1
4200abcc:	86b2                	mv	a3,a2
    vfs_impl_call_void(file->vfs->type, file_resize, ec, file->vfs, file, new_size);
4200abce:	c59d                	beqz	a1,4200abfc <vfs_file_resize+0x32>
4200abd0:	0035f713          	and	a4,a1,3
4200abd4:	e705                	bnez	a4,4200abfc <vfs_file_resize+0x32>
4200abd6:	fdc00713          	li	a4,-36
4200abda:	02e5f163          	bgeu	a1,a4,4200abfc <vfs_file_resize+0x32>
4200abde:	51cc                	lw	a1,36(a1)
4200abe0:	cd91                	beqz	a1,4200abfc <vfs_file_resize+0x32>
4200abe2:	0035f713          	and	a4,a1,3
4200abe6:	eb19                	bnez	a4,4200abfc <vfs_file_resize+0x32>
4200abe8:	5751                	li	a4,-12
4200abea:	00e5f963          	bgeu	a1,a4,4200abfc <vfs_file_resize+0x32>
4200abee:	45d0                	lw	a2,12(a1)
4200abf0:	4709                	li	a4,2
4200abf2:	00e61563          	bne	a2,a4,4200abfc <vfs_file_resize+0x32>
4200abf6:	863e                	mv	a2,a5
4200abf8:	da4ff06f          	j	4200a19c <vfs_ramfs_file_resize>
4200abfc:	9002                	ebreak

4200abfe <vfs_flush>:


// Commit all pending writes to disk.
// The filesystem, if it does caching, must always sync everything to disk at once.
void vfs_flush(badge_err_t *ec, vfs_t *vfs) {
    vfs_impl_call_void(vfs->type, flush, ec, vfs);
4200abfe:	cd89                	beqz	a1,4200ac18 <vfs_flush+0x1a>
4200ac00:	0035f713          	and	a4,a1,3
4200ac04:	eb11                	bnez	a4,4200ac18 <vfs_flush+0x1a>
4200ac06:	5751                	li	a4,-12
4200ac08:	00e5f863          	bgeu	a1,a4,4200ac18 <vfs_flush+0x1a>
4200ac0c:	45d8                	lw	a4,12(a1)
4200ac0e:	4789                	li	a5,2
4200ac10:	00f71463          	bne	a4,a5,4200ac18 <vfs_flush+0x1a>
4200ac14:	e96ff06f          	j	4200a2aa <vfs_ramfs_flush>
4200ac18:	9002                	ebreak

4200ac1a <exit_impl>:


// A built-in library function test.
static void exit_impl(int code) {
    (void)code;
    __builtin_trap();
4200ac1a:	9002                	ebreak

4200ac1c <kbelfq_strlen>:
    return cstr_length(str);
4200ac1c:	93ef706f          	j	42001d5a <cstr_length>

4200ac20 <kbelfq_strcpy>:
void kbelfq_strcpy(char *dst, char const *src) {
4200ac20:	862e                	mv	a2,a1
    cstr_copy(dst, SIZE_MAX, src);
4200ac22:	55fd                	li	a1,-1
4200ac24:	bfcf706f          	j	42002020 <cstr_copy>

4200ac28 <kbelfq_strrchr>:
char const *kbelfq_strrchr(char const *str, char c) {
4200ac28:	1141                	add	sp,sp,-16
4200ac2a:	c422                	sw	s0,8(sp)
4200ac2c:	c606                	sw	ra,12(sp)
4200ac2e:	842a                	mv	s0,a0
    ptrdiff_t off = cstr_last_index(str, c);
4200ac30:	9b4f70ef          	jal	42001de4 <cstr_last_index>
    return off == -1 ? NULL : off + str;
4200ac34:	577d                	li	a4,-1
4200ac36:	00e50f63          	beq	a0,a4,4200ac54 <kbelfq_strrchr+0x2c>
4200ac3a:	87aa                	mv	a5,a0
4200ac3c:	9522                	add	a0,a0,s0
4200ac3e:	0007d863          	bgez	a5,4200ac4e <kbelfq_strrchr+0x26>
4200ac42:	00a46863          	bltu	s0,a0,4200ac52 <kbelfq_strrchr+0x2a>
}
4200ac46:	40b2                	lw	ra,12(sp)
4200ac48:	4422                	lw	s0,8(sp)
4200ac4a:	0141                	add	sp,sp,16
4200ac4c:	8082                	ret
    return off == -1 ? NULL : off + str;
4200ac4e:	fe857ce3          	bgeu	a0,s0,4200ac46 <kbelfq_strrchr+0x1e>
4200ac52:	9002                	ebreak
}
4200ac54:	40b2                	lw	ra,12(sp)
4200ac56:	4422                	lw	s0,8(sp)
    return off == -1 ? NULL : off + str;
4200ac58:	4501                	li	a0,0
}
4200ac5a:	0141                	add	sp,sp,16
4200ac5c:	8082                	ret

4200ac5e <kbelfq_streq>:
    return cstr_equals(a, b);
4200ac5e:	aaef706f          	j	42001f0c <cstr_equals>

4200ac62 <kbelfq_memcpy>:
    mem_copy(dst, src, nmemb);
4200ac62:	f0af706f          	j	4200236c <mem_copy>

4200ac66 <kbelfq_memset>:
    mem_set(dst, c, nmemb);
4200ac66:	be7f706f          	j	4200284c <mem_set>

4200ac6a <kbelfq_memeq>:
    return mem_equals(a, b, nmemb);
4200ac6a:	d78f706f          	j	420021e2 <mem_equals>

4200ac6e <kbelfx_malloc>:
    return malloc(len);
4200ac6e:	4e30206f          	j	4200d950 <malloc>

4200ac72 <kbelfx_realloc>:
    return realloc(mem, len);
4200ac72:	7610206f          	j	4200dbd2 <realloc>

4200ac76 <kbelfx_free>:
    free(mem);
4200ac76:	6e70206f          	j	4200db5c <free>

4200ac7a <kbelfx_seg_alloc>:
bool kbelfx_seg_alloc(kbelf_inst inst, size_t segs_len, kbelf_segment *segs) {
4200ac7a:	7139                	add	sp,sp,-64
4200ac7c:	de06                	sw	ra,60(sp)
4200ac7e:	dc22                	sw	s0,56(sp)
4200ac80:	ce5e                	sw	s7,28(sp)
4200ac82:	8432                	mv	s0,a2
4200ac84:	8bae                	mv	s7,a1
    process_t *proc = proc_get(kbelf_inst_getpid(inst));
4200ac86:	74c070ef          	jal	420123d2 <kbelf_inst_getpid>
4200ac8a:	09d000ef          	jal	4200b526 <proc_get>
    assert_dev_keep(proc != NULL);
4200ac8e:	1e050263          	beqz	a0,4200ae72 <kbelfx_seg_alloc+0x1f8>
4200ac92:	c66e                	sw	s11,12(sp)
4200ac94:	cc62                	sw	s8,24(sp)
4200ac96:	8daa                	mv	s11,a0
    for (size_t i = 0; i < segs_len; i++) {
4200ac98:	1e0b8e63          	beqz	s7,4200ae94 <kbelfx_seg_alloc+0x21a>
4200ac9c:	da26                	sw	s1,52(sp)
4200ac9e:	d84a                	sw	s2,48(sp)
4200aca0:	d64e                	sw	s3,44(sp)
4200aca2:	d452                	sw	s4,40(sp)
4200aca4:	d256                	sw	s5,36(sp)
4200aca6:	d05a                	sw	s6,32(sp)
4200aca8:	ca66                	sw	s9,20(sp)
4200acaa:	c86a                	sw	s10,16(sp)
4200acac:	4981                	li	s3,0
4200acae:	8922                	mv	s2,s0
4200acb0:	84a2                	mv	s1,s0
4200acb2:	4a01                	li	s4,0
    size_t max_addr  = 0;
4200acb4:	4b01                	li	s6,0
    size_t min_addr  = SIZE_MAX;
4200acb6:	5afd                	li	s5,-1
        size_t start = segs[i].vaddr_req;
4200acb8:	5d31                	li	s10,-20
        size_t end = segs[i].vaddr_req + segs[i].size;
4200acba:	5ca1                	li	s9,-24
        logkf(LOG_DEBUG, "Segment %{size;d}: %{size;x} - %{size;x}", i, start, end);
4200acbc:	42019c37          	lui	s8,0x42019
        size_t start = segs[i].vaddr_req;
4200acc0:	013407b3          	add	a5,s0,s3
4200acc4:	0609c063          	bltz	s3,4200ad24 <kbelfx_seg_alloc+0xaa>
4200acc8:	0687e063          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200accc:	ccb1                	beqz	s1,4200ad28 <kbelfx_seg_alloc+0xae>
4200acce:	0034f713          	and	a4,s1,3
4200acd2:	eb39                	bnez	a4,4200ad28 <kbelfx_seg_alloc+0xae>
4200acd4:	05a4fa63          	bgeu	s1,s10,4200ad28 <kbelfx_seg_alloc+0xae>
4200acd8:	48d4                	lw	a3,20(s1)
        if (start < min_addr)
4200acda:	0156f363          	bgeu	a3,s5,4200ace0 <kbelfx_seg_alloc+0x66>
4200acde:	8ab6                	mv	s5,a3
        size_t end = segs[i].vaddr_req + segs[i].size;
4200ace0:	0409c863          	bltz	s3,4200ad30 <kbelfx_seg_alloc+0xb6>
4200ace4:	0487e263          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200ace8:	0409c163          	bltz	s3,4200ad2a <kbelfx_seg_alloc+0xb0>
4200acec:	0287ee63          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200acf0:	0394fc63          	bgeu	s1,s9,4200ad28 <kbelfx_seg_alloc+0xae>
4200acf4:	4c98                	lw	a4,24(s1)
4200acf6:	9736                	add	a4,a4,a3
        if (end > max_addr)
4200acf8:	00eb7363          	bgeu	s6,a4,4200acfe <kbelfx_seg_alloc+0x84>
4200acfc:	8b3a                	mv	s6,a4
        logkf(LOG_DEBUG, "Segment %{size;d}: %{size;x} - %{size;x}", i, start, end);
4200acfe:	8652                	mv	a2,s4
4200ad00:	bf0c0593          	add	a1,s8,-1040 # 42018bf0 <hextab+0x1f24>
4200ad04:	4511                	li	a0,4
4200ad06:	d94f80ef          	jal	4200329a <logkf>
    for (size_t i = 0; i < segs_len; i++) {
4200ad0a:	001a0793          	add	a5,s4,1
4200ad0e:	02898993          	add	s3,s3,40
4200ad12:	02848493          	add	s1,s1,40
4200ad16:	02fb8063          	beq	s7,a5,4200ad36 <kbelfx_seg_alloc+0xbc>
4200ad1a:	8a3e                	mv	s4,a5
        size_t start = segs[i].vaddr_req;
4200ad1c:	013407b3          	add	a5,s0,s3
4200ad20:	fa09d4e3          	bgez	s3,4200acc8 <kbelfx_seg_alloc+0x4e>
4200ad24:	faf474e3          	bgeu	s0,a5,4200accc <kbelfx_seg_alloc+0x52>
    segs[0].alloc_cookie = (void *)vaddr_real;
4200ad28:	9002                	ebreak
        size_t end = segs[i].vaddr_req + segs[i].size;
4200ad2a:	fcf473e3          	bgeu	s0,a5,4200acf0 <kbelfx_seg_alloc+0x76>
    segs[0].alloc_cookie = (void *)vaddr_real;
4200ad2e:	9002                	ebreak
        size_t end = segs[i].vaddr_req + segs[i].size;
4200ad30:	faf47ce3          	bgeu	s0,a5,4200ace8 <kbelfx_seg_alloc+0x6e>
    segs[0].alloc_cookie = (void *)vaddr_real;
4200ad34:	9002                	ebreak
    size_t vaddr_real = proc_map_raw(NULL, proc, min_addr, max_addr - min_addr, min_align);
4200ad36:	4741                	li	a4,16
4200ad38:	415b06b3          	sub	a3,s6,s5
4200ad3c:	8656                	mv	a2,s5
4200ad3e:	85ee                	mv	a1,s11
4200ad40:	4501                	li	a0,0
4200ad42:	4b7000ef          	jal	4200b9f8 <proc_map_raw>
4200ad46:	8c2a                	mv	s8,a0
    if (!vaddr_real)
4200ad48:	10050563          	beqz	a0,4200ae52 <kbelfx_seg_alloc+0x1d8>
4200ad4c:	4481                	li	s1,0
4200ad4e:	41550ab3          	sub	s5,a0,s5
    for (size_t i = 0; i < segs_len; i++) {
4200ad52:	4981                	li	s3,0
        segs[i].vaddr_real   = segs[i].vaddr_req - min_addr + vaddr_real;
4200ad54:	5bb1                	li	s7,-20
        logkf(LOG_DEBUG, "Segment %{size;x} mapped to %{size;x}", i, segs[i].vaddr_real);
4200ad56:	42019b37          	lui	s6,0x42019
        segs[i].vaddr_real   = segs[i].vaddr_req - min_addr + vaddr_real;
4200ad5a:	009407b3          	add	a5,s0,s1
4200ad5e:	0804c563          	bltz	s1,4200ade8 <kbelfx_seg_alloc+0x16e>
4200ad62:	fc87e3e3          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200ad66:	fc0901e3          	beqz	s2,4200ad28 <kbelfx_seg_alloc+0xae>
4200ad6a:	00397713          	and	a4,s2,3
4200ad6e:	ff4d                	bnez	a4,4200ad28 <kbelfx_seg_alloc+0xae>
4200ad70:	fb797ce3          	bgeu	s2,s7,4200ad28 <kbelfx_seg_alloc+0xae>
4200ad74:	01492683          	lw	a3,20(s2)
4200ad78:	0a04c463          	bltz	s1,4200ae20 <kbelfx_seg_alloc+0x1a6>
4200ad7c:	fa87e6e3          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200ad80:	96d6                	add	a3,a3,s5
4200ad82:	00d92823          	sw	a3,16(s2)
        segs[i].paddr        = segs[i].vaddr_real;
4200ad86:	0804ca63          	bltz	s1,4200ae1a <kbelfx_seg_alloc+0x1a0>
4200ad8a:	f887efe3          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200ad8e:	0804c363          	bltz	s1,4200ae14 <kbelfx_seg_alloc+0x19a>
4200ad92:	f887ebe3          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200ad96:	00d92623          	sw	a3,12(s2)
        segs[i].laddr        = segs[i].vaddr_real;
4200ad9a:	0404ca63          	bltz	s1,4200adee <kbelfx_seg_alloc+0x174>
4200ad9e:	f887e5e3          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200ada2:	0404ca63          	bltz	s1,4200adf6 <kbelfx_seg_alloc+0x17c>
4200ada6:	f887e1e3          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200adaa:	00d92423          	sw	a3,8(s2)
        segs[i].alloc_cookie = NULL;
4200adae:	0404ca63          	bltz	s1,4200ae02 <kbelfx_seg_alloc+0x188>
4200adb2:	f687ebe3          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200adb6:	00092023          	sw	zero,0(s2)
        logkf(LOG_DEBUG, "Segment %{size;x} mapped to %{size;x}", i, segs[i].vaddr_real);
4200adba:	0404ca63          	bltz	s1,4200ae0e <kbelfx_seg_alloc+0x194>
4200adbe:	f687e5e3          	bltu	a5,s0,4200ad28 <kbelfx_seg_alloc+0xae>
4200adc2:	864e                	mv	a2,s3
4200adc4:	c1cb0593          	add	a1,s6,-996 # 42018c1c <hextab+0x1f50>
4200adc8:	4511                	li	a0,4
4200adca:	cd0f80ef          	jal	4200329a <logkf>
    for (size_t i = 0; i < segs_len; i++) {
4200adce:	00198793          	add	a5,s3,1
4200add2:	02848493          	add	s1,s1,40
4200add6:	02890913          	add	s2,s2,40
4200adda:	053a0663          	beq	s4,s3,4200ae26 <kbelfx_seg_alloc+0x1ac>
4200adde:	89be                	mv	s3,a5
        segs[i].vaddr_real   = segs[i].vaddr_req - min_addr + vaddr_real;
4200ade0:	009407b3          	add	a5,s0,s1
4200ade4:	f604dfe3          	bgez	s1,4200ad62 <kbelfx_seg_alloc+0xe8>
4200ade8:	f6f47fe3          	bgeu	s0,a5,4200ad66 <kbelfx_seg_alloc+0xec>
    segs[0].alloc_cookie = (void *)vaddr_real;
4200adec:	9002                	ebreak
        segs[i].laddr        = segs[i].vaddr_real;
4200adee:	f2f46de3          	bltu	s0,a5,4200ad28 <kbelfx_seg_alloc+0xae>
4200adf2:	fa04dae3          	bgez	s1,4200ada6 <kbelfx_seg_alloc+0x12c>
4200adf6:	f2f469e3          	bltu	s0,a5,4200ad28 <kbelfx_seg_alloc+0xae>
4200adfa:	00d92423          	sw	a3,8(s2)
        segs[i].alloc_cookie = NULL;
4200adfe:	fa04dae3          	bgez	s1,4200adb2 <kbelfx_seg_alloc+0x138>
4200ae02:	f2f463e3          	bltu	s0,a5,4200ad28 <kbelfx_seg_alloc+0xae>
4200ae06:	00092023          	sw	zero,0(s2)
        logkf(LOG_DEBUG, "Segment %{size;x} mapped to %{size;x}", i, segs[i].vaddr_real);
4200ae0a:	fa04dae3          	bgez	s1,4200adbe <kbelfx_seg_alloc+0x144>
4200ae0e:	faf47ae3          	bgeu	s0,a5,4200adc2 <kbelfx_seg_alloc+0x148>
4200ae12:	bf19                	j	4200ad28 <kbelfx_seg_alloc+0xae>
        segs[i].paddr        = segs[i].vaddr_real;
4200ae14:	f8f471e3          	bgeu	s0,a5,4200ad96 <kbelfx_seg_alloc+0x11c>
    segs[0].alloc_cookie = (void *)vaddr_real;
4200ae18:	9002                	ebreak
        segs[i].paddr        = segs[i].vaddr_real;
4200ae1a:	f6f47ae3          	bgeu	s0,a5,4200ad8e <kbelfx_seg_alloc+0x114>
    segs[0].alloc_cookie = (void *)vaddr_real;
4200ae1e:	9002                	ebreak
        segs[i].vaddr_real   = segs[i].vaddr_req - min_addr + vaddr_real;
4200ae20:	f6f470e3          	bgeu	s0,a5,4200ad80 <kbelfx_seg_alloc+0x106>
    segs[0].alloc_cookie = (void *)vaddr_real;
4200ae24:	9002                	ebreak
4200ae26:	54d2                	lw	s1,52(sp)
4200ae28:	5942                	lw	s2,48(sp)
4200ae2a:	59b2                	lw	s3,44(sp)
4200ae2c:	5a22                	lw	s4,40(sp)
4200ae2e:	5a92                	lw	s5,36(sp)
4200ae30:	5b02                	lw	s6,32(sp)
4200ae32:	4cd2                	lw	s9,20(sp)
4200ae34:	4d42                	lw	s10,16(sp)
4200ae36:	c835                	beqz	s0,4200aeaa <kbelfx_seg_alloc+0x230>
4200ae38:	00347793          	and	a5,s0,3
4200ae3c:	e7bd                	bnez	a5,4200aeaa <kbelfx_seg_alloc+0x230>
4200ae3e:	01842023          	sw	s8,0(s0)
}
4200ae42:	50f2                	lw	ra,60(sp)
4200ae44:	5462                	lw	s0,56(sp)
4200ae46:	4c62                	lw	s8,24(sp)
4200ae48:	4db2                	lw	s11,12(sp)
4200ae4a:	4bf2                	lw	s7,28(sp)
    return true;
4200ae4c:	4505                	li	a0,1
}
4200ae4e:	6121                	add	sp,sp,64
4200ae50:	8082                	ret
4200ae52:	54d2                	lw	s1,52(sp)
4200ae54:	5942                	lw	s2,48(sp)
4200ae56:	59b2                	lw	s3,44(sp)
4200ae58:	5a22                	lw	s4,40(sp)
4200ae5a:	5a92                	lw	s5,36(sp)
4200ae5c:	5b02                	lw	s6,32(sp)
4200ae5e:	4cd2                	lw	s9,20(sp)
4200ae60:	4d42                	lw	s10,16(sp)
        return false;
4200ae62:	4501                	li	a0,0
}
4200ae64:	50f2                	lw	ra,60(sp)
4200ae66:	5462                	lw	s0,56(sp)
4200ae68:	4c62                	lw	s8,24(sp)
4200ae6a:	4db2                	lw	s11,12(sp)
4200ae6c:	4bf2                	lw	s7,28(sp)
4200ae6e:	6121                	add	sp,sp,64
4200ae70:	8082                	ret
    assert_dev_keep(proc != NULL);
4200ae72:	420195b7          	lui	a1,0x42019
4200ae76:	b7858593          	add	a1,a1,-1160 # 42018b78 <hextab+0x1eac>
4200ae7a:	da26                	sw	s1,52(sp)
4200ae7c:	d84a                	sw	s2,48(sp)
4200ae7e:	d64e                	sw	s3,44(sp)
4200ae80:	d452                	sw	s4,40(sp)
4200ae82:	d256                	sw	s5,36(sp)
4200ae84:	d05a                	sw	s6,32(sp)
4200ae86:	cc62                	sw	s8,24(sp)
4200ae88:	ca66                	sw	s9,20(sp)
4200ae8a:	c86a                	sw	s10,16(sp)
4200ae8c:	c66e                	sw	s11,12(sp)
4200ae8e:	bc6f80ef          	jal	42003254 <logk>
4200ae92:	9002                	ebreak
    size_t vaddr_real = proc_map_raw(NULL, proc, min_addr, max_addr - min_addr, min_align);
4200ae94:	85aa                	mv	a1,a0
4200ae96:	4741                	li	a4,16
4200ae98:	4685                	li	a3,1
4200ae9a:	567d                	li	a2,-1
4200ae9c:	4501                	li	a0,0
4200ae9e:	35b000ef          	jal	4200b9f8 <proc_map_raw>
4200aea2:	8c2a                	mv	s8,a0
    if (!vaddr_real)
4200aea4:	f949                	bnez	a0,4200ae36 <kbelfx_seg_alloc+0x1bc>
        return false;
4200aea6:	4501                	li	a0,0
4200aea8:	bf75                	j	4200ae64 <kbelfx_seg_alloc+0x1ea>
4200aeaa:	da26                	sw	s1,52(sp)
4200aeac:	d84a                	sw	s2,48(sp)
4200aeae:	d64e                	sw	s3,44(sp)
4200aeb0:	d452                	sw	s4,40(sp)
4200aeb2:	d256                	sw	s5,36(sp)
4200aeb4:	d05a                	sw	s6,32(sp)
4200aeb6:	ca66                	sw	s9,20(sp)
4200aeb8:	c86a                	sw	s10,16(sp)
    segs[0].alloc_cookie = (void *)vaddr_real;
4200aeba:	9002                	ebreak

4200aebc <kbelfx_seg_free>:
void kbelfx_seg_free(kbelf_inst inst, size_t segs_len, kbelf_segment *segs) {
4200aebc:	1141                	add	sp,sp,-16
4200aebe:	c606                	sw	ra,12(sp)
4200aec0:	c422                	sw	s0,8(sp)
4200aec2:	8432                	mv	s0,a2
    process_t *proc = proc_get(kbelf_inst_getpid(inst));
4200aec4:	50e070ef          	jal	420123d2 <kbelf_inst_getpid>
4200aec8:	2db9                	jal	4200b526 <proc_get>
    assert_dev_keep(proc != NULL);
4200aeca:	cd09                	beqz	a0,4200aee4 <kbelfx_seg_free+0x28>
    proc_unmap_raw(NULL, proc, (size_t)segs[0].alloc_cookie);
4200aecc:	c01d                	beqz	s0,4200aef2 <kbelfx_seg_free+0x36>
4200aece:	00347793          	and	a5,s0,3
4200aed2:	e385                	bnez	a5,4200aef2 <kbelfx_seg_free+0x36>
4200aed4:	4010                	lw	a2,0(s0)
}
4200aed6:	4422                	lw	s0,8(sp)
4200aed8:	40b2                	lw	ra,12(sp)
4200aeda:	85aa                	mv	a1,a0
    proc_unmap_raw(NULL, proc, (size_t)segs[0].alloc_cookie);
4200aedc:	4501                	li	a0,0
}
4200aede:	0141                	add	sp,sp,16
    proc_unmap_raw(NULL, proc, (size_t)segs[0].alloc_cookie);
4200aee0:	1c10006f          	j	4200b8a0 <proc_unmap_raw>
    assert_dev_keep(proc != NULL);
4200aee4:	420195b7          	lui	a1,0x42019
4200aee8:	c4458593          	add	a1,a1,-956 # 42018c44 <hextab+0x1f78>
4200aeec:	b68f80ef          	jal	42003254 <logk>
4200aef0:	9002                	ebreak
    proc_unmap_raw(NULL, proc, (size_t)segs[0].alloc_cookie);
4200aef2:	9002                	ebreak

4200aef4 <kbelfx_open>:
void *kbelfx_open(char const *path) {
4200aef4:	1141                	add	sp,sp,-16
4200aef6:	85aa                	mv	a1,a0
    file_t fd = fs_open(NULL, path, OFLAGS_READONLY);
4200aef8:	4605                	li	a2,1
4200aefa:	4501                	li	a0,0
void *kbelfx_open(char const *path) {
4200aefc:	c606                	sw	ra,12(sp)
    file_t fd = fs_open(NULL, path, OFLAGS_READONLY);
4200aefe:	c8cfb0ef          	jal	4200638a <fs_open>
    if (fd == -1)
4200af02:	57fd                	li	a5,-1
4200af04:	00f50a63          	beq	a0,a5,4200af18 <kbelfx_open+0x24>
        return (void *)(fd + 1);
4200af08:	00150793          	add	a5,a0,1
4200af0c:	00a7ca63          	blt	a5,a0,4200af20 <kbelfx_open+0x2c>
}
4200af10:	40b2                	lw	ra,12(sp)
        return (void *)(fd + 1);
4200af12:	853e                	mv	a0,a5
}
4200af14:	0141                	add	sp,sp,16
4200af16:	8082                	ret
4200af18:	40b2                	lw	ra,12(sp)
        return NULL;
4200af1a:	4501                	li	a0,0
}
4200af1c:	0141                	add	sp,sp,16
4200af1e:	8082                	ret
        return (void *)(fd + 1);
4200af20:	9002                	ebreak

4200af22 <kbelfx_close>:
    fs_close(NULL, (int)fd - 1);
4200af22:	fff50593          	add	a1,a0,-1
4200af26:	00b54563          	blt	a0,a1,4200af30 <kbelfx_close+0xe>
4200af2a:	4501                	li	a0,0
4200af2c:	cf6fc06f          	j	42007422 <fs_close>
4200af30:	9002                	ebreak

4200af32 <kbelfx_getc>:
    fileoff_t len = fs_read(NULL, (int)fd - 1, &buf, 1);
4200af32:	fff50593          	add	a1,a0,-1
4200af36:	02b54363          	blt	a0,a1,4200af5c <kbelfx_getc+0x2a>
int kbelfx_getc(void *fd) {
4200af3a:	1101                	add	sp,sp,-32
    fileoff_t len = fs_read(NULL, (int)fd - 1, &buf, 1);
4200af3c:	4685                	li	a3,1
4200af3e:	00f10613          	add	a2,sp,15
4200af42:	4501                	li	a0,0
int kbelfx_getc(void *fd) {
4200af44:	ce06                	sw	ra,28(sp)
    fileoff_t len = fs_read(NULL, (int)fd - 1, &buf, 1);
4200af46:	fb3fc0ef          	jal	42007ef8 <fs_read>
    return len > 0 ? buf : -1;
4200af4a:	00a05763          	blez	a0,4200af58 <kbelfx_getc+0x26>
4200af4e:	00f14503          	lbu	a0,15(sp)
}
4200af52:	40f2                	lw	ra,28(sp)
4200af54:	6105                	add	sp,sp,32
4200af56:	8082                	ret
    return len > 0 ? buf : -1;
4200af58:	557d                	li	a0,-1
4200af5a:	bfe5                	j	4200af52 <kbelfx_getc+0x20>
    fileoff_t len = fs_read(NULL, (int)fd - 1, &buf, 1);
4200af5c:	9002                	ebreak

4200af5e <kbelfx_read>:
    return fs_read(NULL, (int)fd - 1, buf, buf_len);
4200af5e:	fff50713          	add	a4,a0,-1
int kbelfx_read(void *fd, void *buf, int buf_len) {
4200af62:	86b2                	mv	a3,a2
    return fs_read(NULL, (int)fd - 1, buf, buf_len);
4200af64:	00e54763          	blt	a0,a4,4200af72 <kbelfx_read+0x14>
4200af68:	862e                	mv	a2,a1
4200af6a:	4501                	li	a0,0
4200af6c:	85ba                	mv	a1,a4
4200af6e:	f8bfc06f          	j	42007ef8 <fs_read>
4200af72:	9002                	ebreak

4200af74 <kbelfx_seek>:
int kbelfx_seek(void *fd, long pos) {
4200af74:	1141                	add	sp,sp,-16
4200af76:	c422                	sw	s0,8(sp)
4200af78:	c606                	sw	ra,12(sp)
4200af7a:	842e                	mv	s0,a1
    fileoff_t q = fs_seek(NULL, (int)fd - 1, pos, SEEK_ABS);
4200af7c:	fff50593          	add	a1,a0,-1
4200af80:	02b54163          	blt	a0,a1,4200afa2 <kbelfx_seek+0x2e>
4200af84:	8622                	mv	a2,s0
4200af86:	56fd                	li	a3,-1
4200af88:	4501                	li	a0,0
4200af8a:	d86fd0ef          	jal	42008510 <fs_seek>
}
4200af8e:	40b2                	lw	ra,12(sp)
    return pos == q ? 0 : -1;
4200af90:	40a40533          	sub	a0,s0,a0
}
4200af94:	4422                	lw	s0,8(sp)
    return pos == q ? 0 : -1;
4200af96:	00a03533          	snez	a0,a0
}
4200af9a:	40a00533          	neg	a0,a0
4200af9e:	0141                	add	sp,sp,16
4200afa0:	8082                	ret
    fileoff_t q = fs_seek(NULL, (int)fd - 1, pos, SEEK_ABS);
4200afa2:	9002                	ebreak

4200afa4 <kbelfx_find_lib>:
}
4200afa4:	4501                	li	a0,0
4200afa6:	8082                	ret

4200afa8 <proc_sort_pid_cmp>:
}


// Compare processes by ID.
int proc_sort_pid_cmp(void const *a, void const *b) {
    return (*(process_t **)a)->pid - (*(process_t **)b)->pid;
4200afa8:	c131                	beqz	a0,4200afec <proc_sort_pid_cmp+0x44>
4200afaa:	00357793          	and	a5,a0,3
4200afae:	ef9d                	bnez	a5,4200afec <proc_sort_pid_cmp+0x44>
4200afb0:	411c                	lw	a5,0(a0)
4200afb2:	cf8d                	beqz	a5,4200afec <proc_sort_pid_cmp+0x44>
4200afb4:	0037f713          	and	a4,a5,3
4200afb8:	eb15                	bnez	a4,4200afec <proc_sort_pid_cmp+0x44>
4200afba:	56a1                	li	a3,-24
4200afbc:	02d7f863          	bgeu	a5,a3,4200afec <proc_sort_pid_cmp+0x44>
4200afc0:	4f9c                	lw	a5,24(a5)
4200afc2:	c58d                	beqz	a1,4200afec <proc_sort_pid_cmp+0x44>
4200afc4:	0035f713          	and	a4,a1,3
4200afc8:	e315                	bnez	a4,4200afec <proc_sort_pid_cmp+0x44>
4200afca:	4198                	lw	a4,0(a1)
4200afcc:	c305                	beqz	a4,4200afec <proc_sort_pid_cmp+0x44>
4200afce:	00377613          	and	a2,a4,3
4200afd2:	ee09                	bnez	a2,4200afec <proc_sort_pid_cmp+0x44>
4200afd4:	00d77c63          	bgeu	a4,a3,4200afec <proc_sort_pid_cmp+0x44>
4200afd8:	4f18                	lw	a4,24(a4)
4200afda:	40e78533          	sub	a0,a5,a4
4200afde:	00a7a7b3          	slt	a5,a5,a0
4200afe2:	00072713          	slti	a4,a4,0
4200afe6:	00f71363          	bne	a4,a5,4200afec <proc_sort_pid_cmp+0x44>
}
4200afea:	8082                	ret
    return (*(process_t **)a)->pid - (*(process_t **)b)->pid;
4200afec:	9002                	ebreak

4200afee <prog_memmap_cmp>:

// Memory map address comparator.
static int prog_memmap_cmp(void const *a, void const *b) {
    proc_memmap_ent_t const *a_ptr = a;
    proc_memmap_ent_t const *b_ptr = b;
    if (a_ptr->base < b_ptr->base)
4200afee:	cd19                	beqz	a0,4200b00c <prog_memmap_cmp+0x1e>
4200aff0:	00357793          	and	a5,a0,3
4200aff4:	ef81                	bnez	a5,4200b00c <prog_memmap_cmp+0x1e>
4200aff6:	4108                	lw	a0,0(a0)
4200aff8:	c991                	beqz	a1,4200b00c <prog_memmap_cmp+0x1e>
4200affa:	0035f793          	and	a5,a1,3
4200affe:	e799                	bnez	a5,4200b00c <prog_memmap_cmp+0x1e>
4200b000:	419c                	lw	a5,0(a1)
        return -1;
4200b002:	00f53533          	sltu	a0,a0,a5
    if (a_ptr->base < b_ptr->base)
        return 1;
    return 0;
}
4200b006:	40a00533          	neg	a0,a0
4200b00a:	8082                	ret
    if (a_ptr->base < b_ptr->base)
4200b00c:	9002                	ebreak

4200b00e <proc_setargs_raw.part.0>:
void proc_setargs_raw(badge_err_t *ec, process_t *process, int argc, char const *const *argv) {
4200b00e:	715d                	add	sp,sp,-80
4200b010:	c686                	sw	ra,76(sp)
4200b012:	c4a2                	sw	s0,72(sp)
4200b014:	c2a6                	sw	s1,68(sp)
4200b016:	c0ca                	sw	s2,64(sp)
4200b018:	de4e                	sw	s3,60(sp)
4200b01a:	dc52                	sw	s4,56(sp)
4200b01c:	da56                	sw	s5,52(sp)
4200b01e:	d85a                	sw	s6,48(sp)
4200b020:	d65e                	sw	s7,44(sp)
4200b022:	d462                	sw	s8,40(sp)
4200b024:	d266                	sw	s9,36(sp)
4200b026:	d06a                	sw	s10,32(sp)
4200b028:	ce6e                	sw	s11,28(sp)
4200b02a:	c42a                	sw	a0,8(sp)
    mutex_acquire(NULL, &process->mtx, TIMESTAMP_US_MAX);
4200b02c:	12058863          	beqz	a1,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b030:	0035f793          	and	a5,a1,3
4200b034:	89ae                	mv	s3,a1
4200b036:	12079363          	bnez	a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b03a:	f5800793          	li	a5,-168
4200b03e:	10f5ff63          	bgeu	a1,a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b042:	8436                	mv	s0,a3
4200b044:	0a858793          	add	a5,a1,168
4200b048:	8bb2                	mv	s7,a2
4200b04a:	800006b7          	lui	a3,0x80000
4200b04e:	567d                	li	a2,-1
4200b050:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200b052:	85be                	mv	a1,a5
4200b054:	4501                	li	a0,0
    size_t required = sizeof(size_t) * (size_t)argc;
4200b056:	002b9a13          	sll	s4,s7,0x2
    mutex_acquire(NULL, &process->mtx, TIMESTAMP_US_MAX);
4200b05a:	c63e                	sw	a5,12(sp)
4200b05c:	8aa2                	mv	s5,s0
4200b05e:	e14f80ef          	jal	42003672 <mutex_acquire>
    size_t required = sizeof(size_t) * (size_t)argc;
4200b062:	84a2                	mv	s1,s0
4200b064:	8b52                	mv	s6,s4
    for (size_t i = 0; i < (size_t)argc; i++) {
4200b066:	4901                	li	s2,0
        required += cstr_length(argv[i]) + 1;
4200b068:	00291793          	sll	a5,s2,0x2
4200b06c:	00f40733          	add	a4,s0,a5
4200b070:	0e07c463          	bltz	a5,4200b158 <proc_setargs_raw.part.0+0x14a>
4200b074:	0e876463          	bltu	a4,s0,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b078:	c0f5                	beqz	s1,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b07a:	0034f793          	and	a5,s1,3
4200b07e:	eff9                	bnez	a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b080:	4088                	lw	a0,0(s1)
    for (size_t i = 0; i < (size_t)argc; i++) {
4200b082:	0905                	add	s2,s2,1
4200b084:	0491                	add	s1,s1,4
        required += cstr_length(argv[i]) + 1;
4200b086:	cd5f60ef          	jal	42001d5a <cstr_length>
4200b08a:	0505                	add	a0,a0,1
4200b08c:	9b2a                	add	s6,s6,a0
    for (size_t i = 0; i < (size_t)argc; i++) {
4200b08e:	fd796de3          	bltu	s2,s7,4200b068 <proc_setargs_raw.part.0+0x5a>
    char *mem = realloc(process->argv, required);
4200b092:	0049a503          	lw	a0,4(s3)
4200b096:	85da                	mv	a1,s6
4200b098:	33b020ef          	jal	4200dbd2 <realloc>
4200b09c:	84aa                	mv	s1,a0
    if (!mem) {
4200b09e:	c175                	beqz	a0,4200b182 <proc_setargs_raw.part.0+0x174>
    for (size_t i = 0; i < (size_t)argc; i++) {
4200b0a0:	8b2a                	mv	s6,a0
4200b0a2:	4d81                	li	s11,0
        *(char **)(mem + sizeof(size_t) * i) = (mem + off);
4200b0a4:	002d9993          	sll	s3,s11,0x2
4200b0a8:	013487b3          	add	a5,s1,s3
4200b0ac:	0a09c963          	bltz	s3,4200b15e <proc_setargs_raw.part.0+0x150>
4200b0b0:	0a97e663          	bltu	a5,s1,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b0b4:	01448933          	add	s2,s1,s4
4200b0b8:	0a0a4963          	bltz	s4,4200b16a <proc_setargs_raw.part.0+0x15c>
4200b0bc:	0a996063          	bltu	s2,s1,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b0c0:	080b0e63          	beqz	s6,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b0c4:	003b7793          	and	a5,s6,3
4200b0c8:	ebd1                	bnez	a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b0ca:	012b2023          	sw	s2,0(s6)
        size_t len = cstr_length(argv[i]);
4200b0ce:	01340c33          	add	s8,s0,s3
4200b0d2:	0a09c563          	bltz	s3,4200b17c <proc_setargs_raw.part.0+0x16e>
4200b0d6:	088c6363          	bltu	s8,s0,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b0da:	080a8163          	beqz	s5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b0de:	003af713          	and	a4,s5,3
4200b0e2:	ef2d                	bnez	a4,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b0e4:	000aac83          	lw	s9,0(s5)
4200b0e8:	8566                	mv	a0,s9
4200b0ea:	c71f60ef          	jal	42001d5a <cstr_length>
4200b0ee:	8d2a                	mv	s10,a0
        mem_copy(mem + off, argv[i], len + 1);
4200b0f0:	080a4363          	bltz	s4,4200b176 <proc_setargs_raw.part.0+0x168>
4200b0f4:	06996463          	bltu	s2,s1,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b0f8:	0609cc63          	bltz	s3,4200b170 <proc_setargs_raw.part.0+0x162>
4200b0fc:	068c6063          	bltu	s8,s0,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b100:	001d0613          	add	a2,s10,1
4200b104:	85e6                	mv	a1,s9
4200b106:	854a                	mv	a0,s2
    for (size_t i = 0; i < (size_t)argc; i++) {
4200b108:	0d85                	add	s11,s11,1
        mem_copy(mem + off, argv[i], len + 1);
4200b10a:	a62f70ef          	jal	4200236c <mem_copy>
        off += len;
4200b10e:	9a6a                	add	s4,s4,s10
    for (size_t i = 0; i < (size_t)argc; i++) {
4200b110:	0b11                	add	s6,s6,4
4200b112:	0a91                	add	s5,s5,4
4200b114:	f97de8e3          	bltu	s11,s7,4200b0a4 <proc_setargs_raw.part.0+0x96>
    mutex_release(NULL, &process->mtx);
4200b118:	45b2                	lw	a1,12(sp)
4200b11a:	4501                	li	a0,0
4200b11c:	ee8f80ef          	jal	42003804 <mutex_release>
    badge_err_set_ok(ec);
4200b120:	47a2                	lw	a5,8(sp)
4200b122:	cf81                	beqz	a5,4200b13a <proc_setargs_raw.part.0+0x12c>
4200b124:	8b8d                	and	a5,a5,3
4200b126:	eb9d                	bnez	a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b128:	4722                	lw	a4,8(sp)
4200b12a:	57f1                	li	a5,-4
4200b12c:	02f77863          	bgeu	a4,a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b130:	47a2                	lw	a5,8(sp)
4200b132:	0007a223          	sw	zero,4(a5)
4200b136:	0007a023          	sw	zero,0(a5)
}
4200b13a:	40b6                	lw	ra,76(sp)
4200b13c:	4426                	lw	s0,72(sp)
4200b13e:	4496                	lw	s1,68(sp)
4200b140:	4906                	lw	s2,64(sp)
4200b142:	59f2                	lw	s3,60(sp)
4200b144:	5a62                	lw	s4,56(sp)
4200b146:	5ad2                	lw	s5,52(sp)
4200b148:	5b42                	lw	s6,48(sp)
4200b14a:	5bb2                	lw	s7,44(sp)
4200b14c:	5c22                	lw	s8,40(sp)
4200b14e:	5c92                	lw	s9,36(sp)
4200b150:	5d02                	lw	s10,32(sp)
4200b152:	4df2                	lw	s11,28(sp)
4200b154:	6161                	add	sp,sp,80
4200b156:	8082                	ret
        required += cstr_length(argv[i]) + 1;
4200b158:	f2e470e3          	bgeu	s0,a4,4200b078 <proc_setargs_raw.part.0+0x6a>
    badge_err_set_ok(ec);
4200b15c:	9002                	ebreak
        *(char **)(mem + sizeof(size_t) * i) = (mem + off);
4200b15e:	fef4efe3          	bltu	s1,a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b162:	01448933          	add	s2,s1,s4
4200b166:	f40a5be3          	bgez	s4,4200b0bc <proc_setargs_raw.part.0+0xae>
4200b16a:	f524fbe3          	bgeu	s1,s2,4200b0c0 <proc_setargs_raw.part.0+0xb2>
    badge_err_set_ok(ec);
4200b16e:	9002                	ebreak
        mem_copy(mem + off, argv[i], len + 1);
4200b170:	f98478e3          	bgeu	s0,s8,4200b100 <proc_setargs_raw.part.0+0xf2>
    badge_err_set_ok(ec);
4200b174:	9002                	ebreak
        mem_copy(mem + off, argv[i], len + 1);
4200b176:	f924f1e3          	bgeu	s1,s2,4200b0f8 <proc_setargs_raw.part.0+0xea>
    badge_err_set_ok(ec);
4200b17a:	9002                	ebreak
        size_t len = cstr_length(argv[i]);
4200b17c:	f5847fe3          	bgeu	s0,s8,4200b0da <proc_setargs_raw.part.0+0xcc>
    badge_err_set_ok(ec);
4200b180:	9002                	ebreak
        mutex_release(NULL, &process->mtx);
4200b182:	45b2                	lw	a1,12(sp)
4200b184:	e80f80ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b188:	4422                	lw	s0,8(sp)
4200b18a:	d845                	beqz	s0,4200b13a <proc_setargs_raw.part.0+0x12c>
4200b18c:	420175b7          	lui	a1,0x42017
4200b190:	4699                	li	a3,6
4200b192:	463d                	li	a2,15
4200b194:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200b198:	4511                	li	a0,4
4200b19a:	00000717          	auipc	a4,0x0
4200b19e:	8fcf80ef          	jal	4200329a <logkf>
4200b1a2:	00347793          	and	a5,s0,3
4200b1a6:	fbdd                	bnez	a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b1a8:	4722                	lw	a4,8(sp)
4200b1aa:	57f1                	li	a5,-4
4200b1ac:	faf778e3          	bgeu	a4,a5,4200b15c <proc_setargs_raw.part.0+0x14e>
4200b1b0:	4722                	lw	a4,8(sp)
4200b1b2:	47bd                	li	a5,15
4200b1b4:	c35c                	sw	a5,4(a4)
4200b1b6:	4799                	li	a5,6
4200b1b8:	c31c                	sw	a5,0(a4)
4200b1ba:	b741                	j	4200b13a <proc_setargs_raw.part.0+0x12c>

4200b1bc <proc_exit_self>:
void proc_exit_self(int code) {
4200b1bc:	1141                	add	sp,sp,-16
4200b1be:	c226                	sw	s1,4(sp)
4200b1c0:	c606                	sw	ra,12(sp)
4200b1c2:	c422                	sw	s0,8(sp)
4200b1c4:	c04a                	sw	s2,0(sp)
4200b1c6:	84aa                	mv	s1,a0
    sched_thread_t *thread  = sched_get_current_thread();
4200b1c8:	6ed020ef          	jal	4200e0b4 <sched_get_current_thread>
    process_t      *process = thread->process;
4200b1cc:	c151                	beqz	a0,4200b250 <proc_exit_self+0x94>
4200b1ce:	00357793          	and	a5,a0,3
4200b1d2:	efbd                	bnez	a5,4200b250 <proc_exit_self+0x94>
4200b1d4:	4100                	lw	s0,0(a0)
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200b1d6:	cc2d                	beqz	s0,4200b250 <proc_exit_self+0x94>
4200b1d8:	00347793          	and	a5,s0,3
4200b1dc:	ebb5                	bnez	a5,4200b250 <proc_exit_self+0x94>
4200b1de:	f5800793          	li	a5,-168
4200b1e2:	06f47763          	bgeu	s0,a5,4200b250 <proc_exit_self+0x94>
4200b1e6:	0a840913          	add	s2,s0,168
4200b1ea:	6631                	lui	a2,0xc
4200b1ec:	35060613          	add	a2,a2,848 # c350 <__stack_size+0xa350>
4200b1f0:	4681                	li	a3,0
4200b1f2:	85ca                	mv	a1,s2
4200b1f4:	4501                	li	a0,0
4200b1f6:	c7cf80ef          	jal	42003672 <mutex_acquire>
4200b1fa:	c521                	beqz	a0,4200b242 <proc_exit_self+0x86>
    process->flags     |= PROC_EXITING;
4200b1fc:	f4c00793          	li	a5,-180
4200b200:	04f47863          	bgeu	s0,a5,4200b250 <proc_exit_self+0x94>
4200b204:	4789                	li	a5,2
4200b206:	0b440713          	add	a4,s0,180
4200b20a:	0f50000f          	fence	iorw,ow
4200b20e:	44f7202f          	amoor.w.aq	zero,a5,(a4)
    process->exit_code  = code;
4200b212:	f4800793          	li	a5,-184
4200b216:	02f47d63          	bgeu	s0,a5,4200b250 <proc_exit_self+0x94>
4200b21a:	0a942c23          	sw	s1,184(s0)
    mutex_release(NULL, &process->mtx);
4200b21e:	85ca                	mv	a1,s2
4200b220:	4501                	li	a0,0
4200b222:	de2f80ef          	jal	42003804 <mutex_release>
    hk_add_once(0, clean_up_from_housekeeping, (void *)process->pid);
4200b226:	4c14                	lw	a3,24(s0)
}
4200b228:	4422                	lw	s0,8(sp)
4200b22a:	40b2                	lw	ra,12(sp)
4200b22c:	4492                	lw	s1,4(sp)
4200b22e:	4902                	lw	s2,0(sp)
    hk_add_once(0, clean_up_from_housekeeping, (void *)process->pid);
4200b230:	4200c637          	lui	a2,0x4200c
4200b234:	4a460613          	add	a2,a2,1188 # 4200c4a4 <clean_up_from_housekeeping>
4200b238:	4501                	li	a0,0
4200b23a:	4581                	li	a1,0
}
4200b23c:	0141                	add	sp,sp,16
    hk_add_once(0, clean_up_from_housekeeping, (void *)process->pid);
4200b23e:	1e30106f          	j	4200cc20 <hk_add_once>
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200b242:	420195b7          	lui	a1,0x42019
4200b246:	cd458593          	add	a1,a1,-812 # 42018cd4 <hextab+0x2008>
4200b24a:	80af80ef          	jal	42003254 <logk>
4200b24e:	9002                	ebreak
    process->exit_code  = code;
4200b250:	9002                	ebreak

4200b252 <proc_create_raw>:
process_t *proc_create_raw(badge_err_t *ec) {
4200b252:	7111                	add	sp,sp,-256
4200b254:	d1da                	sw	s6,224(sp)
    mutex_acquire(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200b256:	800006b7          	lui	a3,0x80000
process_t *proc_create_raw(badge_err_t *ec) {
4200b25a:	d7ce                	sw	s3,236(sp)
    mutex_acquire(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200b25c:	567d                	li	a2,-1
process_t *proc_create_raw(badge_err_t *ec) {
4200b25e:	89aa                	mv	s3,a0
    mutex_acquire(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200b260:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200b262:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200b266:	4501                	li	a0,0
process_t *proc_create_raw(badge_err_t *ec) {
4200b268:	df86                	sw	ra,252(sp)
4200b26a:	dba6                	sw	s1,244(sp)
    mutex_acquire(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200b26c:	c06f80ef          	jal	42003672 <mutex_acquire>
    process_t *handle = malloc(sizeof(process_t));
4200b270:	0bc00513          	li	a0,188
4200b274:	6dc020ef          	jal	4200d950 <malloc>
    if (!handle) {
4200b278:	1c050663          	beqz	a0,4200b444 <proc_create_raw+0x1f2>
4200b27c:	dda2                	sw	s0,248(sp)
4200b27e:	d3d6                	sw	s5,228(sp)
4200b280:	d9ca                	sw	s2,240(sp)
    *handle = (process_t){
4200b282:	d5d2                	sw	s4,232(sp)
4200b284:	cfde                	sw	s7,220(sp)
4200b286:	cde2                	sw	s8,216(sp)
4200b288:	cbe6                	sw	s9,212(sp)
4200b28a:	00357793          	and	a5,a0,3
4200b28e:	32c1a403          	lw	s0,812(gp) # 4080032c <pid_counter>
4200b292:	84aa                	mv	s1,a0
4200b294:	1a079763          	bnez	a5,4200b442 <proc_create_raw+0x1f0>
4200b298:	0bc00613          	li	a2,188
4200b29c:	4581                	li	a1,0
4200b29e:	e78f70ef          	jal	42002916 <memset>
4200b2a2:	57a1                	li	a5,-24
4200b2a4:	18f4ff63          	bgeu	s1,a5,4200b442 <proc_create_raw+0x1f0>
4200b2a8:	cc80                	sw	s0,24(s1)
4200b2aa:	f5800793          	li	a5,-168
4200b2ae:	18f4fa63          	bgeu	s1,a5,4200b442 <proc_create_raw+0x1f0>
4200b2b2:	cafec7b7          	lui	a5,0xcafec
4200b2b6:	abe78793          	add	a5,a5,-1346 # cafebabe <__stop_free_lpsram+0x7afe7abe>
4200b2ba:	0af4a423          	sw	a5,168(s1)
4200b2be:	f5400793          	li	a5,-172
4200b2c2:	18f4f063          	bgeu	s1,a5,4200b442 <proc_create_raw+0x1f0>
4200b2c6:	4785                	li	a5,1
4200b2c8:	0af48623          	sb	a5,172(s1)
    process_t         dummy = {.pid = pid_counter};
4200b2cc:	0bc00613          	li	a2,188
4200b2d0:	4581                	li	a1,0
4200b2d2:	0848                	add	a0,sp,20
4200b2d4:	e42f70ef          	jal	42002916 <memset>
    array_binsearch_t res   = array_binsearch(procs, sizeof(process_t *), procs_len, &dummy, proc_sort_pid_cmp);
4200b2d8:	4080abb7          	lui	s7,0x4080a
4200b2dc:	4080aa37          	lui	s4,0x4080a
4200b2e0:	e44ba603          	lw	a2,-444(s7) # 40809e44 <procs_len>
4200b2e4:	e3ca2503          	lw	a0,-452(s4) # 40809e3c <procs>
4200b2e8:	4200b737          	lui	a4,0x4200b
4200b2ec:	fa870713          	add	a4,a4,-88 # 4200afa8 <proc_sort_pid_cmp>
4200b2f0:	0854                	add	a3,sp,20
4200b2f2:	4591                	li	a1,4
    process_t         dummy = {.pid = pid_counter};
4200b2f4:	d622                	sw	s0,44(sp)
// Resize a length-based dynamically allocated array.
static inline bool array_lencap_resize(
    void *_array_ptr, size_t ent_size, size_t *ent_count_ptr, size_t *ent_cap_ptr, size_t new_ent_count
) {
    void **array_ptr = _array_ptr;
    if (*ent_cap_ptr >= new_ent_count) {
4200b2f6:	4080acb7          	lui	s9,0x4080a
    array_binsearch_t res   = array_binsearch(procs, sizeof(process_t *), procs_len, &dummy, proc_sort_pid_cmp);
4200b2fa:	fc8f50ef          	jal	42000ac2 <array_binsearch>
// Insert an element into a dynamically allocated array.
static inline bool array_lencap_insert(
    void *_array_ptr, size_t ent_size, size_t *ent_count_ptr, size_t *ent_cap_ptr, void const *insert, size_t index
) {
    void **array_ptr = _array_ptr;
    if (array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr + 1)) {
4200b2fe:	e44ba903          	lw	s2,-444(s7)
    if (*ent_cap_ptr >= new_ent_count) {
4200b302:	e40ca403          	lw	s0,-448(s9) # 40809e40 <procs_cap>
4200b306:	8c2a                	mv	s8,a0
    if (array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr + 1)) {
4200b308:	0905                	add	s2,s2,1
    if (*ent_cap_ptr >= new_ent_count) {
4200b30a:	13247563          	bgeu	s0,s2,4200b434 <proc_create_raw+0x1e2>
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200b30e:	cc45                	beqz	s0,4200b3c6 <proc_create_raw+0x174>
    while (new_cap < new_ent_count) new_cap *= 2;
4200b310:	0406                	sll	s0,s0,0x1
4200b312:	ff246fe3          	bltu	s0,s2,4200b310 <proc_create_raw+0xbe>
    void *mem = realloc(*array_ptr, ent_size * new_cap);
4200b316:	e3ca2503          	lw	a0,-452(s4)
4200b31a:	00241593          	sll	a1,s0,0x2
4200b31e:	0b5020ef          	jal	4200dbd2 <realloc>
4200b322:	85aa                	mv	a1,a0
    if (!mem)
4200b324:	c945                	beqz	a0,4200b3d4 <proc_create_raw+0x182>
    *array_ptr     = mem;
4200b326:	e2aa2e23          	sw	a0,-452(s4)
    *ent_count_ptr = new_ent_count;
4200b32a:	e52ba223          	sw	s2,-444(s7)
    *ent_cap_ptr   = new_cap;
4200b32e:	e48ca023          	sw	s0,-448(s9)
    array_copy(array, array, ent_size, index + 1, index, ent_count - index);
4200b332:	001c0513          	add	a0,s8,1
        (void *)((size_t)array_dst + ent_size * dst_index),
4200b336:	050a                	sll	a0,a0,0x2
        (void *)((size_t)array_src + ent_size * src_index),
4200b338:	ffc50413          	add	s0,a0,-4
    array_copy(array, array, ent_size, index + 1, index, ent_count - index);
4200b33c:	41890633          	sub	a2,s2,s8
        (void *)((size_t)array_dst + ent_size * dst_index),
4200b340:	952e                	add	a0,a0,a1
    __builtin_memmove(
4200b342:	060a                	sll	a2,a2,0x2
        (void *)((size_t)array_src + ent_size * src_index),
4200b344:	95a2                	add	a1,a1,s0
    __builtin_memmove(
4200b346:	0e050e63          	beqz	a0,4200b442 <proc_create_raw+0x1f0>
4200b34a:	0e058c63          	beqz	a1,4200b442 <proc_create_raw+0x1f0>
4200b34e:	df4f70ef          	jal	42002942 <memmove>
    procs[res.index] = handle;
4200b352:	e3ca2703          	lw	a4,-452(s4)
4200b356:	008707b3          	add	a5,a4,s0
4200b35a:	0e044263          	bltz	s0,4200b43e <proc_create_raw+0x1ec>
4200b35e:	0ee7e263          	bltu	a5,a4,4200b442 <proc_create_raw+0x1f0>
4200b362:	c3e5                	beqz	a5,4200b442 <proc_create_raw+0x1f0>
4200b364:	0037f713          	and	a4,a5,3
4200b368:	ef69                	bnez	a4,4200b442 <proc_create_raw+0x1f0>
    pid_counter++;
4200b36a:	32c1a703          	lw	a4,812(gp) # 4080032c <pid_counter>
    procs[res.index] = handle;
4200b36e:	c384                	sw	s1,0(a5)
    pid_counter++;
4200b370:	00170793          	add	a5,a4,1
4200b374:	0ce7c763          	blt	a5,a4,4200b442 <proc_create_raw+0x1f0>

// Generate MPU configuration cache for a given process.
// The ESP32-C6 only has support for PMPs.
// Returns `true` if the memory map can be represented with the configured amount of PMPs.
static inline bool proc_mpu_gen(proc_memmap_t *memmap) {
    return proc_riscv_pmp_gen(memmap);
4200b378:	01c48513          	add	a0,s1,28
4200b37c:	32f1a623          	sw	a5,812(gp) # 4080032c <pid_counter>
4200b380:	1cd030ef          	jal	4200ed4c <proc_riscv_pmp_gen>
    assert_dev_drop(proc_mpu_gen(&handle->memmap));
4200b384:	0e050e63          	beqz	a0,4200b480 <proc_create_raw+0x22e>
    mutex_release(NULL, &proc_mtx);
4200b388:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200b38c:	4501                	li	a0,0
4200b38e:	c76f80ef          	jal	42003804 <mutex_release>
    badge_err_set_ok(ec);
4200b392:	00098c63          	beqz	s3,4200b3aa <proc_create_raw+0x158>
4200b396:	0039f793          	and	a5,s3,3
4200b39a:	e7c5                	bnez	a5,4200b442 <proc_create_raw+0x1f0>
4200b39c:	57f1                	li	a5,-4
4200b39e:	0af9f263          	bgeu	s3,a5,4200b442 <proc_create_raw+0x1f0>
4200b3a2:	0009a223          	sw	zero,4(s3)
4200b3a6:	0009a023          	sw	zero,0(s3)
4200b3aa:	546e                	lw	s0,248(sp)
}
4200b3ac:	50fe                	lw	ra,252(sp)
4200b3ae:	594e                	lw	s2,240(sp)
4200b3b0:	5a2e                	lw	s4,232(sp)
4200b3b2:	5a9e                	lw	s5,228(sp)
4200b3b4:	4bfe                	lw	s7,220(sp)
4200b3b6:	4c6e                	lw	s8,216(sp)
4200b3b8:	4cde                	lw	s9,212(sp)
4200b3ba:	59be                	lw	s3,236(sp)
4200b3bc:	5b0e                	lw	s6,224(sp)
4200b3be:	8526                	mv	a0,s1
4200b3c0:	54de                	lw	s1,244(sp)
4200b3c2:	6111                	add	sp,sp,256
4200b3c4:	8082                	ret
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200b3c6:	4409                	li	s0,2
    while (new_cap < new_ent_count) new_cap *= 2;
4200b3c8:	f52477e3          	bgeu	s0,s2,4200b316 <proc_create_raw+0xc4>
4200b3cc:	0406                	sll	s0,s0,0x1
4200b3ce:	f52461e3          	bltu	s0,s2,4200b310 <proc_create_raw+0xbe>
4200b3d2:	b791                	j	4200b316 <proc_create_raw+0xc4>
        free(handle);
4200b3d4:	8526                	mv	a0,s1
4200b3d6:	786020ef          	jal	4200db5c <free>
        mutex_release(NULL, &proc_mtx);
4200b3da:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200b3de:	4501                	li	a0,0
4200b3e0:	c24f80ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b3e4:	02098963          	beqz	s3,4200b416 <proc_create_raw+0x1c4>
4200b3e8:	420175b7          	lui	a1,0x42017
4200b3ec:	4699                	li	a3,6
4200b3ee:	463d                	li	a2,15
4200b3f0:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200b3f4:	4511                	li	a0,4
4200b3f6:	00000717          	auipc	a4,0x0
4200b3fa:	ea1f70ef          	jal	4200329a <logkf>
4200b3fe:	0039f793          	and	a5,s3,3
4200b402:	e3a1                	bnez	a5,4200b442 <proc_create_raw+0x1f0>
4200b404:	57f1                	li	a5,-4
4200b406:	02f9fe63          	bgeu	s3,a5,4200b442 <proc_create_raw+0x1f0>
4200b40a:	47bd                	li	a5,15
4200b40c:	00f9a223          	sw	a5,4(s3)
4200b410:	4799                	li	a5,6
4200b412:	00f9a023          	sw	a5,0(s3)
4200b416:	546e                	lw	s0,248(sp)
4200b418:	594e                	lw	s2,240(sp)
4200b41a:	5a2e                	lw	s4,232(sp)
4200b41c:	5a9e                	lw	s5,228(sp)
4200b41e:	4bfe                	lw	s7,220(sp)
4200b420:	4c6e                	lw	s8,216(sp)
4200b422:	4cde                	lw	s9,212(sp)
}
4200b424:	50fe                	lw	ra,252(sp)
        return NULL;
4200b426:	4481                	li	s1,0
}
4200b428:	59be                	lw	s3,236(sp)
4200b42a:	5b0e                	lw	s6,224(sp)
4200b42c:	8526                	mv	a0,s1
4200b42e:	54de                	lw	s1,244(sp)
4200b430:	6111                	add	sp,sp,256
4200b432:	8082                	ret
        array_insert(*array_ptr, ent_size, *ent_count_ptr, insert, index);
4200b434:	e3ca2583          	lw	a1,-452(s4)
        *ent_count_ptr = new_ent_count;
4200b438:	e52ba223          	sw	s2,-444(s7)
        return true;
4200b43c:	bddd                	j	4200b332 <proc_create_raw+0xe0>
    procs[res.index] = handle;
4200b43e:	f2f772e3          	bgeu	a4,a5,4200b362 <proc_create_raw+0x110>
    badge_err_set_ok(ec);
4200b442:	9002                	ebreak
        mutex_release(NULL, &proc_mtx);
4200b444:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200b448:	bbcf80ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b44c:	fc098ce3          	beqz	s3,4200b424 <proc_create_raw+0x1d2>
4200b450:	420175b7          	lui	a1,0x42017
4200b454:	4699                	li	a3,6
4200b456:	463d                	li	a2,15
4200b458:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200b45c:	4511                	li	a0,4
4200b45e:	00000717          	auipc	a4,0x0
4200b462:	e39f70ef          	jal	4200329a <logkf>
4200b466:	0039f793          	and	a5,s3,3
4200b46a:	e395                	bnez	a5,4200b48e <proc_create_raw+0x23c>
4200b46c:	57f1                	li	a5,-4
4200b46e:	02f9f063          	bgeu	s3,a5,4200b48e <proc_create_raw+0x23c>
4200b472:	47bd                	li	a5,15
4200b474:	00f9a223          	sw	a5,4(s3)
4200b478:	4799                	li	a5,6
4200b47a:	00f9a023          	sw	a5,0(s3)
4200b47e:	b75d                	j	4200b424 <proc_create_raw+0x1d2>
    assert_dev_drop(proc_mpu_gen(&handle->memmap));
4200b480:	420195b7          	lui	a1,0x42019
4200b484:	d6c58593          	add	a1,a1,-660 # 42018d6c <hextab+0x20a0>
4200b488:	dcdf70ef          	jal	42003254 <logk>
4200b48c:	9002                	ebreak
4200b48e:	dda2                	sw	s0,248(sp)
4200b490:	d9ca                	sw	s2,240(sp)
4200b492:	d5d2                	sw	s4,232(sp)
4200b494:	d3d6                	sw	s5,228(sp)
4200b496:	cfde                	sw	s7,220(sp)
4200b498:	cde2                	sw	s8,216(sp)
4200b49a:	cbe6                	sw	s9,212(sp)
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b49c:	9002                	ebreak

4200b49e <proc_get_unsafe>:
process_t *proc_get_unsafe(pid_t pid) {
4200b49e:	7115                	add	sp,sp,-224
    process_t         dummy     = {.pid = pid};
4200b4a0:	085c                	add	a5,sp,20
process_t *proc_get_unsafe(pid_t pid) {
4200b4a2:	cda2                	sw	s0,216(sp)
    process_t         dummy     = {.pid = pid};
4200b4a4:	0bc00613          	li	a2,188
process_t *proc_get_unsafe(pid_t pid) {
4200b4a8:	842a                	mv	s0,a0
    process_t         dummy     = {.pid = pid};
4200b4aa:	4581                	li	a1,0
4200b4ac:	853e                	mv	a0,a5
process_t *proc_get_unsafe(pid_t pid) {
4200b4ae:	cf86                	sw	ra,220(sp)
4200b4b0:	cba6                	sw	s1,212(sp)
    process_t         dummy     = {.pid = pid};
4200b4b2:	c64f70ef          	jal	42002916 <memset>
    array_binsearch_t res       = array_binsearch(procs, sizeof(process_t *), procs_len, &dummy_ptr, proc_sort_pid_cmp);
4200b4b6:	4080a737          	lui	a4,0x4080a
4200b4ba:	4080a4b7          	lui	s1,0x4080a
    process_t         dummy     = {.pid = pid};
4200b4be:	87aa                	mv	a5,a0
    array_binsearch_t res       = array_binsearch(procs, sizeof(process_t *), procs_len, &dummy_ptr, proc_sort_pid_cmp);
4200b4c0:	e4472603          	lw	a2,-444(a4) # 40809e44 <procs_len>
4200b4c4:	e3c4a503          	lw	a0,-452(s1) # 40809e3c <procs>
4200b4c8:	4200b737          	lui	a4,0x4200b
4200b4cc:	fa870713          	add	a4,a4,-88 # 4200afa8 <proc_sort_pid_cmp>
4200b4d0:	0034                	add	a3,sp,8
4200b4d2:	4591                	li	a1,4
    process_t        *dummy_ptr = &dummy;
4200b4d4:	c43e                	sw	a5,8(sp)
    process_t         dummy     = {.pid = pid};
4200b4d6:	d622                	sw	s0,44(sp)
    array_binsearch_t res       = array_binsearch(procs, sizeof(process_t *), procs_len, &dummy_ptr, proc_sort_pid_cmp);
4200b4d8:	deaf50ef          	jal	42000ac2 <array_binsearch>
4200b4dc:	c82e                	sw	a1,16(sp)
4200b4de:	c62a                	sw	a0,12(sp)
    return res.found ? procs[res.index] : NULL;
4200b4e0:	0ff5f593          	zext.b	a1,a1
4200b4e4:	4785                	li	a5,1
4200b4e6:	02b7e963          	bltu	a5,a1,4200b518 <proc_get_unsafe+0x7a>
4200b4ea:	8985                	and	a1,a1,1
4200b4ec:	c59d                	beqz	a1,4200b51a <proc_get_unsafe+0x7c>
4200b4ee:	e3c4a703          	lw	a4,-452(s1)
4200b4f2:	050a                	sll	a0,a0,0x2
4200b4f4:	00a707b3          	add	a5,a4,a0
4200b4f8:	00055e63          	bgez	a0,4200b514 <proc_get_unsafe+0x76>
4200b4fc:	00f76e63          	bltu	a4,a5,4200b518 <proc_get_unsafe+0x7a>
4200b500:	cf81                	beqz	a5,4200b518 <proc_get_unsafe+0x7a>
4200b502:	0037f713          	and	a4,a5,3
4200b506:	eb09                	bnez	a4,4200b518 <proc_get_unsafe+0x7a>
}
4200b508:	40fe                	lw	ra,220(sp)
4200b50a:	446e                	lw	s0,216(sp)
    return res.found ? procs[res.index] : NULL;
4200b50c:	4388                	lw	a0,0(a5)
}
4200b50e:	44de                	lw	s1,212(sp)
4200b510:	612d                	add	sp,sp,224
4200b512:	8082                	ret
    return res.found ? procs[res.index] : NULL;
4200b514:	fee7f6e3          	bgeu	a5,a4,4200b500 <proc_get_unsafe+0x62>
4200b518:	9002                	ebreak
}
4200b51a:	40fe                	lw	ra,220(sp)
4200b51c:	446e                	lw	s0,216(sp)
4200b51e:	44de                	lw	s1,212(sp)
    return res.found ? procs[res.index] : NULL;
4200b520:	4501                	li	a0,0
}
4200b522:	612d                	add	sp,sp,224
4200b524:	8082                	ret

4200b526 <proc_get>:
process_t *proc_get(pid_t pid) {
4200b526:	1141                	add	sp,sp,-16
4200b528:	c226                	sw	s1,4(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200b52a:	800006b7          	lui	a3,0x80000
process_t *proc_get(pid_t pid) {
4200b52e:	c422                	sw	s0,8(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200b530:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
process_t *proc_get(pid_t pid) {
4200b534:	842a                	mv	s0,a0
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200b536:	567d                	li	a2,-1
4200b538:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200b53a:	4501                	li	a0,0
process_t *proc_get(pid_t pid) {
4200b53c:	c606                	sw	ra,12(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200b53e:	becf80ef          	jal	4200392a <mutex_acquire_shared>
    process_t *res = proc_get_unsafe(pid);
4200b542:	8522                	mv	a0,s0
4200b544:	f5bff0ef          	jal	4200b49e <proc_get_unsafe>
4200b548:	842a                	mv	s0,a0
    mutex_release_shared(NULL, &proc_mtx);
4200b54a:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200b54e:	4501                	li	a0,0
4200b550:	e04f80ef          	jal	42003b54 <mutex_release_shared>
}
4200b554:	40b2                	lw	ra,12(sp)
4200b556:	8522                	mv	a0,s0
4200b558:	4422                	lw	s0,8(sp)
4200b55a:	4492                	lw	s1,4(sp)
4200b55c:	0141                	add	sp,sp,16
4200b55e:	8082                	ret

4200b560 <proc_getflags_raw>:
    return atomic_load(&process->flags);
4200b560:	cd19                	beqz	a0,4200b57e <proc_getflags_raw+0x1e>
4200b562:	00357793          	and	a5,a0,3
4200b566:	ef81                	bnez	a5,4200b57e <proc_getflags_raw+0x1e>
4200b568:	f4c00793          	li	a5,-180
4200b56c:	00f57963          	bgeu	a0,a5,4200b57e <proc_getflags_raw+0x1e>
4200b570:	0ff0000f          	fence
4200b574:	0b452503          	lw	a0,180(a0)
4200b578:	0ff0000f          	fence
}
4200b57c:	8082                	ret
    return atomic_load(&process->flags);
4200b57e:	9002                	ebreak

4200b580 <proc_current>:
process_t *proc_current() {
4200b580:	1141                	add	sp,sp,-16
4200b582:	c606                	sw	ra,12(sp)
    return sched_get_current_thread()->process;
4200b584:	331020ef          	jal	4200e0b4 <sched_get_current_thread>
4200b588:	c901                	beqz	a0,4200b598 <proc_current+0x18>
4200b58a:	00357793          	and	a5,a0,3
4200b58e:	e789                	bnez	a5,4200b598 <proc_current+0x18>
}
4200b590:	40b2                	lw	ra,12(sp)
4200b592:	4108                	lw	a0,0(a0)
4200b594:	0141                	add	sp,sp,16
4200b596:	8082                	ret
    return sched_get_current_thread()->process;
4200b598:	9002                	ebreak

4200b59a <proc_setargs_raw>:
    if (argc <= 0)
4200b59a:	00c05463          	blez	a2,4200b5a2 <proc_setargs_raw+0x8>
4200b59e:	a71ff06f          	j	4200b00e <proc_setargs_raw.part.0>
}
4200b5a2:	8082                	ret

4200b5a4 <proc_create_thread_raw_unsafe>:
    void *mem = realloc(process->threads, sizeof(sched_thread_t *) * (process->threads_len + 1));
4200b5a4:	14058063          	beqz	a1,4200b6e4 <proc_create_thread_raw_unsafe+0x140>
) {
4200b5a8:	7179                	add	sp,sp,-48
4200b5aa:	d422                	sw	s0,40(sp)
4200b5ac:	d606                	sw	ra,44(sp)
4200b5ae:	d226                	sw	s1,36(sp)
4200b5b0:	d04a                	sw	s2,32(sp)
4200b5b2:	cc52                	sw	s4,24(sp)
4200b5b4:	ca56                	sw	s5,20(sp)
    void *mem = realloc(process->threads, sizeof(sched_thread_t *) * (process->threads_len + 1));
4200b5b6:	0035f793          	and	a5,a1,3
4200b5ba:	842e                	mv	s0,a1
4200b5bc:	10079c63          	bnez	a5,4200b6d4 <proc_create_thread_raw_unsafe+0x130>
4200b5c0:	57b1                	li	a5,-20
4200b5c2:	10f5fb63          	bgeu	a1,a5,4200b6d8 <proc_create_thread_raw_unsafe+0x134>
4200b5c6:	498c                	lw	a1,16(a1)
4200b5c8:	84aa                	mv	s1,a0
4200b5ca:	4848                	lw	a0,20(s0)
4200b5cc:	0585                	add	a1,a1,1
4200b5ce:	058a                	sll	a1,a1,0x2
4200b5d0:	8932                	mv	s2,a2
4200b5d2:	8a36                	mv	s4,a3
4200b5d4:	8aba                	mv	s5,a4
4200b5d6:	5fc020ef          	jal	4200dbd2 <realloc>
    if (!mem) {
4200b5da:	c159                	beqz	a0,4200b660 <proc_create_thread_raw_unsafe+0xbc>
4200b5dc:	ce4e                	sw	s3,28(sp)
    process->threads = mem;
4200b5de:	c848                	sw	a0,20(s0)
    void        *kstack      = malloc(kstack_size);
4200b5e0:	6509                	lui	a0,0x2
4200b5e2:	36e020ef          	jal	4200d950 <malloc>
4200b5e6:	89aa                	mv	s3,a0
    if (!kstack) {
4200b5e8:	c545                	beqz	a0,4200b690 <proc_create_thread_raw_unsafe+0xec>
    sched_thread_t *thread = sched_create_userland_thread(ec, process, entry_point, arg, kstack, kstack_size, priority);
4200b5ea:	872a                	mv	a4,a0
4200b5ec:	8856                	mv	a6,s5
4200b5ee:	8526                	mv	a0,s1
4200b5f0:	6789                	lui	a5,0x2
4200b5f2:	86d2                	mv	a3,s4
4200b5f4:	864a                	mv	a2,s2
4200b5f6:	85a2                	mv	a1,s0
4200b5f8:	42b020ef          	jal	4200e222 <sched_create_userland_thread>
4200b5fc:	c62a                	sw	a0,12(sp)
4200b5fe:	84aa                	mv	s1,a0
    if (!thread) {
4200b600:	c561                	beqz	a0,4200b6c8 <proc_create_thread_raw_unsafe+0x124>
    array_copy(array, array, ent_size, index + 1, index, ent_count - index);
4200b602:	481c                	lw	a5,16(s0)
        (void *)((size_t)array_dst + ent_size * dst_index),
4200b604:	4854                	lw	a3,20(s0)
    array_copy(array, array, ent_size, index + 1, index, ent_count - index);
4200b606:	0785                	add	a5,a5,1 # 2001 <__stack_size+0x1>
        (void *)((size_t)array_dst + ent_size * dst_index),
4200b608:	078a                	sll	a5,a5,0x2
        (void *)((size_t)array_src + ent_size * src_index),
4200b60a:	ffc78713          	add	a4,a5,-4
        (void *)((size_t)array_dst + ent_size * dst_index),
4200b60e:	97b6                	add	a5,a5,a3
        (void *)((size_t)array_src + ent_size * src_index),
4200b610:	9736                	add	a4,a4,a3
    __builtin_memmove(
4200b612:	cfe1                	beqz	a5,4200b6ea <proc_create_thread_raw_unsafe+0x146>
4200b614:	cb79                	beqz	a4,4200b6ea <proc_create_thread_raw_unsafe+0x146>
4200b616:	00c14583          	lbu	a1,12(sp)
4200b61a:	00d14603          	lbu	a2,13(sp)
4200b61e:	00f14783          	lbu	a5,15(sp)
4200b622:	00e14683          	lbu	a3,14(sp)
4200b626:	00b70023          	sb	a1,0(a4)
4200b62a:	00c700a3          	sb	a2,1(a4)
4200b62e:	00d70123          	sb	a3,2(a4)
4200b632:	00f701a3          	sb	a5,3(a4)
    process->threads_len++;
4200b636:	481c                	lw	a5,16(s0)
    logkf(LOG_DEBUG, "Creating user thread, PC: 0x%{size;x}", entry_point);
4200b638:	420195b7          	lui	a1,0x42019
4200b63c:	864a                	mv	a2,s2
    process->threads_len++;
4200b63e:	0785                	add	a5,a5,1
4200b640:	c81c                	sw	a5,16(s0)
    logkf(LOG_DEBUG, "Creating user thread, PC: 0x%{size;x}", entry_point);
4200b642:	df058593          	add	a1,a1,-528 # 42018df0 <hextab+0x2124>
4200b646:	4511                	li	a0,4
4200b648:	c53f70ef          	jal	4200329a <logkf>
4200b64c:	49f2                	lw	s3,28(sp)
}
4200b64e:	50b2                	lw	ra,44(sp)
4200b650:	5422                	lw	s0,40(sp)
4200b652:	5902                	lw	s2,32(sp)
4200b654:	4a62                	lw	s4,24(sp)
4200b656:	4ad2                	lw	s5,20(sp)
4200b658:	8526                	mv	a0,s1
4200b65a:	5492                	lw	s1,36(sp)
4200b65c:	6145                	add	sp,sp,48
4200b65e:	8082                	ret
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b660:	c495                	beqz	s1,4200b68c <proc_create_thread_raw_unsafe+0xe8>
4200b662:	420175b7          	lui	a1,0x42017
4200b666:	4699                	li	a3,6
4200b668:	463d                	li	a2,15
4200b66a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200b66e:	4511                	li	a0,4
4200b670:	00000717          	auipc	a4,0x0
4200b674:	c27f70ef          	jal	4200329a <logkf>
4200b678:	0034f793          	and	a5,s1,3
4200b67c:	e7ad                	bnez	a5,4200b6e6 <proc_create_thread_raw_unsafe+0x142>
4200b67e:	57f1                	li	a5,-4
4200b680:	04f4ff63          	bgeu	s1,a5,4200b6de <proc_create_thread_raw_unsafe+0x13a>
4200b684:	47bd                	li	a5,15
4200b686:	c0dc                	sw	a5,4(s1)
4200b688:	4799                	li	a5,6
4200b68a:	c09c                	sw	a5,0(s1)
        return NULL;
4200b68c:	4481                	li	s1,0
4200b68e:	b7c1                	j	4200b64e <proc_create_thread_raw_unsafe+0xaa>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b690:	c88d                	beqz	s1,4200b6c2 <proc_create_thread_raw_unsafe+0x11e>
4200b692:	420175b7          	lui	a1,0x42017
4200b696:	4699                	li	a3,6
4200b698:	463d                	li	a2,15
4200b69a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200b69e:	4511                	li	a0,4
4200b6a0:	00000717          	auipc	a4,0x0
4200b6a4:	bf7f70ef          	jal	4200329a <logkf>
4200b6a8:	0034f793          	and	a5,s1,3
4200b6ac:	eb85                	bnez	a5,4200b6dc <proc_create_thread_raw_unsafe+0x138>
4200b6ae:	57f1                	li	a5,-4
4200b6b0:	02f4f963          	bgeu	s1,a5,4200b6e2 <proc_create_thread_raw_unsafe+0x13e>
4200b6b4:	47bd                	li	a5,15
4200b6b6:	c0dc                	sw	a5,4(s1)
4200b6b8:	4799                	li	a5,6
4200b6ba:	c09c                	sw	a5,0(s1)
4200b6bc:	49f2                	lw	s3,28(sp)
        return NULL;
4200b6be:	4481                	li	s1,0
4200b6c0:	b779                	j	4200b64e <proc_create_thread_raw_unsafe+0xaa>
4200b6c2:	49f2                	lw	s3,28(sp)
4200b6c4:	4481                	li	s1,0
4200b6c6:	b761                	j	4200b64e <proc_create_thread_raw_unsafe+0xaa>
        free(kstack);
4200b6c8:	854e                	mv	a0,s3
4200b6ca:	492020ef          	jal	4200db5c <free>
        return NULL;
4200b6ce:	4481                	li	s1,0
        return NULL;
4200b6d0:	49f2                	lw	s3,28(sp)
4200b6d2:	bfb5                	j	4200b64e <proc_create_thread_raw_unsafe+0xaa>
4200b6d4:	ce4e                	sw	s3,28(sp)
    void *mem = realloc(process->threads, sizeof(sched_thread_t *) * (process->threads_len + 1));
4200b6d6:	9002                	ebreak
4200b6d8:	ce4e                	sw	s3,28(sp)
4200b6da:	9002                	ebreak
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b6dc:	9002                	ebreak
4200b6de:	ce4e                	sw	s3,28(sp)
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b6e0:	9002                	ebreak
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b6e2:	9002                	ebreak
    void *mem = realloc(process->threads, sizeof(sched_thread_t *) * (process->threads_len + 1));
4200b6e4:	9002                	ebreak
4200b6e6:	ce4e                	sw	s3,28(sp)
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200b6e8:	9002                	ebreak
4200b6ea:	9002                	ebreak

4200b6ec <proc_start_raw>:
    mutex_acquire(NULL, &process->mtx, TIMESTAMP_US_MAX);
4200b6ec:	1a058863          	beqz	a1,4200b89c <proc_start_raw+0x1b0>
void proc_start_raw(badge_err_t *ec, process_t *process, char const *executable) {
4200b6f0:	1101                	add	sp,sp,-32
4200b6f2:	cc22                	sw	s0,24(sp)
4200b6f4:	ce06                	sw	ra,28(sp)
4200b6f6:	ca26                	sw	s1,20(sp)
4200b6f8:	c84a                	sw	s2,16(sp)
4200b6fa:	c64e                	sw	s3,12(sp)
4200b6fc:	c452                	sw	s4,8(sp)
    mutex_acquire(NULL, &process->mtx, TIMESTAMP_US_MAX);
4200b6fe:	0035f793          	and	a5,a1,3
4200b702:	842e                	mv	s0,a1
4200b704:	18079763          	bnez	a5,4200b892 <proc_start_raw+0x1a6>
4200b708:	f5800793          	li	a5,-168
4200b70c:	18f5f263          	bgeu	a1,a5,4200b890 <proc_start_raw+0x1a4>
4200b710:	0a858a13          	add	s4,a1,168
4200b714:	800006b7          	lui	a3,0x80000
4200b718:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200b71a:	89b2                	mv	s3,a2
4200b71c:	85d2                	mv	a1,s4
4200b71e:	567d                	li	a2,-1
4200b720:	892a                	mv	s2,a0
4200b722:	4501                	li	a0,0
4200b724:	f4ff70ef          	jal	42003672 <mutex_acquire>
    logk(LOG_DEBUG, "Creating dynamic loader");
4200b728:	420195b7          	lui	a1,0x42019
4200b72c:	e1858593          	add	a1,a1,-488 # 42018e18 <hextab+0x214c>
4200b730:	4511                	li	a0,4
4200b732:	b23f70ef          	jal	42003254 <logk>
    kbelf_dyn dyn = kbelf_dyn_create(process->pid);
4200b736:	4c08                	lw	a0,24(s0)
4200b738:	301050ef          	jal	42011238 <kbelf_dyn_create>
    logk(LOG_DEBUG, "Adding executable");
4200b73c:	420195b7          	lui	a1,0x42019
    kbelf_dyn dyn = kbelf_dyn_create(process->pid);
4200b740:	84aa                	mv	s1,a0
    logk(LOG_DEBUG, "Adding executable");
4200b742:	e3058593          	add	a1,a1,-464 # 42018e30 <hextab+0x2164>
4200b746:	4511                	li	a0,4
4200b748:	b0df70ef          	jal	42003254 <logk>
    if (!kbelf_dyn_set_exec(dyn, executable, NULL)) {
4200b74c:	4601                	li	a2,0
4200b74e:	85ce                	mv	a1,s3
4200b750:	8526                	mv	a0,s1
4200b752:	471050ef          	jal	420113c2 <kbelf_dyn_set_exec>
4200b756:	c561                	beqz	a0,4200b81e <proc_start_raw+0x132>
    logk(LOG_DEBUG, "Loading program");
4200b758:	420195b7          	lui	a1,0x42019
4200b75c:	4511                	li	a0,4
4200b75e:	e4458593          	add	a1,a1,-444 # 42018e44 <hextab+0x2178>
4200b762:	af3f70ef          	jal	42003254 <logk>
    if (!kbelf_dyn_load(dyn)) {
4200b766:	8526                	mv	a0,s1
4200b768:	491050ef          	jal	420113f8 <kbelf_dyn_load>
4200b76c:	cd35                	beqz	a0,4200b7e8 <proc_start_raw+0xfc>
    logk(LOG_DEBUG, "Creating main thread");
4200b76e:	420195b7          	lui	a1,0x42019
4200b772:	e5458593          	add	a1,a1,-428 # 42018e54 <hextab+0x2188>
4200b776:	4511                	li	a0,4
4200b778:	addf70ef          	jal	42003254 <logk>
        (sched_entry_point_t)kbelf_dyn_entrypoint(dyn),
4200b77c:	8526                	mv	a0,s1
4200b77e:	63e060ef          	jal	42011dbc <kbelf_dyn_entrypoint>
4200b782:	862a                	mv	a2,a0
    sched_thread_t *thread = proc_create_thread_raw_unsafe(
4200b784:	4729                	li	a4,10
4200b786:	4681                	li	a3,0
4200b788:	85a2                	mv	a1,s0
4200b78a:	854a                	mv	a0,s2
4200b78c:	e19ff0ef          	jal	4200b5a4 <proc_create_thread_raw_unsafe>
4200b790:	89aa                	mv	s3,a0
    if (!thread) {
4200b792:	0c050e63          	beqz	a0,4200b86e <proc_start_raw+0x182>
    logk(LOG_DEBUG, "Starting main thread");
4200b796:	420195b7          	lui	a1,0x42019
4200b79a:	e6c58593          	add	a1,a1,-404 # 42018e6c <hextab+0x21a0>
4200b79e:	4511                	li	a0,4
4200b7a0:	ab5f70ef          	jal	42003254 <logk>
    atomic_store(&process->flags, PROC_RUNNING);
4200b7a4:	f4c00793          	li	a5,-180
4200b7a8:	0ef47663          	bgeu	s0,a5,4200b894 <proc_start_raw+0x1a8>
4200b7ac:	4785                	li	a5,1
4200b7ae:	0b440713          	add	a4,s0,180
4200b7b2:	0f50000f          	fence	iorw,ow
4200b7b6:	0cf7202f          	amoswap.w.aq	zero,a5,(a4)
    sched_resume_thread(ec, thread);
4200b7ba:	85ce                	mv	a1,s3
4200b7bc:	854a                	mv	a0,s2
4200b7be:	53b020ef          	jal	4200e4f8 <sched_resume_thread>
    mutex_release(NULL, &process->mtx);
4200b7c2:	85d2                	mv	a1,s4
4200b7c4:	4501                	li	a0,0
4200b7c6:	83ef80ef          	jal	42003804 <mutex_release>
    logkf(LOG_INFO, "Process %{d} started", process->pid);
4200b7ca:	4c10                	lw	a2,24(s0)
}
4200b7cc:	4462                	lw	s0,24(sp)
4200b7ce:	40f2                	lw	ra,28(sp)
4200b7d0:	44d2                	lw	s1,20(sp)
4200b7d2:	4942                	lw	s2,16(sp)
4200b7d4:	49b2                	lw	s3,12(sp)
4200b7d6:	4a22                	lw	s4,8(sp)
    logkf(LOG_INFO, "Process %{d} started", process->pid);
4200b7d8:	420195b7          	lui	a1,0x42019
4200b7dc:	e8458593          	add	a1,a1,-380 # 42018e84 <hextab+0x21b8>
4200b7e0:	450d                	li	a0,3
}
4200b7e2:	6105                	add	sp,sp,32
    logkf(LOG_INFO, "Process %{d} started", process->pid);
4200b7e4:	ab7f706f          	j	4200329a <logkf>
        kbelf_dyn_destroy(dyn);
4200b7e8:	8526                	mv	a0,s1
4200b7ea:	2cb050ef          	jal	420112b4 <kbelf_dyn_destroy>
        mutex_release(NULL, &process->mtx);
4200b7ee:	85d2                	mv	a1,s4
4200b7f0:	4501                	li	a0,0
4200b7f2:	812f80ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_UNKNOWN);
4200b7f6:	06090463          	beqz	s2,4200b85e <proc_start_raw+0x172>
4200b7fa:	420175b7          	lui	a1,0x42017
4200b7fe:	4685                	li	a3,1
4200b800:	463d                	li	a2,15
4200b802:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200b806:	4511                	li	a0,4
4200b808:	00000717          	auipc	a4,0x0
4200b80c:	a8ff70ef          	jal	4200329a <logkf>
4200b810:	00397793          	and	a5,s2,3
4200b814:	e3c9                	bnez	a5,4200b896 <proc_start_raw+0x1aa>
4200b816:	57f1                	li	a5,-4
4200b818:	02f96d63          	bltu	s2,a5,4200b852 <proc_start_raw+0x166>
4200b81c:	9002                	ebreak
        kbelf_dyn_destroy(dyn);
4200b81e:	8526                	mv	a0,s1
4200b820:	295050ef          	jal	420112b4 <kbelf_dyn_destroy>
        mutex_release(NULL, &process->mtx);
4200b824:	85d2                	mv	a1,s4
4200b826:	4501                	li	a0,0
4200b828:	fddf70ef          	jal	42003804 <mutex_release>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_UNKNOWN);
4200b82c:	02090963          	beqz	s2,4200b85e <proc_start_raw+0x172>
4200b830:	420175b7          	lui	a1,0x42017
4200b834:	4685                	li	a3,1
4200b836:	463d                	li	a2,15
4200b838:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200b83c:	4511                	li	a0,4
4200b83e:	00000717          	auipc	a4,0x0
4200b842:	a59f70ef          	jal	4200329a <logkf>
4200b846:	00397793          	and	a5,s2,3
4200b84a:	eba1                	bnez	a5,4200b89a <proc_start_raw+0x1ae>
4200b84c:	57f1                	li	a5,-4
4200b84e:	04f97563          	bgeu	s2,a5,4200b898 <proc_start_raw+0x1ac>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_UNKNOWN);
4200b852:	47bd                	li	a5,15
4200b854:	00f92223          	sw	a5,4(s2)
4200b858:	4785                	li	a5,1
4200b85a:	00f92023          	sw	a5,0(s2)
}
4200b85e:	40f2                	lw	ra,28(sp)
4200b860:	4462                	lw	s0,24(sp)
4200b862:	44d2                	lw	s1,20(sp)
4200b864:	4942                	lw	s2,16(sp)
4200b866:	49b2                	lw	s3,12(sp)
4200b868:	4a22                	lw	s4,8(sp)
4200b86a:	6105                	add	sp,sp,32
4200b86c:	8082                	ret
        kbelf_dyn_unload(dyn);
4200b86e:	8526                	mv	a0,s1
4200b870:	34b050ef          	jal	420113ba <kbelf_dyn_unload>
        kbelf_dyn_destroy(dyn);
4200b874:	8526                	mv	a0,s1
4200b876:	23f050ef          	jal	420112b4 <kbelf_dyn_destroy>
}
4200b87a:	4462                	lw	s0,24(sp)
4200b87c:	40f2                	lw	ra,28(sp)
4200b87e:	44d2                	lw	s1,20(sp)
4200b880:	4942                	lw	s2,16(sp)
4200b882:	49b2                	lw	s3,12(sp)
        mutex_release(NULL, &process->mtx);
4200b884:	85d2                	mv	a1,s4
}
4200b886:	4a22                	lw	s4,8(sp)
        mutex_release(NULL, &process->mtx);
4200b888:	4501                	li	a0,0
}
4200b88a:	6105                	add	sp,sp,32
        mutex_release(NULL, &process->mtx);
4200b88c:	f79f706f          	j	42003804 <mutex_release>
    mutex_acquire(NULL, &process->mtx, TIMESTAMP_US_MAX);
4200b890:	9002                	ebreak
4200b892:	9002                	ebreak
    atomic_store(&process->flags, PROC_RUNNING);
4200b894:	9002                	ebreak
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_UNKNOWN);
4200b896:	9002                	ebreak
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_UNKNOWN);
4200b898:	9002                	ebreak
4200b89a:	9002                	ebreak
    mutex_acquire(NULL, &process->mtx, TIMESTAMP_US_MAX);
4200b89c:	9002                	ebreak

4200b89e <proc_delete_thread_raw_unsafe>:
    __builtin_trap();
4200b89e:	9002                	ebreak

4200b8a0 <proc_unmap_raw>:
    return (size_t)base;
}

// Release memory allocated to a process.
void proc_unmap_raw(badge_err_t *ec, process_t *proc, size_t base) {
    proc_memmap_t *map = &proc->memmap;
4200b8a0:	14058763          	beqz	a1,4200b9ee <proc_unmap_raw+0x14e>
void proc_unmap_raw(badge_err_t *ec, process_t *proc, size_t base) {
4200b8a4:	1101                	add	sp,sp,-32
4200b8a6:	c64e                	sw	s3,12(sp)
4200b8a8:	ce06                	sw	ra,28(sp)
4200b8aa:	cc22                	sw	s0,24(sp)
4200b8ac:	ca26                	sw	s1,20(sp)
4200b8ae:	c452                	sw	s4,8(sp)
4200b8b0:	c256                	sw	s5,4(sp)
    proc_memmap_t *map = &proc->memmap;
4200b8b2:	0035f793          	and	a5,a1,3
4200b8b6:	89ae                	mv	s3,a1
4200b8b8:	12079563          	bnez	a5,4200b9e2 <proc_unmap_raw+0x142>
4200b8bc:	5791                	li	a5,-28
4200b8be:	12f5f063          	bgeu	a1,a5,4200b9de <proc_unmap_raw+0x13e>
4200b8c2:	01c58493          	add	s1,a1,28
    for (size_t i = 0; i < map->regions_len; i++) {
4200b8c6:	10048a63          	beqz	s1,4200b9da <proc_unmap_raw+0x13a>
4200b8ca:	0034f793          	and	a5,s1,3
4200b8ce:	10079663          	bnez	a5,4200b9da <proc_unmap_raw+0x13a>
4200b8d2:	fd800793          	li	a5,-40
4200b8d6:	10f4f063          	bgeu	s1,a5,4200b9d6 <proc_unmap_raw+0x136>
4200b8da:	41f4                	lw	a3,68(a1)
4200b8dc:	8aaa                	mv	s5,a0
4200b8de:	4401                	li	s0,0
4200b8e0:	4a01                	li	s4,0
4200b8e2:	ca95                	beqz	a3,4200b916 <proc_unmap_raw+0x76>
4200b8e4:	c84a                	sw	s2,16(sp)
4200b8e6:	a831                	j	4200b902 <proc_unmap_raw+0x62>
        if (map->regions[i].base == base) {
4200b8e8:	02976563          	bltu	a4,s1,4200b912 <proc_unmap_raw+0x72>
4200b8ec:	008987b3          	add	a5,s3,s0
4200b8f0:	47bc                	lw	a5,72(a5)
    array_copy(array, array, ent_size, index, index + 1, ent_count - index);
4200b8f2:	001a0913          	add	s2,s4,1
4200b8f6:	06c78163          	beq	a5,a2,4200b958 <proc_unmap_raw+0xb8>
    for (size_t i = 0; i < map->regions_len; i++) {
4200b8fa:	0431                	add	s0,s0,12
4200b8fc:	00d90c63          	beq	s2,a3,4200b914 <proc_unmap_raw+0x74>
4200b900:	8a4a                	mv	s4,s2
        if (map->regions[i].base == base) {
4200b902:	02c40793          	add	a5,s0,44
4200b906:	00f48733          	add	a4,s1,a5
4200b90a:	fc07dfe3          	bgez	a5,4200b8e8 <proc_unmap_raw+0x48>
4200b90e:	fce4ffe3          	bgeu	s1,a4,4200b8ec <proc_unmap_raw+0x4c>
4200b912:	9002                	ebreak
4200b914:	4942                	lw	s2,16(sp)
            map->regions_len--;
            badge_err_set_ok(ec);
            return;
        }
    }
    badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200b916:	020a8963          	beqz	s5,4200b948 <proc_unmap_raw+0xa8>
4200b91a:	420175b7          	lui	a1,0x42017
4200b91e:	46e1                	li	a3,24
4200b920:	463d                	li	a2,15
4200b922:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200b926:	4511                	li	a0,4
4200b928:	00000717          	auipc	a4,0x0
4200b92c:	96ff70ef          	jal	4200329a <logkf>
4200b930:	003af793          	and	a5,s5,3
4200b934:	ebcd                	bnez	a5,4200b9e6 <proc_unmap_raw+0x146>
4200b936:	57f1                	li	a5,-4
4200b938:	0afaf963          	bgeu	s5,a5,4200b9ea <proc_unmap_raw+0x14a>
4200b93c:	47bd                	li	a5,15
4200b93e:	00faa223          	sw	a5,4(s5)
4200b942:	47e1                	li	a5,24
4200b944:	00faa023          	sw	a5,0(s5)
}
4200b948:	40f2                	lw	ra,28(sp)
4200b94a:	4462                	lw	s0,24(sp)
4200b94c:	44d2                	lw	s1,20(sp)
4200b94e:	49b2                	lw	s3,12(sp)
4200b950:	4a22                	lw	s4,8(sp)
4200b952:	4a92                	lw	s5,4(sp)
4200b954:	6105                	add	sp,sp,32
4200b956:	8082                	ret
            free((void *)base);
4200b958:	8532                	mv	a0,a2
4200b95a:	202020ef          	jal	4200db5c <free>
            array_remove(&map->regions[0], sizeof(map->regions[0]), map->regions_len, NULL, i);
4200b95e:	fd400793          	li	a5,-44
4200b962:	08f4f863          	bgeu	s1,a5,4200b9f2 <proc_unmap_raw+0x152>
4200b966:	0449a703          	lw	a4,68(s3)
        (void *)((size_t)array_src + ent_size * src_index),
4200b96a:	00191593          	sll	a1,s2,0x1
4200b96e:	04898793          	add	a5,s3,72
    array_copy(array, array, ent_size, index, index + 1, ent_count - index);
4200b972:	41470733          	sub	a4,a4,s4
        (void *)((size_t)array_src + ent_size * src_index),
4200b976:	95ca                	add	a1,a1,s2
    __builtin_memmove(
4200b978:	00171613          	sll	a2,a4,0x1
        (void *)((size_t)array_src + ent_size * src_index),
4200b97c:	058a                	sll	a1,a1,0x2
    __builtin_memmove(
4200b97e:	963a                	add	a2,a2,a4
        (void *)((size_t)array_dst + ent_size * dst_index),
4200b980:	00f40533          	add	a0,s0,a5
        (void *)((size_t)array_src + ent_size * src_index),
4200b984:	95be                	add	a1,a1,a5
    __builtin_memmove(
4200b986:	060a                	sll	a2,a2,0x2
4200b988:	c53d                	beqz	a0,4200b9f6 <proc_unmap_raw+0x156>
4200b98a:	c5b5                	beqz	a1,4200b9f6 <proc_unmap_raw+0x156>
4200b98c:	fb7f60ef          	jal	42002942 <memmove>
            map->regions_len--;
4200b990:	0449a783          	lw	a5,68(s3)
4200b994:	17fd                	add	a5,a5,-1
4200b996:	04f9a223          	sw	a5,68(s3)
            badge_err_set_ok(ec);
4200b99a:	020a8563          	beqz	s5,4200b9c4 <proc_unmap_raw+0x124>
4200b99e:	003af793          	and	a5,s5,3
4200b9a2:	e7b9                	bnez	a5,4200b9f0 <proc_unmap_raw+0x150>
4200b9a4:	57f1                	li	a5,-4
4200b9a6:	04faf763          	bgeu	s5,a5,4200b9f4 <proc_unmap_raw+0x154>
}
4200b9aa:	40f2                	lw	ra,28(sp)
4200b9ac:	4462                	lw	s0,24(sp)
            badge_err_set_ok(ec);
4200b9ae:	000aa223          	sw	zero,4(s5)
4200b9b2:	000aa023          	sw	zero,0(s5)
4200b9b6:	4942                	lw	s2,16(sp)
}
4200b9b8:	44d2                	lw	s1,20(sp)
4200b9ba:	49b2                	lw	s3,12(sp)
4200b9bc:	4a22                	lw	s4,8(sp)
4200b9be:	4a92                	lw	s5,4(sp)
4200b9c0:	6105                	add	sp,sp,32
4200b9c2:	8082                	ret
4200b9c4:	40f2                	lw	ra,28(sp)
4200b9c6:	4462                	lw	s0,24(sp)
4200b9c8:	4942                	lw	s2,16(sp)
4200b9ca:	44d2                	lw	s1,20(sp)
4200b9cc:	49b2                	lw	s3,12(sp)
4200b9ce:	4a22                	lw	s4,8(sp)
4200b9d0:	4a92                	lw	s5,4(sp)
4200b9d2:	6105                	add	sp,sp,32
4200b9d4:	8082                	ret
4200b9d6:	c84a                	sw	s2,16(sp)
    for (size_t i = 0; i < map->regions_len; i++) {
4200b9d8:	9002                	ebreak
4200b9da:	c84a                	sw	s2,16(sp)
4200b9dc:	9002                	ebreak
4200b9de:	c84a                	sw	s2,16(sp)
    proc_memmap_t *map = &proc->memmap;
4200b9e0:	9002                	ebreak
4200b9e2:	c84a                	sw	s2,16(sp)
4200b9e4:	9002                	ebreak
4200b9e6:	c84a                	sw	s2,16(sp)
    badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200b9e8:	9002                	ebreak
4200b9ea:	c84a                	sw	s2,16(sp)
4200b9ec:	9002                	ebreak
    proc_memmap_t *map = &proc->memmap;
4200b9ee:	9002                	ebreak
            badge_err_set_ok(ec);
4200b9f0:	9002                	ebreak
            array_remove(&map->regions[0], sizeof(map->regions[0]), map->regions_len, NULL, i);
4200b9f2:	9002                	ebreak
            badge_err_set_ok(ec);
4200b9f4:	9002                	ebreak
4200b9f6:	9002                	ebreak

4200b9f8 <proc_map_raw>:
    proc_memmap_t *map = &proc->memmap;
4200b9f8:	24058763          	beqz	a1,4200bc46 <proc_map_raw+0x24e>
size_t proc_map_raw(badge_err_t *ec, process_t *proc, size_t vaddr_req, size_t min_size, size_t min_align) {
4200b9fc:	1101                	add	sp,sp,-32
4200b9fe:	cc22                	sw	s0,24(sp)
4200ba00:	ce06                	sw	ra,28(sp)
4200ba02:	ca26                	sw	s1,20(sp)
4200ba04:	c84a                	sw	s2,16(sp)
4200ba06:	c256                	sw	s5,4(sp)
    proc_memmap_t *map = &proc->memmap;
4200ba08:	0035f793          	and	a5,a1,3
4200ba0c:	842e                	mv	s0,a1
4200ba0e:	20079963          	bnez	a5,4200bc20 <proc_map_raw+0x228>
4200ba12:	5791                	li	a5,-28
4200ba14:	20f5f363          	bgeu	a1,a5,4200bc1a <proc_map_raw+0x222>
4200ba18:	01c58493          	add	s1,a1,28
    if (map->regions_len >= PROC_MEMMAP_MAX_REGIONS) {
4200ba1c:	1e048c63          	beqz	s1,4200bc14 <proc_map_raw+0x21c>
4200ba20:	0034f793          	and	a5,s1,3
4200ba24:	1e079863          	bnez	a5,4200bc14 <proc_map_raw+0x21c>
4200ba28:	fd800793          	li	a5,-40
4200ba2c:	1ef4fd63          	bgeu	s1,a5,4200bc26 <proc_map_raw+0x22e>
4200ba30:	41f8                	lw	a4,68(a1)
4200ba32:	479d                	li	a5,7
4200ba34:	892a                	mv	s2,a0
4200ba36:	04e7f463          	bgeu	a5,a4,4200ba7e <proc_map_raw+0x86>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200ba3a:	c90d                	beqz	a0,4200ba6c <proc_map_raw+0x74>
4200ba3c:	420175b7          	lui	a1,0x42017
4200ba40:	4699                	li	a3,6
4200ba42:	463d                	li	a2,15
4200ba44:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200ba48:	4511                	li	a0,4
4200ba4a:	00000717          	auipc	a4,0x0
4200ba4e:	84df70ef          	jal	4200329a <logkf>
4200ba52:	00397793          	and	a5,s2,3
4200ba56:	1c079e63          	bnez	a5,4200bc32 <proc_map_raw+0x23a>
4200ba5a:	57f1                	li	a5,-4
4200ba5c:	1cf97e63          	bgeu	s2,a5,4200bc38 <proc_map_raw+0x240>
4200ba60:	47bd                	li	a5,15
4200ba62:	00f92223          	sw	a5,4(s2)
4200ba66:	4799                	li	a5,6
4200ba68:	00f92023          	sw	a5,0(s2)
        return 0;
4200ba6c:	4a81                	li	s5,0
}
4200ba6e:	40f2                	lw	ra,28(sp)
4200ba70:	4462                	lw	s0,24(sp)
4200ba72:	44d2                	lw	s1,20(sp)
4200ba74:	4942                	lw	s2,16(sp)
4200ba76:	8556                	mv	a0,s5
4200ba78:	4a92                	lw	s5,4(sp)
4200ba7a:	6105                	add	sp,sp,32
4200ba7c:	8082                	ret
    void *base = malloc(min_size);
4200ba7e:	8536                	mv	a0,a3
4200ba80:	c64e                	sw	s3,12(sp)
4200ba82:	c452                	sw	s4,8(sp)
4200ba84:	89b6                	mv	s3,a3
4200ba86:	6cb010ef          	jal	4200d950 <malloc>
4200ba8a:	8a2a                	mv	s4,a0
    if (!base) {
4200ba8c:	14050263          	beqz	a0,4200bbd0 <proc_map_raw+0x1d8>
    map->regions[map->regions_len] = (proc_memmap_ent_t){
4200ba90:	4070                	lw	a2,68(s0)
        .base  = (size_t)base,
4200ba92:	8aaa                	mv	s5,a0
4200ba94:	00161793          	sll	a5,a2,0x1
4200ba98:	00c78733          	add	a4,a5,a2
4200ba9c:	070a                	sll	a4,a4,0x2
4200ba9e:	02c70693          	add	a3,a4,44 # 4200ba76 <proc_map_raw+0x7e>
    map->regions[map->regions_len] = (proc_memmap_ent_t){
4200baa2:	00d485b3          	add	a1,s1,a3
4200baa6:	0e06d263          	bgez	a3,4200bb8a <proc_map_raw+0x192>
4200baaa:	0eb4e263          	bltu	s1,a1,4200bb8e <proc_map_raw+0x196>
4200baae:	00c786b3          	add	a3,a5,a2
4200bab2:	068a                	sll	a3,a3,0x2
4200bab4:	96a2                	add	a3,a3,s0
4200bab6:	03070593          	add	a1,a4,48
4200baba:	0546a423          	sw	s4,72(a3)
4200babe:	86ae                	mv	a3,a1
4200bac0:	95a6                	add	a1,a1,s1
4200bac2:	0c06d163          	bgez	a3,4200bb84 <proc_map_raw+0x18c>
4200bac6:	0cb4e163          	bltu	s1,a1,4200bb88 <proc_map_raw+0x190>
4200baca:	00c786b3          	add	a3,a5,a2
4200bace:	068a                	sll	a3,a3,0x2
4200bad0:	96a2                	add	a3,a3,s0
4200bad2:	03470593          	add	a1,a4,52
4200bad6:	0536a623          	sw	s3,76(a3)
4200bada:	86ae                	mv	a3,a1
4200badc:	95a6                	add	a1,a1,s1
4200bade:	0a06d063          	bgez	a3,4200bb7e <proc_map_raw+0x186>
4200bae2:	0ab4e063          	bltu	s1,a1,4200bb82 <proc_map_raw+0x18a>
4200bae6:	00c786b3          	add	a3,a5,a2
4200baea:	068a                	sll	a3,a3,0x2
4200baec:	96a2                	add	a3,a3,s0
4200baee:	4585                	li	a1,1
4200baf0:	03570713          	add	a4,a4,53
4200baf4:	04b68823          	sb	a1,80(a3)
4200baf8:	00e486b3          	add	a3,s1,a4
4200bafc:	06075e63          	bgez	a4,4200bb78 <proc_map_raw+0x180>
4200bb00:	06d4ee63          	bltu	s1,a3,4200bb7c <proc_map_raw+0x184>
4200bb04:	97b2                	add	a5,a5,a2
4200bb06:	078a                	sll	a5,a5,0x2
4200bb08:	97a2                	add	a5,a5,s0
4200bb0a:	4705                	li	a4,1
4200bb0c:	04e788a3          	sb	a4,81(a5)
    map->regions_len++;
4200bb10:	0605                	add	a2,a2,1
4200bb12:	c070                	sw	a2,68(s0)
    array_sort(&memmap->regions[0], sizeof(memmap->regions[0]), memmap->regions_len, prog_memmap_cmp);
4200bb14:	fd400793          	li	a5,-44
4200bb18:	10f4fa63          	bgeu	s1,a5,4200bc2c <proc_map_raw+0x234>
4200bb1c:	4200b6b7          	lui	a3,0x4200b
4200bb20:	04840513          	add	a0,s0,72
4200bb24:	fee68693          	add	a3,a3,-18 # 4200afee <prog_memmap_cmp>
4200bb28:	45b1                	li	a1,12
4200bb2a:	998f50ef          	jal	42000cc2 <array_sort>
4200bb2e:	8526                	mv	a0,s1
4200bb30:	21c030ef          	jal	4200ed4c <proc_riscv_pmp_gen>
    if (!proc_mpu_gen(map)) {
4200bb34:	ed31                	bnez	a0,4200bb90 <proc_map_raw+0x198>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200bb36:	02090963          	beqz	s2,4200bb68 <proc_map_raw+0x170>
4200bb3a:	420175b7          	lui	a1,0x42017
4200bb3e:	4699                	li	a3,6
4200bb40:	463d                	li	a2,15
4200bb42:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200bb46:	4511                	li	a0,4
4200bb48:	00000717          	auipc	a4,0x0
4200bb4c:	f4ef70ef          	jal	4200329a <logkf>
4200bb50:	00397793          	and	a5,s2,3
4200bb54:	ebe5                	bnez	a5,4200bc44 <proc_map_raw+0x24c>
4200bb56:	57f1                	li	a5,-4
4200bb58:	0ef97563          	bgeu	s2,a5,4200bc42 <proc_map_raw+0x24a>
4200bb5c:	47bd                	li	a5,15
4200bb5e:	00f92223          	sw	a5,4(s2)
4200bb62:	4799                	li	a5,6
4200bb64:	00f92023          	sw	a5,0(s2)
        proc_unmap_raw(NULL, proc, (size_t)base);
4200bb68:	8652                	mv	a2,s4
4200bb6a:	85a2                	mv	a1,s0
4200bb6c:	4501                	li	a0,0
4200bb6e:	d33ff0ef          	jal	4200b8a0 <proc_unmap_raw>
        return 0;
4200bb72:	49b2                	lw	s3,12(sp)
4200bb74:	4a22                	lw	s4,8(sp)
4200bb76:	bddd                	j	4200ba6c <proc_map_raw+0x74>
    map->regions[map->regions_len] = (proc_memmap_ent_t){
4200bb78:	f896f6e3          	bgeu	a3,s1,4200bb04 <proc_map_raw+0x10c>
4200bb7c:	9002                	ebreak
4200bb7e:	f695f4e3          	bgeu	a1,s1,4200bae6 <proc_map_raw+0xee>
4200bb82:	9002                	ebreak
4200bb84:	f495f3e3          	bgeu	a1,s1,4200baca <proc_map_raw+0xd2>
4200bb88:	9002                	ebreak
4200bb8a:	f295f2e3          	bgeu	a1,s1,4200baae <proc_map_raw+0xb6>
4200bb8e:	9002                	ebreak
    logkf(LOG_INFO, "Mapped %{size;d} bytes at %{size;x} to process %{d}", min_size, base, proc->pid);
4200bb90:	4c18                	lw	a4,24(s0)
4200bb92:	420195b7          	lui	a1,0x42019
4200bb96:	86d2                	mv	a3,s4
4200bb98:	864e                	mv	a2,s3
4200bb9a:	e9c58593          	add	a1,a1,-356 # 42018e9c <hextab+0x21d0>
4200bb9e:	450d                	li	a0,3
4200bba0:	efaf70ef          	jal	4200329a <logkf>
    badge_err_set_ok(ec);
4200bba4:	06090563          	beqz	s2,4200bc0e <proc_map_raw+0x216>
4200bba8:	00397793          	and	a5,s2,3
4200bbac:	e3d1                	bnez	a5,4200bc30 <proc_map_raw+0x238>
4200bbae:	57f1                	li	a5,-4
4200bbb0:	06f97f63          	bgeu	s2,a5,4200bc2e <proc_map_raw+0x236>
}
4200bbb4:	40f2                	lw	ra,28(sp)
4200bbb6:	4462                	lw	s0,24(sp)
    badge_err_set_ok(ec);
4200bbb8:	00092223          	sw	zero,4(s2)
4200bbbc:	00092023          	sw	zero,0(s2)
4200bbc0:	49b2                	lw	s3,12(sp)
4200bbc2:	4a22                	lw	s4,8(sp)
}
4200bbc4:	44d2                	lw	s1,20(sp)
4200bbc6:	4942                	lw	s2,16(sp)
4200bbc8:	8556                	mv	a0,s5
4200bbca:	4a92                	lw	s5,4(sp)
4200bbcc:	6105                	add	sp,sp,32
4200bbce:	8082                	ret
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200bbd0:	02090c63          	beqz	s2,4200bc08 <proc_map_raw+0x210>
4200bbd4:	420175b7          	lui	a1,0x42017
4200bbd8:	4699                	li	a3,6
4200bbda:	463d                	li	a2,15
4200bbdc:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200bbe0:	4511                	li	a0,4
4200bbe2:	00000717          	auipc	a4,0x0
4200bbe6:	eb4f70ef          	jal	4200329a <logkf>
4200bbea:	00397793          	and	a5,s2,3
4200bbee:	eba9                	bnez	a5,4200bc40 <proc_map_raw+0x248>
4200bbf0:	57f1                	li	a5,-4
4200bbf2:	04f97663          	bgeu	s2,a5,4200bc3e <proc_map_raw+0x246>
4200bbf6:	47bd                	li	a5,15
4200bbf8:	00f92223          	sw	a5,4(s2)
4200bbfc:	4799                	li	a5,6
4200bbfe:	49b2                	lw	s3,12(sp)
4200bc00:	4a22                	lw	s4,8(sp)
4200bc02:	00f92023          	sw	a5,0(s2)
4200bc06:	b59d                	j	4200ba6c <proc_map_raw+0x74>
4200bc08:	49b2                	lw	s3,12(sp)
4200bc0a:	4a22                	lw	s4,8(sp)
4200bc0c:	b585                	j	4200ba6c <proc_map_raw+0x74>
4200bc0e:	49b2                	lw	s3,12(sp)
4200bc10:	4a22                	lw	s4,8(sp)
4200bc12:	bdb1                	j	4200ba6e <proc_map_raw+0x76>
4200bc14:	c64e                	sw	s3,12(sp)
4200bc16:	c452                	sw	s4,8(sp)
    if (map->regions_len >= PROC_MEMMAP_MAX_REGIONS) {
4200bc18:	9002                	ebreak
4200bc1a:	c64e                	sw	s3,12(sp)
4200bc1c:	c452                	sw	s4,8(sp)
    proc_memmap_t *map = &proc->memmap;
4200bc1e:	9002                	ebreak
4200bc20:	c64e                	sw	s3,12(sp)
4200bc22:	c452                	sw	s4,8(sp)
4200bc24:	9002                	ebreak
4200bc26:	c64e                	sw	s3,12(sp)
4200bc28:	c452                	sw	s4,8(sp)
    if (map->regions_len >= PROC_MEMMAP_MAX_REGIONS) {
4200bc2a:	9002                	ebreak
    array_sort(&memmap->regions[0], sizeof(memmap->regions[0]), memmap->regions_len, prog_memmap_cmp);
4200bc2c:	9002                	ebreak
    badge_err_set_ok(ec);
4200bc2e:	9002                	ebreak
4200bc30:	9002                	ebreak
4200bc32:	c64e                	sw	s3,12(sp)
4200bc34:	c452                	sw	s4,8(sp)
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200bc36:	9002                	ebreak
4200bc38:	c64e                	sw	s3,12(sp)
4200bc3a:	c452                	sw	s4,8(sp)
4200bc3c:	9002                	ebreak
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200bc3e:	9002                	ebreak
4200bc40:	9002                	ebreak
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200bc42:	9002                	ebreak
4200bc44:	9002                	ebreak
    proc_memmap_t *map = &proc->memmap;
4200bc46:	9002                	ebreak

4200bc48 <proc_add_fd_raw>:

// Add a file to the process file handle list.
int proc_add_fd_raw(badge_err_t *ec, process_t *process, file_t real) {
4200bc48:	7179                	add	sp,sp,-48
4200bc4a:	d606                	sw	ra,44(sp)
4200bc4c:	d422                	sw	s0,40(sp)
4200bc4e:	d226                	sw	s1,36(sp)
4200bc50:	d04a                	sw	s2,32(sp)
4200bc52:	ce4e                	sw	s3,28(sp)
4200bc54:	cc52                	sw	s4,24(sp)
    proc_fd_t fd = {.real = real, .virt = 0};
4200bc56:	c402                	sw	zero,8(sp)
4200bc58:	c632                	sw	a2,12(sp)
    for (size_t i = 0; i < process->fds_len; i++) {
4200bc5a:	c1bd                	beqz	a1,4200bcc0 <proc_add_fd_raw+0x78>
4200bc5c:	0035f793          	and	a5,a1,3
4200bc60:	842e                	mv	s0,a1
4200bc62:	efb9                	bnez	a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bc64:	57e1                	li	a5,-8
4200bc66:	892a                	mv	s2,a0
4200bc68:	00858513          	add	a0,a1,8
4200bc6c:	04f5fa63          	bgeu	a1,a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bc70:	4584                	lw	s1,8(a1)
4200bc72:	12048c63          	beqz	s1,4200bdaa <proc_add_fd_raw+0x162>
4200bc76:	4801                	li	a6,0
4200bc78:	4681                	li	a3,0
        if (process->fds[i].virt > fd.virt) {
4200bc7a:	58d1                	li	a7,-12
4200bc7c:	05147263          	bgeu	s0,a7,4200bcc0 <proc_add_fd_raw+0x78>
4200bc80:	4458                	lw	a4,12(s0)
4200bc82:	00369613          	sll	a2,a3,0x3
4200bc86:	00c707b3          	add	a5,a4,a2
4200bc8a:	02064963          	bltz	a2,4200bcbc <proc_add_fd_raw+0x74>
4200bc8e:	02e7e963          	bltu	a5,a4,4200bcc0 <proc_add_fd_raw+0x78>
4200bc92:	c79d                	beqz	a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bc94:	0037f593          	and	a1,a5,3
4200bc98:	e585                	bnez	a1,4200bcc0 <proc_add_fd_raw+0x78>
4200bc9a:	438c                	lw	a1,0(a5)
4200bc9c:	00b85b63          	bge	a6,a1,4200bcb2 <proc_add_fd_raw+0x6a>
            fd.virt = process->fds[i].virt + 1;
4200bca0:	02064163          	bltz	a2,4200bcc2 <proc_add_fd_raw+0x7a>
4200bca4:	00e7ee63          	bltu	a5,a4,4200bcc0 <proc_add_fd_raw+0x78>
4200bca8:	00158793          	add	a5,a1,1
4200bcac:	00b7ca63          	blt	a5,a1,4200bcc0 <proc_add_fd_raw+0x78>
4200bcb0:	c43e                	sw	a5,8(sp)
    for (size_t i = 0; i < process->fds_len; i++) {
4200bcb2:	0685                	add	a3,a3,1
4200bcb4:	00968a63          	beq	a3,s1,4200bcc8 <proc_add_fd_raw+0x80>
        if (process->fds[i].virt > fd.virt) {
4200bcb8:	4822                	lw	a6,8(sp)
4200bcba:	b7c9                	j	4200bc7c <proc_add_fd_raw+0x34>
4200bcbc:	fcf77be3          	bgeu	a4,a5,4200bc92 <proc_add_fd_raw+0x4a>
    }
    if (array_len_insert(&process->fds, sizeof(proc_fd_t), &process->fds_len, &fd, process->fds_len)) {
        badge_err_set_ok(ec);
        return fd.virt;
    } else {
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200bcc0:	9002                	ebreak
            fd.virt = process->fds[i].virt + 1;
4200bcc2:	fef773e3          	bgeu	a4,a5,4200bca8 <proc_add_fd_raw+0x60>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200bcc6:	9002                	ebreak
    if (array_len_resize(array_ptr, ent_size, ent_count_ptr, *ent_count_ptr + 1)) {
4200bcc8:	00148a13          	add	s4,s1,1
    void  *mem       = realloc(*array_ptr, ent_size * new_ent_count);
4200bccc:	003a1993          	sll	s3,s4,0x3
    if (array_len_insert(&process->fds, sizeof(proc_fd_t), &process->fds_len, &fd, process->fds_len)) {
4200bcd0:	57d1                	li	a5,-12
4200bcd2:	fef477e3          	bgeu	s0,a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bcd6:	00c40793          	add	a5,s0,12
    if (array_len_resize(array_ptr, ent_size, ent_count_ptr, *ent_count_ptr + 1)) {
4200bcda:	d17d                	beqz	a0,4200bcc0 <proc_add_fd_raw+0x78>
4200bcdc:	890d                	and	a0,a0,3
4200bcde:	f16d                	bnez	a0,4200bcc0 <proc_add_fd_raw+0x78>
    void  *mem       = realloc(*array_ptr, ent_size * new_ent_count);
4200bce0:	d3e5                	beqz	a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bce2:	8b8d                	and	a5,a5,3
4200bce4:	fff1                	bnez	a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bce6:	4448                	lw	a0,12(s0)
4200bce8:	85ce                	mv	a1,s3
4200bcea:	6e9010ef          	jal	4200dbd2 <realloc>
4200bcee:	87aa                	mv	a5,a0
    if (!mem)
4200bcf0:	c151                	beqz	a0,4200bd74 <proc_add_fd_raw+0x12c>
        (void *)((size_t)array_src + ent_size * src_index),
4200bcf2:	048e                	sll	s1,s1,0x3
    *array_ptr     = mem;
4200bcf4:	c448                	sw	a0,12(s0)
    *ent_count_ptr = new_ent_count;
4200bcf6:	01442423          	sw	s4,8(s0)
        (void *)((size_t)array_dst + ent_size * dst_index),
4200bcfa:	954e                	add	a0,a0,s3
        (void *)((size_t)array_src + ent_size * src_index),
4200bcfc:	94be                	add	s1,s1,a5
    __builtin_memmove(
4200bcfe:	d169                	beqz	a0,4200bcc0 <proc_add_fd_raw+0x78>
4200bd00:	d0e1                	beqz	s1,4200bcc0 <proc_add_fd_raw+0x78>
4200bd02:	4621                	li	a2,8
4200bd04:	85a6                	mv	a1,s1
4200bd06:	c3df60ef          	jal	42002942 <memmove>
4200bd0a:	00814883          	lbu	a7,8(sp)
4200bd0e:	00914803          	lbu	a6,9(sp)
4200bd12:	00a14503          	lbu	a0,10(sp)
4200bd16:	00b14583          	lbu	a1,11(sp)
4200bd1a:	00c14603          	lbu	a2,12(sp)
4200bd1e:	00d14683          	lbu	a3,13(sp)
4200bd22:	00e14703          	lbu	a4,14(sp)
4200bd26:	00f14783          	lbu	a5,15(sp)
4200bd2a:	01148023          	sb	a7,0(s1)
4200bd2e:	010480a3          	sb	a6,1(s1)
4200bd32:	00a48123          	sb	a0,2(s1)
4200bd36:	00b481a3          	sb	a1,3(s1)
4200bd3a:	00c48223          	sb	a2,4(s1)
4200bd3e:	00d482a3          	sb	a3,5(s1)
4200bd42:	00e48323          	sb	a4,6(s1)
4200bd46:	00f483a3          	sb	a5,7(s1)
        badge_err_set_ok(ec);
4200bd4a:	00090c63          	beqz	s2,4200bd62 <proc_add_fd_raw+0x11a>
4200bd4e:	00397793          	and	a5,s2,3
4200bd52:	f7bd                	bnez	a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bd54:	57f1                	li	a5,-4
4200bd56:	f6f975e3          	bgeu	s2,a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bd5a:	00092223          	sw	zero,4(s2)
4200bd5e:	00092023          	sw	zero,0(s2)
        return fd.virt;
4200bd62:	4522                	lw	a0,8(sp)
        return -1;
    }
}
4200bd64:	50b2                	lw	ra,44(sp)
4200bd66:	5422                	lw	s0,40(sp)
4200bd68:	5492                	lw	s1,36(sp)
4200bd6a:	5902                	lw	s2,32(sp)
4200bd6c:	49f2                	lw	s3,28(sp)
4200bd6e:	4a62                	lw	s4,24(sp)
4200bd70:	6145                	add	sp,sp,48
4200bd72:	8082                	ret
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOMEM);
4200bd74:	02090963          	beqz	s2,4200bda6 <proc_add_fd_raw+0x15e>
4200bd78:	420175b7          	lui	a1,0x42017
4200bd7c:	4699                	li	a3,6
4200bd7e:	463d                	li	a2,15
4200bd80:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200bd84:	4511                	li	a0,4
4200bd86:	00000717          	auipc	a4,0x0
4200bd8a:	d10f70ef          	jal	4200329a <logkf>
4200bd8e:	00397793          	and	a5,s2,3
4200bd92:	f79d                	bnez	a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bd94:	57f1                	li	a5,-4
4200bd96:	f2f975e3          	bgeu	s2,a5,4200bcc0 <proc_add_fd_raw+0x78>
4200bd9a:	47bd                	li	a5,15
4200bd9c:	00f92223          	sw	a5,4(s2)
4200bda0:	4799                	li	a5,6
4200bda2:	00f92023          	sw	a5,0(s2)
        return -1;
4200bda6:	557d                	li	a0,-1
4200bda8:	bf75                	j	4200bd64 <proc_add_fd_raw+0x11c>
    for (size_t i = 0; i < process->fds_len; i++) {
4200bdaa:	49a1                	li	s3,8
4200bdac:	4a05                	li	s4,1
4200bdae:	b70d                	j	4200bcd0 <proc_add_fd_raw+0x88>

4200bdb0 <proc_find_fd_raw>:

// Find a file in the process file handle list.
file_t proc_find_fd_raw(badge_err_t *ec, process_t *process, int virt) {
    for (size_t i = 0; i < process->fds_len; i++) {
4200bdb0:	c1f1                	beqz	a1,4200be74 <proc_find_fd_raw+0xc4>
4200bdb2:	0035f793          	and	a5,a1,3
4200bdb6:	efdd                	bnez	a5,4200be74 <proc_find_fd_raw+0xc4>
4200bdb8:	57e1                	li	a5,-8
4200bdba:	0af5fe63          	bgeu	a1,a5,4200be76 <proc_find_fd_raw+0xc6>
4200bdbe:	0085a303          	lw	t1,8(a1)
file_t proc_find_fd_raw(badge_err_t *ec, process_t *process, int virt) {
4200bdc2:	1141                	add	sp,sp,-16
4200bdc4:	c422                	sw	s0,8(sp)
4200bdc6:	c606                	sw	ra,12(sp)
4200bdc8:	842a                	mv	s0,a0
    for (size_t i = 0; i < process->fds_len; i++) {
4200bdca:	02030b63          	beqz	t1,4200be00 <proc_find_fd_raw+0x50>
4200bdce:	4701                	li	a4,0
        if (process->fds[i].virt == virt) {
4200bdd0:	5e51                	li	t3,-12
4200bdd2:	0bc5f063          	bgeu	a1,t3,4200be72 <proc_find_fd_raw+0xc2>
4200bdd6:	45d4                	lw	a3,12(a1)
4200bdd8:	00371813          	sll	a6,a4,0x3
4200bddc:	010687b3          	add	a5,a3,a6
4200bde0:	04084b63          	bltz	a6,4200be36 <proc_find_fd_raw+0x86>
4200bde4:	04d7eb63          	bltu	a5,a3,4200be3a <proc_find_fd_raw+0x8a>
4200bde8:	c7c1                	beqz	a5,4200be70 <proc_find_fd_raw+0xc0>
4200bdea:	0037f893          	and	a7,a5,3
4200bdee:	08089163          	bnez	a7,4200be70 <proc_find_fd_raw+0xc0>
4200bdf2:	0007a883          	lw	a7,0(a5)
4200bdf6:	04c88363          	beq	a7,a2,4200be3c <proc_find_fd_raw+0x8c>
    for (size_t i = 0; i < process->fds_len; i++) {
4200bdfa:	0705                	add	a4,a4,1 # 4200bd87 <proc_add_fd_raw+0x13f>
4200bdfc:	fc671be3          	bne	a4,t1,4200bdd2 <proc_find_fd_raw+0x22>
            badge_err_set_ok(ec);
            return process->fds[i].real;
        }
    }
    badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200be00:	c415                	beqz	s0,4200be2c <proc_find_fd_raw+0x7c>
4200be02:	420175b7          	lui	a1,0x42017
4200be06:	46e1                	li	a3,24
4200be08:	463d                	li	a2,15
4200be0a:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200be0e:	4511                	li	a0,4
4200be10:	00000717          	auipc	a4,0x0
4200be14:	c86f70ef          	jal	4200329a <logkf>
4200be18:	00347793          	and	a5,s0,3
4200be1c:	e3ad                	bnez	a5,4200be7e <proc_find_fd_raw+0xce>
4200be1e:	57f1                	li	a5,-4
4200be20:	06f47063          	bgeu	s0,a5,4200be80 <proc_find_fd_raw+0xd0>
4200be24:	47bd                	li	a5,15
4200be26:	c05c                	sw	a5,4(s0)
4200be28:	47e1                	li	a5,24
4200be2a:	c01c                	sw	a5,0(s0)
    return -1;
}
4200be2c:	40b2                	lw	ra,12(sp)
4200be2e:	4422                	lw	s0,8(sp)
    return -1;
4200be30:	557d                	li	a0,-1
}
4200be32:	0141                	add	sp,sp,16
4200be34:	8082                	ret
        if (process->fds[i].virt == virt) {
4200be36:	faf6f9e3          	bgeu	a3,a5,4200bde8 <proc_find_fd_raw+0x38>
4200be3a:	9002                	ebreak
            badge_err_set_ok(ec);
4200be3c:	c819                	beqz	s0,4200be52 <proc_find_fd_raw+0xa2>
4200be3e:	00347713          	and	a4,s0,3
4200be42:	eb1d                	bnez	a4,4200be78 <proc_find_fd_raw+0xc8>
4200be44:	5771                	li	a4,-4
4200be46:	02e47a63          	bgeu	s0,a4,4200be7a <proc_find_fd_raw+0xca>
4200be4a:	00042223          	sw	zero,4(s0)
4200be4e:	00042023          	sw	zero,0(s0)
            return process->fds[i].real;
4200be52:	00084c63          	bltz	a6,4200be6a <proc_find_fd_raw+0xba>
4200be56:	00d7ec63          	bltu	a5,a3,4200be6e <proc_find_fd_raw+0xbe>
4200be5a:	5771                	li	a4,-4
4200be5c:	02e7f063          	bgeu	a5,a4,4200be7c <proc_find_fd_raw+0xcc>
}
4200be60:	40b2                	lw	ra,12(sp)
4200be62:	4422                	lw	s0,8(sp)
            return process->fds[i].real;
4200be64:	43c8                	lw	a0,4(a5)
}
4200be66:	0141                	add	sp,sp,16
4200be68:	8082                	ret
            return process->fds[i].real;
4200be6a:	fef6f8e3          	bgeu	a3,a5,4200be5a <proc_find_fd_raw+0xaa>
4200be6e:	9002                	ebreak
        if (process->fds[i].virt == virt) {
4200be70:	9002                	ebreak
4200be72:	9002                	ebreak
    for (size_t i = 0; i < process->fds_len; i++) {
4200be74:	9002                	ebreak
4200be76:	9002                	ebreak
            badge_err_set_ok(ec);
4200be78:	9002                	ebreak
4200be7a:	9002                	ebreak
            return process->fds[i].real;
4200be7c:	9002                	ebreak
    badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200be7e:	9002                	ebreak
4200be80:	9002                	ebreak

4200be82 <proc_remove_fd_raw>:

// Remove a file from the process file handle list.
void proc_remove_fd_raw(badge_err_t *ec, process_t *process, int virt) {
    for (size_t i = 0; i < process->fds_len; i++) {
4200be82:	12058063          	beqz	a1,4200bfa2 <proc_remove_fd_raw+0x120>
void proc_remove_fd_raw(badge_err_t *ec, process_t *process, int virt) {
4200be86:	1141                	add	sp,sp,-16
4200be88:	c422                	sw	s0,8(sp)
4200be8a:	c606                	sw	ra,12(sp)
4200be8c:	c226                	sw	s1,4(sp)
    for (size_t i = 0; i < process->fds_len; i++) {
4200be8e:	0035f793          	and	a5,a1,3
4200be92:	842e                	mv	s0,a1
4200be94:	10079163          	bnez	a5,4200bf96 <proc_remove_fd_raw+0x114>
4200be98:	57e1                	li	a5,-8
4200be9a:	0ef5fc63          	bgeu	a1,a5,4200bf92 <proc_remove_fd_raw+0x110>
4200be9e:	0085a883          	lw	a7,8(a1)
4200bea2:	84aa                	mv	s1,a0
4200bea4:	4681                	li	a3,0
        if (process->fds[i].virt == virt) {
4200bea6:	5351                	li	t1,-12
    for (size_t i = 0; i < process->fds_len; i++) {
4200bea8:	02088b63          	beqz	a7,4200bede <proc_remove_fd_raw+0x5c>
        if (process->fds[i].virt == virt) {
4200beac:	0e647163          	bgeu	s0,t1,4200bf8e <proc_remove_fd_raw+0x10c>
4200beb0:	445c                	lw	a5,12(s0)
4200beb2:	00369713          	sll	a4,a3,0x3
4200beb6:	00e78533          	add	a0,a5,a4
4200beba:	04074d63          	bltz	a4,4200bf14 <proc_remove_fd_raw+0x92>
4200bebe:	04f56d63          	bltu	a0,a5,4200bf18 <proc_remove_fd_raw+0x96>
4200bec2:	c561                	beqz	a0,4200bf8a <proc_remove_fd_raw+0x108>
4200bec4:	00357593          	and	a1,a0,3
4200bec8:	e1e9                	bnez	a1,4200bf8a <proc_remove_fd_raw+0x108>
4200beca:	00052803          	lw	a6,0(a0) # 2000 <__stack_size>
    array_copy(array, array, ent_size, index, index + 1, ent_count - index);
4200bece:	00168593          	add	a1,a3,1
4200bed2:	04c80563          	beq	a6,a2,4200bf1c <proc_remove_fd_raw+0x9a>
    for (size_t i = 0; i < process->fds_len; i++) {
4200bed6:	01158463          	beq	a1,a7,4200bede <proc_remove_fd_raw+0x5c>
4200beda:	86ae                	mv	a3,a1
4200bedc:	bfc1                	j	4200beac <proc_remove_fd_raw+0x2a>
            array_len_remove(&process->fds, sizeof(proc_fd_t), &process->fds_len, NULL, i);
            badge_err_set_ok(ec);
            return;
        }
    }
    badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200bede:	c495                	beqz	s1,4200bf0a <proc_remove_fd_raw+0x88>
4200bee0:	420175b7          	lui	a1,0x42017
4200bee4:	46e1                	li	a3,24
4200bee6:	463d                	li	a2,15
4200bee8:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200beec:	4511                	li	a0,4
4200beee:	00000717          	auipc	a4,0x0
4200bef2:	ba8f70ef          	jal	4200329a <logkf>
4200bef6:	0034f793          	and	a5,s1,3
4200befa:	e7cd                	bnez	a5,4200bfa4 <proc_remove_fd_raw+0x122>
4200befc:	57f1                	li	a5,-4
4200befe:	0af4f063          	bgeu	s1,a5,4200bf9e <proc_remove_fd_raw+0x11c>
4200bf02:	47bd                	li	a5,15
4200bf04:	c0dc                	sw	a5,4(s1)
4200bf06:	47e1                	li	a5,24
4200bf08:	c09c                	sw	a5,0(s1)
}
4200bf0a:	40b2                	lw	ra,12(sp)
4200bf0c:	4422                	lw	s0,8(sp)
4200bf0e:	4492                	lw	s1,4(sp)
4200bf10:	0141                	add	sp,sp,16
4200bf12:	8082                	ret
        if (process->fds[i].virt == virt) {
4200bf14:	faa7f7e3          	bgeu	a5,a0,4200bec2 <proc_remove_fd_raw+0x40>
4200bf18:	c04a                	sw	s2,0(sp)
4200bf1a:	9002                	ebreak
4200bf1c:	c04a                	sw	s2,0(sp)
4200bf1e:	00c40593          	add	a1,s0,12
    array_remove(*array_ptr, ent_size, *ent_count_ptr, removed, index);
4200bf22:	00840613          	add	a2,s0,8
4200bf26:	c9b5                	beqz	a1,4200bf9a <proc_remove_fd_raw+0x118>
4200bf28:	898d                	and	a1,a1,3
4200bf2a:	e9a5                	bnez	a1,4200bf9a <proc_remove_fd_raw+0x118>
4200bf2c:	ca25                	beqz	a2,4200bf9c <proc_remove_fd_raw+0x11a>
4200bf2e:	8a0d                	and	a2,a2,3
4200bf30:	e635                	bnez	a2,4200bf9c <proc_remove_fd_raw+0x11a>
        (void *)((size_t)array_src + ent_size * src_index),
4200bf32:	0721                	add	a4,a4,8 # 4200bef6 <proc_remove_fd_raw+0x74>
    array_copy(array, array, ent_size, index, index + 1, ent_count - index);
4200bf34:	40d88633          	sub	a2,a7,a3
        (void *)((size_t)array_src + ent_size * src_index),
4200bf38:	00f705b3          	add	a1,a4,a5
    __builtin_memmove(
4200bf3c:	060e                	sll	a2,a2,0x3
4200bf3e:	c5bd                	beqz	a1,4200bfac <proc_remove_fd_raw+0x12a>
4200bf40:	a03f60ef          	jal	42002942 <memmove>
    array_len_resize(array_ptr, ent_size, ent_count_ptr, *ent_count_ptr - 1);
4200bf44:	00842903          	lw	s2,8(s0)
    void  *mem       = realloc(*array_ptr, ent_size * new_ent_count);
4200bf48:	4448                	lw	a0,12(s0)
    array_len_resize(array_ptr, ent_size, ent_count_ptr, *ent_count_ptr - 1);
4200bf4a:	197d                	add	s2,s2,-1
    void  *mem       = realloc(*array_ptr, ent_size * new_ent_count);
4200bf4c:	00391593          	sll	a1,s2,0x3
4200bf50:	483010ef          	jal	4200dbd2 <realloc>
    if (!mem)
4200bf54:	c501                	beqz	a0,4200bf5c <proc_remove_fd_raw+0xda>
    *array_ptr     = mem;
4200bf56:	c448                	sw	a0,12(s0)
    *ent_count_ptr = new_ent_count;
4200bf58:	01242423          	sw	s2,8(s0)
            badge_err_set_ok(ec);
4200bf5c:	c08d                	beqz	s1,4200bf7e <proc_remove_fd_raw+0xfc>
4200bf5e:	0034f793          	and	a5,s1,3
4200bf62:	e3b9                	bnez	a5,4200bfa8 <proc_remove_fd_raw+0x126>
4200bf64:	57f1                	li	a5,-4
4200bf66:	04f4f263          	bgeu	s1,a5,4200bfaa <proc_remove_fd_raw+0x128>
}
4200bf6a:	40b2                	lw	ra,12(sp)
4200bf6c:	4422                	lw	s0,8(sp)
            badge_err_set_ok(ec);
4200bf6e:	0004a223          	sw	zero,4(s1)
4200bf72:	0004a023          	sw	zero,0(s1)
4200bf76:	4902                	lw	s2,0(sp)
}
4200bf78:	4492                	lw	s1,4(sp)
4200bf7a:	0141                	add	sp,sp,16
4200bf7c:	8082                	ret
4200bf7e:	40b2                	lw	ra,12(sp)
4200bf80:	4422                	lw	s0,8(sp)
4200bf82:	4902                	lw	s2,0(sp)
4200bf84:	4492                	lw	s1,4(sp)
4200bf86:	0141                	add	sp,sp,16
4200bf88:	8082                	ret
4200bf8a:	c04a                	sw	s2,0(sp)
        if (process->fds[i].virt == virt) {
4200bf8c:	9002                	ebreak
4200bf8e:	c04a                	sw	s2,0(sp)
4200bf90:	9002                	ebreak
4200bf92:	c04a                	sw	s2,0(sp)
    for (size_t i = 0; i < process->fds_len; i++) {
4200bf94:	9002                	ebreak
4200bf96:	c04a                	sw	s2,0(sp)
4200bf98:	9002                	ebreak
    array_remove(*array_ptr, ent_size, *ent_count_ptr, removed, index);
4200bf9a:	9002                	ebreak
4200bf9c:	9002                	ebreak
4200bf9e:	c04a                	sw	s2,0(sp)
    badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200bfa0:	9002                	ebreak
    for (size_t i = 0; i < process->fds_len; i++) {
4200bfa2:	9002                	ebreak
4200bfa4:	c04a                	sw	s2,0(sp)
    badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200bfa6:	9002                	ebreak
            badge_err_set_ok(ec);
4200bfa8:	9002                	ebreak
4200bfaa:	9002                	ebreak
    __builtin_memmove(
4200bfac:	9002                	ebreak

4200bfae <proc_suspend>:


// Suspend all threads for a process except the current.
void proc_suspend(process_t *process, sched_thread_t *current) {
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200bfae:	c15d                	beqz	a0,4200c054 <proc_suspend+0xa6>
void proc_suspend(process_t *process, sched_thread_t *current) {
4200bfb0:	1101                	add	sp,sp,-32
4200bfb2:	ca26                	sw	s1,20(sp)
4200bfb4:	ce06                	sw	ra,28(sp)
4200bfb6:	cc22                	sw	s0,24(sp)
4200bfb8:	c84a                	sw	s2,16(sp)
4200bfba:	c64e                	sw	s3,12(sp)
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200bfbc:	00357793          	and	a5,a0,3
4200bfc0:	84aa                	mv	s1,a0
4200bfc2:	e7d9                	bnez	a5,4200c050 <proc_suspend+0xa2>
4200bfc4:	f5800793          	li	a5,-168
4200bfc8:	08f57563          	bgeu	a0,a5,4200c052 <proc_suspend+0xa4>
4200bfcc:	0a850993          	add	s3,a0,168
4200bfd0:	6631                	lui	a2,0xc
4200bfd2:	892e                	mv	s2,a1
4200bfd4:	35060613          	add	a2,a2,848 # c350 <__stack_size+0xa350>
4200bfd8:	4681                	li	a3,0
4200bfda:	85ce                	mv	a1,s3
4200bfdc:	4501                	li	a0,0
4200bfde:	e94f70ef          	jal	42003672 <mutex_acquire>
4200bfe2:	cd39                	beqz	a0,4200c040 <proc_suspend+0x92>
    for (size_t i = 0; i < process->threads_len; i++) {
4200bfe4:	4888                	lw	a0,16(s1)
4200bfe6:	4401                	li	s0,0
4200bfe8:	cd05                	beqz	a0,4200c020 <proc_suspend+0x72>
        if (process->threads[i] != current) {
4200bfea:	48d8                	lw	a4,20(s1)
4200bfec:	00241693          	sll	a3,s0,0x2
4200bff0:	00d707b3          	add	a5,a4,a3
4200bff4:	0406c063          	bltz	a3,4200c034 <proc_suspend+0x86>
4200bff8:	04e7e063          	bltu	a5,a4,4200c038 <proc_suspend+0x8a>
4200bffc:	cba9                	beqz	a5,4200c04e <proc_suspend+0xa0>
4200bffe:	0037f613          	and	a2,a5,3
4200c002:	e631                	bnez	a2,4200c04e <proc_suspend+0xa0>
4200c004:	438c                	lw	a1,0(a5)
4200c006:	01258a63          	beq	a1,s2,4200c01a <proc_suspend+0x6c>
            sched_suspend_thread(NULL, process->threads[i]);
4200c00a:	0206c863          	bltz	a3,4200c03a <proc_suspend+0x8c>
4200c00e:	02e7e863          	bltu	a5,a4,4200c03e <proc_suspend+0x90>
4200c012:	4501                	li	a0,0
4200c014:	63a020ef          	jal	4200e64e <sched_suspend_thread>
4200c018:	4888                	lw	a0,16(s1)
    for (size_t i = 0; i < process->threads_len; i++) {
4200c01a:	0405                	add	s0,s0,1
4200c01c:	fca467e3          	bltu	s0,a0,4200bfea <proc_suspend+0x3c>
        }
    }
    mutex_release(NULL, &process->mtx);
}
4200c020:	4462                	lw	s0,24(sp)
4200c022:	40f2                	lw	ra,28(sp)
4200c024:	44d2                	lw	s1,20(sp)
4200c026:	4942                	lw	s2,16(sp)
    mutex_release(NULL, &process->mtx);
4200c028:	85ce                	mv	a1,s3
}
4200c02a:	49b2                	lw	s3,12(sp)
    mutex_release(NULL, &process->mtx);
4200c02c:	4501                	li	a0,0
}
4200c02e:	6105                	add	sp,sp,32
    mutex_release(NULL, &process->mtx);
4200c030:	fd4f706f          	j	42003804 <mutex_release>
        if (process->threads[i] != current) {
4200c034:	fcf774e3          	bgeu	a4,a5,4200bffc <proc_suspend+0x4e>
4200c038:	9002                	ebreak
            sched_suspend_thread(NULL, process->threads[i]);
4200c03a:	fcf77ce3          	bgeu	a4,a5,4200c012 <proc_suspend+0x64>
4200c03e:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c040:	420195b7          	lui	a1,0x42019
4200c044:	ed058593          	add	a1,a1,-304 # 42018ed0 <hextab+0x2204>
4200c048:	a0cf70ef          	jal	42003254 <logk>
4200c04c:	9002                	ebreak
        if (process->threads[i] != current) {
4200c04e:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c050:	9002                	ebreak
4200c052:	9002                	ebreak
4200c054:	9002                	ebreak

4200c056 <proc_resume>:

// Resume all threads for a process.
void proc_resume(process_t *process) {
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c056:	c559                	beqz	a0,4200c0e4 <proc_resume+0x8e>
void proc_resume(process_t *process) {
4200c058:	1141                	add	sp,sp,-16
4200c05a:	c226                	sw	s1,4(sp)
4200c05c:	c606                	sw	ra,12(sp)
4200c05e:	c422                	sw	s0,8(sp)
4200c060:	c04a                	sw	s2,0(sp)
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c062:	00357793          	and	a5,a0,3
4200c066:	84aa                	mv	s1,a0
4200c068:	efa5                	bnez	a5,4200c0e0 <proc_resume+0x8a>
4200c06a:	f5800793          	li	a5,-168
4200c06e:	06f57a63          	bgeu	a0,a5,4200c0e2 <proc_resume+0x8c>
4200c072:	0a850913          	add	s2,a0,168
4200c076:	6631                	lui	a2,0xc
4200c078:	35060613          	add	a2,a2,848 # c350 <__stack_size+0xa350>
4200c07c:	4681                	li	a3,0
4200c07e:	85ca                	mv	a1,s2
4200c080:	4501                	li	a0,0
4200c082:	df0f70ef          	jal	42003672 <mutex_acquire>
4200c086:	c529                	beqz	a0,4200c0d0 <proc_resume+0x7a>
    for (size_t i = 0; i < process->threads_len; i++) {
4200c088:	489c                	lw	a5,16(s1)
4200c08a:	4401                	li	s0,0
4200c08c:	c795                	beqz	a5,4200c0b8 <proc_resume+0x62>
        sched_resume_thread(NULL, process->threads[i]);
4200c08e:	48d8                	lw	a4,20(s1)
4200c090:	00241693          	sll	a3,s0,0x2
4200c094:	00d707b3          	add	a5,a4,a3
4200c098:	0206c963          	bltz	a3,4200c0ca <proc_resume+0x74>
4200c09c:	02e7e963          	bltu	a5,a4,4200c0ce <proc_resume+0x78>
4200c0a0:	cf9d                	beqz	a5,4200c0de <proc_resume+0x88>
4200c0a2:	0037f713          	and	a4,a5,3
4200c0a6:	ef05                	bnez	a4,4200c0de <proc_resume+0x88>
4200c0a8:	438c                	lw	a1,0(a5)
4200c0aa:	4501                	li	a0,0
    for (size_t i = 0; i < process->threads_len; i++) {
4200c0ac:	0405                	add	s0,s0,1
        sched_resume_thread(NULL, process->threads[i]);
4200c0ae:	44a020ef          	jal	4200e4f8 <sched_resume_thread>
    for (size_t i = 0; i < process->threads_len; i++) {
4200c0b2:	489c                	lw	a5,16(s1)
4200c0b4:	fcf46de3          	bltu	s0,a5,4200c08e <proc_resume+0x38>
    }
    mutex_release(NULL, &process->mtx);
}
4200c0b8:	4422                	lw	s0,8(sp)
4200c0ba:	40b2                	lw	ra,12(sp)
4200c0bc:	4492                	lw	s1,4(sp)
    mutex_release(NULL, &process->mtx);
4200c0be:	85ca                	mv	a1,s2
}
4200c0c0:	4902                	lw	s2,0(sp)
    mutex_release(NULL, &process->mtx);
4200c0c2:	4501                	li	a0,0
}
4200c0c4:	0141                	add	sp,sp,16
    mutex_release(NULL, &process->mtx);
4200c0c6:	f3ef706f          	j	42003804 <mutex_release>
        sched_resume_thread(NULL, process->threads[i]);
4200c0ca:	fcf77be3          	bgeu	a4,a5,4200c0a0 <proc_resume+0x4a>
4200c0ce:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c0d0:	420195b7          	lui	a1,0x42019
4200c0d4:	f6858593          	add	a1,a1,-152 # 42018f68 <hextab+0x229c>
4200c0d8:	97cf70ef          	jal	42003254 <logk>
4200c0dc:	9002                	ebreak
        sched_resume_thread(NULL, process->threads[i]);
4200c0de:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c0e0:	9002                	ebreak
4200c0e2:	9002                	ebreak
4200c0e4:	9002                	ebreak

4200c0e6 <proc_delete_runtime>:

// Release all process runtime resources (threads, memory, files, etc.).
// Does not remove args, exit code, etc.
void proc_delete_runtime(process_t *process) {
    // This may not be run from one of the process' threads because it kills all of them.
    for (size_t i = 0; i < process->threads_len; i++) {
4200c0e6:	24050663          	beqz	a0,4200c332 <proc_delete_runtime+0x24c>
void proc_delete_runtime(process_t *process) {
4200c0ea:	1101                	add	sp,sp,-32
4200c0ec:	cc22                	sw	s0,24(sp)
4200c0ee:	ce06                	sw	ra,28(sp)
4200c0f0:	ca26                	sw	s1,20(sp)
4200c0f2:	c84a                	sw	s2,16(sp)
4200c0f4:	c64e                	sw	s3,12(sp)
4200c0f6:	c452                	sw	s4,8(sp)
    for (size_t i = 0; i < process->threads_len; i++) {
4200c0f8:	00357793          	and	a5,a0,3
4200c0fc:	842a                	mv	s0,a0
4200c0fe:	22079c63          	bnez	a5,4200c336 <proc_delete_runtime+0x250>
4200c102:	57c1                	li	a5,-16
4200c104:	22f57863          	bgeu	a0,a5,4200c334 <proc_delete_runtime+0x24e>
4200c108:	491c                	lw	a5,16(a0)
4200c10a:	cf8d                	beqz	a5,4200c144 <proc_delete_runtime+0x5e>
4200c10c:	4481                	li	s1,0
        assert_dev_drop(sched_get_current_thread() != process->threads[i]);
4200c10e:	5931                	li	s2,-20
4200c110:	7a5010ef          	jal	4200e0b4 <sched_get_current_thread>
4200c114:	21247763          	bgeu	s0,s2,4200c322 <proc_delete_runtime+0x23c>
4200c118:	4858                	lw	a4,20(s0)
4200c11a:	00249693          	sll	a3,s1,0x2
4200c11e:	00d707b3          	add	a5,a4,a3
4200c122:	0606ca63          	bltz	a3,4200c196 <proc_delete_runtime+0xb0>
4200c126:	06e7ea63          	bltu	a5,a4,4200c19a <proc_delete_runtime+0xb4>
4200c12a:	1e078d63          	beqz	a5,4200c324 <proc_delete_runtime+0x23e>
4200c12e:	0037f713          	and	a4,a5,3
4200c132:	1e071963          	bnez	a4,4200c324 <proc_delete_runtime+0x23e>
4200c136:	439c                	lw	a5,0(a5)
4200c138:	06f50263          	beq	a0,a5,4200c19c <proc_delete_runtime+0xb6>
    for (size_t i = 0; i < process->threads_len; i++) {
4200c13c:	481c                	lw	a5,16(s0)
4200c13e:	0485                	add	s1,s1,1
4200c140:	fcf4e8e3          	bltu	s1,a5,4200c110 <proc_delete_runtime+0x2a>
    }

    if (process->pid == 1 && !allow_proc1_death()) {
4200c144:	57a1                	li	a5,-24
4200c146:	1ef47963          	bgeu	s0,a5,4200c338 <proc_delete_runtime+0x252>
        logkf(LOG_FATAL, "Process 1 exited unexpectedly");
        panic_abort();
    }

    // Set the exiting flag so any return to user-mode kills the thread.
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c14a:	f5800793          	li	a5,-168
4200c14e:	1ef47663          	bgeu	s0,a5,4200c33a <proc_delete_runtime+0x254>
4200c152:	0a840a13          	add	s4,s0,168
4200c156:	6631                	lui	a2,0xc
4200c158:	35060613          	add	a2,a2,848 # c350 <__stack_size+0xa350>
4200c15c:	4681                	li	a3,0
4200c15e:	85d2                	mv	a1,s4
4200c160:	4501                	li	a0,0
4200c162:	d10f70ef          	jal	42003672 <mutex_acquire>
4200c166:	1a050663          	beqz	a0,4200c312 <proc_delete_runtime+0x22c>
    if (atomic_load(&process->flags) & PROC_EXITED) {
4200c16a:	f4c00793          	li	a5,-180
4200c16e:	1cf47763          	bgeu	s0,a5,4200c33c <proc_delete_runtime+0x256>
4200c172:	0ff0000f          	fence
4200c176:	0b442983          	lw	s3,180(s0)
4200c17a:	0ff0000f          	fence
4200c17e:	0049f993          	and	s3,s3,4
4200c182:	02098563          	beqz	s3,4200c1ac <proc_delete_runtime+0xc6>
    // Mark the process as exited.
    process->flags |= PROC_EXITED;
    process->flags &= ~PROC_EXITING & ~PROC_RUNNING;
    logkf(LOG_INFO, "Process %{d} stopped with code %{d}", process->pid, process->exit_code);
    mutex_release(NULL, &process->mtx);
}
4200c186:	40f2                	lw	ra,28(sp)
4200c188:	4462                	lw	s0,24(sp)
4200c18a:	44d2                	lw	s1,20(sp)
4200c18c:	4942                	lw	s2,16(sp)
4200c18e:	49b2                	lw	s3,12(sp)
4200c190:	4a22                	lw	s4,8(sp)
4200c192:	6105                	add	sp,sp,32
4200c194:	8082                	ret
        assert_dev_drop(sched_get_current_thread() != process->threads[i]);
4200c196:	f8f77ae3          	bgeu	a4,a5,4200c12a <proc_delete_runtime+0x44>
4200c19a:	9002                	ebreak
4200c19c:	420195b7          	lui	a1,0x42019
4200c1a0:	00058593          	mv	a1,a1
4200c1a4:	4501                	li	a0,0
4200c1a6:	8aef70ef          	jal	42003254 <logk>
4200c1aa:	9002                	ebreak
        atomic_fetch_or(&process->flags, PROC_EXITING);
4200c1ac:	4789                	li	a5,2
4200c1ae:	0b440713          	add	a4,s0,180
4200c1b2:	0f50000f          	fence	iorw,ow
4200c1b6:	44f7202f          	amoor.w.aq	zero,a5,(a4)
        atomic_thread_fence(memory_order_release);
4200c1ba:	0ff0000f          	fence
    for (size_t i = 0; i < process->threads_len; i++) {
4200c1be:	481c                	lw	a5,16(s0)
4200c1c0:	cbbd                	beqz	a5,4200c236 <proc_delete_runtime+0x150>
4200c1c2:	4481                	li	s1,0
        sched_resume_thread(NULL, process->threads[i]);
4200c1c4:	4858                	lw	a4,20(s0)
4200c1c6:	00249693          	sll	a3,s1,0x2
4200c1ca:	00d707b3          	add	a5,a4,a3
4200c1ce:	1206c963          	bltz	a3,4200c300 <proc_delete_runtime+0x21a>
4200c1d2:	12e7e963          	bltu	a5,a4,4200c304 <proc_delete_runtime+0x21e>
4200c1d6:	14078963          	beqz	a5,4200c328 <proc_delete_runtime+0x242>
4200c1da:	0037f713          	and	a4,a5,3
4200c1de:	14071563          	bnez	a4,4200c328 <proc_delete_runtime+0x242>
4200c1e2:	438c                	lw	a1,0(a5)
4200c1e4:	4501                	li	a0,0
    for (size_t i = 0; i < process->threads_len; i++) {
4200c1e6:	0485                	add	s1,s1,1
        sched_resume_thread(NULL, process->threads[i]);
4200c1e8:	310020ef          	jal	4200e4f8 <sched_resume_thread>
    for (size_t i = 0; i < process->threads_len; i++) {
4200c1ec:	481c                	lw	a5,16(s0)
4200c1ee:	fcf4ebe3          	bltu	s1,a5,4200c1c4 <proc_delete_runtime+0xde>
        for (size_t i = 0; i < process->threads_len; i++) {
4200c1f2:	c3b1                	beqz	a5,4200c236 <proc_delete_runtime+0x150>
4200c1f4:	4481                	li	s1,0
        waiting = false;
4200c1f6:	4901                	li	s2,0
            if (sched_thread_is_running(NULL, process->threads[i])) {
4200c1f8:	4858                	lw	a4,20(s0)
4200c1fa:	00249693          	sll	a3,s1,0x2
4200c1fe:	00d707b3          	add	a5,a4,a3
4200c202:	0e06cc63          	bltz	a3,4200c2fa <proc_delete_runtime+0x214>
4200c206:	0ee7ec63          	bltu	a5,a4,4200c2fe <proc_delete_runtime+0x218>
4200c20a:	10078b63          	beqz	a5,4200c320 <proc_delete_runtime+0x23a>
4200c20e:	0037f713          	and	a4,a5,3
4200c212:	10071763          	bnez	a4,4200c320 <proc_delete_runtime+0x23a>
4200c216:	438c                	lw	a1,0(a5)
4200c218:	4501                	li	a0,0
4200c21a:	2ea020ef          	jal	4200e504 <sched_thread_is_running>
4200c21e:	c111                	beqz	a0,4200c222 <proc_delete_runtime+0x13c>
                waiting = true;
4200c220:	892a                	mv	s2,a0
        for (size_t i = 0; i < process->threads_len; i++) {
4200c222:	481c                	lw	a5,16(s0)
4200c224:	0485                	add	s1,s1,1
4200c226:	fcf4e9e3          	bltu	s1,a5,4200c1f8 <proc_delete_runtime+0x112>
        sched_yield();
4200c22a:	38a020ef          	jal	4200e5b4 <sched_yield>
    while (waiting) {
4200c22e:	00090663          	beqz	s2,4200c23a <proc_delete_runtime+0x154>
4200c232:	481c                	lw	a5,16(s0)
        for (size_t i = 0; i < process->threads_len; i++) {
4200c234:	f3e1                	bnez	a5,4200c1f4 <proc_delete_runtime+0x10e>
        sched_yield();
4200c236:	37e020ef          	jal	4200e5b4 <sched_yield>
    for (size_t i = 0; i < process->threads_len; i++) {
4200c23a:	481c                	lw	a5,16(s0)
4200c23c:	cfa1                	beqz	a5,4200c294 <proc_delete_runtime+0x1ae>
        free((void *)process->threads[i]->kernel_stack_bottom);
4200c23e:	5971                	li	s2,-4
4200c240:	4858                	lw	a4,20(s0)
4200c242:	00299493          	sll	s1,s3,0x2
4200c246:	009707b3          	add	a5,a4,s1
4200c24a:	0c04c163          	bltz	s1,4200c30c <proc_delete_runtime+0x226>
4200c24e:	0ce7e163          	bltu	a5,a4,4200c310 <proc_delete_runtime+0x22a>
4200c252:	cbf1                	beqz	a5,4200c326 <proc_delete_runtime+0x240>
4200c254:	0037f713          	and	a4,a5,3
4200c258:	e779                	bnez	a4,4200c326 <proc_delete_runtime+0x240>
4200c25a:	439c                	lw	a5,0(a5)
4200c25c:	cbe9                	beqz	a5,4200c32e <proc_delete_runtime+0x248>
4200c25e:	0037f713          	and	a4,a5,3
4200c262:	e771                	bnez	a4,4200c32e <proc_delete_runtime+0x248>
4200c264:	0d27f463          	bgeu	a5,s2,4200c32c <proc_delete_runtime+0x246>
4200c268:	43c8                	lw	a0,4(a5)
4200c26a:	0f3010ef          	jal	4200db5c <free>
        sched_destroy_thread(NULL, process->threads[i]);
4200c26e:	4858                	lw	a4,20(s0)
4200c270:	009707b3          	add	a5,a4,s1
4200c274:	0804c963          	bltz	s1,4200c306 <proc_delete_runtime+0x220>
4200c278:	08e7e963          	bltu	a5,a4,4200c30a <proc_delete_runtime+0x224>
4200c27c:	c7dd                	beqz	a5,4200c32a <proc_delete_runtime+0x244>
4200c27e:	0037f713          	and	a4,a5,3
4200c282:	e745                	bnez	a4,4200c32a <proc_delete_runtime+0x244>
4200c284:	438c                	lw	a1,0(a5)
4200c286:	4501                	li	a0,0
    for (size_t i = 0; i < process->threads_len; i++) {
4200c288:	0985                	add	s3,s3,1
        sched_destroy_thread(NULL, process->threads[i]);
4200c28a:	7d4020ef          	jal	4200ea5e <sched_destroy_thread>
    for (size_t i = 0; i < process->threads_len; i++) {
4200c28e:	481c                	lw	a5,16(s0)
4200c290:	faf9e8e3          	bltu	s3,a5,4200c240 <proc_delete_runtime+0x15a>
    free(process->threads);
4200c294:	4848                	lw	a0,20(s0)
    process->threads_len = 0;
4200c296:	00042823          	sw	zero,16(s0)
    free(process->threads);
4200c29a:	0c3010ef          	jal	4200db5c <free>
    while (process->memmap.regions_len) {
4200c29e:	407c                	lw	a5,68(s0)
4200c2a0:	cb81                	beqz	a5,4200c2b0 <proc_delete_runtime+0x1ca>
        proc_unmap_raw(NULL, process, process->memmap.regions[0].base);
4200c2a2:	4430                	lw	a2,72(s0)
4200c2a4:	85a2                	mv	a1,s0
4200c2a6:	4501                	li	a0,0
4200c2a8:	df8ff0ef          	jal	4200b8a0 <proc_unmap_raw>
    while (process->memmap.regions_len) {
4200c2ac:	407c                	lw	a5,68(s0)
4200c2ae:	fbf5                	bnez	a5,4200c2a2 <proc_delete_runtime+0x1bc>
    process->flags |= PROC_EXITED;
4200c2b0:	4791                	li	a5,4
4200c2b2:	0b440713          	add	a4,s0,180
4200c2b6:	0f50000f          	fence	iorw,ow
4200c2ba:	44f7202f          	amoor.w.aq	zero,a5,(a4)
    process->flags &= ~PROC_EXITING & ~PROC_RUNNING;
4200c2be:	57f1                	li	a5,-4
4200c2c0:	0f50000f          	fence	iorw,ow
4200c2c4:	64f7202f          	amoand.w.aq	zero,a5,(a4)
    logkf(LOG_INFO, "Process %{d} stopped with code %{d}", process->pid, process->exit_code);
4200c2c8:	f4800793          	li	a5,-184
4200c2cc:	4c10                	lw	a2,24(s0)
4200c2ce:	06f47163          	bgeu	s0,a5,4200c330 <proc_delete_runtime+0x24a>
4200c2d2:	0b842683          	lw	a3,184(s0)
4200c2d6:	420195b7          	lui	a1,0x42019
4200c2da:	13058593          	add	a1,a1,304 # 42019130 <hextab+0x2464>
4200c2de:	450d                	li	a0,3
4200c2e0:	fbbf60ef          	jal	4200329a <logkf>
}
4200c2e4:	4462                	lw	s0,24(sp)
4200c2e6:	40f2                	lw	ra,28(sp)
4200c2e8:	44d2                	lw	s1,20(sp)
4200c2ea:	4942                	lw	s2,16(sp)
4200c2ec:	49b2                	lw	s3,12(sp)
    mutex_release(NULL, &process->mtx);
4200c2ee:	85d2                	mv	a1,s4
}
4200c2f0:	4a22                	lw	s4,8(sp)
    mutex_release(NULL, &process->mtx);
4200c2f2:	4501                	li	a0,0
}
4200c2f4:	6105                	add	sp,sp,32
    mutex_release(NULL, &process->mtx);
4200c2f6:	d0ef706f          	j	42003804 <mutex_release>
            if (sched_thread_is_running(NULL, process->threads[i])) {
4200c2fa:	f0f778e3          	bgeu	a4,a5,4200c20a <proc_delete_runtime+0x124>
4200c2fe:	9002                	ebreak
        sched_resume_thread(NULL, process->threads[i]);
4200c300:	ecf77be3          	bgeu	a4,a5,4200c1d6 <proc_delete_runtime+0xf0>
4200c304:	9002                	ebreak
        sched_destroy_thread(NULL, process->threads[i]);
4200c306:	f6f77be3          	bgeu	a4,a5,4200c27c <proc_delete_runtime+0x196>
4200c30a:	9002                	ebreak
        free((void *)process->threads[i]->kernel_stack_bottom);
4200c30c:	f4f773e3          	bgeu	a4,a5,4200c252 <proc_delete_runtime+0x16c>
4200c310:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c312:	420195b7          	lui	a1,0x42019
4200c316:	09858593          	add	a1,a1,152 # 42019098 <hextab+0x23cc>
4200c31a:	f3bf60ef          	jal	42003254 <logk>
4200c31e:	9002                	ebreak
            if (sched_thread_is_running(NULL, process->threads[i])) {
4200c320:	9002                	ebreak
        assert_dev_drop(sched_get_current_thread() != process->threads[i]);
4200c322:	9002                	ebreak
4200c324:	9002                	ebreak
        free((void *)process->threads[i]->kernel_stack_bottom);
4200c326:	9002                	ebreak
        sched_resume_thread(NULL, process->threads[i]);
4200c328:	9002                	ebreak
        sched_destroy_thread(NULL, process->threads[i]);
4200c32a:	9002                	ebreak
        free((void *)process->threads[i]->kernel_stack_bottom);
4200c32c:	9002                	ebreak
4200c32e:	9002                	ebreak
    logkf(LOG_INFO, "Process %{d} stopped with code %{d}", process->pid, process->exit_code);
4200c330:	9002                	ebreak
    for (size_t i = 0; i < process->threads_len; i++) {
4200c332:	9002                	ebreak
4200c334:	9002                	ebreak
4200c336:	9002                	ebreak
    if (process->pid == 1 && !allow_proc1_death()) {
4200c338:	9002                	ebreak
    assert_always(mutex_acquire(NULL, &process->mtx, PROC_MTX_TIMEOUT));
4200c33a:	9002                	ebreak
    if (atomic_load(&process->flags) & PROC_EXITED) {
4200c33c:	9002                	ebreak

4200c33e <proc_create>:



// Create a new, empty process.
pid_t proc_create(badge_err_t *ec) {
4200c33e:	1141                	add	sp,sp,-16
4200c340:	c606                	sw	ra,12(sp)
    return proc_create_raw(ec)->pid;
4200c342:	f11fe0ef          	jal	4200b252 <proc_create_raw>
4200c346:	c919                	beqz	a0,4200c35c <proc_create+0x1e>
4200c348:	00357793          	and	a5,a0,3
4200c34c:	eb81                	bnez	a5,4200c35c <proc_create+0x1e>
4200c34e:	57a1                	li	a5,-24
4200c350:	00f57663          	bgeu	a0,a5,4200c35c <proc_create+0x1e>
}
4200c354:	40b2                	lw	ra,12(sp)
4200c356:	4d08                	lw	a0,24(a0)
4200c358:	0141                	add	sp,sp,16
4200c35a:	8082                	ret
    return proc_create_raw(ec)->pid;
4200c35c:	9002                	ebreak

4200c35e <proc_delete>:

// Delete a process and release any resources it had.
void proc_delete(pid_t pid) {
4200c35e:	7151                	add	sp,sp,-240
4200c360:	cdd2                	sw	s4,216(sp)
    mutex_acquire(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c362:	800006b7          	lui	a3,0x80000
4200c366:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
void proc_delete(pid_t pid) {
4200c368:	d5a2                	sw	s0,232(sp)
    mutex_acquire(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c36a:	567d                	li	a2,-1
void proc_delete(pid_t pid) {
4200c36c:	842a                	mv	s0,a0
    mutex_acquire(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c36e:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c372:	4501                	li	a0,0
void proc_delete(pid_t pid) {
4200c374:	d786                	sw	ra,236(sp)
4200c376:	d1ca                	sw	s2,224(sp)
4200c378:	cfce                	sw	s3,220(sp)
    mutex_acquire(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c37a:	af8f70ef          	jal	42003672 <mutex_acquire>
    process_t         dummy     = {.pid = pid};
4200c37e:	085c                	add	a5,sp,20
4200c380:	0bc00613          	li	a2,188
4200c384:	4581                	li	a1,0
4200c386:	853e                	mv	a0,a5
4200c388:	d8ef60ef          	jal	42002916 <memset>
    process_t        *dummy_ptr = &dummy;
    array_binsearch_t res       = array_binsearch(procs, sizeof(process_t *), procs_len, &dummy_ptr, proc_sort_pid_cmp);
4200c38c:	4080a9b7          	lui	s3,0x4080a
4200c390:	4080a937          	lui	s2,0x4080a
    process_t         dummy     = {.pid = pid};
4200c394:	87aa                	mv	a5,a0
    array_binsearch_t res       = array_binsearch(procs, sizeof(process_t *), procs_len, &dummy_ptr, proc_sort_pid_cmp);
4200c396:	e449a603          	lw	a2,-444(s3) # 40809e44 <procs_len>
4200c39a:	e3c92503          	lw	a0,-452(s2) # 40809e3c <procs>
4200c39e:	4200b737          	lui	a4,0x4200b
4200c3a2:	fa870713          	add	a4,a4,-88 # 4200afa8 <proc_sort_pid_cmp>
4200c3a6:	0034                	add	a3,sp,8
4200c3a8:	4591                	li	a1,4
    process_t        *dummy_ptr = &dummy;
4200c3aa:	c43e                	sw	a5,8(sp)
    process_t         dummy     = {.pid = pid};
4200c3ac:	d622                	sw	s0,44(sp)
    array_binsearch_t res       = array_binsearch(procs, sizeof(process_t *), procs_len, &dummy_ptr, proc_sort_pid_cmp);
4200c3ae:	f14f40ef          	jal	42000ac2 <array_binsearch>
4200c3b2:	c82e                	sw	a1,16(sp)
4200c3b4:	c62a                	sw	a0,12(sp)
    if (!res.found) {
4200c3b6:	0ff5f593          	zext.b	a1,a1
4200c3ba:	4785                	li	a5,1
4200c3bc:	0eb7e163          	bltu	a5,a1,4200c49e <proc_delete+0x140>
4200c3c0:	8985                	and	a1,a1,1
4200c3c2:	c5dd                	beqz	a1,4200c470 <proc_delete+0x112>
        mutex_release(NULL, &proc_mtx);
        return;
    }
    process_t *handle = procs[res.index];
4200c3c4:	e3c92703          	lw	a4,-452(s2)
4200c3c8:	00251693          	sll	a3,a0,0x2
4200c3cc:	d3a6                	sw	s1,228(sp)
4200c3ce:	cbd6                	sw	s5,212(sp)
4200c3d0:	842a                	mv	s0,a0
4200c3d2:	00d707b3          	add	a5,a4,a3
4200c3d6:	0a06d963          	bgez	a3,4200c488 <proc_delete+0x12a>
4200c3da:	0af76963          	bltu	a4,a5,4200c48c <proc_delete+0x12e>
4200c3de:	c7dd                	beqz	a5,4200c48c <proc_delete+0x12e>
4200c3e0:	0037f713          	and	a4,a5,3
4200c3e4:	e745                	bnez	a4,4200c48c <proc_delete+0x12e>
4200c3e6:	4384                	lw	s1,0(a5)

    // Stop the possibly running process and release all run-time resources.
    proc_delete_runtime(handle);
4200c3e8:	8526                	mv	a0,s1
4200c3ea:	cfdff0ef          	jal	4200c0e6 <proc_delete_runtime>

    // Release kernel memory allocated to process.
    free(handle->argv);
4200c3ee:	ccd9                	beqz	s1,4200c48c <proc_delete+0x12e>
4200c3f0:	0034f793          	and	a5,s1,3
4200c3f4:	efc1                	bnez	a5,4200c48c <proc_delete+0x12e>
4200c3f6:	57f1                	li	a5,-4
4200c3f8:	08f4fa63          	bgeu	s1,a5,4200c48c <proc_delete+0x12e>
4200c3fc:	40c8                	lw	a0,4(s1)
4200c3fe:	75e010ef          	jal	4200db5c <free>
    free(handle);
4200c402:	8526                	mv	a0,s1
4200c404:	758010ef          	jal	4200db5c <free>
        (void *)((size_t)array_dst + ent_size * dst_index),
4200c408:	0bc00713          	li	a4,188
4200c40c:	02e40533          	mul	a0,s0,a4
4200c410:	e3c92783          	lw	a5,-452(s2)
    array_copy(array, array, ent_size, index, index + 1, ent_count - index);
4200c414:	e449a603          	lw	a2,-444(s3)
4200c418:	8e01                	sub	a2,a2,s0
        (void *)((size_t)array_src + ent_size * src_index),
4200c41a:	0bc50593          	add	a1,a0,188
        (void *)((size_t)array_dst + ent_size * dst_index),
4200c41e:	953e                	add	a0,a0,a5
    __builtin_memmove(
4200c420:	02e60633          	mul	a2,a2,a4
        (void *)((size_t)array_src + ent_size * src_index),
4200c424:	95be                	add	a1,a1,a5
    __builtin_memmove(
4200c426:	c13d                	beqz	a0,4200c48c <proc_delete+0x12e>
4200c428:	c1b5                	beqz	a1,4200c48c <proc_delete+0x12e>
4200c42a:	d18f60ef          	jal	42002942 <memmove>
    if (*ent_cap_ptr >= new_ent_count) {
4200c42e:	4080aab7          	lui	s5,0x4080a
static inline void array_lencap_remove(
    void *_array_ptr, size_t ent_size, size_t *ent_count_ptr, size_t *ent_cap_ptr, void *removed, size_t index
) {
    void **array_ptr = _array_ptr;
    array_remove(*array_ptr, ent_size, *ent_count_ptr, removed, index);
    array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr - 1);
4200c432:	e449a483          	lw	s1,-444(s3)
    if (*ent_cap_ptr >= new_ent_count) {
4200c436:	e40aa403          	lw	s0,-448(s5) # 40809e40 <procs_cap>
    array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr - 1);
4200c43a:	14fd                	add	s1,s1,-1
    if (*ent_cap_ptr >= new_ent_count) {
4200c43c:	04947963          	bgeu	s0,s1,4200c48e <proc_delete+0x130>
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200c440:	e401                	bnez	s0,4200c448 <proc_delete+0xea>
4200c442:	4409                	li	s0,2
    while (new_cap < new_ent_count) new_cap *= 2;
4200c444:	00947563          	bgeu	s0,s1,4200c44e <proc_delete+0xf0>
4200c448:	0406                	sll	s0,s0,0x1
4200c44a:	fe946fe3          	bltu	s0,s1,4200c448 <proc_delete+0xea>
    void *mem = realloc(*array_ptr, ent_size * new_cap);
4200c44e:	0bc00593          	li	a1,188
4200c452:	02b405b3          	mul	a1,s0,a1
4200c456:	e3c92503          	lw	a0,-452(s2)
4200c45a:	778010ef          	jal	4200dbd2 <realloc>
    if (!mem)
4200c45e:	cd0d                	beqz	a0,4200c498 <proc_delete+0x13a>
    *ent_count_ptr = new_ent_count;
4200c460:	e499a223          	sw	s1,-444(s3)
    *ent_cap_ptr   = new_cap;
4200c464:	e48aa023          	sw	s0,-448(s5)
    return true;
4200c468:	549e                	lw	s1,228(sp)
4200c46a:	4ade                	lw	s5,212(sp)
    *array_ptr     = mem;
4200c46c:	e2a92e23          	sw	a0,-452(s2)
        mutex_release(NULL, &proc_mtx);
4200c470:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c474:	4501                	li	a0,0
4200c476:	b8ef70ef          	jal	42003804 <mutex_release>
    array_lencap_remove(&procs, sizeof(process_t), &procs_len, &procs_cap, NULL, res.index);
    mutex_release(NULL, &proc_mtx);
}
4200c47a:	50be                	lw	ra,236(sp)
4200c47c:	542e                	lw	s0,232(sp)
4200c47e:	590e                	lw	s2,224(sp)
4200c480:	49fe                	lw	s3,220(sp)
4200c482:	4a6e                	lw	s4,216(sp)
4200c484:	616d                	add	sp,sp,240
4200c486:	8082                	ret
    process_t *handle = procs[res.index];
4200c488:	f4e7fbe3          	bgeu	a5,a4,4200c3de <proc_delete+0x80>
    free(handle->argv);
4200c48c:	9002                	ebreak
        *ent_count_ptr = new_ent_count;
4200c48e:	e499a223          	sw	s1,-444(s3)
        return true;
4200c492:	4ade                	lw	s5,212(sp)
4200c494:	549e                	lw	s1,228(sp)
4200c496:	bfe9                	j	4200c470 <proc_delete+0x112>
4200c498:	549e                	lw	s1,228(sp)
4200c49a:	4ade                	lw	s5,212(sp)
4200c49c:	bfd1                	j	4200c470 <proc_delete+0x112>
4200c49e:	d3a6                	sw	s1,228(sp)
4200c4a0:	cbd6                	sw	s5,212(sp)
4200c4a2:	9002                	ebreak

4200c4a4 <clean_up_from_housekeeping>:
    proc_delete((pid_t)arg);
4200c4a4:	852e                	mv	a0,a1
4200c4a6:	eb9ff06f          	j	4200c35e <proc_delete>

4200c4aa <proc_getflags>:

// Get the process' flags.
uint32_t proc_getflags(badge_err_t *ec, pid_t pid) {
4200c4aa:	1141                	add	sp,sp,-16
4200c4ac:	c04a                	sw	s2,0(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c4ae:	800006b7          	lui	a3,0x80000
uint32_t proc_getflags(badge_err_t *ec, pid_t pid) {
4200c4b2:	c422                	sw	s0,8(sp)
4200c4b4:	c226                	sw	s1,4(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c4b6:	567d                	li	a2,-1
uint32_t proc_getflags(badge_err_t *ec, pid_t pid) {
4200c4b8:	84ae                	mv	s1,a1
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c4ba:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c4bc:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
uint32_t proc_getflags(badge_err_t *ec, pid_t pid) {
4200c4c0:	842a                	mv	s0,a0
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c4c2:	4501                	li	a0,0
uint32_t proc_getflags(badge_err_t *ec, pid_t pid) {
4200c4c4:	c606                	sw	ra,12(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c4c6:	c64f70ef          	jal	4200392a <mutex_acquire_shared>
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c4ca:	800006b7          	lui	a3,0x80000
4200c4ce:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c4d2:	567d                	li	a2,-1
4200c4d4:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c4d6:	4501                	li	a0,0
4200c4d8:	c52f70ef          	jal	4200392a <mutex_acquire_shared>
    process_t *res = proc_get_unsafe(pid);
4200c4dc:	8526                	mv	a0,s1
4200c4de:	fc1fe0ef          	jal	4200b49e <proc_get_unsafe>
4200c4e2:	84aa                	mv	s1,a0
    mutex_release_shared(NULL, &proc_mtx);
4200c4e4:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c4e8:	4501                	li	a0,0
4200c4ea:	e6af70ef          	jal	42003b54 <mutex_release_shared>
    process_t *proc = proc_get(pid);
    uint32_t   flags;
    if (proc) {
4200c4ee:	c4a9                	beqz	s1,4200c538 <proc_getflags+0x8e>
        flags = atomic_load(&proc->flags);
4200c4f0:	0034f793          	and	a5,s1,3
4200c4f4:	ebb5                	bnez	a5,4200c568 <proc_getflags+0xbe>
4200c4f6:	f4c00793          	li	a5,-180
4200c4fa:	06f4f763          	bgeu	s1,a5,4200c568 <proc_getflags+0xbe>
4200c4fe:	0ff0000f          	fence
4200c502:	0b44a483          	lw	s1,180(s1)
4200c506:	0ff0000f          	fence
        badge_err_set_ok(ec);
4200c50a:	c819                	beqz	s0,4200c520 <proc_getflags+0x76>
4200c50c:	00347793          	and	a5,s0,3
4200c510:	efa1                	bnez	a5,4200c568 <proc_getflags+0xbe>
4200c512:	57f1                	li	a5,-4
4200c514:	04f47a63          	bgeu	s0,a5,4200c568 <proc_getflags+0xbe>
4200c518:	00042223          	sw	zero,4(s0)
4200c51c:	00042023          	sw	zero,0(s0)
    } else {
        flags = 0;
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
    }
    mutex_release_shared(NULL, &proc_mtx);
4200c520:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c524:	4501                	li	a0,0
4200c526:	e2ef70ef          	jal	42003b54 <mutex_release_shared>
    return flags;
}
4200c52a:	40b2                	lw	ra,12(sp)
4200c52c:	4422                	lw	s0,8(sp)
4200c52e:	4902                	lw	s2,0(sp)
4200c530:	8526                	mv	a0,s1
4200c532:	4492                	lw	s1,4(sp)
4200c534:	0141                	add	sp,sp,16
4200c536:	8082                	ret
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200c538:	c415                	beqz	s0,4200c564 <proc_getflags+0xba>
4200c53a:	420175b7          	lui	a1,0x42017
4200c53e:	46e1                	li	a3,24
4200c540:	463d                	li	a2,15
4200c542:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200c546:	4511                	li	a0,4
4200c548:	00000717          	auipc	a4,0x0
4200c54c:	d4ff60ef          	jal	4200329a <logkf>
4200c550:	00347793          	and	a5,s0,3
4200c554:	eb91                	bnez	a5,4200c568 <proc_getflags+0xbe>
4200c556:	57f1                	li	a5,-4
4200c558:	00f47863          	bgeu	s0,a5,4200c568 <proc_getflags+0xbe>
4200c55c:	47bd                	li	a5,15
4200c55e:	c05c                	sw	a5,4(s0)
4200c560:	47e1                	li	a5,24
4200c562:	c01c                	sw	a5,0(s0)
        flags = 0;
4200c564:	4481                	li	s1,0
4200c566:	bf6d                	j	4200c520 <proc_getflags+0x76>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200c568:	9002                	ebreak

4200c56a <proc_setargs>:


// Set arguments for a process.
// If omitted, argc will be 0 and argv will be NULL.
void proc_setargs(badge_err_t *ec, pid_t pid, int argc, char const *const *argv) {
4200c56a:	1101                	add	sp,sp,-32
4200c56c:	cc22                	sw	s0,24(sp)
4200c56e:	c452                	sw	s4,8(sp)
4200c570:	8a36                	mv	s4,a3
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c572:	800006b7          	lui	a3,0x80000
void proc_setargs(badge_err_t *ec, pid_t pid, int argc, char const *const *argv) {
4200c576:	ca26                	sw	s1,20(sp)
4200c578:	c84a                	sw	s2,16(sp)
4200c57a:	c64e                	sw	s3,12(sp)
4200c57c:	84ae                	mv	s1,a1
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c57e:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c580:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
void proc_setargs(badge_err_t *ec, pid_t pid, int argc, char const *const *argv) {
4200c584:	892a                	mv	s2,a0
4200c586:	89b2                	mv	s3,a2
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c588:	4501                	li	a0,0
4200c58a:	567d                	li	a2,-1
void proc_setargs(badge_err_t *ec, pid_t pid, int argc, char const *const *argv) {
4200c58c:	ce06                	sw	ra,28(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c58e:	b9cf70ef          	jal	4200392a <mutex_acquire_shared>
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c592:	800006b7          	lui	a3,0x80000
4200c596:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c59a:	567d                	li	a2,-1
4200c59c:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c59e:	4501                	li	a0,0
4200c5a0:	b8af70ef          	jal	4200392a <mutex_acquire_shared>
    process_t *res = proc_get_unsafe(pid);
4200c5a4:	8526                	mv	a0,s1
4200c5a6:	ef9fe0ef          	jal	4200b49e <proc_get_unsafe>
4200c5aa:	84aa                	mv	s1,a0
    mutex_release_shared(NULL, &proc_mtx);
4200c5ac:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c5b0:	4501                	li	a0,0
4200c5b2:	da2f70ef          	jal	42003b54 <mutex_release_shared>
    process_t *proc = proc_get(pid);
    if (proc) {
4200c5b6:	c48d                	beqz	s1,4200c5e0 <proc_setargs+0x76>
    if (argc <= 0)
4200c5b8:	01305863          	blez	s3,4200c5c8 <proc_setargs+0x5e>
4200c5bc:	86d2                	mv	a3,s4
4200c5be:	864e                	mv	a2,s3
4200c5c0:	85a6                	mv	a1,s1
4200c5c2:	854a                	mv	a0,s2
4200c5c4:	a4bfe0ef          	jal	4200b00e <proc_setargs_raw.part.0>
        proc_setargs_raw(ec, proc, argc, argv);
    } else {
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
    }
    mutex_release_shared(NULL, &proc_mtx);
4200c5c8:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
}
4200c5cc:	4462                	lw	s0,24(sp)
4200c5ce:	40f2                	lw	ra,28(sp)
4200c5d0:	44d2                	lw	s1,20(sp)
4200c5d2:	4942                	lw	s2,16(sp)
4200c5d4:	49b2                	lw	s3,12(sp)
4200c5d6:	4a22                	lw	s4,8(sp)
    mutex_release_shared(NULL, &proc_mtx);
4200c5d8:	4501                	li	a0,0
}
4200c5da:	6105                	add	sp,sp,32
    mutex_release_shared(NULL, &proc_mtx);
4200c5dc:	d78f706f          	j	42003b54 <mutex_release_shared>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200c5e0:	fe0904e3          	beqz	s2,4200c5c8 <proc_setargs+0x5e>
4200c5e4:	420175b7          	lui	a1,0x42017
4200c5e8:	46e1                	li	a3,24
4200c5ea:	463d                	li	a2,15
4200c5ec:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200c5f0:	4511                	li	a0,4
4200c5f2:	00000717          	auipc	a4,0x0
4200c5f6:	ca5f60ef          	jal	4200329a <logkf>
4200c5fa:	00397793          	and	a5,s2,3
4200c5fe:	eb99                	bnez	a5,4200c614 <proc_setargs+0xaa>
4200c600:	57f1                	li	a5,-4
4200c602:	00f97963          	bgeu	s2,a5,4200c614 <proc_setargs+0xaa>
4200c606:	47bd                	li	a5,15
4200c608:	00f92223          	sw	a5,4(s2)
4200c60c:	47e1                	li	a5,24
4200c60e:	00f92023          	sw	a5,0(s2)
4200c612:	bf5d                	j	4200c5c8 <proc_setargs+0x5e>
4200c614:	9002                	ebreak

4200c616 <proc_start>:

// Load an executable and start a prepared process.
void proc_start(badge_err_t *ec, pid_t pid, char const *executable) {
4200c616:	1101                	add	sp,sp,-32
4200c618:	cc22                	sw	s0,24(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c61a:	800006b7          	lui	a3,0x80000
void proc_start(badge_err_t *ec, pid_t pid, char const *executable) {
4200c61e:	ca26                	sw	s1,20(sp)
4200c620:	c84a                	sw	s2,16(sp)
4200c622:	c64e                	sw	s3,12(sp)
4200c624:	892e                	mv	s2,a1
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c626:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c628:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
void proc_start(badge_err_t *ec, pid_t pid, char const *executable) {
4200c62c:	84aa                	mv	s1,a0
4200c62e:	89b2                	mv	s3,a2
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c630:	4501                	li	a0,0
4200c632:	567d                	li	a2,-1
void proc_start(badge_err_t *ec, pid_t pid, char const *executable) {
4200c634:	ce06                	sw	ra,28(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c636:	af4f70ef          	jal	4200392a <mutex_acquire_shared>
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c63a:	800006b7          	lui	a3,0x80000
4200c63e:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c642:	567d                	li	a2,-1
4200c644:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c646:	4501                	li	a0,0
4200c648:	ae2f70ef          	jal	4200392a <mutex_acquire_shared>
    process_t *res = proc_get_unsafe(pid);
4200c64c:	854a                	mv	a0,s2
4200c64e:	e51fe0ef          	jal	4200b49e <proc_get_unsafe>
4200c652:	892a                	mv	s2,a0
    mutex_release_shared(NULL, &proc_mtx);
4200c654:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c658:	4501                	li	a0,0
4200c65a:	cfaf70ef          	jal	42003b54 <mutex_release_shared>
    process_t *proc = proc_get(pid);
    if (proc) {
4200c65e:	02090263          	beqz	s2,4200c682 <proc_start+0x6c>
        proc_start_raw(ec, proc, executable);
4200c662:	864e                	mv	a2,s3
4200c664:	85ca                	mv	a1,s2
4200c666:	8526                	mv	a0,s1
4200c668:	884ff0ef          	jal	4200b6ec <proc_start_raw>
    } else {
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
    }
    mutex_release_shared(NULL, &proc_mtx);
4200c66c:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
}
4200c670:	4462                	lw	s0,24(sp)
4200c672:	40f2                	lw	ra,28(sp)
4200c674:	44d2                	lw	s1,20(sp)
4200c676:	4942                	lw	s2,16(sp)
4200c678:	49b2                	lw	s3,12(sp)
    mutex_release_shared(NULL, &proc_mtx);
4200c67a:	4501                	li	a0,0
}
4200c67c:	6105                	add	sp,sp,32
    mutex_release_shared(NULL, &proc_mtx);
4200c67e:	cd6f706f          	j	42003b54 <mutex_release_shared>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200c682:	d4ed                	beqz	s1,4200c66c <proc_start+0x56>
4200c684:	420175b7          	lui	a1,0x42017
4200c688:	46e1                	li	a3,24
4200c68a:	463d                	li	a2,15
4200c68c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200c690:	4511                	li	a0,4
4200c692:	00000717          	auipc	a4,0x0
4200c696:	c05f60ef          	jal	4200329a <logkf>
4200c69a:	0034f793          	and	a5,s1,3
4200c69e:	eb89                	bnez	a5,4200c6b0 <proc_start+0x9a>
4200c6a0:	57f1                	li	a5,-4
4200c6a2:	00f4f763          	bgeu	s1,a5,4200c6b0 <proc_start+0x9a>
4200c6a6:	47bd                	li	a5,15
4200c6a8:	c0dc                	sw	a5,4(s1)
4200c6aa:	47e1                	li	a5,24
4200c6ac:	c09c                	sw	a5,0(s1)
4200c6ae:	bf7d                	j	4200c66c <proc_start+0x56>
4200c6b0:	9002                	ebreak

4200c6b2 <proc_map>:


// Allocate more memory to a process.
// Returns actual virtual address on success, 0 on failure.
size_t proc_map(badge_err_t *ec, pid_t pid, size_t vaddr_req, size_t min_size, size_t min_align) {
4200c6b2:	1101                	add	sp,sp,-32
4200c6b4:	cc22                	sw	s0,24(sp)
4200c6b6:	c452                	sw	s4,8(sp)
4200c6b8:	8a36                	mv	s4,a3
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c6ba:	800006b7          	lui	a3,0x80000
size_t proc_map(badge_err_t *ec, pid_t pid, size_t vaddr_req, size_t min_size, size_t min_align) {
4200c6be:	ca26                	sw	s1,20(sp)
4200c6c0:	c84a                	sw	s2,16(sp)
4200c6c2:	c64e                	sw	s3,12(sp)
4200c6c4:	892e                	mv	s2,a1
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c6c6:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c6c8:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
size_t proc_map(badge_err_t *ec, pid_t pid, size_t vaddr_req, size_t min_size, size_t min_align) {
4200c6cc:	84aa                	mv	s1,a0
4200c6ce:	89b2                	mv	s3,a2
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c6d0:	4501                	li	a0,0
4200c6d2:	567d                	li	a2,-1
size_t proc_map(badge_err_t *ec, pid_t pid, size_t vaddr_req, size_t min_size, size_t min_align) {
4200c6d4:	ce06                	sw	ra,28(sp)
4200c6d6:	c256                	sw	s5,4(sp)
4200c6d8:	8aba                	mv	s5,a4
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c6da:	a50f70ef          	jal	4200392a <mutex_acquire_shared>
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c6de:	800006b7          	lui	a3,0x80000
4200c6e2:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c6e6:	567d                	li	a2,-1
4200c6e8:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c6ea:	4501                	li	a0,0
4200c6ec:	a3ef70ef          	jal	4200392a <mutex_acquire_shared>
    process_t *res = proc_get_unsafe(pid);
4200c6f0:	854a                	mv	a0,s2
4200c6f2:	dadfe0ef          	jal	4200b49e <proc_get_unsafe>
4200c6f6:	892a                	mv	s2,a0
    mutex_release_shared(NULL, &proc_mtx);
4200c6f8:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c6fc:	4501                	li	a0,0
4200c6fe:	c56f70ef          	jal	42003b54 <mutex_release_shared>
    process_t *proc = proc_get(pid);
    size_t     res  = 0;
    if (proc) {
4200c702:	02090963          	beqz	s2,4200c734 <proc_map+0x82>
        res = proc_map_raw(ec, proc, vaddr_req, min_size, min_align);
4200c706:	8526                	mv	a0,s1
4200c708:	8756                	mv	a4,s5
4200c70a:	86d2                	mv	a3,s4
4200c70c:	864e                	mv	a2,s3
4200c70e:	85ca                	mv	a1,s2
4200c710:	ae8ff0ef          	jal	4200b9f8 <proc_map_raw>
4200c714:	84aa                	mv	s1,a0
    } else {
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
    }
    mutex_release_shared(NULL, &proc_mtx);
4200c716:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c71a:	4501                	li	a0,0
4200c71c:	c38f70ef          	jal	42003b54 <mutex_release_shared>
    return res;
}
4200c720:	40f2                	lw	ra,28(sp)
4200c722:	4462                	lw	s0,24(sp)
4200c724:	4942                	lw	s2,16(sp)
4200c726:	49b2                	lw	s3,12(sp)
4200c728:	4a22                	lw	s4,8(sp)
4200c72a:	4a92                	lw	s5,4(sp)
4200c72c:	8526                	mv	a0,s1
4200c72e:	44d2                	lw	s1,20(sp)
4200c730:	6105                	add	sp,sp,32
4200c732:	8082                	ret
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200c734:	c495                	beqz	s1,4200c760 <proc_map+0xae>
4200c736:	420175b7          	lui	a1,0x42017
4200c73a:	46e1                	li	a3,24
4200c73c:	463d                	li	a2,15
4200c73e:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200c742:	4511                	li	a0,4
4200c744:	00000717          	auipc	a4,0x0
4200c748:	b53f60ef          	jal	4200329a <logkf>
4200c74c:	0034f793          	and	a5,s1,3
4200c750:	eb91                	bnez	a5,4200c764 <proc_map+0xb2>
4200c752:	57f1                	li	a5,-4
4200c754:	00f4f863          	bgeu	s1,a5,4200c764 <proc_map+0xb2>
4200c758:	47bd                	li	a5,15
4200c75a:	c0dc                	sw	a5,4(s1)
4200c75c:	47e1                	li	a5,24
4200c75e:	c09c                	sw	a5,0(s1)
    size_t     res  = 0;
4200c760:	4481                	li	s1,0
4200c762:	bf55                	j	4200c716 <proc_map+0x64>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200c764:	9002                	ebreak

4200c766 <proc_unmap>:

// Release memory allocated to a process.
void proc_unmap(badge_err_t *ec, pid_t pid, size_t base) {
4200c766:	1101                	add	sp,sp,-32
4200c768:	cc22                	sw	s0,24(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c76a:	800006b7          	lui	a3,0x80000
void proc_unmap(badge_err_t *ec, pid_t pid, size_t base) {
4200c76e:	ca26                	sw	s1,20(sp)
4200c770:	c84a                	sw	s2,16(sp)
4200c772:	c64e                	sw	s3,12(sp)
4200c774:	892e                	mv	s2,a1
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c776:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c778:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
void proc_unmap(badge_err_t *ec, pid_t pid, size_t base) {
4200c77c:	84aa                	mv	s1,a0
4200c77e:	89b2                	mv	s3,a2
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c780:	4501                	li	a0,0
4200c782:	567d                	li	a2,-1
void proc_unmap(badge_err_t *ec, pid_t pid, size_t base) {
4200c784:	ce06                	sw	ra,28(sp)
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c786:	9a4f70ef          	jal	4200392a <mutex_acquire_shared>
    mutex_acquire_shared(NULL, &proc_mtx, TIMESTAMP_US_MAX);
4200c78a:	800006b7          	lui	a3,0x80000
4200c78e:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c792:	567d                	li	a2,-1
4200c794:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200c796:	4501                	li	a0,0
4200c798:	992f70ef          	jal	4200392a <mutex_acquire_shared>
    process_t *res = proc_get_unsafe(pid);
4200c79c:	854a                	mv	a0,s2
4200c79e:	d01fe0ef          	jal	4200b49e <proc_get_unsafe>
4200c7a2:	892a                	mv	s2,a0
    mutex_release_shared(NULL, &proc_mtx);
4200c7a4:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
4200c7a8:	4501                	li	a0,0
4200c7aa:	baaf70ef          	jal	42003b54 <mutex_release_shared>
    process_t *proc = proc_get(pid);
    if (proc) {
4200c7ae:	02090263          	beqz	s2,4200c7d2 <proc_unmap+0x6c>
        proc_unmap_raw(ec, proc, base);
4200c7b2:	864e                	mv	a2,s3
4200c7b4:	85ca                	mv	a1,s2
4200c7b6:	8526                	mv	a0,s1
4200c7b8:	8e8ff0ef          	jal	4200b8a0 <proc_unmap_raw>
    } else {
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
    }
    mutex_release_shared(NULL, &proc_mtx);
4200c7bc:	0dc18593          	add	a1,gp,220 # 408000dc <proc_mtx>
}
4200c7c0:	4462                	lw	s0,24(sp)
4200c7c2:	40f2                	lw	ra,28(sp)
4200c7c4:	44d2                	lw	s1,20(sp)
4200c7c6:	4942                	lw	s2,16(sp)
4200c7c8:	49b2                	lw	s3,12(sp)
    mutex_release_shared(NULL, &proc_mtx);
4200c7ca:	4501                	li	a0,0
}
4200c7cc:	6105                	add	sp,sp,32
    mutex_release_shared(NULL, &proc_mtx);
4200c7ce:	b86f706f          	j	42003b54 <mutex_release_shared>
        badge_err_set(ec, ELOC_PROCESS, ECAUSE_NOTFOUND);
4200c7d2:	d4ed                	beqz	s1,4200c7bc <proc_unmap+0x56>
4200c7d4:	420175b7          	lui	a1,0x42017
4200c7d8:	46e1                	li	a3,24
4200c7da:	463d                	li	a2,15
4200c7dc:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200c7e0:	4511                	li	a0,4
4200c7e2:	00000717          	auipc	a4,0x0
4200c7e6:	ab5f60ef          	jal	4200329a <logkf>
4200c7ea:	0034f793          	and	a5,s1,3
4200c7ee:	eb89                	bnez	a5,4200c800 <proc_unmap+0x9a>
4200c7f0:	57f1                	li	a5,-4
4200c7f2:	00f4f763          	bgeu	s1,a5,4200c800 <proc_unmap+0x9a>
4200c7f6:	47bd                	li	a5,15
4200c7f8:	c0dc                	sw	a5,4(s1)
4200c7fa:	47e1                	li	a5,24
4200c7fc:	c09c                	sw	a5,0(s1)
4200c7fe:	bf7d                	j	4200c7bc <proc_unmap+0x56>
4200c800:	9002                	ebreak

4200c802 <syscall_self_exit>:
#include "process/internal.h"

// Sycall: Exit the process; exit code can be read by parent process.
// When this system call returns, the thread will be suspended awaiting process termination.
void syscall_self_exit(int code) {
    proc_exit_self(code);
4200c802:	9bbfe06f          	j	4200b1bc <proc_exit_self>

4200c806 <hk_task_time_cmp>:

// Compare two `taskent_t` time.
int hk_task_time_cmp(void const *a, void const *b) {
    taskent_t const *a_ptr = a;
    taskent_t const *b_ptr = b;
    if (a_ptr->next_time < b_ptr->next_time)
4200c806:	cd15                	beqz	a0,4200c842 <hk_task_time_cmp+0x3c>
4200c808:	00357793          	and	a5,a0,3
4200c80c:	eb9d                	bnez	a5,4200c842 <hk_task_time_cmp+0x3c>
4200c80e:	4110                	lw	a2,0(a0)
4200c810:	4158                	lw	a4,4(a0)
4200c812:	c985                	beqz	a1,4200c842 <hk_task_time_cmp+0x3c>
4200c814:	0035f793          	and	a5,a1,3
4200c818:	e78d                	bnez	a5,4200c842 <hk_task_time_cmp+0x3c>
4200c81a:	41dc                	lw	a5,4(a1)
4200c81c:	4194                	lw	a3,0(a1)
4200c81e:	00f74d63          	blt	a4,a5,4200c838 <hk_task_time_cmp+0x32>
4200c822:	00e78963          	beq	a5,a4,4200c834 <hk_task_time_cmp+0x2e>
        return -1;
    if (a_ptr->next_time > b_ptr->next_time)
4200c826:	4505                	li	a0,1
4200c828:	00e7c963          	blt	a5,a4,4200c83a <hk_task_time_cmp+0x34>
4200c82c:	00f70863          	beq	a4,a5,4200c83c <hk_task_time_cmp+0x36>
4200c830:	4501                	li	a0,0
4200c832:	8082                	ret
    if (a_ptr->next_time < b_ptr->next_time)
4200c834:	fed679e3          	bgeu	a2,a3,4200c826 <hk_task_time_cmp+0x20>
        return -1;
4200c838:	557d                	li	a0,-1
        return 1;
    return 0;
}
4200c83a:	8082                	ret
    if (a_ptr->next_time > b_ptr->next_time)
4200c83c:	fec6fae3          	bgeu	a3,a2,4200c830 <hk_task_time_cmp+0x2a>
}
4200c840:	8082                	ret
    if (a_ptr->next_time < b_ptr->next_time)
4200c842:	9002                	ebreak

4200c844 <hk_thread_func>:
static sched_thread_t *hk_thread;
// Task mutex.
static mutex_t         hk_mtx = MUTEX_T_INIT;

// Runs housekeeping tasks.
void hk_thread_func(void *ignored) {
4200c844:	711d                	add	sp,sp,-96
4200c846:	c2d6                	sw	s5,68(sp)
4200c848:	de5e                	sw	s7,60(sp)
    (void)ignored;

    while (1) {
        mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200c84a:	80000ab7          	lui	s5,0x80000
            // Run the first task.
            array_remove(queue, sizeof(taskent_t), queue_len, &task, 0);
            assert_dev_drop(task.callback != NULL);
            task.callback(task.taskno, task.arg);

            if (task.interval > 0 && task.next_time <= TIMESTAMP_US_MAX - task.interval) {
4200c84e:	80000bb7          	lui	s7,0x80000
void hk_thread_func(void *ignored) {
4200c852:	c6ce                	sw	s3,76(sp)
4200c854:	c4d2                	sw	s4,72(sp)
4200c856:	c0da                	sw	s6,64(sp)
4200c858:	da66                	sw	s9,52(sp)
4200c85a:	d86a                	sw	s10,48(sp)
4200c85c:	ce86                	sw	ra,92(sp)
4200c85e:	cca2                	sw	s0,88(sp)
4200c860:	caa6                	sw	s1,84(sp)
4200c862:	c8ca                	sw	s2,80(sp)
4200c864:	dc62                	sw	s8,56(sp)
4200c866:	4080a9b7          	lui	s3,0x4080a
4200c86a:	4080ab37          	lui	s6,0x4080a
        mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200c86e:	5a7d                	li	s4,-1
4200c870:	1afd                	add	s5,s5,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
            if (task.interval > 0 && task.next_time <= TIMESTAMP_US_MAX - task.interval) {
4200c872:	1bfd                	add	s7,s7,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
    size_t index = array_binsearch(array, ent_size, ent_count, insert, comparator).index;
4200c874:	4200dd37          	lui	s10,0x4200d
        mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200c878:	8652                	mv	a2,s4
4200c87a:	86d6                	mv	a3,s5
4200c87c:	0e818593          	add	a1,gp,232 # 408000e8 <hk_mtx>
4200c880:	4501                	li	a0,0
4200c882:	df1f60ef          	jal	42003672 <mutex_acquire>
        timestamp_us_t now  = time_us();
4200c886:	6e3030ef          	jal	42010768 <time_us>
        while (queue_len && queue[0].next_time <= now) {
4200c88a:	e549a483          	lw	s1,-428(s3) # 40809e54 <queue_len>
        taskent_t      task = {0};
4200c88e:	ca02                	sw	zero,20(sp)
4200c890:	cc02                	sw	zero,24(sp)
4200c892:	ce02                	sw	zero,28(sp)
4200c894:	d002                	sw	zero,32(sp)
4200c896:	d202                	sw	zero,36(sp)
4200c898:	d402                	sw	zero,40(sp)
4200c89a:	d602                	sw	zero,44(sp)
        timestamp_us_t now  = time_us();
4200c89c:	8c2a                	mv	s8,a0
4200c89e:	892e                	mv	s2,a1
        while (queue_len && queue[0].next_time <= now) {
4200c8a0:	c8a5                	beqz	s1,4200c910 <hk_thread_func+0xcc>
4200c8a2:	e4cb2403          	lw	s0,-436(s6) # 40809e4c <queue>
4200c8a6:	12040063          	beqz	s0,4200c9c6 <hk_thread_func+0x182>
4200c8aa:	00347793          	and	a5,s0,3
4200c8ae:	10079c63          	bnez	a5,4200c9c6 <hk_thread_func+0x182>
4200c8b2:	405c                	lw	a5,4(s0)
4200c8b4:	4018                	lw	a4,0(s0)
4200c8b6:	04f94d63          	blt	s2,a5,4200c910 <hk_thread_func+0xcc>
4200c8ba:	11278763          	beq	a5,s2,4200c9c8 <hk_thread_func+0x184>
    __builtin_memmove(
4200c8be:	10040463          	beqz	s0,4200c9c6 <hk_thread_func+0x182>
4200c8c2:	4671                	li	a2,28
4200c8c4:	85a2                	mv	a1,s0
4200c8c6:	0848                	add	a0,sp,20
4200c8c8:	87af60ef          	jal	42002942 <memmove>
4200c8cc:	00349613          	sll	a2,s1,0x3
4200c8d0:	8e05                	sub	a2,a2,s1
        (void *)((size_t)array_src + ent_size * src_index),
4200c8d2:	01c40593          	add	a1,s0,28
    __builtin_memmove(
4200c8d6:	060a                	sll	a2,a2,0x2
4200c8d8:	0e058763          	beqz	a1,4200c9c6 <hk_thread_func+0x182>
4200c8dc:	8522                	mv	a0,s0
4200c8de:	864f60ef          	jal	42002942 <memmove>
            assert_dev_drop(task.callback != NULL);
4200c8e2:	57a2                	lw	a5,40(sp)
4200c8e4:	cbf1                	beqz	a5,4200c9b8 <hk_thread_func+0x174>
            task.callback(task.taskno, task.arg);
4200c8e6:	55b2                	lw	a1,44(sp)
4200c8e8:	5512                	lw	a0,36(sp)
4200c8ea:	9782                	jalr	a5
            if (task.interval > 0 && task.next_time <= TIMESTAMP_US_MAX - task.interval) {
4200c8ec:	5782                	lw	a5,32(sp)
4200c8ee:	4772                	lw	a4,28(sp)
4200c8f0:	02f05863          	blez	a5,4200c920 <hk_thread_func+0xdc>
4200c8f4:	46e2                	lw	a3,24(sp)
4200c8f6:	40fb85b3          	sub	a1,s7,a5
4200c8fa:	4652                	lw	a2,20(sp)
4200c8fc:	fff74513          	not	a0,a4
4200c900:	02d5da63          	bge	a1,a3,4200c934 <hk_thread_func+0xf0>
                // Repeated tasks get put back into the queue.
                task.next_time += task.interval;
                array_sorted_insert(queue, sizeof(taskent_t), queue_len, &task, hk_task_time_cmp);
            } else {
                // One-time tasks are removed.
                queue_len--;
4200c904:	e549a483          	lw	s1,-428(s3)
4200c908:	14fd                	add	s1,s1,-1
4200c90a:	e499aa23          	sw	s1,-428(s3)
        while (queue_len && queue[0].next_time <= now) {
4200c90e:	f8d1                	bnez	s1,4200c8a2 <hk_thread_func+0x5e>
            }
        }

        mutex_release(NULL, &hk_mtx);
4200c910:	0e818593          	add	a1,gp,232 # 408000e8 <hk_mtx>
4200c914:	4501                	li	a0,0
4200c916:	eeff60ef          	jal	42003804 <mutex_release>
        sched_yield();
4200c91a:	49b010ef          	jal	4200e5b4 <sched_yield>
    while (1) {
4200c91e:	bfa9                	j	4200c878 <hk_thread_func+0x34>
            if (task.interval > 0 && task.next_time <= TIMESTAMP_US_MAX - task.interval) {
4200c920:	f3f5                	bnez	a5,4200c904 <hk_thread_func+0xc0>
4200c922:	d36d                	beqz	a4,4200c904 <hk_thread_func+0xc0>
4200c924:	46e2                	lw	a3,24(sp)
4200c926:	40fb85b3          	sub	a1,s7,a5
4200c92a:	4652                	lw	a2,20(sp)
4200c92c:	fff74513          	not	a0,a4
4200c930:	fcd5cae3          	blt	a1,a3,4200c904 <hk_thread_func+0xc0>
4200c934:	00b69463          	bne	a3,a1,4200c93c <hk_thread_func+0xf8>
4200c938:	fcc566e3          	bltu	a0,a2,4200c904 <hk_thread_func+0xc0>
                task.next_time += task.interval;
4200c93c:	00c708b3          	add	a7,a4,a2
4200c940:	00e8b733          	sltu	a4,a7,a4
4200c944:	00d78633          	add	a2,a5,a3
4200c948:	00c70833          	add	a6,a4,a2
4200c94c:	8fb5                	xor	a5,a5,a3
4200c94e:	fff7c793          	not	a5,a5
4200c952:	00d846b3          	xor	a3,a6,a3
4200c956:	8efd                	and	a3,a3,a5
                array_sorted_insert(queue, sizeof(taskent_t), queue_len, &task, hk_task_time_cmp);
4200c958:	e549a403          	lw	s0,-428(s3)
                task.next_time += task.interval;
4200c95c:	0606c563          	bltz	a3,4200c9c6 <hk_thread_func+0x182>
                array_sorted_insert(queue, sizeof(taskent_t), queue_len, &task, hk_task_time_cmp);
4200c960:	e4cb2483          	lw	s1,-436(s6)
    size_t index = array_binsearch(array, ent_size, ent_count, insert, comparator).index;
4200c964:	8622                	mv	a2,s0
4200c966:	806d0713          	add	a4,s10,-2042 # 4200c806 <hk_task_time_cmp>
4200c96a:	0854                	add	a3,sp,20
4200c96c:	45f1                	li	a1,28
4200c96e:	8526                	mv	a0,s1
                task.next_time += task.interval;
4200c970:	ca46                	sw	a7,20(sp)
4200c972:	cc42                	sw	a6,24(sp)
4200c974:	94ef40ef          	jal	42000ac2 <array_binsearch>
    array_copy(array, array, ent_size, index + 1, index, ent_count - index);
4200c978:	00150693          	add	a3,a0,1
        (void *)((size_t)array_dst + ent_size * dst_index),
4200c97c:	00369793          	sll	a5,a3,0x3
    array_copy(array, array, ent_size, index + 1, index, ent_count - index);
4200c980:	40a40733          	sub	a4,s0,a0
        (void *)((size_t)array_dst + ent_size * dst_index),
4200c984:	8f95                	sub	a5,a5,a3
4200c986:	078a                	sll	a5,a5,0x2
    __builtin_memmove(
4200c988:	00371613          	sll	a2,a4,0x3
        (void *)((size_t)array_src + ent_size * src_index),
4200c98c:	fe478413          	add	s0,a5,-28
    __builtin_memmove(
4200c990:	8e19                	sub	a2,a2,a4
    size_t index = array_binsearch(array, ent_size, ent_count, insert, comparator).index;
4200c992:	c62a                	sw	a0,12(sp)
4200c994:	c82e                	sw	a1,16(sp)
        (void *)((size_t)array_dst + ent_size * dst_index),
4200c996:	00978533          	add	a0,a5,s1
        (void *)((size_t)array_src + ent_size * src_index),
4200c99a:	9426                	add	s0,s0,s1
    __builtin_memmove(
4200c99c:	060a                	sll	a2,a2,0x2
4200c99e:	c505                	beqz	a0,4200c9c6 <hk_thread_func+0x182>
4200c9a0:	c01d                	beqz	s0,4200c9c6 <hk_thread_func+0x182>
4200c9a2:	85a2                	mv	a1,s0
4200c9a4:	f9ff50ef          	jal	42002942 <memmove>
4200c9a8:	4671                	li	a2,28
4200c9aa:	084c                	add	a1,sp,20
4200c9ac:	8522                	mv	a0,s0
4200c9ae:	f95f50ef          	jal	42002942 <memmove>
        while (queue_len && queue[0].next_time <= now) {
4200c9b2:	e549a483          	lw	s1,-428(s3)
}
4200c9b6:	b5ed                	j	4200c8a0 <hk_thread_func+0x5c>
            assert_dev_drop(task.callback != NULL);
4200c9b8:	420195b7          	lui	a1,0x42019
4200c9bc:	15458593          	add	a1,a1,340 # 42019154 <hextab+0x2488>
4200c9c0:	4501                	li	a0,0
4200c9c2:	893f60ef          	jal	42003254 <logk>
4200c9c6:	9002                	ebreak
        while (queue_len && queue[0].next_time <= now) {
4200c9c8:	eeec7be3          	bgeu	s8,a4,4200c8be <hk_thread_func+0x7a>
4200c9cc:	b791                	j	4200c910 <hk_thread_func+0xcc>

4200c9ce <hk_init>:
    }
}

// Initialize the housekeeping system.
void hk_init() {
4200c9ce:	1101                	add	sp,sp,-32
    badge_err_t ec;
    hk_thread = sched_create_kernel_thread(&ec, hk_thread_func, NULL, hk_stack, sizeof(hk_stack), SCHED_PRIO_NORMAL);
4200c9d0:	408006b7          	lui	a3,0x40800
4200c9d4:	4200d5b7          	lui	a1,0x4200d
4200c9d8:	47a9                	li	a5,10
4200c9da:	6709                	lui	a4,0x2
4200c9dc:	40068693          	add	a3,a3,1024 # 40800400 <hk_stack>
4200c9e0:	4601                	li	a2,0
4200c9e2:	84458593          	add	a1,a1,-1980 # 4200c844 <hk_thread_func>
4200c9e6:	850a                	mv	a0,sp
void hk_init() {
4200c9e8:	cc22                	sw	s0,24(sp)
4200c9ea:	ce06                	sw	ra,28(sp)
    hk_thread = sched_create_kernel_thread(&ec, hk_thread_func, NULL, hk_stack, sizeof(hk_stack), SCHED_PRIO_NORMAL);
4200c9ec:	167010ef          	jal	4200e352 <sched_create_kernel_thread>
    badge_err_assert_always(&ec);
4200c9f0:	4402                	lw	s0,0(sp)
4200c9f2:	e819                	bnez	s0,4200ca08 <hk_init+0x3a>
4200c9f4:	85aa                	mv	a1,a0
    sched_resume_thread(&ec, hk_thread);
4200c9f6:	850a                	mv	a0,sp
4200c9f8:	301010ef          	jal	4200e4f8 <sched_resume_thread>
    badge_err_assert_always(&ec);
4200c9fc:	4402                	lw	s0,0(sp)
4200c9fe:	ec0d                	bnez	s0,4200ca38 <hk_init+0x6a>
}
4200ca00:	40f2                	lw	ra,28(sp)
4200ca02:	4462                	lw	s0,24(sp)
4200ca04:	6105                	add	sp,sp,32
4200ca06:	8082                	ret
    badge_err_assert_always(&ec);
4200ca08:	4512                	lw	a0,4(sp)
4200ca0a:	b46f40ef          	jal	42000d50 <badge_eloc_get_name>
4200ca0e:	872a                	mv	a4,a0
4200ca10:	8522                	mv	a0,s0
4200ca12:	843a                	mv	s0,a4
4200ca14:	b7af40ef          	jal	42000d8e <badge_ecause_get_name>
4200ca18:	87aa                	mv	a5,a0
4200ca1a:	8722                	mv	a4,s0
4200ca1c:	05d00693          	li	a3,93
    badge_err_assert_always(&ec);
4200ca20:	42019637          	lui	a2,0x42019
4200ca24:	420175b7          	lui	a1,0x42017
4200ca28:	1d060613          	add	a2,a2,464 # 420191d0 <hextab+0x2504>
4200ca2c:	df058593          	add	a1,a1,-528 # 42016df0 <hextab+0x124>
4200ca30:	4501                	li	a0,0
4200ca32:	869f60ef          	jal	4200329a <logkf>
4200ca36:	9002                	ebreak
4200ca38:	4512                	lw	a0,4(sp)
4200ca3a:	b16f40ef          	jal	42000d50 <badge_eloc_get_name>
4200ca3e:	872a                	mv	a4,a0
4200ca40:	8522                	mv	a0,s0
4200ca42:	843a                	mv	s0,a4
4200ca44:	b4af40ef          	jal	42000d8e <badge_ecause_get_name>
4200ca48:	87aa                	mv	a5,a0
4200ca4a:	8722                	mv	a4,s0
4200ca4c:	05f00693          	li	a3,95
4200ca50:	bfc1                	j	4200ca20 <hk_init+0x52>

4200ca52 <hk_add_repeated>:
}

// Add a repeating task with optional start timestamp to the queue.
// This task will be run in the "housekeeping" task.
// Returns the task number.
int hk_add_repeated(timestamp_us_t time, timestamp_us_t interval, hk_task_t task, void *arg) {
4200ca52:	711d                	add	sp,sp,-96
4200ca54:	ce86                	sw	ra,92(sp)
4200ca56:	c8ca                	sw	s2,80(sp)
    if (!task) {
4200ca58:	1c070163          	beqz	a4,4200cc1a <hk_add_repeated+0x1c8>
4200ca5c:	c6ce                	sw	s3,76(sp)
4200ca5e:	c0da                	sw	s6,64(sp)
        return -1;
    }
    mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200ca60:	8b36                	mv	s6,a3
4200ca62:	800006b7          	lui	a3,0x80000
4200ca66:	cca2                	sw	s0,88(sp)
4200ca68:	c4d2                	sw	s4,72(sp)
4200ca6a:	de5e                	sw	s7,60(sp)
4200ca6c:	dc62                	sw	s8,56(sp)
4200ca6e:	8a2a                	mv	s4,a0
4200ca70:	842e                	mv	s0,a1
4200ca72:	8bb2                	mv	s7,a2
4200ca74:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200ca76:	567d                	li	a2,-1
4200ca78:	0e818593          	add	a1,gp,232 # 408000e8 <hk_mtx>
4200ca7c:	4501                	li	a0,0

    int       taskno = taskno_ctr;
4200ca7e:	4080ac37          	lui	s8,0x4080a
4200ca82:	caa6                	sw	s1,84(sp)
4200ca84:	c2d6                	sw	s5,68(sp)
4200ca86:	84ba                	mv	s1,a4
4200ca88:	8abe                	mv	s5,a5
    mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200ca8a:	be9f60ef          	jal	42003672 <mutex_acquire>
    int       taskno = taskno_ctr;
4200ca8e:	e48c2903          	lw	s2,-440(s8) # 40809e48 <taskno_ctr>
    taskent_t ent    = {
4200ca92:	ca52                	sw	s4,20(sp)
4200ca94:	cc22                	sw	s0,24(sp)
4200ca96:	ce5e                	sw	s7,28(sp)
4200ca98:	d05a                	sw	s6,32(sp)
4200ca9a:	d24a                	sw	s2,36(sp)
4200ca9c:	d426                	sw	s1,40(sp)
4200ca9e:	d656                	sw	s5,44(sp)
           .taskno    = taskno,
           .callback  = task,
           .arg       = arg,
    };

    if (time <= 0) {
4200caa0:	0c805863          	blez	s0,4200cb70 <hk_add_repeated+0x11e>
    size_t           *ent_cap_ptr,
    void const       *insert,
    array_sort_comp_t comparator
) {
    void **array_ptr = _array_ptr;
    size_t index     = array_binsearch(*array_ptr, ent_size, *ent_count_ptr, insert, comparator).index;
4200caa4:	4080aa37          	lui	s4,0x4080a
4200caa8:	4080aab7          	lui	s5,0x4080a
4200caac:	e54a2603          	lw	a2,-428(s4) # 40809e54 <queue_len>
4200cab0:	e4caa503          	lw	a0,-436(s5) # 40809e4c <queue>
4200cab4:	4200d737          	lui	a4,0x4200d
4200cab8:	80670713          	add	a4,a4,-2042 # 4200c806 <hk_task_time_cmp>
4200cabc:	0854                	add	a3,sp,20
4200cabe:	45f1                	li	a1,28
4200cac0:	802f40ef          	jal	42000ac2 <array_binsearch>
    if (*ent_cap_ptr >= new_ent_count) {
4200cac4:	4080ab37          	lui	s6,0x4080a
    if (array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr + 1)) {
4200cac8:	e54a2483          	lw	s1,-428(s4)
    if (*ent_cap_ptr >= new_ent_count) {
4200cacc:	e50b2403          	lw	s0,-432(s6) # 40809e50 <queue_cap>
    size_t index     = array_binsearch(*array_ptr, ent_size, *ent_count_ptr, insert, comparator).index;
4200cad0:	8baa                	mv	s7,a0
    if (array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr + 1)) {
4200cad2:	0485                	add	s1,s1,1
    if (*ent_cap_ptr >= new_ent_count) {
4200cad4:	10947363          	bgeu	s0,s1,4200cbda <hk_add_repeated+0x188>
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200cad8:	10040663          	beqz	s0,4200cbe4 <hk_add_repeated+0x192>
    while (new_cap < new_ent_count) new_cap *= 2;
4200cadc:	0406                	sll	s0,s0,0x1
4200cade:	fe946fe3          	bltu	s0,s1,4200cadc <hk_add_repeated+0x8a>
    void *mem = realloc(*array_ptr, ent_size * new_cap);
4200cae2:	e4caa503          	lw	a0,-436(s5)
4200cae6:	00341593          	sll	a1,s0,0x3
4200caea:	8d81                	sub	a1,a1,s0
4200caec:	058a                	sll	a1,a1,0x2
4200caee:	0e4010ef          	jal	4200dbd2 <realloc>
4200caf2:	87aa                	mv	a5,a0
    if (!mem)
4200caf4:	12050163          	beqz	a0,4200cc16 <hk_add_repeated+0x1c4>
    *array_ptr     = mem;
4200caf8:	e4aaa623          	sw	a0,-436(s5)
    *ent_count_ptr = new_ent_count;
4200cafc:	e49a2a23          	sw	s1,-428(s4)
    *ent_cap_ptr   = new_cap;
4200cb00:	e48b2823          	sw	s0,-432(s6)
    array_copy(array, array, ent_size, index + 1, index, ent_count - index);
4200cb04:	001b8713          	add	a4,s7,1
        (void *)((size_t)array_dst + ent_size * dst_index),
4200cb08:	00371513          	sll	a0,a4,0x3
    array_copy(array, array, ent_size, index + 1, index, ent_count - index);
4200cb0c:	417484b3          	sub	s1,s1,s7
        (void *)((size_t)array_dst + ent_size * dst_index),
4200cb10:	8d19                	sub	a0,a0,a4
4200cb12:	050a                	sll	a0,a0,0x2
    __builtin_memmove(
4200cb14:	00349613          	sll	a2,s1,0x3
        (void *)((size_t)array_src + ent_size * src_index),
4200cb18:	fe450413          	add	s0,a0,-28
    __builtin_memmove(
4200cb1c:	8e05                	sub	a2,a2,s1
        (void *)((size_t)array_dst + ent_size * dst_index),
4200cb1e:	953e                	add	a0,a0,a5
        (void *)((size_t)array_src + ent_size * src_index),
4200cb20:	943e                	add	s0,s0,a5
    __builtin_memmove(
4200cb22:	060a                	sll	a2,a2,0x2
4200cb24:	0e050d63          	beqz	a0,4200cc1e <hk_add_repeated+0x1cc>
4200cb28:	0e040b63          	beqz	s0,4200cc1e <hk_add_repeated+0x1cc>
4200cb2c:	85a2                	mv	a1,s0
4200cb2e:	e15f50ef          	jal	42002942 <memmove>
4200cb32:	4671                	li	a2,28
4200cb34:	084c                	add	a1,sp,20
4200cb36:	8522                	mv	a0,s0
4200cb38:	e0bf50ef          	jal	42002942 <memmove>
4200cb3c:	4785                	li	a5,1
        taskno_ctr += array_lencap_insert(&queue, sizeof(taskent_t), &queue_len, &queue_cap, &ent, 0);
    } else {
        taskno_ctr +=
4200cb3e:	e48c2703          	lw	a4,-440(s8)
4200cb42:	97ba                	add	a5,a5,a4
4200cb44:	0ce7cd63          	blt	a5,a4,4200cc1e <hk_add_repeated+0x1cc>
            array_lencap_sorted_insert(&queue, sizeof(taskent_t), &queue_len, &queue_cap, &ent, hk_task_time_cmp);
    }

    mutex_release(NULL, &hk_mtx);
4200cb48:	0e818593          	add	a1,gp,232 # 408000e8 <hk_mtx>
4200cb4c:	4501                	li	a0,0
        taskno_ctr += array_lencap_insert(&queue, sizeof(taskent_t), &queue_len, &queue_cap, &ent, 0);
4200cb4e:	e4fc2423          	sw	a5,-440(s8)
    mutex_release(NULL, &hk_mtx);
4200cb52:	cb3f60ef          	jal	42003804 <mutex_release>
    return taskno;
4200cb56:	4466                	lw	s0,88(sp)
4200cb58:	44d6                	lw	s1,84(sp)
4200cb5a:	49b6                	lw	s3,76(sp)
4200cb5c:	4a26                	lw	s4,72(sp)
4200cb5e:	4a96                	lw	s5,68(sp)
4200cb60:	4b06                	lw	s6,64(sp)
4200cb62:	5bf2                	lw	s7,60(sp)
4200cb64:	5c62                	lw	s8,56(sp)
}
4200cb66:	40f6                	lw	ra,92(sp)
4200cb68:	854a                	mv	a0,s2
4200cb6a:	4946                	lw	s2,80(sp)
4200cb6c:	6125                	add	sp,sp,96
4200cb6e:	8082                	ret
    if (time <= 0) {
4200cb70:	e019                	bnez	s0,4200cb76 <hk_add_repeated+0x124>
4200cb72:	f20a19e3          	bnez	s4,4200caa4 <hk_add_repeated+0x52>
    if (array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr + 1)) {
4200cb76:	4080aa37          	lui	s4,0x4080a
4200cb7a:	e54a2483          	lw	s1,-428(s4) # 40809e54 <queue_len>
    if (*ent_cap_ptr >= new_ent_count) {
4200cb7e:	4080ab37          	lui	s6,0x4080a
4200cb82:	e50b2403          	lw	s0,-432(s6) # 40809e50 <queue_cap>
    void *mem = realloc(*array_ptr, ent_size * new_cap);
4200cb86:	4080aab7          	lui	s5,0x4080a
    if (array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr + 1)) {
4200cb8a:	0485                	add	s1,s1,1
    void *mem = realloc(*array_ptr, ent_size * new_cap);
4200cb8c:	e4caab83          	lw	s7,-436(s5) # 40809e4c <queue>
    if (*ent_cap_ptr >= new_ent_count) {
4200cb90:	06947863          	bgeu	s0,s1,4200cc00 <hk_add_repeated+0x1ae>
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200cb94:	cc39                	beqz	s0,4200cbf2 <hk_add_repeated+0x1a0>
    while (new_cap < new_ent_count) new_cap *= 2;
4200cb96:	0406                	sll	s0,s0,0x1
4200cb98:	fe946fe3          	bltu	s0,s1,4200cb96 <hk_add_repeated+0x144>
    void *mem = realloc(*array_ptr, ent_size * new_cap);
4200cb9c:	00341593          	sll	a1,s0,0x3
4200cba0:	8d81                	sub	a1,a1,s0
4200cba2:	855e                	mv	a0,s7
4200cba4:	058a                	sll	a1,a1,0x2
4200cba6:	02c010ef          	jal	4200dbd2 <realloc>
4200cbaa:	8baa                	mv	s7,a0
    if (!mem)
4200cbac:	c52d                	beqz	a0,4200cc16 <hk_add_repeated+0x1c4>
    __builtin_memmove(
4200cbae:	00349613          	sll	a2,s1,0x3
4200cbb2:	8e05                	sub	a2,a2,s1
    *array_ptr     = mem;
4200cbb4:	e4aaa623          	sw	a0,-436(s5)
    *ent_count_ptr = new_ent_count;
4200cbb8:	e49a2a23          	sw	s1,-428(s4)
    *ent_cap_ptr   = new_cap;
4200cbbc:	e48b2823          	sw	s0,-432(s6)
        (void *)((size_t)array_dst + ent_size * dst_index),
4200cbc0:	0571                	add	a0,a0,28
    __builtin_memmove(
4200cbc2:	060a                	sll	a2,a2,0x2
4200cbc4:	cd29                	beqz	a0,4200cc1e <hk_add_repeated+0x1cc>
4200cbc6:	85de                	mv	a1,s7
4200cbc8:	d7bf50ef          	jal	42002942 <memmove>
4200cbcc:	4671                	li	a2,28
4200cbce:	084c                	add	a1,sp,20
4200cbd0:	855e                	mv	a0,s7
4200cbd2:	d71f50ef          	jal	42002942 <memmove>
4200cbd6:	4785                	li	a5,1
4200cbd8:	b79d                	j	4200cb3e <hk_add_repeated+0xec>
        array_insert(*array_ptr, ent_size, *ent_count_ptr, insert, index);
4200cbda:	e4caa783          	lw	a5,-436(s5)
        *ent_count_ptr = new_ent_count;
4200cbde:	e49a2a23          	sw	s1,-428(s4)
        return true;
4200cbe2:	b70d                	j	4200cb04 <hk_add_repeated+0xb2>
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200cbe4:	4409                	li	s0,2
    while (new_cap < new_ent_count) new_cap *= 2;
4200cbe6:	ee947ee3          	bgeu	s0,s1,4200cae2 <hk_add_repeated+0x90>
4200cbea:	0406                	sll	s0,s0,0x1
4200cbec:	ee9468e3          	bltu	s0,s1,4200cadc <hk_add_repeated+0x8a>
4200cbf0:	bdcd                	j	4200cae2 <hk_add_repeated+0x90>
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200cbf2:	4409                	li	s0,2
    while (new_cap < new_ent_count) new_cap *= 2;
4200cbf4:	fa9474e3          	bgeu	s0,s1,4200cb9c <hk_add_repeated+0x14a>
4200cbf8:	0406                	sll	s0,s0,0x1
4200cbfa:	f8946ee3          	bltu	s0,s1,4200cb96 <hk_add_repeated+0x144>
4200cbfe:	bf79                	j	4200cb9c <hk_add_repeated+0x14a>
        *ent_count_ptr = new_ent_count;
4200cc00:	e49a2a23          	sw	s1,-428(s4)
        (void *)((size_t)array_dst + ent_size * dst_index),
4200cc04:	01cb8513          	add	a0,s7,28
    __builtin_memmove(
4200cc08:	c919                	beqz	a0,4200cc1e <hk_add_repeated+0x1cc>
4200cc0a:	000b8a63          	beqz	s7,4200cc1e <hk_add_repeated+0x1cc>
4200cc0e:	4671                	li	a2,28
4200cc10:	02c48633          	mul	a2,s1,a2
4200cc14:	bf4d                	j	4200cbc6 <hk_add_repeated+0x174>
4200cc16:	4781                	li	a5,0
4200cc18:	b71d                	j	4200cb3e <hk_add_repeated+0xec>
        return -1;
4200cc1a:	597d                	li	s2,-1
4200cc1c:	b7a9                	j	4200cb66 <hk_add_repeated+0x114>
        taskno_ctr +=
4200cc1e:	9002                	ebreak

4200cc20 <hk_add_once>:
int hk_add_once(timestamp_us_t time, hk_task_t task, void *arg) {
4200cc20:	8732                	mv	a4,a2
4200cc22:	87b6                	mv	a5,a3
    return hk_add_repeated(time, 0, task, arg);
4200cc24:	4601                	li	a2,0
4200cc26:	4681                	li	a3,0
4200cc28:	e2bff06f          	j	4200ca52 <hk_add_repeated>

4200cc2c <hk_cancel>:

// Cancel a housekeeping task.
void hk_cancel(int taskno) {
4200cc2c:	1101                	add	sp,sp,-32
4200cc2e:	ca26                	sw	s1,20(sp)
    mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200cc30:	800006b7          	lui	a3,0x80000
void hk_cancel(int taskno) {
4200cc34:	cc22                	sw	s0,24(sp)
    mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200cc36:	567d                	li	a2,-1
void hk_cancel(int taskno) {
4200cc38:	842a                	mv	s0,a0
    mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200cc3a:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200cc3c:	0e818593          	add	a1,gp,232 # 408000e8 <hk_mtx>
4200cc40:	4501                	li	a0,0
void hk_cancel(int taskno) {
4200cc42:	c84a                	sw	s2,16(sp)
4200cc44:	ce06                	sw	ra,28(sp)
    for (size_t i = 0; i < queue_len; i++) {
4200cc46:	4080a937          	lui	s2,0x4080a
    mutex_acquire(NULL, &hk_mtx, TIMESTAMP_US_MAX);
4200cc4a:	a29f60ef          	jal	42003672 <mutex_acquire>
    for (size_t i = 0; i < queue_len; i++) {
4200cc4e:	e5492883          	lw	a7,-428(s2) # 40809e54 <queue_len>
4200cc52:	04088b63          	beqz	a7,4200cca8 <hk_cancel+0x7c>
4200cc56:	c64e                	sw	s3,12(sp)
        if (queue[i].taskno == taskno) {
4200cc58:	4080a9b7          	lui	s3,0x4080a
4200cc5c:	e4c9a583          	lw	a1,-436(s3) # 40809e4c <queue>
4200cc60:	4701                	li	a4,0
    for (size_t i = 0; i < queue_len; i++) {
4200cc62:	4601                	li	a2,0
        if (queue[i].taskno == taskno) {
4200cc64:	87ae                	mv	a5,a1
4200cc66:	5341                	li	t1,-16
4200cc68:	00e58533          	add	a0,a1,a4
4200cc6c:	02074963          	bltz	a4,4200cc9e <hk_cancel+0x72>
4200cc70:	02b56963          	bltu	a0,a1,4200cca2 <hk_cancel+0x76>
4200cc74:	c79d                	beqz	a5,4200cca2 <hk_cancel+0x76>
4200cc76:	0037f693          	and	a3,a5,3
4200cc7a:	e685                	bnez	a3,4200cca2 <hk_cancel+0x76>
4200cc7c:	0267f363          	bgeu	a5,t1,4200cca2 <hk_cancel+0x76>
4200cc80:	0107a803          	lw	a6,16(a5)
    array_copy(array, array, ent_size, index, index + 1, ent_count - index);
4200cc84:	00160693          	add	a3,a2,1
4200cc88:	02880a63          	beq	a6,s0,4200ccbc <hk_cancel+0x90>
    for (size_t i = 0; i < queue_len; i++) {
4200cc8c:	0771                	add	a4,a4,28
4200cc8e:	07f1                	add	a5,a5,28
4200cc90:	01168b63          	beq	a3,a7,4200cca6 <hk_cancel+0x7a>
4200cc94:	8636                	mv	a2,a3
        if (queue[i].taskno == taskno) {
4200cc96:	00e58533          	add	a0,a1,a4
4200cc9a:	fc075be3          	bgez	a4,4200cc70 <hk_cancel+0x44>
4200cc9e:	fca5fbe3          	bgeu	a1,a0,4200cc74 <hk_cancel+0x48>
4200cca2:	c452                	sw	s4,8(sp)
4200cca4:	9002                	ebreak
4200cca6:	49b2                	lw	s3,12(sp)
            array_lencap_remove(&queue, sizeof(taskent_t), &queue_len, &queue_cap, NULL, i);
            return;
        }
    }
    mutex_release(NULL, &hk_mtx);
}
4200cca8:	4462                	lw	s0,24(sp)
4200ccaa:	40f2                	lw	ra,28(sp)
4200ccac:	4942                	lw	s2,16(sp)
    mutex_release(NULL, &hk_mtx);
4200ccae:	0e818593          	add	a1,gp,232 # 408000e8 <hk_mtx>
}
4200ccb2:	44d2                	lw	s1,20(sp)
    mutex_release(NULL, &hk_mtx);
4200ccb4:	4501                	li	a0,0
}
4200ccb6:	6105                	add	sp,sp,32
    mutex_release(NULL, &hk_mtx);
4200ccb8:	b4df606f          	j	42003804 <mutex_release>
4200ccbc:	40c888b3          	sub	a7,a7,a2
        (void *)((size_t)array_src + ent_size * src_index),
4200ccc0:	00369793          	sll	a5,a3,0x3
4200ccc4:	8f95                	sub	a5,a5,a3
    __builtin_memmove(
4200ccc6:	00389613          	sll	a2,a7,0x3
        (void *)((size_t)array_src + ent_size * src_index),
4200ccca:	078a                	sll	a5,a5,0x2
    __builtin_memmove(
4200cccc:	41160633          	sub	a2,a2,a7
4200ccd0:	c452                	sw	s4,8(sp)
        (void *)((size_t)array_src + ent_size * src_index),
4200ccd2:	95be                	add	a1,a1,a5
    __builtin_memmove(
4200ccd4:	060a                	sll	a2,a2,0x2
4200ccd6:	c92d                	beqz	a0,4200cd48 <hk_cancel+0x11c>
4200ccd8:	c9a5                	beqz	a1,4200cd48 <hk_cancel+0x11c>
4200ccda:	c69f50ef          	jal	42002942 <memmove>
    if (*ent_cap_ptr >= new_ent_count) {
4200ccde:	4080aa37          	lui	s4,0x4080a
    array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr - 1);
4200cce2:	e5492483          	lw	s1,-428(s2)
    if (*ent_cap_ptr >= new_ent_count) {
4200cce6:	e50a2403          	lw	s0,-432(s4) # 40809e50 <queue_cap>
    array_lencap_resize(array_ptr, ent_size, ent_count_ptr, ent_cap_ptr, *ent_count_ptr - 1);
4200ccea:	14fd                	add	s1,s1,-1
    if (*ent_cap_ptr >= new_ent_count) {
4200ccec:	04947463          	bgeu	s0,s1,4200cd34 <hk_cancel+0x108>
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200ccf0:	c81d                	beqz	s0,4200cd26 <hk_cancel+0xfa>
    while (new_cap < new_ent_count) new_cap *= 2;
4200ccf2:	0406                	sll	s0,s0,0x1
4200ccf4:	fe946fe3          	bltu	s0,s1,4200ccf2 <hk_cancel+0xc6>
    void *mem = realloc(*array_ptr, ent_size * new_cap);
4200ccf8:	00341593          	sll	a1,s0,0x3
4200ccfc:	e4c9a503          	lw	a0,-436(s3)
4200cd00:	8d81                	sub	a1,a1,s0
4200cd02:	058a                	sll	a1,a1,0x2
4200cd04:	6cf000ef          	jal	4200dbd2 <realloc>
    if (!mem)
4200cd08:	c519                	beqz	a0,4200cd16 <hk_cancel+0xea>
    *array_ptr     = mem;
4200cd0a:	e4a9a623          	sw	a0,-436(s3)
    *ent_count_ptr = new_ent_count;
4200cd0e:	e4992a23          	sw	s1,-428(s2)
    *ent_cap_ptr   = new_cap;
4200cd12:	e48a2823          	sw	s0,-432(s4)
}
4200cd16:	40f2                	lw	ra,28(sp)
4200cd18:	4462                	lw	s0,24(sp)
4200cd1a:	49b2                	lw	s3,12(sp)
4200cd1c:	4a22                	lw	s4,8(sp)
4200cd1e:	44d2                	lw	s1,20(sp)
4200cd20:	4942                	lw	s2,16(sp)
4200cd22:	6105                	add	sp,sp,32
4200cd24:	8082                	ret
    size_t new_cap = *ent_cap_ptr ? *ent_cap_ptr : 2;
4200cd26:	4409                	li	s0,2
    while (new_cap < new_ent_count) new_cap *= 2;
4200cd28:	fc9478e3          	bgeu	s0,s1,4200ccf8 <hk_cancel+0xcc>
4200cd2c:	0406                	sll	s0,s0,0x1
4200cd2e:	fc9462e3          	bltu	s0,s1,4200ccf2 <hk_cancel+0xc6>
4200cd32:	b7d9                	j	4200ccf8 <hk_cancel+0xcc>
4200cd34:	40f2                	lw	ra,28(sp)
4200cd36:	4462                	lw	s0,24(sp)
        *ent_count_ptr = new_ent_count;
4200cd38:	e4992a23          	sw	s1,-428(s2)
        return true;
4200cd3c:	49b2                	lw	s3,12(sp)
4200cd3e:	4a22                	lw	s4,8(sp)
4200cd40:	44d2                	lw	s1,20(sp)
4200cd42:	4942                	lw	s2,16(sp)
4200cd44:	6105                	add	sp,sp,32
4200cd46:	8082                	ret
    __builtin_memmove(
4200cd48:	9002                	ebreak

4200cd4a <dlist_pop_front>:
    list->len  += 1;
}

#include "rawprint.h"

dlist_node_t *dlist_pop_front(dlist_t *const list) {
4200cd4a:	1141                	add	sp,sp,-16
4200cd4c:	c606                	sw	ra,12(sp)
    assert_dev_drop(list != NULL);
4200cd4e:	cd51                	beqz	a0,4200cdea <dlist_pop_front+0xa0>

    if (list->head != NULL) {
4200cd50:	00357713          	and	a4,a0,3
4200cd54:	87aa                	mv	a5,a0
4200cd56:	e351                	bnez	a4,4200cdda <dlist_pop_front+0x90>
4200cd58:	5771                	li	a4,-4
4200cd5a:	08e57063          	bgeu	a0,a4,4200cdda <dlist_pop_front+0x90>
4200cd5e:	4148                	lw	a0,4(a0)
        assert_dev_drop(list->tail != NULL);
4200cd60:	5761                	li	a4,-8
    if (list->head != NULL) {
4200cd62:	cd39                	beqz	a0,4200cdc0 <dlist_pop_front+0x76>
        assert_dev_drop(list->tail != NULL);
4200cd64:	06e7fb63          	bgeu	a5,a4,4200cdda <dlist_pop_front+0x90>
4200cd68:	4790                	lw	a2,8(a5)
4200cd6a:	c659                	beqz	a2,4200cdf8 <dlist_pop_front+0xae>
        assert_dev_drop(list->len > 0);
4200cd6c:	4398                	lw	a4,0(a5)
4200cd6e:	cf49                	beqz	a4,4200ce08 <dlist_pop_front+0xbe>

        dlist_node_t *const node = list->head;

        if (node->next != NULL) {
4200cd70:	00357693          	and	a3,a0,3
4200cd74:	e2bd                	bnez	a3,4200cdda <dlist_pop_front+0x90>
4200cd76:	4114                	lw	a3,0(a0)
            node->next->previous = node->previous;
        }

        list->len  -= 1;
4200cd78:	177d                	add	a4,a4,-1
        if (node->next != NULL) {
4200cd7a:	c2ad                	beqz	a3,4200cddc <dlist_pop_front+0x92>
            node->next->previous = node->previous;
4200cd7c:	5871                	li	a6,-4
4200cd7e:	05057e63          	bgeu	a0,a6,4200cdda <dlist_pop_front+0x90>
4200cd82:	0036f593          	and	a1,a3,3
4200cd86:	00452883          	lw	a7,4(a0)
4200cd8a:	e9a1                	bnez	a1,4200cdda <dlist_pop_front+0x90>
4200cd8c:	0506f763          	bgeu	a3,a6,4200cdda <dlist_pop_front+0x90>
4200cd90:	0116a223          	sw	a7,4(a3)
        list->len  -= 1;
4200cd94:	c398                	sw	a4,0(a5)
        list->head  = node->next;
4200cd96:	c3d4                	sw	a3,4(a5)
        if (list->head == NULL) {
            list->tail = NULL;
        }

        assert_dev_drop((list->head != NULL) == (list->tail != NULL));
4200cd98:	00d036b3          	snez	a3,a3
4200cd9c:	00c03633          	snez	a2,a2
4200cda0:	06d61c63          	bne	a2,a3,4200ce18 <dlist_pop_front+0xce>
        assert_dev_drop((list->head != NULL) == (list->len > 0));
4200cda4:	00e03733          	snez	a4,a4
4200cda8:	08c71063          	bne	a4,a2,4200ce28 <dlist_pop_front+0xde>

        *node = DLIST_NODE_EMPTY;
4200cdac:	00052023          	sw	zero,0(a0)
4200cdb0:	57f1                	li	a5,-4
4200cdb2:	02f57463          	bgeu	a0,a5,4200cdda <dlist_pop_front+0x90>
4200cdb6:	00052223          	sw	zero,4(a0)
    } else {
        assert_dev_drop(list->tail == NULL);
        assert_dev_drop(list->len == 0);
        return NULL;
    }
}
4200cdba:	40b2                	lw	ra,12(sp)
4200cdbc:	0141                	add	sp,sp,16
4200cdbe:	8082                	ret
        assert_dev_drop(list->tail == NULL);
4200cdc0:	00e7fd63          	bgeu	a5,a4,4200cdda <dlist_pop_front+0x90>
4200cdc4:	4798                	lw	a4,8(a5)
4200cdc6:	eb2d                	bnez	a4,4200ce38 <dlist_pop_front+0xee>
        assert_dev_drop(list->len == 0);
4200cdc8:	439c                	lw	a5,0(a5)
4200cdca:	dbe5                	beqz	a5,4200cdba <dlist_pop_front+0x70>
4200cdcc:	420195b7          	lui	a1,0x42019
4200cdd0:	4e858593          	add	a1,a1,1256 # 420194e8 <hextab+0x281c>
4200cdd4:	4501                	li	a0,0
4200cdd6:	c7ef60ef          	jal	42003254 <logk>
4200cdda:	9002                	ebreak
        list->len  -= 1;
4200cddc:	c398                	sw	a4,0(a5)
        list->head  = node->next;
4200cdde:	0007a223          	sw	zero,4(a5)
            list->tail = NULL;
4200cde2:	0007a423          	sw	zero,8(a5)
4200cde6:	4601                	li	a2,0
4200cde8:	bf45                	j	4200cd98 <dlist_pop_front+0x4e>
    assert_dev_drop(list != NULL);
4200cdea:	420195b7          	lui	a1,0x42019
4200cdee:	21058593          	add	a1,a1,528 # 42019210 <hextab+0x2544>
4200cdf2:	c62f60ef          	jal	42003254 <logk>
4200cdf6:	9002                	ebreak
        assert_dev_drop(list->tail != NULL);
4200cdf8:	420195b7          	lui	a1,0x42019
4200cdfc:	27c58593          	add	a1,a1,636 # 4201927c <hextab+0x25b0>
4200ce00:	4501                	li	a0,0
4200ce02:	c52f60ef          	jal	42003254 <logk>
4200ce06:	9002                	ebreak
        assert_dev_drop(list->len > 0);
4200ce08:	420195b7          	lui	a1,0x42019
4200ce0c:	2f058593          	add	a1,a1,752 # 420192f0 <hextab+0x2624>
4200ce10:	4501                	li	a0,0
4200ce12:	c42f60ef          	jal	42003254 <logk>
4200ce16:	9002                	ebreak
        assert_dev_drop((list->head != NULL) == (list->tail != NULL));
4200ce18:	420195b7          	lui	a1,0x42019
4200ce1c:	35858593          	add	a1,a1,856 # 42019358 <hextab+0x268c>
4200ce20:	4501                	li	a0,0
4200ce22:	c32f60ef          	jal	42003254 <logk>
4200ce26:	9002                	ebreak
        assert_dev_drop((list->head != NULL) == (list->len > 0));
4200ce28:	420195b7          	lui	a1,0x42019
4200ce2c:	3ec58593          	add	a1,a1,1004 # 420193ec <hextab+0x2720>
4200ce30:	4501                	li	a0,0
4200ce32:	c22f60ef          	jal	42003254 <logk>
4200ce36:	9002                	ebreak
        assert_dev_drop(list->tail == NULL);
4200ce38:	420195b7          	lui	a1,0x42019
4200ce3c:	47458593          	add	a1,a1,1140 # 42019474 <hextab+0x27a8>
4200ce40:	4501                	li	a0,0
4200ce42:	c12f60ef          	jal	42003254 <logk>
4200ce46:	9002                	ebreak

4200ce48 <dlist_pop_back>:

dlist_node_t *dlist_pop_back(dlist_t *const list) {
4200ce48:	1141                	add	sp,sp,-16
4200ce4a:	c606                	sw	ra,12(sp)
    assert_dev_drop(list != NULL);
4200ce4c:	c541                	beqz	a0,4200ced4 <dlist_pop_back+0x8c>

    if (list->tail != NULL) {
4200ce4e:	00357713          	and	a4,a0,3
4200ce52:	87aa                	mv	a5,a0
4200ce54:	eb25                	bnez	a4,4200cec4 <dlist_pop_back+0x7c>
4200ce56:	5761                	li	a4,-8
4200ce58:	06e57663          	bgeu	a0,a4,4200cec4 <dlist_pop_back+0x7c>
4200ce5c:	4508                	lw	a0,8(a0)
4200ce5e:	c921                	beqz	a0,4200ceae <dlist_pop_back+0x66>
        assert_dev_drop(list->head != NULL);
4200ce60:	43d0                	lw	a2,4(a5)
4200ce62:	c241                	beqz	a2,4200cee2 <dlist_pop_back+0x9a>
        assert_dev_drop(list->len > 0);
4200ce64:	4394                	lw	a3,0(a5)
4200ce66:	c6d1                	beqz	a3,4200cef2 <dlist_pop_back+0xaa>

        dlist_node_t *const node = list->tail;

        if (node->previous != NULL) {
4200ce68:	00357713          	and	a4,a0,3
4200ce6c:	ef21                	bnez	a4,4200cec4 <dlist_pop_back+0x7c>
4200ce6e:	5771                	li	a4,-4
4200ce70:	04e57a63          	bgeu	a0,a4,4200cec4 <dlist_pop_back+0x7c>
4200ce74:	4158                	lw	a4,4(a0)
            node->previous->next = node->next;
        }

        list->len  -= 1;
4200ce76:	16fd                	add	a3,a3,-1
        if (node->previous != NULL) {
4200ce78:	c739                	beqz	a4,4200cec6 <dlist_pop_back+0x7e>
            node->previous->next = node->next;
4200ce7a:	00377593          	and	a1,a4,3
4200ce7e:	00052803          	lw	a6,0(a0)
4200ce82:	e1a9                	bnez	a1,4200cec4 <dlist_pop_back+0x7c>
4200ce84:	01072023          	sw	a6,0(a4)
        list->len  -= 1;
4200ce88:	c394                	sw	a3,0(a5)
        list->tail  = node->previous;
4200ce8a:	c798                	sw	a4,8(a5)
        if (list->tail == NULL) {
            list->head = NULL;
        }

        assert_dev_drop((list->head != NULL) == (list->tail != NULL));
4200ce8c:	00c03633          	snez	a2,a2
4200ce90:	00e03733          	snez	a4,a4
4200ce94:	06c71763          	bne	a4,a2,4200cf02 <dlist_pop_back+0xba>
        assert_dev_drop((list->head != NULL) == (list->len > 0));
4200ce98:	00d036b3          	snez	a3,a3
4200ce9c:	06e69b63          	bne	a3,a4,4200cf12 <dlist_pop_back+0xca>

        *node = DLIST_NODE_EMPTY;
4200cea0:	00052023          	sw	zero,0(a0)
4200cea4:	00052223          	sw	zero,4(a0)
    } else {
        assert_dev_drop(list->head == NULL);
        assert_dev_drop(list->len == 0);
        return NULL;
    }
}
4200cea8:	40b2                	lw	ra,12(sp)
4200ceaa:	0141                	add	sp,sp,16
4200ceac:	8082                	ret
        assert_dev_drop(list->head == NULL);
4200ceae:	43d8                	lw	a4,4(a5)
4200ceb0:	eb2d                	bnez	a4,4200cf22 <dlist_pop_back+0xda>
        assert_dev_drop(list->len == 0);
4200ceb2:	439c                	lw	a5,0(a5)
4200ceb4:	dbf5                	beqz	a5,4200cea8 <dlist_pop_back+0x60>
4200ceb6:	4201a5b7          	lui	a1,0x4201a
4200ceba:	82858593          	add	a1,a1,-2008 # 42019828 <hextab+0x2b5c>
4200cebe:	4501                	li	a0,0
4200cec0:	b94f60ef          	jal	42003254 <logk>
4200cec4:	9002                	ebreak
        list->len  -= 1;
4200cec6:	c394                	sw	a3,0(a5)
        list->tail  = node->previous;
4200cec8:	0007a423          	sw	zero,8(a5)
            list->head = NULL;
4200cecc:	0007a223          	sw	zero,4(a5)
4200ced0:	4601                	li	a2,0
4200ced2:	bf6d                	j	4200ce8c <dlist_pop_back+0x44>
    assert_dev_drop(list != NULL);
4200ced4:	420195b7          	lui	a1,0x42019
4200ced8:	55058593          	add	a1,a1,1360 # 42019550 <hextab+0x2884>
4200cedc:	b78f60ef          	jal	42003254 <logk>
4200cee0:	9002                	ebreak
        assert_dev_drop(list->head != NULL);
4200cee2:	420195b7          	lui	a1,0x42019
4200cee6:	5bc58593          	add	a1,a1,1468 # 420195bc <hextab+0x28f0>
4200ceea:	4501                	li	a0,0
4200ceec:	b68f60ef          	jal	42003254 <logk>
4200cef0:	9002                	ebreak
        assert_dev_drop(list->len > 0);
4200cef2:	420195b7          	lui	a1,0x42019
4200cef6:	63058593          	add	a1,a1,1584 # 42019630 <hextab+0x2964>
4200cefa:	4501                	li	a0,0
4200cefc:	b58f60ef          	jal	42003254 <logk>
4200cf00:	9002                	ebreak
        assert_dev_drop((list->head != NULL) == (list->tail != NULL));
4200cf02:	420195b7          	lui	a1,0x42019
4200cf06:	69858593          	add	a1,a1,1688 # 42019698 <hextab+0x29cc>
4200cf0a:	4501                	li	a0,0
4200cf0c:	b48f60ef          	jal	42003254 <logk>
4200cf10:	9002                	ebreak
        assert_dev_drop((list->head != NULL) == (list->len > 0));
4200cf12:	420195b7          	lui	a1,0x42019
4200cf16:	72c58593          	add	a1,a1,1836 # 4201972c <hextab+0x2a60>
4200cf1a:	4501                	li	a0,0
4200cf1c:	b38f60ef          	jal	42003254 <logk>
4200cf20:	9002                	ebreak
        assert_dev_drop(list->head == NULL);
4200cf22:	420195b7          	lui	a1,0x42019
4200cf26:	7b458593          	add	a1,a1,1972 # 420197b4 <hextab+0x2ae8>
4200cf2a:	4501                	li	a0,0
4200cf2c:	b28f60ef          	jal	42003254 <logk>
4200cf30:	9002                	ebreak

4200cf32 <dlist_contains>:

bool dlist_contains(dlist_t const *const list, dlist_node_t const *const node) {
4200cf32:	1141                	add	sp,sp,-16
4200cf34:	c606                	sw	ra,12(sp)
    assert_dev_drop(list != NULL);
4200cf36:	c915                	beqz	a0,4200cf6a <dlist_contains+0x38>
    assert_dev_drop(node != NULL);
4200cf38:	c1a1                	beqz	a1,4200cf78 <dlist_contains+0x46>

    dlist_node_t const *iter = list->head;
4200cf3a:	00357713          	and	a4,a0,3
4200cf3e:	e729                	bnez	a4,4200cf88 <dlist_contains+0x56>
4200cf40:	5771                	li	a4,-4
4200cf42:	04e57363          	bgeu	a0,a4,4200cf88 <dlist_contains+0x56>
4200cf46:	415c                	lw	a5,4(a0)
    while (iter != NULL) {
4200cf48:	cb89                	beqz	a5,4200cf5a <dlist_contains+0x28>
        if (iter == node) {
4200cf4a:	00f58c63          	beq	a1,a5,4200cf62 <dlist_contains+0x30>
            return true;
        }
        iter = iter->next;
4200cf4e:	cf8d                	beqz	a5,4200cf88 <dlist_contains+0x56>
4200cf50:	0037f713          	and	a4,a5,3
4200cf54:	eb15                	bnez	a4,4200cf88 <dlist_contains+0x56>
4200cf56:	439c                	lw	a5,0(a5)
    while (iter != NULL) {
4200cf58:	fbed                	bnez	a5,4200cf4a <dlist_contains+0x18>
    }

    return false;
}
4200cf5a:	40b2                	lw	ra,12(sp)
    return false;
4200cf5c:	4501                	li	a0,0
}
4200cf5e:	0141                	add	sp,sp,16
4200cf60:	8082                	ret
4200cf62:	40b2                	lw	ra,12(sp)
            return true;
4200cf64:	4505                	li	a0,1
}
4200cf66:	0141                	add	sp,sp,16
4200cf68:	8082                	ret
    assert_dev_drop(list != NULL);
4200cf6a:	4201a5b7          	lui	a1,0x4201a
4200cf6e:	89058593          	add	a1,a1,-1904 # 42019890 <hextab+0x2bc4>
4200cf72:	ae2f60ef          	jal	42003254 <logk>
4200cf76:	9002                	ebreak
    assert_dev_drop(node != NULL);
4200cf78:	4201a5b7          	lui	a1,0x4201a
4200cf7c:	8fc58593          	add	a1,a1,-1796 # 420198fc <hextab+0x2c30>
4200cf80:	4501                	li	a0,0
4200cf82:	ad2f60ef          	jal	42003254 <logk>
4200cf86:	9002                	ebreak
        iter = iter->next;
4200cf88:	9002                	ebreak

4200cf8a <dlist_append>:
void dlist_append(dlist_t *const list, dlist_node_t *const node) {
4200cf8a:	1141                	add	sp,sp,-16
4200cf8c:	c606                	sw	ra,12(sp)
4200cf8e:	c422                	sw	s0,8(sp)
4200cf90:	c226                	sw	s1,4(sp)
    assert_dev_drop(list != NULL);
4200cf92:	c135                	beqz	a0,4200cff6 <dlist_append+0x6c>
4200cf94:	84ae                	mv	s1,a1
    assert_dev_drop(node != NULL);
4200cf96:	c5bd                	beqz	a1,4200d004 <dlist_append+0x7a>
    assert_dev_drop(!dlist_contains(list, node));
4200cf98:	842a                	mv	s0,a0
4200cf9a:	f99ff0ef          	jal	4200cf32 <dlist_contains>
4200cf9e:	e93d                	bnez	a0,4200d014 <dlist_append+0x8a>
        .previous = list->tail,
4200cfa0:	00347793          	and	a5,s0,3
4200cfa4:	efd1                	bnez	a5,4200d040 <dlist_append+0xb6>
4200cfa6:	57e1                	li	a5,-8
4200cfa8:	08f47c63          	bgeu	s0,a5,4200d040 <dlist_append+0xb6>
    *node = (dlist_node_t){
4200cfac:	0034f713          	and	a4,s1,3
        .previous = list->tail,
4200cfb0:	441c                	lw	a5,8(s0)
    *node = (dlist_node_t){
4200cfb2:	e759                	bnez	a4,4200d040 <dlist_append+0xb6>
4200cfb4:	0004a023          	sw	zero,0(s1)
4200cfb8:	5771                	li	a4,-4
4200cfba:	08e4f363          	bgeu	s1,a4,4200d040 <dlist_append+0xb6>
4200cfbe:	c0dc                	sw	a5,4(s1)
    if (list->tail != NULL) {
4200cfc0:	cf91                	beqz	a5,4200cfdc <dlist_append+0x52>
        list->tail->next = node;
4200cfc2:	0037f713          	and	a4,a5,3
4200cfc6:	ef2d                	bnez	a4,4200d040 <dlist_append+0xb6>
4200cfc8:	4018                	lw	a4,0(s0)
4200cfca:	c384                	sw	s1,0(a5)
    list->tail  = node;
4200cfcc:	c404                	sw	s1,8(s0)
    list->len  += 1;
4200cfce:	0705                	add	a4,a4,1
}
4200cfd0:	40b2                	lw	ra,12(sp)
    list->len  += 1;
4200cfd2:	c018                	sw	a4,0(s0)
}
4200cfd4:	4422                	lw	s0,8(sp)
4200cfd6:	4492                	lw	s1,4(sp)
4200cfd8:	0141                	add	sp,sp,16
4200cfda:	8082                	ret
        assert_dev_drop(list->head == NULL);
4200cfdc:	405c                	lw	a5,4(s0)
4200cfde:	e3b9                	bnez	a5,4200d024 <dlist_append+0x9a>
        assert_dev_drop(list->len == 0);
4200cfe0:	4018                	lw	a4,0(s0)
4200cfe2:	eb21                	bnez	a4,4200d032 <dlist_append+0xa8>
    list->len  += 1;
4200cfe4:	0705                	add	a4,a4,1
        list->head = node;
4200cfe6:	c044                	sw	s1,4(s0)
    list->tail  = node;
4200cfe8:	c404                	sw	s1,8(s0)
}
4200cfea:	40b2                	lw	ra,12(sp)
    list->len  += 1;
4200cfec:	c018                	sw	a4,0(s0)
}
4200cfee:	4422                	lw	s0,8(sp)
4200cff0:	4492                	lw	s1,4(sp)
4200cff2:	0141                	add	sp,sp,16
4200cff4:	8082                	ret
    assert_dev_drop(list != NULL);
4200cff6:	4201a5b7          	lui	a1,0x4201a
4200cffa:	96858593          	add	a1,a1,-1688 # 42019968 <hextab+0x2c9c>
4200cffe:	a56f60ef          	jal	42003254 <logk>
4200d002:	9002                	ebreak
    assert_dev_drop(node != NULL);
4200d004:	4201a5b7          	lui	a1,0x4201a
4200d008:	9d458593          	add	a1,a1,-1580 # 420199d4 <hextab+0x2d08>
4200d00c:	4501                	li	a0,0
4200d00e:	a46f60ef          	jal	42003254 <logk>
4200d012:	9002                	ebreak
    assert_dev_drop(!dlist_contains(list, node));
4200d014:	4201a5b7          	lui	a1,0x4201a
4200d018:	a4058593          	add	a1,a1,-1472 # 42019a40 <hextab+0x2d74>
4200d01c:	4501                	li	a0,0
4200d01e:	a36f60ef          	jal	42003254 <logk>
4200d022:	9002                	ebreak
        assert_dev_drop(list->head == NULL);
4200d024:	4201a5b7          	lui	a1,0x4201a
4200d028:	ab458593          	add	a1,a1,-1356 # 42019ab4 <hextab+0x2de8>
4200d02c:	a28f60ef          	jal	42003254 <logk>
4200d030:	9002                	ebreak
        assert_dev_drop(list->len == 0);
4200d032:	4201a5b7          	lui	a1,0x4201a
4200d036:	b2858593          	add	a1,a1,-1240 # 42019b28 <hextab+0x2e5c>
4200d03a:	4501                	li	a0,0
4200d03c:	a18f60ef          	jal	42003254 <logk>
4200d040:	9002                	ebreak

4200d042 <dlist_prepend>:
void dlist_prepend(dlist_t *const list, dlist_node_t *const node) {
4200d042:	1141                	add	sp,sp,-16
4200d044:	c606                	sw	ra,12(sp)
4200d046:	c422                	sw	s0,8(sp)
4200d048:	c226                	sw	s1,4(sp)
    assert_dev_drop(list != NULL);
4200d04a:	c53d                	beqz	a0,4200d0b8 <dlist_prepend+0x76>
4200d04c:	84ae                	mv	s1,a1
    assert_dev_drop(node != NULL);
4200d04e:	cda5                	beqz	a1,4200d0c6 <dlist_prepend+0x84>
    assert_dev_drop(!dlist_contains(list, node));
4200d050:	842a                	mv	s0,a0
4200d052:	ee1ff0ef          	jal	4200cf32 <dlist_contains>
4200d056:	e141                	bnez	a0,4200d0d6 <dlist_prepend+0x94>
        .next     = list->head,
4200d058:	00347793          	and	a5,s0,3
4200d05c:	e7c5                	bnez	a5,4200d104 <dlist_prepend+0xc2>
4200d05e:	56f1                	li	a3,-4
4200d060:	0ad47263          	bgeu	s0,a3,4200d104 <dlist_prepend+0xc2>
    *node = (dlist_node_t){
4200d064:	0034f713          	and	a4,s1,3
        .next     = list->head,
4200d068:	405c                	lw	a5,4(s0)
    *node = (dlist_node_t){
4200d06a:	ef49                	bnez	a4,4200d104 <dlist_prepend+0xc2>
4200d06c:	c09c                	sw	a5,0(s1)
4200d06e:	08d4fb63          	bgeu	s1,a3,4200d104 <dlist_prepend+0xc2>
4200d072:	0004a223          	sw	zero,4(s1)
    if (list->head != NULL) {
4200d076:	c38d                	beqz	a5,4200d098 <dlist_prepend+0x56>
        list->head->previous = node;
4200d078:	0037f713          	and	a4,a5,3
4200d07c:	e741                	bnez	a4,4200d104 <dlist_prepend+0xc2>
4200d07e:	5771                	li	a4,-4
4200d080:	08e7f263          	bgeu	a5,a4,4200d104 <dlist_prepend+0xc2>
4200d084:	4018                	lw	a4,0(s0)
4200d086:	c3c4                	sw	s1,4(a5)
    list->head  = node;
4200d088:	c044                	sw	s1,4(s0)
    list->len  += 1;
4200d08a:	0705                	add	a4,a4,1
}
4200d08c:	40b2                	lw	ra,12(sp)
    list->len  += 1;
4200d08e:	c018                	sw	a4,0(s0)
}
4200d090:	4422                	lw	s0,8(sp)
4200d092:	4492                	lw	s1,4(sp)
4200d094:	0141                	add	sp,sp,16
4200d096:	8082                	ret
        assert_dev_drop(list->tail == NULL);
4200d098:	57e1                	li	a5,-8
4200d09a:	06f47563          	bgeu	s0,a5,4200d104 <dlist_prepend+0xc2>
4200d09e:	441c                	lw	a5,8(s0)
4200d0a0:	e3b9                	bnez	a5,4200d0e6 <dlist_prepend+0xa4>
        assert_dev_drop(list->len == 0);
4200d0a2:	4018                	lw	a4,0(s0)
4200d0a4:	eb29                	bnez	a4,4200d0f6 <dlist_prepend+0xb4>
    list->len  += 1;
4200d0a6:	0705                	add	a4,a4,1
        list->tail = node;
4200d0a8:	c404                	sw	s1,8(s0)
    list->head  = node;
4200d0aa:	c044                	sw	s1,4(s0)
}
4200d0ac:	40b2                	lw	ra,12(sp)
    list->len  += 1;
4200d0ae:	c018                	sw	a4,0(s0)
}
4200d0b0:	4422                	lw	s0,8(sp)
4200d0b2:	4492                	lw	s1,4(sp)
4200d0b4:	0141                	add	sp,sp,16
4200d0b6:	8082                	ret
    assert_dev_drop(list != NULL);
4200d0b8:	4201a5b7          	lui	a1,0x4201a
4200d0bc:	b9058593          	add	a1,a1,-1136 # 42019b90 <hextab+0x2ec4>
4200d0c0:	994f60ef          	jal	42003254 <logk>
4200d0c4:	9002                	ebreak
    assert_dev_drop(node != NULL);
4200d0c6:	4201a5b7          	lui	a1,0x4201a
4200d0ca:	bfc58593          	add	a1,a1,-1028 # 42019bfc <hextab+0x2f30>
4200d0ce:	4501                	li	a0,0
4200d0d0:	984f60ef          	jal	42003254 <logk>
4200d0d4:	9002                	ebreak
    assert_dev_drop(!dlist_contains(list, node));
4200d0d6:	4201a5b7          	lui	a1,0x4201a
4200d0da:	c6858593          	add	a1,a1,-920 # 42019c68 <hextab+0x2f9c>
4200d0de:	4501                	li	a0,0
4200d0e0:	974f60ef          	jal	42003254 <logk>
4200d0e4:	9002                	ebreak
        assert_dev_drop(list->tail == NULL);
4200d0e6:	4201a5b7          	lui	a1,0x4201a
4200d0ea:	cdc58593          	add	a1,a1,-804 # 42019cdc <hextab+0x3010>
4200d0ee:	4501                	li	a0,0
4200d0f0:	964f60ef          	jal	42003254 <logk>
4200d0f4:	9002                	ebreak
        assert_dev_drop(list->len == 0);
4200d0f6:	4201a5b7          	lui	a1,0x4201a
4200d0fa:	d5058593          	add	a1,a1,-688 # 42019d50 <hextab+0x3084>
4200d0fe:	4501                	li	a0,0
4200d100:	954f60ef          	jal	42003254 <logk>
4200d104:	9002                	ebreak

4200d106 <dlist_remove>:

void dlist_remove(dlist_t *const list, dlist_node_t *const node) {
4200d106:	1141                	add	sp,sp,-16
4200d108:	c422                	sw	s0,8(sp)
4200d10a:	c226                	sw	s1,4(sp)
4200d10c:	c606                	sw	ra,12(sp)
4200d10e:	84aa                	mv	s1,a0
4200d110:	842e                	mv	s0,a1
    assert_dev_drop(dlist_contains(list, node) || ((node->next == NULL) && (node->previous == NULL)));
4200d112:	e21ff0ef          	jal	4200cf32 <dlist_contains>
4200d116:	e505                	bnez	a0,4200d13e <dlist_remove+0x38>
4200d118:	cc09                	beqz	s0,4200d132 <dlist_remove+0x2c>
4200d11a:	00347793          	and	a5,s0,3
4200d11e:	eb91                	bnez	a5,4200d132 <dlist_remove+0x2c>
4200d120:	401c                	lw	a5,0(s0)
4200d122:	cb89                	beqz	a5,4200d134 <dlist_remove+0x2e>
4200d124:	4201a5b7          	lui	a1,0x4201a
4200d128:	db858593          	add	a1,a1,-584 # 42019db8 <hextab+0x30ec>
4200d12c:	4501                	li	a0,0
4200d12e:	926f60ef          	jal	42003254 <logk>
4200d132:	9002                	ebreak
4200d134:	57f1                	li	a5,-4
4200d136:	fef47ee3          	bgeu	s0,a5,4200d132 <dlist_remove+0x2c>
4200d13a:	405c                	lw	a5,4(s0)
4200d13c:	f7e5                	bnez	a5,4200d124 <dlist_remove+0x1e>

    bool decrement = false;
    if (node->previous != NULL) {
4200d13e:	d875                	beqz	s0,4200d132 <dlist_remove+0x2c>
4200d140:	00347793          	and	a5,s0,3
4200d144:	f7fd                	bnez	a5,4200d132 <dlist_remove+0x2c>
4200d146:	57f1                	li	a5,-4
4200d148:	fef475e3          	bgeu	s0,a5,4200d132 <dlist_remove+0x2c>
4200d14c:	405c                	lw	a5,4(s0)
4200d14e:	c7d1                	beqz	a5,4200d1da <dlist_remove+0xd4>
        node->previous->next = node->next;
4200d150:	0037f713          	and	a4,a5,3
4200d154:	4014                	lw	a3,0(s0)
4200d156:	ff71                	bnez	a4,4200d132 <dlist_remove+0x2c>
4200d158:	c394                	sw	a3,0(a5)
        decrement            = true;
4200d15a:	4685                	li	a3,1
    }
    if (node->next != NULL) {
4200d15c:	4018                	lw	a4,0(s0)
4200d15e:	cb39                	beqz	a4,4200d1b4 <dlist_remove+0xae>
        node->next->previous = node->previous;
4200d160:	00377693          	and	a3,a4,3
4200d164:	f6f9                	bnez	a3,4200d132 <dlist_remove+0x2c>
4200d166:	56f1                	li	a3,-4
4200d168:	fcd775e3          	bgeu	a4,a3,4200d132 <dlist_remove+0x2c>
4200d16c:	c35c                	sw	a5,4(a4)
        decrement            = true;
    }

    if (node == list->head) {
4200d16e:	d0f1                	beqz	s1,4200d132 <dlist_remove+0x2c>
4200d170:	0034f613          	and	a2,s1,3
4200d174:	fe5d                	bnez	a2,4200d132 <dlist_remove+0x2c>
4200d176:	fad4fee3          	bgeu	s1,a3,4200d132 <dlist_remove+0x2c>
4200d17a:	40dc                	lw	a5,4(s1)
4200d17c:	04f40663          	beq	s0,a5,4200d1c8 <dlist_remove+0xc2>
        list->head = node->next;
        decrement  = true;
    }
    if (node == list->tail) {
4200d180:	57e1                	li	a5,-8
4200d182:	faf4f8e3          	bgeu	s1,a5,4200d132 <dlist_remove+0x2c>
4200d186:	449c                	lw	a5,8(s1)
4200d188:	00f40f63          	beq	s0,a5,4200d1a6 <dlist_remove+0xa0>
        list->tail = node->previous;
        decrement  = true;
    }

    if (decrement) {
        list->len -= 1;
4200d18c:	d0dd                	beqz	s1,4200d132 <dlist_remove+0x2c>
4200d18e:	409c                	lw	a5,0(s1)
    }
    *node = DLIST_NODE_EMPTY;
}
4200d190:	40b2                	lw	ra,12(sp)
        list->len -= 1;
4200d192:	17fd                	add	a5,a5,-1
4200d194:	c09c                	sw	a5,0(s1)
    *node = DLIST_NODE_EMPTY;
4200d196:	00042023          	sw	zero,0(s0)
4200d19a:	00042223          	sw	zero,4(s0)
}
4200d19e:	4422                	lw	s0,8(sp)
4200d1a0:	4492                	lw	s1,4(sp)
4200d1a2:	0141                	add	sp,sp,16
4200d1a4:	8082                	ret
4200d1a6:	405c                	lw	a5,4(s0)
        list->tail = node->previous;
4200d1a8:	d4c9                	beqz	s1,4200d132 <dlist_remove+0x2c>
4200d1aa:	5761                	li	a4,-8
4200d1ac:	f8e4f3e3          	bgeu	s1,a4,4200d132 <dlist_remove+0x2c>
4200d1b0:	c49c                	sw	a5,8(s1)
    if (decrement) {
4200d1b2:	bfe9                	j	4200d18c <dlist_remove+0x86>
    if (node == list->head) {
4200d1b4:	dcbd                	beqz	s1,4200d132 <dlist_remove+0x2c>
4200d1b6:	0034f613          	and	a2,s1,3
4200d1ba:	fe25                	bnez	a2,4200d132 <dlist_remove+0x2c>
4200d1bc:	5671                	li	a2,-4
4200d1be:	f6c4fae3          	bgeu	s1,a2,4200d132 <dlist_remove+0x2c>
4200d1c2:	40d0                	lw	a2,4(s1)
4200d1c4:	00861d63          	bne	a2,s0,4200d1de <dlist_remove+0xd8>
        list->head = node->next;
4200d1c8:	d4ad                	beqz	s1,4200d132 <dlist_remove+0x2c>
4200d1ca:	57f1                	li	a5,-4
4200d1cc:	f6f4f3e3          	bgeu	s1,a5,4200d132 <dlist_remove+0x2c>
4200d1d0:	c0d8                	sw	a4,4(s1)
    if (node == list->tail) {
4200d1d2:	57e1                	li	a5,-8
4200d1d4:	faf4e9e3          	bltu	s1,a5,4200d186 <dlist_remove+0x80>
    assert_dev_drop(dlist_contains(list, node) || ((node->next == NULL) && (node->previous == NULL)));
4200d1d8:	9002                	ebreak
    bool decrement = false;
4200d1da:	4681                	li	a3,0
4200d1dc:	b741                	j	4200d15c <dlist_remove+0x56>
    if (node == list->tail) {
4200d1de:	5761                	li	a4,-8
4200d1e0:	f4e4f9e3          	bgeu	s1,a4,4200d132 <dlist_remove+0x2c>
4200d1e4:	4498                	lw	a4,8(s1)
4200d1e6:	fc8701e3          	beq	a4,s0,4200d1a8 <dlist_remove+0xa2>
    if (decrement) {
4200d1ea:	f2cd                	bnez	a3,4200d18c <dlist_remove+0x86>
}
4200d1ec:	40b2                	lw	ra,12(sp)
    *node = DLIST_NODE_EMPTY;
4200d1ee:	00042023          	sw	zero,0(s0)
4200d1f2:	00042223          	sw	zero,4(s0)
}
4200d1f6:	4422                	lw	s0,8(sp)
4200d1f8:	4492                	lw	s1,4(sp)
4200d1fa:	0141                	add	sp,sp,16
4200d1fc:	8082                	ret

4200d1fe <kernel_lifetime_func>:
// After basic runtime initialization, the booting CPU core continues here.
// This finishes the initialization of all kernel systems, resources and services.
// When finished, the non-booting CPUs will be started (method and entrypoints to be determined).
static void kernel_init() {
    badge_err_t ec = {0};
    logk(LOG_INFO, "BadgerOS starting...");
4200d1fe:	4201a5b7          	lui	a1,0x4201a
static void kernel_lifetime_func() {
4200d202:	1101                	add	sp,sp,-32
    logk(LOG_INFO, "BadgerOS starting...");
4200d204:	e7058593          	add	a1,a1,-400 # 42019e70 <hextab+0x31a4>
4200d208:	450d                	li	a0,3
static void kernel_lifetime_func() {
4200d20a:	ce06                	sw	ra,28(sp)
4200d20c:	cc22                	sw	s0,24(sp)
    badge_err_t ec = {0};
4200d20e:	c002                	sw	zero,0(sp)
4200d210:	c202                	sw	zero,4(sp)
4200d212:	c402                	sw	zero,8(sp)
4200d214:	c602                	sw	zero,12(sp)
    logk(LOG_INFO, "BadgerOS starting...");
4200d216:	83ef60ef          	jal	42003254 <logk>

    // Temporary filesystem image.
    fs_mount(&ec, FS_TYPE_RAMFS, NULL, "/", 0);
4200d21a:	420186b7          	lui	a3,0x42018
4200d21e:	4701                	li	a4,0
4200d220:	d4468693          	add	a3,a3,-700 # 42017d44 <hextab+0x1078>
4200d224:	4601                	li	a2,0
4200d226:	4589                	li	a1,2
4200d228:	850a                	mv	a0,sp
4200d22a:	d56fa0ef          	jal	42007780 <fs_mount>
    badge_err_assert_always(&ec);
4200d22e:	4402                	lw	s0,0(sp)
4200d230:	e83d                	bnez	s0,4200d2a6 <kernel_lifetime_func+0xa8>
    init_ramfs();
4200d232:	f20f30ef          	jal	42000952 <init_ramfs>
// After kernel initialization, the booting CPU core continues here.
// This starts up the `init` process while other CPU cores wait for processes to be scheduled for them.
// When finished, this function returns and the thread should wait for a shutdown event.
static void userland_init() {
    badge_err_t ec = {0};
    logk(LOG_INFO, "Kernel initialized");
4200d236:	4201a5b7          	lui	a1,0x4201a
4200d23a:	ec058593          	add	a1,a1,-320 # 42019ec0 <hextab+0x31f4>
4200d23e:	450d                	li	a0,3
    badge_err_t ec = {0};
4200d240:	c002                	sw	zero,0(sp)
4200d242:	c202                	sw	zero,4(sp)
4200d244:	c402                	sw	zero,8(sp)
4200d246:	c602                	sw	zero,12(sp)
    logk(LOG_INFO, "Kernel initialized");
4200d248:	80cf60ef          	jal	42003254 <logk>
    logk(LOG_INFO, "Staring init process");
4200d24c:	4201a5b7          	lui	a1,0x4201a
4200d250:	ed458593          	add	a1,a1,-300 # 42019ed4 <hextab+0x3208>
4200d254:	450d                	li	a0,3
4200d256:	ffff50ef          	jal	42003254 <logk>

    pid_t pid = proc_create(&ec);
4200d25a:	850a                	mv	a0,sp
4200d25c:	8e2ff0ef          	jal	4200c33e <proc_create>
    badge_err_assert_always(&ec);
4200d260:	4402                	lw	s0,0(sp)
4200d262:	e83d                	bnez	s0,4200d2d8 <kernel_lifetime_func+0xda>
    assert_dev_drop(pid == 1);
4200d264:	4785                	li	a5,1
4200d266:	ca26                	sw	s1,20(sp)
4200d268:	08f51663          	bne	a0,a5,4200d2f4 <kernel_lifetime_func+0xf6>
    proc_start(&ec, pid, "/sbin/init");
4200d26c:	42017637          	lui	a2,0x42017
4200d270:	e1860613          	add	a2,a2,-488 # 42016e18 <hextab+0x14c>
4200d274:	4585                	li	a1,1
4200d276:	850a                	mv	a0,sp
4200d278:	b9eff0ef          	jal	4200c616 <proc_start>
    badge_err_assert_always(&ec);
4200d27c:	4482                	lw	s1,0(sp)
4200d27e:	4080a437          	lui	s0,0x4080a
4200d282:	e0c9                	bnez	s1,4200d304 <kernel_lifetime_func+0x106>
        sched_yield();
4200d284:	330010ef          	jal	4200e5b4 <sched_yield>
        shutdown_mode = atomic_load(&kernel_shutdown_mode);
4200d288:	0ff0000f          	fence
4200d28c:	e5842783          	lw	a5,-424(s0) # 40809e58 <kernel_shutdown_mode>
4200d290:	0ff0000f          	fence
    } while (shutdown_mode == 0);
4200d294:	dbe5                	beqz	a5,4200d284 <kernel_lifetime_func+0x86>
    logk(LOG_INFO, "TODO: Shutdown procedure.");
4200d296:	4201a5b7          	lui	a1,0x4201a
4200d29a:	f5058593          	add	a1,a1,-176 # 42019f50 <hextab+0x3284>
4200d29e:	450d                	li	a0,3
4200d2a0:	fb5f50ef          	jal	42003254 <logk>
    while (1) continue;
4200d2a4:	a001                	j	4200d2a4 <kernel_lifetime_func+0xa6>
    badge_err_assert_always(&ec);
4200d2a6:	4512                	lw	a0,4(sp)
4200d2a8:	ca26                	sw	s1,20(sp)
4200d2aa:	aa7f30ef          	jal	42000d50 <badge_eloc_get_name>
4200d2ae:	87aa                	mv	a5,a0
4200d2b0:	8522                	mv	a0,s0
4200d2b2:	843e                	mv	s0,a5
4200d2b4:	adbf30ef          	jal	42000d8e <badge_ecause_get_name>
4200d2b8:	87aa                	mv	a5,a0
4200d2ba:	8722                	mv	a4,s0
4200d2bc:	0d400693          	li	a3,212
    badge_err_assert_always(&ec);
4200d2c0:	4201a637          	lui	a2,0x4201a
4200d2c4:	420175b7          	lui	a1,0x42017
4200d2c8:	e8860613          	add	a2,a2,-376 # 42019e88 <hextab+0x31bc>
4200d2cc:	df058593          	add	a1,a1,-528 # 42016df0 <hextab+0x124>
4200d2d0:	4501                	li	a0,0
4200d2d2:	fc9f50ef          	jal	4200329a <logkf>
4200d2d6:	9002                	ebreak
4200d2d8:	4512                	lw	a0,4(sp)
4200d2da:	ca26                	sw	s1,20(sp)
4200d2dc:	a75f30ef          	jal	42000d50 <badge_eloc_get_name>
4200d2e0:	87aa                	mv	a5,a0
4200d2e2:	8522                	mv	a0,s0
4200d2e4:	843e                	mv	s0,a5
4200d2e6:	aa9f30ef          	jal	42000d8e <badge_ecause_get_name>
4200d2ea:	87aa                	mv	a5,a0
4200d2ec:	8722                	mv	a4,s0
4200d2ee:	0e300693          	li	a3,227
4200d2f2:	b7f9                	j	4200d2c0 <kernel_lifetime_func+0xc2>
    assert_dev_drop(pid == 1);
4200d2f4:	4201a5b7          	lui	a1,0x4201a
4200d2f8:	eec58593          	add	a1,a1,-276 # 42019eec <hextab+0x3220>
4200d2fc:	4501                	li	a0,0
4200d2fe:	f57f50ef          	jal	42003254 <logk>
4200d302:	9002                	ebreak
    badge_err_assert_always(&ec);
4200d304:	4512                	lw	a0,4(sp)
4200d306:	a4bf30ef          	jal	42000d50 <badge_eloc_get_name>
4200d30a:	842a                	mv	s0,a0
4200d30c:	8526                	mv	a0,s1
4200d30e:	a81f30ef          	jal	42000d8e <badge_ecause_get_name>
4200d312:	87aa                	mv	a5,a0
4200d314:	8722                	mv	a4,s0
4200d316:	0e600693          	li	a3,230
4200d31a:	b75d                	j	4200d2c0 <kernel_lifetime_func+0xc2>

4200d31c <syscall_sys_shutdown>:
void syscall_sys_shutdown(bool is_reboot) {
4200d31c:	1141                	add	sp,sp,-16
4200d31e:	c422                	sw	s0,8(sp)
4200d320:	c606                	sw	ra,12(sp)
4200d322:	842a                	mv	s0,a0
    logk(LOG_INFO, is_reboot ? "Reboot requested" : "Shutdown requested");
4200d324:	c50d                	beqz	a0,4200d34e <syscall_sys_shutdown+0x32>
4200d326:	4201a5b7          	lui	a1,0x4201a
4200d32a:	f6c58593          	add	a1,a1,-148 # 42019f6c <hextab+0x32a0>
4200d32e:	450d                	li	a0,3
4200d330:	f25f50ef          	jal	42003254 <logk>
    atomic_store(&kernel_shutdown_mode, 1 + is_reboot);
4200d334:	0405                	add	s0,s0,1
4200d336:	4080a7b7          	lui	a5,0x4080a
4200d33a:	e5878793          	add	a5,a5,-424 # 40809e58 <kernel_shutdown_mode>
4200d33e:	0f50000f          	fence	iorw,ow
4200d342:	0c87a02f          	amoswap.w.aq	zero,s0,(a5)
}
4200d346:	40b2                	lw	ra,12(sp)
4200d348:	4422                	lw	s0,8(sp)
4200d34a:	0141                	add	sp,sp,16
4200d34c:	8082                	ret
    logk(LOG_INFO, is_reboot ? "Reboot requested" : "Shutdown requested");
4200d34e:	4201a5b7          	lui	a1,0x4201a
4200d352:	f8058593          	add	a1,a1,-128 # 42019f80 <hextab+0x32b4>
4200d356:	bfe1                	j	4200d32e <syscall_sys_shutdown+0x12>

4200d358 <basic_runtime_init>:
void basic_runtime_init() {
4200d358:	7155                	add	sp,sp,-208
    interrupt_init(&tmp_ctx);
4200d35a:	0848                	add	a0,sp,20
void basic_runtime_init() {
4200d35c:	c786                	sw	ra,204(sp)
4200d35e:	c5a2                	sw	s0,200(sp)
    badge_err_t ec = {0};
4200d360:	c202                	sw	zero,4(sp)
4200d362:	c402                	sw	zero,8(sp)
4200d364:	c602                	sw	zero,12(sp)
4200d366:	c802                	sw	zero,16(sp)
    interrupt_init(&tmp_ctx);
4200d368:	28b020ef          	jal	4200fdf2 <interrupt_init>
    time_init();
4200d36c:	154030ef          	jal	420104c0 <time_init>
    kernel_heap_init();
4200d370:	2cf9                	jal	4200d64e <kernel_heap_init>
    memprotect_init();
4200d372:	50d020ef          	jal	4201007e <memprotect_init>
    sched_init();
4200d376:	5c9000ef          	jal	4200e13e <sched_init>
    hk_init();
4200d37a:	e54ff0ef          	jal	4200c9ce <hk_init>
        stack_top - stack_bottom,
4200d37e:	408086b7          	lui	a3,0x40808
    sched_thread_t *thread = sched_create_kernel_thread(
4200d382:	4080a737          	lui	a4,0x4080a
        stack_top - stack_bottom,
4200d386:	e2068613          	add	a2,a3,-480 # 40807e20 <__stack_bottom>
    sched_thread_t *thread = sched_create_kernel_thread(
4200d38a:	e2070713          	add	a4,a4,-480 # 40809e20 <__stack_top>
4200d38e:	4200d5b7          	lui	a1,0x4200d
4200d392:	8f11                	sub	a4,a4,a2
4200d394:	47a9                	li	a5,10
4200d396:	e2068693          	add	a3,a3,-480
4200d39a:	4601                	li	a2,0
4200d39c:	1fe58593          	add	a1,a1,510 # 4200d1fe <kernel_lifetime_func>
4200d3a0:	0048                	add	a0,sp,4
4200d3a2:	7b1000ef          	jal	4200e352 <sched_create_kernel_thread>
    badge_err_assert_always(&ec);
4200d3a6:	4412                	lw	s0,4(sp)
4200d3a8:	e809                	bnez	s0,4200d3ba <basic_runtime_init+0x62>
4200d3aa:	85aa                	mv	a1,a0
    sched_resume_thread(&ec, thread);
4200d3ac:	0048                	add	a0,sp,4
4200d3ae:	14a010ef          	jal	4200e4f8 <sched_resume_thread>
    badge_err_assert_always(&ec);
4200d3b2:	4412                	lw	s0,4(sp)
4200d3b4:	e81d                	bnez	s0,4200d3ea <basic_runtime_init+0x92>
    sched_exec();
4200d3b6:	60c010ef          	jal	4200e9c2 <sched_exec>
    badge_err_assert_always(&ec);
4200d3ba:	4522                	lw	a0,8(sp)
4200d3bc:	995f30ef          	jal	42000d50 <badge_eloc_get_name>
4200d3c0:	872a                	mv	a4,a0
4200d3c2:	8522                	mv	a0,s0
4200d3c4:	843a                	mv	s0,a4
4200d3c6:	9c9f30ef          	jal	42000d8e <badge_ecause_get_name>
4200d3ca:	87aa                	mv	a5,a0
4200d3cc:	8722                	mv	a4,s0
4200d3ce:	0be00693          	li	a3,190
    badge_err_assert_always(&ec);
4200d3d2:	4201a637          	lui	a2,0x4201a
4200d3d6:	420175b7          	lui	a1,0x42017
4200d3da:	e8860613          	add	a2,a2,-376 # 42019e88 <hextab+0x31bc>
4200d3de:	df058593          	add	a1,a1,-528 # 42016df0 <hextab+0x124>
4200d3e2:	4501                	li	a0,0
4200d3e4:	eb7f50ef          	jal	4200329a <logkf>
4200d3e8:	9002                	ebreak
4200d3ea:	4522                	lw	a0,8(sp)
4200d3ec:	965f30ef          	jal	42000d50 <badge_eloc_get_name>
4200d3f0:	872a                	mv	a4,a0
4200d3f2:	8522                	mv	a0,s0
4200d3f4:	843a                	mv	s0,a4
4200d3f6:	999f30ef          	jal	42000d8e <badge_ecause_get_name>
4200d3fa:	87aa                	mv	a5,a0
4200d3fc:	8722                	mv	a4,s0
4200d3fe:	0c000693          	li	a3,192
4200d402:	bfc1                	j	4200d3d2 <basic_runtime_init+0x7a>

4200d404 <_free>:
    return ptr;
}

// NOLINTNEXTLINE
static void _free(void *ptr) {
    if (!ptr) {
4200d404:	c159                	beqz	a0,4200d48a <_free+0x86>
        return;
    }

    BADGEROS_MALLOC_ASSERT_DEBUG(
4200d406:	4080a7b7          	lui	a5,0x4080a
4200d40a:	e6c7a803          	lw	a6,-404(a5) # 40809e6c <mem_start>
static void _free(void *ptr) {
4200d40e:	1141                	add	sp,sp,-16
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200d410:	4080a7b7          	lui	a5,0x4080a
static void _free(void *ptr) {
4200d414:	c606                	sw	ra,12(sp)
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200d416:	e647a883          	lw	a7,-412(a5) # 40809e64 <mem_end_max>
4200d41a:	0d056c63          	bltu	a0,a6,4200d4f2 <_free+0xee>
4200d41e:	0d157a63          	bgeu	a0,a7,4200d4f2 <_free+0xee>
        ptr,
        mem_start,
        mem_end_max
    );

    free_blk_header_t *header = (free_blk_header_t *)((char *)ptr - MAX(sizeof(size_t), ALIGNMENT));
4200d422:	47c1                	li	a5,16
4200d424:	0ef56b63          	bltu	a0,a5,4200d51a <_free+0x116>
4200d428:	ff050f13          	add	t5,a0,-16
    size_t             size   = header->size;
4200d42c:	100f0c63          	beqz	t5,4200d544 <_free+0x140>
4200d430:	003f7793          	and	a5,t5,3
4200d434:	10079863          	bnez	a5,4200d544 <_free+0x140>
4200d438:	ff052883          	lw	a7,-16(a0)
    header->size              = *(size_t *)header & ~1L;
4200d43c:	ffe8f793          	and	a5,a7,-2
4200d440:	fef52823          	sw	a5,-16(a0)
    BADGEROS_MALLOC_ASSERT_DEBUG(size & 1, "free: double free on pointer " FMT_P, ptr);
4200d444:	0018f793          	and	a5,a7,1
4200d448:	cbf1                	beqz	a5,4200d51c <_free+0x118>
4200d44a:	0f418593          	add	a1,gp,244 # 408000f4 <min_class_size>
4200d44e:	4811                	li	a6,4
4200d450:	40b80833          	sub	a6,a6,a1
4200d454:	01058693          	add	a3,a1,16

    for (int i = NUM_SIZE_CLASSES - 1; i >= 0; i--) {
4200d458:	4711                	li	a4,4
        if (min_class_size[i] <= size) {
4200d45a:	4e15                	li	t3,5
4200d45c:	4351                	li	t1,20
    for (int i = NUM_SIZE_CLASSES - 1; i >= 0; i--) {
4200d45e:	5efd                	li	t4,-1
        if (min_class_size[i] <= size) {
4200d460:	09c77863          	bgeu	a4,t3,4200d4f0 <_free+0xec>
4200d464:	010687b3          	add	a5,a3,a6
4200d468:	00271613          	sll	a2,a4,0x2
4200d46c:	06f36e63          	bltu	t1,a5,4200d4e8 <_free+0xe4>
4200d470:	962e                	add	a2,a2,a1
4200d472:	06b66a63          	bltu	a2,a1,4200d4e6 <_free+0xe2>
4200d476:	429c                	lw	a5,0(a3)
4200d478:	00f8fa63          	bgeu	a7,a5,4200d48c <_free+0x88>
    for (int i = NUM_SIZE_CLASSES - 1; i >= 0; i--) {
4200d47c:	177d                	add	a4,a4,-1
4200d47e:	16f1                	add	a3,a3,-4
4200d480:	ffd710e3          	bne	a4,t4,4200d460 <_free+0x5c>
            header->prior      = &free_lists[i];
            free_lists[i].next = free_lists[i].next->prior = header;
            return;
        }
    }
}
4200d484:	40b2                	lw	ra,12(sp)
4200d486:	0141                	add	sp,sp,16
4200d488:	8082                	ret
4200d48a:	8082                	ret
            header->next       = free_lists[i].next;
4200d48c:	4080a7b7          	lui	a5,0x4080a
4200d490:	e607a683          	lw	a3,-416(a5) # 40809e60 <free_lists>
4200d494:	00171793          	sll	a5,a4,0x1
4200d498:	97ba                	add	a5,a5,a4
4200d49a:	078a                	sll	a5,a5,0x2
4200d49c:	97b6                	add	a5,a5,a3
4200d49e:	0ad7e763          	bltu	a5,a3,4200d54c <_free+0x148>
4200d4a2:	c7c5                	beqz	a5,4200d54a <_free+0x146>
4200d4a4:	0037f713          	and	a4,a5,3
4200d4a8:	e34d                	bnez	a4,4200d54a <_free+0x146>
4200d4aa:	5771                	li	a4,-4
4200d4ac:	0ae7f463          	bgeu	a5,a4,4200d554 <_free+0x150>
4200d4b0:	43d0                	lw	a2,4(a5)
4200d4b2:	0aef7063          	bgeu	t5,a4,4200d552 <_free+0x14e>
4200d4b6:	fec52a23          	sw	a2,-12(a0)
            header->prior      = &free_lists[i];
4200d4ba:	5761                	li	a4,-8
4200d4bc:	08ef7a63          	bgeu	t5,a4,4200d550 <_free+0x14c>
            free_lists[i].next = free_lists[i].next->prior = header;
4200d4c0:	43d8                	lw	a4,4(a5)
            header->prior      = &free_lists[i];
4200d4c2:	fef52c23          	sw	a5,-8(a0)
            free_lists[i].next = free_lists[i].next->prior = header;
4200d4c6:	c741                	beqz	a4,4200d54e <_free+0x14a>
4200d4c8:	00377613          	and	a2,a4,3
4200d4cc:	e249                	bnez	a2,4200d54e <_free+0x14a>
4200d4ce:	5661                	li	a2,-8
4200d4d0:	06c77c63          	bgeu	a4,a2,4200d548 <_free+0x144>
4200d4d4:	01e72423          	sw	t5,8(a4)
4200d4d8:	06d7e763          	bltu	a5,a3,4200d546 <_free+0x142>
}
4200d4dc:	40b2                	lw	ra,12(sp)
            free_lists[i].next = free_lists[i].next->prior = header;
4200d4de:	01e7a223          	sw	t5,4(a5)
}
4200d4e2:	0141                	add	sp,sp,16
4200d4e4:	8082                	ret
        if (min_class_size[i] <= size) {
4200d4e6:	9002                	ebreak
4200d4e8:	97b6                	add	a5,a5,a3
4200d4ea:	f8d7e3e3          	bltu	a5,a3,4200d470 <_free+0x6c>
4200d4ee:	9002                	ebreak
4200d4f0:	9002                	ebreak
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200d4f2:	4201c6b7          	lui	a3,0x4201c
4200d4f6:	4201a637          	lui	a2,0x4201a
4200d4fa:	4201a5b7          	lui	a1,0x4201a
4200d4fe:	87aa                	mv	a5,a0
4200d500:	11100713          	li	a4,273
4200d504:	9c068693          	add	a3,a3,-1600 # 4201b9c0 <__func__.1>
4200d508:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200d50c:	fd458593          	add	a1,a1,-44 # 42019fd4 <hextab+0x3308>
4200d510:	4511                	li	a0,4
4200d512:	d89f50ef          	jal	4200329a <logkf>
4200d516:	499010ef          	jal	4200f1ae <panic_abort>
    free_blk_header_t *header = (free_blk_header_t *)((char *)ptr - MAX(sizeof(size_t), ALIGNMENT));
4200d51a:	9002                	ebreak
    BADGEROS_MALLOC_ASSERT_DEBUG(size & 1, "free: double free on pointer " FMT_P, ptr);
4200d51c:	4201c6b7          	lui	a3,0x4201c
4200d520:	4201a637          	lui	a2,0x4201a
4200d524:	4201a5b7          	lui	a1,0x4201a
4200d528:	87aa                	mv	a5,a0
4200d52a:	11c00713          	li	a4,284
4200d52e:	9c068693          	add	a3,a3,-1600 # 4201b9c0 <__func__.1>
4200d532:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200d536:	03458593          	add	a1,a1,52 # 4201a034 <hextab+0x3368>
4200d53a:	4511                	li	a0,4
4200d53c:	d5ff50ef          	jal	4200329a <logkf>
4200d540:	46f010ef          	jal	4200f1ae <panic_abort>
    size_t             size   = header->size;
4200d544:	9002                	ebreak
            free_lists[i].next = free_lists[i].next->prior = header;
4200d546:	9002                	ebreak
4200d548:	9002                	ebreak
            header->next       = free_lists[i].next;
4200d54a:	9002                	ebreak
4200d54c:	9002                	ebreak
            free_lists[i].next = free_lists[i].next->prior = header;
4200d54e:	9002                	ebreak
            header->prior      = &free_lists[i];
4200d550:	9002                	ebreak
            header->next       = free_lists[i].next;
4200d552:	9002                	ebreak
4200d554:	9002                	ebreak

4200d556 <print_heap>:
void print_heap() {
4200d556:	7139                	add	sp,sp,-64
4200d558:	d05a                	sw	s6,32(sp)
4200d55a:	ce5e                	sw	s7,28(sp)
4200d55c:	ca66                	sw	s9,20(sp)
4200d55e:	0f418b93          	add	s7,gp,244 # 408000f4 <min_class_size>
4200d562:	4c91                	li	s9,4
4200d564:	da26                	sw	s1,52(sp)
4200d566:	d84a                	sw	s2,48(sp)
4200d568:	d64e                	sw	s3,44(sp)
4200d56a:	d452                	sw	s4,40(sp)
4200d56c:	d256                	sw	s5,36(sp)
4200d56e:	cc62                	sw	s8,24(sp)
4200d570:	c86a                	sw	s10,16(sp)
4200d572:	c66e                	sw	s11,12(sp)
4200d574:	de06                	sw	ra,60(sp)
4200d576:	dc22                	sw	s0,56(sp)
4200d578:	0f418b13          	add	s6,gp,244 # 408000f4 <min_class_size>
4200d57c:	417c8cb3          	sub	s9,s9,s7
4200d580:	4901                	li	s2,0
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
4200d582:	4a81                	li	s5,0
        logkf(LOG_DEBUG, "Bucket size: %{size;d}", min_class_size[i]);
4200d584:	4c15                	li	s8,5
4200d586:	4dd1                	li	s11,20
4200d588:	4201ad37          	lui	s10,0x4201a
        free_blk_header_t *fp = &free_lists[i];
4200d58c:	4080a9b7          	lui	s3,0x4080a
        while (fp->next != &free_lists[i]) {
4200d590:	54f1                	li	s1,-4
            logkf(LOG_DEBUG, "\tFree block 0x%{size;x} of size: %{size;d}", fp->next, fp->next->size);
4200d592:	4201aa37          	lui	s4,0x4201a
        logkf(LOG_DEBUG, "Bucket size: %{size;d}", min_class_size[i]);
4200d596:	0b8afb63          	bgeu	s5,s8,4200d64c <print_heap+0xf6>
4200d59a:	019b0733          	add	a4,s6,s9
4200d59e:	002a9793          	sll	a5,s5,0x2
4200d5a2:	0aede263          	bltu	s11,a4,4200d646 <print_heap+0xf0>
4200d5a6:	97de                	add	a5,a5,s7
4200d5a8:	0b77e263          	bltu	a5,s7,4200d64c <print_heap+0xf6>
4200d5ac:	000b2603          	lw	a2,0(s6)
4200d5b0:	084d0593          	add	a1,s10,132 # 4201a084 <hextab+0x33b8>
4200d5b4:	4511                	li	a0,4
4200d5b6:	ce5f50ef          	jal	4200329a <logkf>
        free_blk_header_t *fp = &free_lists[i];
4200d5ba:	e609a703          	lw	a4,-416(s3) # 40809e60 <free_lists>
4200d5be:	012707b3          	add	a5,a4,s2
4200d5c2:	08e7e563          	bltu	a5,a4,4200d64c <print_heap+0xf6>
4200d5c6:	843e                	mv	s0,a5
        while (fp->next != &free_lists[i]) {
4200d5c8:	c3d1                	beqz	a5,4200d64c <print_heap+0xf6>
4200d5ca:	0037f693          	and	a3,a5,3
4200d5ce:	eebd                	bnez	a3,4200d64c <print_heap+0xf6>
4200d5d0:	0697fe63          	bgeu	a5,s1,4200d64c <print_heap+0xf6>
4200d5d4:	43d0                	lw	a2,4(a5)
4200d5d6:	06e7eb63          	bltu	a5,a4,4200d64c <print_heap+0xf6>
4200d5da:	04f60263          	beq	a2,a5,4200d61e <print_heap+0xc8>
            logkf(LOG_DEBUG, "\tFree block 0x%{size;x} of size: %{size;d}", fp->next, fp->next->size);
4200d5de:	c43d                	beqz	s0,4200d64c <print_heap+0xf6>
4200d5e0:	00347793          	and	a5,s0,3
4200d5e4:	e7a5                	bnez	a5,4200d64c <print_heap+0xf6>
4200d5e6:	06947363          	bgeu	s0,s1,4200d64c <print_heap+0xf6>
4200d5ea:	c22d                	beqz	a2,4200d64c <print_heap+0xf6>
4200d5ec:	00367793          	and	a5,a2,3
4200d5f0:	efb1                	bnez	a5,4200d64c <print_heap+0xf6>
4200d5f2:	4214                	lw	a3,0(a2)
4200d5f4:	09ca0593          	add	a1,s4,156 # 4201a09c <hextab+0x33d0>
4200d5f8:	4511                	li	a0,4
4200d5fa:	ca1f50ef          	jal	4200329a <logkf>
            fp = fp->next;
4200d5fe:	4040                	lw	s0,4(s0)
        while (fp->next != &free_lists[i]) {
4200d600:	c431                	beqz	s0,4200d64c <print_heap+0xf6>
4200d602:	00347793          	and	a5,s0,3
4200d606:	e3b9                	bnez	a5,4200d64c <print_heap+0xf6>
4200d608:	04947263          	bgeu	s0,s1,4200d64c <print_heap+0xf6>
4200d60c:	e609a703          	lw	a4,-416(s3)
4200d610:	4050                	lw	a2,4(s0)
4200d612:	012707b3          	add	a5,a4,s2
4200d616:	02e7eb63          	bltu	a5,a4,4200d64c <print_heap+0xf6>
4200d61a:	fcf612e3          	bne	a2,a5,4200d5de <print_heap+0x88>
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
4200d61e:	0a85                	add	s5,s5,1
4200d620:	0b11                	add	s6,s6,4
4200d622:	0931                	add	s2,s2,12
4200d624:	f78a99e3          	bne	s5,s8,4200d596 <print_heap+0x40>
}
4200d628:	50f2                	lw	ra,60(sp)
4200d62a:	5462                	lw	s0,56(sp)
4200d62c:	54d2                	lw	s1,52(sp)
4200d62e:	5942                	lw	s2,48(sp)
4200d630:	59b2                	lw	s3,44(sp)
4200d632:	5a22                	lw	s4,40(sp)
4200d634:	5a92                	lw	s5,36(sp)
4200d636:	5b02                	lw	s6,32(sp)
4200d638:	4bf2                	lw	s7,28(sp)
4200d63a:	4c62                	lw	s8,24(sp)
4200d63c:	4cd2                	lw	s9,20(sp)
4200d63e:	4d42                	lw	s10,16(sp)
4200d640:	4db2                	lw	s11,12(sp)
4200d642:	6121                	add	sp,sp,64
4200d644:	8082                	ret
        logkf(LOG_DEBUG, "Bucket size: %{size;d}", min_class_size[i]);
4200d646:	975a                	add	a4,a4,s6
4200d648:	f5676fe3          	bltu	a4,s6,4200d5a6 <print_heap+0x50>
        while (fp->next != &free_lists[i]) {
4200d64c:	9002                	ebreak

4200d64e <kernel_heap_init>:
    free_lists  = (free_blk_header_t *)__start_free_sram;
4200d64e:	4080a7b7          	lui	a5,0x4080a
4200d652:	4080a737          	lui	a4,0x4080a
4200d656:	e9078693          	add	a3,a5,-368 # 40809e90 <__start_free_sram>
4200d65a:	e6d72023          	sw	a3,-416(a4) # 40809e60 <free_lists>
    mem_end_max = __stop_free_sram;
4200d65e:	40880737          	lui	a4,0x40880
4200d662:	00070713          	mv	a4,a4
4200d666:	4080a637          	lui	a2,0x4080a
4200d66a:	e6e62223          	sw	a4,-412(a2) # 40809e64 <mem_end_max>
    mem_start = ((char *)free_lists) + (NUM_SIZE_CLASSES * sizeof(free_blk_header_t));
4200d66e:	fc400713          	li	a4,-60
4200d672:	04e6f763          	bgeu	a3,a4,4200d6c0 <kernel_heap_init+0x72>
4200d676:	4080a737          	lui	a4,0x4080a
4200d67a:	ecc70713          	add	a4,a4,-308 # 40809ecc <__start_free_sram+0x3c>
4200d67e:	4080a637          	lui	a2,0x4080a
4200d682:	e6e62623          	sw	a4,-404(a2) # 40809e6c <mem_start>
    mem_end   = mem_start;
4200d686:	4080a637          	lui	a2,0x4080a
4200d68a:	e6e62423          	sw	a4,-408(a2) # 40809e68 <mem_end>
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
4200d68e:	e9078793          	add	a5,a5,-368
    mem_end   = mem_start;
4200d692:	4701                	li	a4,0
        free_lists[i].next = free_lists[i].prior = &free_lists[i];
4200d694:	5561                	li	a0,-8
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
4200d696:	03c00593          	li	a1,60
        free_lists[i].size = 0;
4200d69a:	00e68633          	add	a2,a3,a4
4200d69e:	02d66163          	bltu	a2,a3,4200d6c0 <kernel_heap_init+0x72>
4200d6a2:	cf99                	beqz	a5,4200d6c0 <kernel_heap_init+0x72>
4200d6a4:	0037f613          	and	a2,a5,3
4200d6a8:	ee01                	bnez	a2,4200d6c0 <kernel_heap_init+0x72>
4200d6aa:	0007a023          	sw	zero,0(a5)
        free_lists[i].next = free_lists[i].prior = &free_lists[i];
4200d6ae:	00a7f963          	bgeu	a5,a0,4200d6c0 <kernel_heap_init+0x72>
4200d6b2:	c79c                	sw	a5,8(a5)
4200d6b4:	c3dc                	sw	a5,4(a5)
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
4200d6b6:	0731                	add	a4,a4,12
4200d6b8:	07b1                	add	a5,a5,12
4200d6ba:	feb710e3          	bne	a4,a1,4200d69a <kernel_heap_init+0x4c>
}
4200d6be:	8082                	ret
        free_lists[i].next = free_lists[i].prior = &free_lists[i];
4200d6c0:	9002                	ebreak

4200d6c2 <_malloc>:
    size_t  blk_size = ALIGN(size + MAX(sizeof(size_t), ALIGNMENT));
4200d6c2:	e111                	bnez	a0,4200d6c6 <_malloc+0x4>
4200d6c4:	4505                	li	a0,1
4200d6c6:	057d                	add	a0,a0,31
4200d6c8:	ff057693          	and	a3,a0,-16
    blk_size = (blk_size < MBLK_SIZE) ? MBLK_SIZE : blk_size;
4200d6cc:	04000793          	li	a5,64
4200d6d0:	00f6f463          	bgeu	a3,a5,4200d6d8 <_malloc+0x16>
4200d6d4:	04000693          	li	a3,64
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200d6d8:	4080a7b7          	lui	a5,0x4080a
4200d6dc:	e607a603          	lw	a2,-416(a5) # 40809e60 <free_lists>
4200d6e0:	4e01                	li	t3,0
4200d6e2:	4080a7b7          	lui	a5,0x4080a
4200d6e6:	01c60eb3          	add	t4,a2,t3
4200d6ea:	e647a883          	lw	a7,-412(a5) # 40809e64 <mem_end_max>
4200d6ee:	0f418f13          	add	t5,gp,244 # 408000f4 <min_class_size>
4200d6f2:	8732                	mv	a4,a2
4200d6f4:	0f418513          	add	a0,gp,244 # 408000f4 <min_class_size>
4200d6f8:	4311                	li	t1,4
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
4200d6fa:	4781                	li	a5,0
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200d6fc:	53f1                	li	t2,-4
        if (min_class_size[i] >= size && free_lists[i].next != &free_lists[i]) {
4200d6fe:	4f95                	li	t6,5
4200d700:	42d1                	li	t0,20
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200d702:	22ceea63          	bltu	t4,a2,4200d936 <_malloc+0x274>
4200d706:	22060963          	beqz	a2,4200d938 <_malloc+0x276>
4200d70a:	00367593          	and	a1,a2,3
4200d70e:	22059563          	bnez	a1,4200d938 <_malloc+0x276>
4200d712:	22767163          	bgeu	a2,t2,4200d934 <_malloc+0x272>
void *_malloc(size_t size) {
4200d716:	1101                	add	sp,sp,-32
4200d718:	ce06                	sw	ra,28(sp)
4200d71a:	cc22                	sw	s0,24(sp)
4200d71c:	a829                	j	4200d736 <_malloc+0x74>
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200d71e:	01c60eb3          	add	t4,a2,t3
4200d722:	1cceee63          	bltu	t4,a2,4200d8fe <_malloc+0x23c>
4200d726:	1c070b63          	beqz	a4,4200d8fc <_malloc+0x23a>
4200d72a:	00377593          	and	a1,a4,3
4200d72e:	1c059763          	bnez	a1,4200d8fc <_malloc+0x23a>
4200d732:	1c777463          	bgeu	a4,t2,4200d8fa <_malloc+0x238>
4200d736:	00472803          	lw	a6,4(a4)
4200d73a:	18c86363          	bltu	a6,a2,4200d8c0 <_malloc+0x1fe>
4200d73e:	19187163          	bgeu	a6,a7,4200d8c0 <_malloc+0x1fe>
        if (min_class_size[i] >= size && free_lists[i].next != &free_lists[i]) {
4200d742:	1bf7ff63          	bgeu	a5,t6,4200d900 <_malloc+0x23e>
4200d746:	00279593          	sll	a1,a5,0x2
4200d74a:	1a62e263          	bltu	t0,t1,4200d8ee <_malloc+0x22c>
4200d74e:	95fa                	add	a1,a1,t5
4200d750:	1be5e463          	bltu	a1,t5,4200d8f8 <_malloc+0x236>
4200d754:	410c                	lw	a1,0(a0)
4200d756:	00d5e663          	bltu	a1,a3,4200d762 <_malloc+0xa0>
4200d75a:	1cceeb63          	bltu	t4,a2,4200d930 <_malloc+0x26e>
4200d75e:	10e81463          	bne	a6,a4,4200d866 <_malloc+0x1a4>
    for (int i = 0; i < NUM_SIZE_CLASSES; i++) {
4200d762:	0785                	add	a5,a5,1
4200d764:	0e31                	add	t3,t3,12
4200d766:	0731                	add	a4,a4,12
4200d768:	0511                	add	a0,a0,4
4200d76a:	0311                	add	t1,t1,4 # 80000004 <__stop_free_lpsram+0x2fffc004>
4200d76c:	fbf799e3          	bne	a5,t6,4200d71e <_malloc+0x5c>
    fp = &free_lists[NUM_SIZE_CLASSES - 1];
4200d770:	fd000793          	li	a5,-48
4200d774:	18f67863          	bgeu	a2,a5,4200d904 <_malloc+0x242>
4200d778:	03060513          	add	a0,a2,48
    while (fp->next != &free_lists[NUM_SIZE_CLASSES - 1]) {
4200d77c:	18050363          	beqz	a0,4200d902 <_malloc+0x240>
4200d780:	00357793          	and	a5,a0,3
4200d784:	16079f63          	bnez	a5,4200d902 <_malloc+0x240>
4200d788:	57f1                	li	a5,-4
4200d78a:	16f57e63          	bgeu	a0,a5,4200d906 <_malloc+0x244>
4200d78e:	5a5c                	lw	a5,52(a2)
4200d790:	0af50263          	beq	a0,a5,4200d834 <_malloc+0x172>
    fp = &free_lists[NUM_SIZE_CLASSES - 1];
4200d794:	882a                	mv	a6,a0
        fp = fp->next;
4200d796:	55f1                	li	a1,-4
        if (fp->size >= size) {
4200d798:	12080063          	beqz	a6,4200d8b8 <_malloc+0x1f6>
4200d79c:	00387613          	and	a2,a6,3
4200d7a0:	10061c63          	bnez	a2,4200d8b8 <_malloc+0x1f6>
4200d7a4:	00082703          	lw	a4,0(a6)
4200d7a8:	02d77263          	bgeu	a4,a3,4200d7cc <_malloc+0x10a>
        fp = fp->next;
4200d7ac:	10b87963          	bgeu	a6,a1,4200d8be <_malloc+0x1fc>
    while (fp->next != &free_lists[NUM_SIZE_CLASSES - 1]) {
4200d7b0:	10078663          	beqz	a5,4200d8bc <_malloc+0x1fa>
4200d7b4:	0037f713          	and	a4,a5,3
4200d7b8:	10071263          	bnez	a4,4200d8bc <_malloc+0x1fa>
4200d7bc:	0eb7ff63          	bgeu	a5,a1,4200d8ba <_malloc+0x1f8>
4200d7c0:	43d8                	lw	a4,4(a5)
4200d7c2:	883e                	mv	a6,a5
4200d7c4:	06e50863          	beq	a0,a4,4200d834 <_malloc+0x172>
4200d7c8:	87ba                	mv	a5,a4
4200d7ca:	b7f9                	j	4200d798 <_malloc+0xd6>
            fp->next->prior = fp->prior;
4200d7cc:	5771                	li	a4,-4
4200d7ce:	18e87063          	bgeu	a6,a4,4200d94e <_malloc+0x28c>
4200d7d2:	5761                	li	a4,-8
4200d7d4:	16e87c63          	bgeu	a6,a4,4200d94c <_malloc+0x28a>
4200d7d8:	00882603          	lw	a2,8(a6)
4200d7dc:	16078763          	beqz	a5,4200d94a <_malloc+0x288>
4200d7e0:	0037f593          	and	a1,a5,3
4200d7e4:	16059363          	bnez	a1,4200d94a <_malloc+0x288>
4200d7e8:	16e7f063          	bgeu	a5,a4,4200d948 <_malloc+0x286>
4200d7ec:	c790                	sw	a2,8(a5)
            fp->prior->next = fp->next;
4200d7ee:	00882703          	lw	a4,8(a6)
4200d7f2:	14070963          	beqz	a4,4200d944 <_malloc+0x282>
4200d7f6:	00377613          	and	a2,a4,3
4200d7fa:	14061563          	bnez	a2,4200d944 <_malloc+0x282>
4200d7fe:	5671                	li	a2,-4
4200d800:	14c77163          	bgeu	a4,a2,4200d942 <_malloc+0x280>
4200d804:	c35c                	sw	a5,4(a4)
    if (header) {
4200d806:	02080763          	beqz	a6,4200d834 <_malloc+0x172>
        *header = *(size_t *)header | 1;
4200d80a:	00082783          	lw	a5,0(a6)
    void *ptr = ALIGN_UP((char *)header + sizeof(size_t), ALIGNMENT);
4200d80e:	8542                	mv	a0,a6
        *header = *(size_t *)header | 1;
4200d810:	0017e793          	or	a5,a5,1
4200d814:	00f82023          	sw	a5,0(a6)
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200d818:	4080a7b7          	lui	a5,0x4080a
4200d81c:	e6c7a803          	lw	a6,-404(a5) # 40809e6c <mem_start>
    void *ptr = ALIGN_UP((char *)header + sizeof(size_t), ALIGNMENT);
4200d820:	054d                	add	a0,a0,19
4200d822:	9941                	and	a0,a0,-16
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200d824:	0f056263          	bltu	a0,a6,4200d908 <_malloc+0x246>
4200d828:	0f157063          	bgeu	a0,a7,4200d908 <_malloc+0x246>
}
4200d82c:	40f2                	lw	ra,28(sp)
4200d82e:	4462                	lw	s0,24(sp)
4200d830:	6105                	add	sp,sp,32
4200d832:	8082                	ret
        header = ALIGN_UP((size_t *)mem_end, ALIGNMENT);
4200d834:	4080a737          	lui	a4,0x4080a
4200d838:	e6872503          	lw	a0,-408(a4) # 40809e68 <mem_end>
4200d83c:	053d                	add	a0,a0,15
4200d83e:	9941                	and	a0,a0,-16
        if ((void *)header > (void *)mem_end_max) {
4200d840:	04a8e963          	bltu	a7,a0,4200d892 <_malloc+0x1d0>
        mem_end = (char *)header + blk_size;
4200d844:	00d507b3          	add	a5,a0,a3
4200d848:	0006cc63          	bltz	a3,4200d860 <_malloc+0x19e>
4200d84c:	00a7ec63          	bltu	a5,a0,4200d864 <_malloc+0x1a2>
4200d850:	e6f72423          	sw	a5,-408(a4)
        *header = blk_size | 1;
4200d854:	0016e693          	or	a3,a3,1
4200d858:	0e050763          	beqz	a0,4200d946 <_malloc+0x284>
4200d85c:	c114                	sw	a3,0(a0)
4200d85e:	bf6d                	j	4200d818 <_malloc+0x156>
        mem_end = (char *)header + blk_size;
4200d860:	fef578e3          	bgeu	a0,a5,4200d850 <_malloc+0x18e>
4200d864:	9002                	ebreak
            free_lists[i].next = fp->next;
4200d866:	0c080d63          	beqz	a6,4200d940 <_malloc+0x27e>
4200d86a:	00387613          	and	a2,a6,3
4200d86e:	ea69                	bnez	a2,4200d940 <_malloc+0x27e>
4200d870:	57f1                	li	a5,-4
4200d872:	0cf87663          	bgeu	a6,a5,4200d93e <_malloc+0x27c>
4200d876:	00482783          	lw	a5,4(a6)
4200d87a:	c35c                	sw	a5,4(a4)
            fp->next->prior    = &free_lists[i];
4200d87c:	00482783          	lw	a5,4(a6)
4200d880:	cfd5                	beqz	a5,4200d93c <_malloc+0x27a>
4200d882:	0037f613          	and	a2,a5,3
4200d886:	ea5d                	bnez	a2,4200d93c <_malloc+0x27a>
4200d888:	5661                	li	a2,-8
4200d88a:	0ac7f863          	bgeu	a5,a2,4200d93a <_malloc+0x278>
4200d88e:	c798                	sw	a4,8(a5)
            return fp;
4200d890:	bf9d                	j	4200d806 <_malloc+0x144>
            BADGEROS_MALLOC_MSG_DEBUG("malloc: out of memory, returning NULL");
4200d892:	4201c6b7          	lui	a3,0x4201c
4200d896:	4201a637          	lui	a2,0x4201a
4200d89a:	4201a5b7          	lui	a1,0x4201a
4200d89e:	4511                	li	a0,4
4200d8a0:	0c000713          	li	a4,192
4200d8a4:	9c868693          	add	a3,a3,-1592 # 4201b9c8 <__func__.3>
4200d8a8:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200d8ac:	15458593          	add	a1,a1,340 # 4201a154 <hextab+0x3488>
4200d8b0:	9ebf50ef          	jal	4200329a <logkf>
            return NULL;
4200d8b4:	4501                	li	a0,0
4200d8b6:	bf9d                	j	4200d82c <_malloc+0x16a>
        if (fp->size >= size) {
4200d8b8:	9002                	ebreak
    while (fp->next != &free_lists[NUM_SIZE_CLASSES - 1]) {
4200d8ba:	9002                	ebreak
4200d8bc:	9002                	ebreak
        fp = fp->next;
4200d8be:	9002                	ebreak
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200d8c0:	06cee963          	bltu	t4,a2,4200d932 <_malloc+0x270>
4200d8c4:	c046                	sw	a7,0(sp)
4200d8c6:	420176b7          	lui	a3,0x42017
4200d8ca:	88b2                	mv	a7,a2
4200d8cc:	4201a5b7          	lui	a1,0x4201a
4200d8d0:	4201a637          	lui	a2,0x4201a
4200d8d4:	09200713          	li	a4,146
4200d8d8:	bf068693          	add	a3,a3,-1040 # 42016bf0 <__func__.2>
4200d8dc:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200d8e0:	0c858593          	add	a1,a1,200 # 4201a0c8 <hextab+0x33fc>
4200d8e4:	4511                	li	a0,4
4200d8e6:	9b5f50ef          	jal	4200329a <logkf>
4200d8ea:	0c5010ef          	jal	4200f1ae <panic_abort>
        if (min_class_size[i] >= size && free_lists[i].next != &free_lists[i]) {
4200d8ee:	00650433          	add	s0,a0,t1
4200d8f2:	e4a46ee3          	bltu	s0,a0,4200d74e <_malloc+0x8c>
4200d8f6:	9002                	ebreak
4200d8f8:	9002                	ebreak
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200d8fa:	9002                	ebreak
4200d8fc:	9002                	ebreak
4200d8fe:	9002                	ebreak
        if (min_class_size[i] >= size && free_lists[i].next != &free_lists[i]) {
4200d900:	9002                	ebreak
    while (fp->next != &free_lists[NUM_SIZE_CLASSES - 1]) {
4200d902:	9002                	ebreak
    fp = &free_lists[NUM_SIZE_CLASSES - 1];
4200d904:	9002                	ebreak
    while (fp->next != &free_lists[NUM_SIZE_CLASSES - 1]) {
4200d906:	9002                	ebreak
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200d908:	4201c6b7          	lui	a3,0x4201c
4200d90c:	4201a637          	lui	a2,0x4201a
4200d910:	4201a5b7          	lui	a1,0x4201a
4200d914:	87aa                	mv	a5,a0
4200d916:	0c800713          	li	a4,200
4200d91a:	9c868693          	add	a3,a3,-1592 # 4201b9c8 <__func__.3>
4200d91e:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200d922:	19058593          	add	a1,a1,400 # 4201a190 <hextab+0x34c4>
4200d926:	4511                	li	a0,4
4200d928:	973f50ef          	jal	4200329a <logkf>
4200d92c:	083010ef          	jal	4200f1ae <panic_abort>
        if (min_class_size[i] >= size && free_lists[i].next != &free_lists[i]) {
4200d930:	9002                	ebreak
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200d932:	9002                	ebreak
4200d934:	9002                	ebreak
4200d936:	9002                	ebreak
4200d938:	9002                	ebreak
            fp->next->prior    = &free_lists[i];
4200d93a:	9002                	ebreak
4200d93c:	9002                	ebreak
            free_lists[i].next = fp->next;
4200d93e:	9002                	ebreak
4200d940:	9002                	ebreak
            fp->prior->next = fp->next;
4200d942:	9002                	ebreak
4200d944:	9002                	ebreak
        *header = blk_size | 1;
4200d946:	9002                	ebreak
            fp->next->prior = fp->prior;
4200d948:	9002                	ebreak
4200d94a:	9002                	ebreak
4200d94c:	9002                	ebreak
4200d94e:	9002                	ebreak

4200d950 <malloc>:
void *__wrap_malloc(size_t size) {
4200d950:	1141                	add	sp,sp,-16
4200d952:	c422                	sw	s0,8(sp)
4200d954:	4080a437          	lui	s0,0x4080a
4200d958:	e5c40693          	add	a3,s0,-420 # 40809e5c <lock>
    SPIN_LOCK_LOCK(lock);
4200d95c:	0036f613          	and	a2,a3,3
4200d960:	4705                	li	a4,1
4200d962:	060e                	sll	a2,a2,0x3
void *__wrap_malloc(size_t size) {
4200d964:	c606                	sw	ra,12(sp)
    SPIN_LOCK_LOCK(lock);
4200d966:	9af1                	and	a3,a3,-4
4200d968:	00c715b3          	sll	a1,a4,a2
4200d96c:	483d                	li	a6,15
4200d96e:	44b6a7af          	amoor.w.aq	a5,a1,(a3)
4200d972:	00c7d7b3          	srl	a5,a5,a2
4200d976:	0ff7f793          	zext.b	a5,a5
4200d97a:	cb91                	beqz	a5,4200d98e <malloc+0x3e>
4200d97c:	ef05                	bnez	a4,4200d9b4 <malloc+0x64>
4200d97e:	0706                	sll	a4,a4,0x1
4200d980:	44b6a7af          	amoor.w.aq	a5,a1,(a3)
4200d984:	00c7d7b3          	srl	a5,a5,a2
4200d988:	0ff7f793          	zext.b	a5,a5
4200d98c:	fbe5                	bnez	a5,4200d97c <malloc+0x2c>
    void *ptr = _malloc(size);
4200d98e:	d35ff0ef          	jal	4200d6c2 <_malloc>
    SPIN_LOCK_UNLOCK(lock);
4200d992:	0ff0000f          	fence
4200d996:	e4040e23          	sb	zero,-420(s0)
}
4200d99a:	40b2                	lw	ra,12(sp)
4200d99c:	4422                	lw	s0,8(sp)
4200d99e:	0141                	add	sp,sp,16
4200d9a0:	8082                	ret
    SPIN_LOCK_LOCK(lock);
4200d9a2:	fce85ee3          	bge	a6,a4,4200d97e <malloc+0x2e>
4200d9a6:	44b6a7af          	amoor.w.aq	a5,a1,(a3)
4200d9aa:	00c7d7b3          	srl	a5,a5,a2
4200d9ae:	0ff7f793          	zext.b	a5,a5
4200d9b2:	dff1                	beqz	a5,4200d98e <malloc+0x3e>
4200d9b4:	4781                	li	a5,0
#elif (defined(__aarch64__))
    __asm__ volatile("yield");
#elif (defined(__riscv))
    // On some versions of GCC the riscv_pause() builtin doesn't work
    // on the badge hardware
    __asm__ volatile("nop");
4200d9b6:	0001                	nop
    __asm__ volatile("nop");
4200d9b8:	0001                	nop
    __asm__ volatile("nop");
4200d9ba:	0001                	nop
    __asm__ volatile("nop");
4200d9bc:	0001                	nop
4200d9be:	0785                	add	a5,a5,1
4200d9c0:	fee79be3          	bne	a5,a4,4200d9b6 <malloc+0x66>
4200d9c4:	bff9                	j	4200d9a2 <malloc+0x52>

4200d9c6 <aligned_alloc>:
void *__wrap_aligned_alloc(size_t alignment, size_t size) {
4200d9c6:	1141                	add	sp,sp,-16
4200d9c8:	c422                	sw	s0,8(sp)
4200d9ca:	4080a437          	lui	s0,0x4080a
4200d9ce:	e5c40693          	add	a3,s0,-420 # 40809e5c <lock>
    SPIN_LOCK_LOCK(lock);
4200d9d2:	0036f613          	and	a2,a3,3
4200d9d6:	4705                	li	a4,1
4200d9d8:	060e                	sll	a2,a2,0x3
void *__wrap_aligned_alloc(size_t alignment, size_t size) {
4200d9da:	c606                	sw	ra,12(sp)
4200d9dc:	852e                	mv	a0,a1
    SPIN_LOCK_LOCK(lock);
4200d9de:	9af1                	and	a3,a3,-4
4200d9e0:	00c71833          	sll	a6,a4,a2
4200d9e4:	48bd                	li	a7,15
4200d9e6:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200d9ea:	00c7d7b3          	srl	a5,a5,a2
4200d9ee:	0ff7f793          	zext.b	a5,a5
4200d9f2:	cb91                	beqz	a5,4200da06 <aligned_alloc+0x40>
4200d9f4:	ef05                	bnez	a4,4200da2c <aligned_alloc+0x66>
4200d9f6:	0706                	sll	a4,a4,0x1
4200d9f8:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200d9fc:	00c7d7b3          	srl	a5,a5,a2
4200da00:	0ff7f793          	zext.b	a5,a5
4200da04:	fbe5                	bnez	a5,4200d9f4 <aligned_alloc+0x2e>
    void *ptr = _malloc(size);
4200da06:	cbdff0ef          	jal	4200d6c2 <_malloc>
    SPIN_LOCK_UNLOCK(lock);
4200da0a:	0ff0000f          	fence
4200da0e:	e4040e23          	sb	zero,-420(s0)
}
4200da12:	40b2                	lw	ra,12(sp)
4200da14:	4422                	lw	s0,8(sp)
4200da16:	0141                	add	sp,sp,16
4200da18:	8082                	ret
    SPIN_LOCK_LOCK(lock);
4200da1a:	fce8dee3          	bge	a7,a4,4200d9f6 <aligned_alloc+0x30>
4200da1e:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200da22:	00c7d7b3          	srl	a5,a5,a2
4200da26:	0ff7f793          	zext.b	a5,a5
4200da2a:	dff1                	beqz	a5,4200da06 <aligned_alloc+0x40>
4200da2c:	4781                	li	a5,0
    __asm__ volatile("nop");
4200da2e:	0001                	nop
    __asm__ volatile("nop");
4200da30:	0001                	nop
    __asm__ volatile("nop");
4200da32:	0001                	nop
    __asm__ volatile("nop");
4200da34:	0001                	nop
4200da36:	0785                	add	a5,a5,1
4200da38:	fee79be3          	bne	a5,a4,4200da2e <aligned_alloc+0x68>
4200da3c:	bff9                	j	4200da1a <aligned_alloc+0x54>

4200da3e <posix_memalign>:
int __wrap_posix_memalign(void **memptr, size_t alignment, size_t size) {
4200da3e:	1141                	add	sp,sp,-16
4200da40:	c226                	sw	s1,4(sp)
4200da42:	4080a4b7          	lui	s1,0x4080a
4200da46:	e5c48693          	add	a3,s1,-420 # 40809e5c <lock>
    SPIN_LOCK_LOCK(lock);
4200da4a:	0036f593          	and	a1,a3,3
4200da4e:	4705                	li	a4,1
4200da50:	058e                	sll	a1,a1,0x3
int __wrap_posix_memalign(void **memptr, size_t alignment, size_t size) {
4200da52:	c422                	sw	s0,8(sp)
4200da54:	c606                	sw	ra,12(sp)
4200da56:	842a                	mv	s0,a0
    SPIN_LOCK_LOCK(lock);
4200da58:	9af1                	and	a3,a3,-4
int __wrap_posix_memalign(void **memptr, size_t alignment, size_t size) {
4200da5a:	8532                	mv	a0,a2
    SPIN_LOCK_LOCK(lock);
4200da5c:	00b71833          	sll	a6,a4,a1
4200da60:	48bd                	li	a7,15
4200da62:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200da66:	00b7d7b3          	srl	a5,a5,a1
4200da6a:	0ff7f793          	zext.b	a5,a5
4200da6e:	cb91                	beqz	a5,4200da82 <posix_memalign+0x44>
4200da70:	e339                	bnez	a4,4200dab6 <posix_memalign+0x78>
4200da72:	0706                	sll	a4,a4,0x1
4200da74:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200da78:	00b7d7b3          	srl	a5,a5,a1
4200da7c:	0ff7f793          	zext.b	a5,a5
4200da80:	fbe5                	bnez	a5,4200da70 <posix_memalign+0x32>
    void *ptr = _malloc(size);
4200da82:	c41ff0ef          	jal	4200d6c2 <_malloc>
    SPIN_LOCK_UNLOCK(lock);
4200da86:	0ff0000f          	fence
4200da8a:	e4048e23          	sb	zero,-420(s1)
    *memptr = ptr;
4200da8e:	cc0d                	beqz	s0,4200dac8 <posix_memalign+0x8a>
4200da90:	00347793          	and	a5,s0,3
4200da94:	eb95                	bnez	a5,4200dac8 <posix_memalign+0x8a>
4200da96:	c008                	sw	a0,0(s0)
}
4200da98:	40b2                	lw	ra,12(sp)
4200da9a:	4422                	lw	s0,8(sp)
4200da9c:	4492                	lw	s1,4(sp)
4200da9e:	4501                	li	a0,0
4200daa0:	0141                	add	sp,sp,16
4200daa2:	8082                	ret
    SPIN_LOCK_LOCK(lock);
4200daa4:	fce8d7e3          	bge	a7,a4,4200da72 <posix_memalign+0x34>
4200daa8:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200daac:	00b7d7b3          	srl	a5,a5,a1
4200dab0:	0ff7f793          	zext.b	a5,a5
4200dab4:	d7f9                	beqz	a5,4200da82 <posix_memalign+0x44>
4200dab6:	4781                	li	a5,0
    __asm__ volatile("nop");
4200dab8:	0001                	nop
    __asm__ volatile("nop");
4200daba:	0001                	nop
    __asm__ volatile("nop");
4200dabc:	0001                	nop
    __asm__ volatile("nop");
4200dabe:	0001                	nop
4200dac0:	0785                	add	a5,a5,1
4200dac2:	fee79be3          	bne	a5,a4,4200dab8 <posix_memalign+0x7a>
4200dac6:	bff9                	j	4200daa4 <posix_memalign+0x66>
    *memptr = ptr;
4200dac8:	9002                	ebreak

4200daca <calloc>:
void *__wrap_calloc(size_t nmemb, size_t size) {
4200daca:	1141                	add	sp,sp,-16
4200dacc:	c422                	sw	s0,8(sp)
4200dace:	4080a437          	lui	s0,0x4080a
4200dad2:	e5c40693          	add	a3,s0,-420 # 40809e5c <lock>
    SPIN_LOCK_LOCK(lock);
4200dad6:	0036f613          	and	a2,a3,3
4200dada:	4705                	li	a4,1
4200dadc:	060e                	sll	a2,a2,0x3
void *__wrap_calloc(size_t nmemb, size_t size) {
4200dade:	c606                	sw	ra,12(sp)
4200dae0:	c226                	sw	s1,4(sp)
4200dae2:	c04a                	sw	s2,0(sp)
    SPIN_LOCK_LOCK(lock);
4200dae4:	9af1                	and	a3,a3,-4
4200dae6:	00c71833          	sll	a6,a4,a2
4200daea:	48bd                	li	a7,15
4200daec:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200daf0:	00c7d7b3          	srl	a5,a5,a2
4200daf4:	0ff7f793          	zext.b	a5,a5
4200daf8:	cb91                	beqz	a5,4200db0c <calloc+0x42>
4200dafa:	eb21                	bnez	a4,4200db4a <calloc+0x80>
4200dafc:	0706                	sll	a4,a4,0x1
4200dafe:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200db02:	00c7d7b3          	srl	a5,a5,a2
4200db06:	0ff7f793          	zext.b	a5,a5
4200db0a:	fbe5                	bnez	a5,4200dafa <calloc+0x30>
    void *ptr = _malloc(nmemb * size);
4200db0c:	02b504b3          	mul	s1,a0,a1
4200db10:	8526                	mv	a0,s1
4200db12:	bb1ff0ef          	jal	4200d6c2 <_malloc>
4200db16:	892a                	mv	s2,a0
    if (ptr)
4200db18:	c509                	beqz	a0,4200db22 <calloc+0x58>
        __builtin_memset(ptr, 0, nmemb * size); // NOLINT
4200db1a:	8626                	mv	a2,s1
4200db1c:	4581                	li	a1,0
4200db1e:	df9f40ef          	jal	42002916 <memset>
    SPIN_LOCK_UNLOCK(lock);
4200db22:	0ff0000f          	fence
4200db26:	e4040e23          	sb	zero,-420(s0)
}
4200db2a:	40b2                	lw	ra,12(sp)
4200db2c:	4422                	lw	s0,8(sp)
4200db2e:	4492                	lw	s1,4(sp)
4200db30:	854a                	mv	a0,s2
4200db32:	4902                	lw	s2,0(sp)
4200db34:	0141                	add	sp,sp,16
4200db36:	8082                	ret
    SPIN_LOCK_LOCK(lock);
4200db38:	fce8d2e3          	bge	a7,a4,4200dafc <calloc+0x32>
4200db3c:	4506a7af          	amoor.w.aq	a5,a6,(a3)
4200db40:	00c7d7b3          	srl	a5,a5,a2
4200db44:	0ff7f793          	zext.b	a5,a5
4200db48:	d3f1                	beqz	a5,4200db0c <calloc+0x42>
4200db4a:	4781                	li	a5,0
    __asm__ volatile("nop");
4200db4c:	0001                	nop
    __asm__ volatile("nop");
4200db4e:	0001                	nop
    __asm__ volatile("nop");
4200db50:	0001                	nop
    __asm__ volatile("nop");
4200db52:	0001                	nop
4200db54:	0785                	add	a5,a5,1
4200db56:	fee79be3          	bne	a5,a4,4200db4c <calloc+0x82>
4200db5a:	bff9                	j	4200db38 <calloc+0x6e>

4200db5c <free>:

// NOLINTNEXTLINE
void __wrap_free(void *ptr) {
4200db5c:	1141                	add	sp,sp,-16
4200db5e:	c422                	sw	s0,8(sp)
4200db60:	4080a437          	lui	s0,0x4080a
4200db64:	e5c40693          	add	a3,s0,-420 # 40809e5c <lock>
#ifdef PRELOAD
    if (!free_lists)
        kernel_heap_init();
#endif

    SPIN_LOCK_LOCK(lock);
4200db68:	0036f613          	and	a2,a3,3
4200db6c:	4705                	li	a4,1
4200db6e:	060e                	sll	a2,a2,0x3
void __wrap_free(void *ptr) {
4200db70:	c606                	sw	ra,12(sp)
    SPIN_LOCK_LOCK(lock);
4200db72:	9af1                	and	a3,a3,-4
4200db74:	00c715b3          	sll	a1,a4,a2
4200db78:	483d                	li	a6,15
4200db7a:	44b6a7af          	amoor.w.aq	a5,a1,(a3)
4200db7e:	00c7d7b3          	srl	a5,a5,a2
4200db82:	0ff7f793          	zext.b	a5,a5
4200db86:	cb91                	beqz	a5,4200db9a <free+0x3e>
4200db88:	ef05                	bnez	a4,4200dbc0 <free+0x64>
4200db8a:	0706                	sll	a4,a4,0x1
4200db8c:	44b6a7af          	amoor.w.aq	a5,a1,(a3)
4200db90:	00c7d7b3          	srl	a5,a5,a2
4200db94:	0ff7f793          	zext.b	a5,a5
4200db98:	fbe5                	bnez	a5,4200db88 <free+0x2c>
    _free(ptr);
4200db9a:	86bff0ef          	jal	4200d404 <_free>
    SPIN_LOCK_UNLOCK(lock);
4200db9e:	0ff0000f          	fence
4200dba2:	e4040e23          	sb	zero,-420(s0)
}
4200dba6:	40b2                	lw	ra,12(sp)
4200dba8:	4422                	lw	s0,8(sp)
4200dbaa:	0141                	add	sp,sp,16
4200dbac:	8082                	ret
    SPIN_LOCK_LOCK(lock);
4200dbae:	fce85ee3          	bge	a6,a4,4200db8a <free+0x2e>
4200dbb2:	44b6a7af          	amoor.w.aq	a5,a1,(a3)
4200dbb6:	00c7d7b3          	srl	a5,a5,a2
4200dbba:	0ff7f793          	zext.b	a5,a5
4200dbbe:	dff1                	beqz	a5,4200db9a <free+0x3e>
4200dbc0:	4781                	li	a5,0
    __asm__ volatile("nop");
4200dbc2:	0001                	nop
    __asm__ volatile("nop");
4200dbc4:	0001                	nop
    __asm__ volatile("nop");
4200dbc6:	0001                	nop
    __asm__ volatile("nop");
4200dbc8:	0001                	nop
4200dbca:	0785                	add	a5,a5,1
4200dbcc:	fee79be3          	bne	a5,a4,4200dbc2 <free+0x66>
4200dbd0:	bff9                	j	4200dbae <free+0x52>

4200dbd2 <realloc>:

// NOLINTNEXTLINE
void *__wrap_realloc(void *ptr, size_t size) {
4200dbd2:	7179                	add	sp,sp,-48
4200dbd4:	ce4e                	sw	s3,28(sp)
4200dbd6:	d606                	sw	ra,44(sp)
4200dbd8:	89ae                	mv	s3,a1
#ifdef PRELOAD
    if (!free_lists)
        kernel_heap_init();
#endif

    if (!ptr) {
4200dbda:	14050963          	beqz	a0,4200dd2c <realloc+0x15a>
4200dbde:	d226                	sw	s1,36(sp)
        return __wrap_malloc(size);
    }

    if (!size) {
4200dbe0:	14058c63          	beqz	a1,4200dd38 <realloc+0x166>
4200dbe4:	cc52                	sw	s4,24(sp)
        __wrap_free(ptr);
        return NULL;
    }

    BADGEROS_MALLOC_ASSERT_DEBUG(
4200dbe6:	4080aa37          	lui	s4,0x4080a
4200dbea:	e6ca2803          	lw	a6,-404(s4) # 40809e6c <mem_start>
4200dbee:	d422                	sw	s0,40(sp)
4200dbf0:	c85a                	sw	s6,16(sp)
4200dbf2:	d04a                	sw	s2,32(sp)
4200dbf4:	4080ab37          	lui	s6,0x4080a
4200dbf8:	ca56                	sw	s5,20(sp)
4200dbfa:	e64b2883          	lw	a7,-412(s6) # 40809e64 <mem_end_max>
4200dbfe:	842a                	mv	s0,a0
4200dc00:	1d056963          	bltu	a0,a6,4200ddd2 <realloc+0x200>
4200dc04:	1d157763          	bgeu	a0,a7,4200ddd2 <realloc+0x200>
        "realloc: invalid pointer " FMT_P " range " FMT_P "-" FMT_P,
        ptr,
        mem_start,
        mem_end_max
    );
    free_blk_header_t *header = (free_blk_header_t *)((char *)ptr - MAX(sizeof(size_t), ALIGNMENT));
4200dc08:	47c1                	li	a5,16
4200dc0a:	0cf56763          	bltu	a0,a5,4200dcd8 <realloc+0x106>
4200dc0e:	ff050793          	add	a5,a0,-16
    BADGEROS_MALLOC_ASSERT_DEBUG(header->size & 1, "realloc: attempting to resize freed pointer " FMT_P, ptr);
4200dc12:	c3f9                	beqz	a5,4200dcd8 <realloc+0x106>
4200dc14:	8b8d                	and	a5,a5,3
4200dc16:	e3e9                	bnez	a5,4200dcd8 <realloc+0x106>
4200dc18:	ff052783          	lw	a5,-16(a0)
4200dc1c:	8b85                	and	a5,a5,1
4200dc1e:	18078663          	beqz	a5,4200ddaa <realloc+0x1d8>
4200dc22:	4080a937          	lui	s2,0x4080a
4200dc26:	e5c90793          	add	a5,s2,-420 # 40809e5c <lock>

    SPIN_LOCK_LOCK(lock);
4200dc2a:	0037f613          	and	a2,a5,3
4200dc2e:	4685                	li	a3,1
4200dc30:	060e                	sll	a2,a2,0x3
4200dc32:	9bf1                	and	a5,a5,-4
4200dc34:	00c695b3          	sll	a1,a3,a2
4200dc38:	453d                	li	a0,15
4200dc3a:	44b7a72f          	amoor.w.aq	a4,a1,(a5)
4200dc3e:	00c75733          	srl	a4,a4,a2
4200dc42:	0ff77713          	zext.b	a4,a4
4200dc46:	cb11                	beqz	a4,4200dc5a <realloc+0x88>
4200dc48:	e2d5                	bnez	a3,4200dcec <realloc+0x11a>
4200dc4a:	0686                	sll	a3,a3,0x1
4200dc4c:	44b7a72f          	amoor.w.aq	a4,a1,(a5)
4200dc50:	00c75733          	srl	a4,a4,a2
4200dc54:	0ff77713          	zext.b	a4,a4
4200dc58:	fb65                	bnez	a4,4200dc48 <realloc+0x76>
    char *new_ptr = _malloc(size);
4200dc5a:	854e                	mv	a0,s3
4200dc5c:	a67ff0ef          	jal	4200d6c2 <_malloc>
4200dc60:	84aa                	mv	s1,a0
    if (!new_ptr) {
4200dc62:	cd79                	beqz	a0,4200dd40 <realloc+0x16e>
        BADGEROS_MALLOC_MSG_DEBUG("realloc: failed to allocate memory, returning NULL");
        SPIN_LOCK_UNLOCK(lock);
        return NULL;
    }

    size_t old_size = header->size & ~1L;
4200dc64:	ff042a83          	lw	s5,-16(s0)
4200dc68:	ffeafa93          	and	s5,s5,-2
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200dc6c:	180a8763          	beqz	s5,4200ddfa <realloc+0x228>
4200dc70:	e64b2783          	lw	a5,-412(s6)
4200dc74:	e6ca2703          	lw	a4,-404(s4)
4200dc78:	8f99                	sub	a5,a5,a4
4200dc7a:	18faf063          	bgeu	s5,a5,4200ddfa <realloc+0x228>
        (old_size > 0 && old_size < (size_t)mem_end_max - (size_t)mem_start),
        "realloc: block corruption"
    );

    size_t copy_size = old_size < size ? old_size : size;
4200dc7e:	8a4e                	mv	s4,s3
4200dc80:	0b3ae463          	bltu	s5,s3,4200dd28 <realloc+0x156>
    __builtin_memcpy(new_ptr, ptr, copy_size); // NOLINT
4200dc84:	8652                	mv	a2,s4
4200dc86:	85a2                	mv	a1,s0
4200dc88:	8526                	mv	a0,s1
4200dc8a:	ca5f40ef          	jal	4200292e <memcpy>

#if BADGEROS_MALLOC_DEBUG_LEVEL >= BADGEROS_MALLOC_DEBUG_DEBUG
    for (size_t i = 0; i < copy_size; ++i) {
4200dc8e:	4701                	li	a4,0
4200dc90:	8322                	mv	t1,s0
4200dc92:	86a6                	mv	a3,s1
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200dc94:	00e407b3          	add	a5,s0,a4
4200dc98:	02074e63          	bltz	a4,4200dcd4 <realloc+0x102>
4200dc9c:	0287ee63          	bltu	a5,s0,4200dcd8 <realloc+0x106>
4200dca0:	02030c63          	beqz	t1,4200dcd8 <realloc+0x106>
4200dca4:	00034e03          	lbu	t3,0(t1)
4200dca8:	00170793          	add	a5,a4,1
4200dcac:	00e48533          	add	a0,s1,a4
4200dcb0:	04074763          	bltz	a4,4200dcfe <realloc+0x12c>
4200dcb4:	02956263          	bltu	a0,s1,4200dcd8 <realloc+0x106>
4200dcb8:	c285                	beqz	a3,4200dcd8 <realloc+0x106>
4200dcba:	0006c503          	lbu	a0,0(a3)
4200dcbe:	0305                	add	t1,t1,1
4200dcc0:	0685                	add	a3,a3,1
4200dcc2:	0bc51b63          	bne	a0,t3,4200dd78 <realloc+0x1a6>
    for (size_t i = 0; i < copy_size; ++i) {
4200dcc6:	02fa0f63          	beq	s4,a5,4200dd04 <realloc+0x132>
4200dcca:	873e                	mv	a4,a5
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200dccc:	00e407b3          	add	a5,s0,a4
4200dcd0:	fc0756e3          	bgez	a4,4200dc9c <realloc+0xca>
4200dcd4:	fcf476e3          	bgeu	s0,a5,4200dca0 <realloc+0xce>
4200dcd8:	9002                	ebreak
    SPIN_LOCK_LOCK(lock);
4200dcda:	f6d558e3          	bge	a0,a3,4200dc4a <realloc+0x78>
4200dcde:	44b7a72f          	amoor.w.aq	a4,a1,(a5)
4200dce2:	00c75733          	srl	a4,a4,a2
4200dce6:	0ff77713          	zext.b	a4,a4
4200dcea:	db25                	beqz	a4,4200dc5a <realloc+0x88>
4200dcec:	4701                	li	a4,0
    __asm__ volatile("nop");
4200dcee:	0001                	nop
    __asm__ volatile("nop");
4200dcf0:	0001                	nop
    __asm__ volatile("nop");
4200dcf2:	0001                	nop
    __asm__ volatile("nop");
4200dcf4:	0001                	nop
4200dcf6:	0705                	add	a4,a4,1
4200dcf8:	fed71be3          	bne	a4,a3,4200dcee <realloc+0x11c>
4200dcfc:	bff9                	j	4200dcda <realloc+0x108>
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200dcfe:	faa4fde3          	bgeu	s1,a0,4200dcb8 <realloc+0xe6>
4200dd02:	9002                	ebreak
            i
        );
    }
#endif

    _free(ptr);
4200dd04:	8522                	mv	a0,s0
4200dd06:	efeff0ef          	jal	4200d404 <_free>
    SPIN_LOCK_UNLOCK(lock);
4200dd0a:	0ff0000f          	fence
4200dd0e:	e4090e23          	sb	zero,-420(s2)
4200dd12:	5422                	lw	s0,40(sp)
4200dd14:	5902                	lw	s2,32(sp)
4200dd16:	4a62                	lw	s4,24(sp)
4200dd18:	4ad2                	lw	s5,20(sp)
4200dd1a:	4b42                	lw	s6,16(sp)
    return new_ptr;
}
4200dd1c:	50b2                	lw	ra,44(sp)
4200dd1e:	49f2                	lw	s3,28(sp)
4200dd20:	8526                	mv	a0,s1
4200dd22:	5492                	lw	s1,36(sp)
4200dd24:	6145                	add	sp,sp,48
4200dd26:	8082                	ret
    size_t copy_size = old_size < size ? old_size : size;
4200dd28:	8a56                	mv	s4,s5
4200dd2a:	bfa9                	j	4200dc84 <realloc+0xb2>
}
4200dd2c:	50b2                	lw	ra,44(sp)
4200dd2e:	49f2                	lw	s3,28(sp)
        return __wrap_malloc(size);
4200dd30:	852e                	mv	a0,a1
}
4200dd32:	6145                	add	sp,sp,48
        return __wrap_malloc(size);
4200dd34:	c1dff06f          	j	4200d950 <malloc>
        __wrap_free(ptr);
4200dd38:	e25ff0ef          	jal	4200db5c <free>
        return NULL;
4200dd3c:	4481                	li	s1,0
4200dd3e:	bff9                	j	4200dd1c <realloc+0x14a>
        BADGEROS_MALLOC_MSG_DEBUG("realloc: failed to allocate memory, returning NULL");
4200dd40:	4201c6b7          	lui	a3,0x4201c
4200dd44:	4201a637          	lui	a2,0x4201a
4200dd48:	4201a5b7          	lui	a1,0x4201a
4200dd4c:	15100713          	li	a4,337
4200dd50:	9b868693          	add	a3,a3,-1608 # 4201b9b8 <__func__.0>
4200dd54:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200dd58:	2b458593          	add	a1,a1,692 # 4201a2b4 <hextab+0x35e8>
4200dd5c:	4511                	li	a0,4
4200dd5e:	d3cf50ef          	jal	4200329a <logkf>
        SPIN_LOCK_UNLOCK(lock);
4200dd62:	0ff0000f          	fence
4200dd66:	e4090e23          	sb	zero,-420(s2)
4200dd6a:	5422                	lw	s0,40(sp)
4200dd6c:	5902                	lw	s2,32(sp)
4200dd6e:	4a62                	lw	s4,24(sp)
4200dd70:	4ad2                	lw	s5,20(sp)
4200dd72:	4b42                	lw	s6,16(sp)
        return NULL;
4200dd74:	4481                	li	s1,0
4200dd76:	b75d                	j	4200dd1c <realloc+0x14a>
        BADGEROS_MALLOC_ASSERT_DEBUG(
4200dd78:	4201c6b7          	lui	a3,0x4201c
4200dd7c:	4201a637          	lui	a2,0x4201a
4200dd80:	4201a5b7          	lui	a1,0x4201a
4200dd84:	c43a                	sw	a4,8(sp)
4200dd86:	88d6                	mv	a7,s5
4200dd88:	884e                	mv	a6,s3
4200dd8a:	87a2                	mv	a5,s0
4200dd8c:	16100713          	li	a4,353
4200dd90:	9b868693          	add	a3,a3,-1608 # 4201b9b8 <__func__.0>
4200dd94:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200dd98:	33c58593          	add	a1,a1,828 # 4201a33c <hextab+0x3670>
4200dd9c:	4511                	li	a0,4
4200dd9e:	c226                	sw	s1,4(sp)
4200dda0:	c052                	sw	s4,0(sp)
4200dda2:	cf8f50ef          	jal	4200329a <logkf>
4200dda6:	408010ef          	jal	4200f1ae <panic_abort>
    BADGEROS_MALLOC_ASSERT_DEBUG(header->size & 1, "realloc: attempting to resize freed pointer " FMT_P, ptr);
4200ddaa:	4201c6b7          	lui	a3,0x4201c
4200ddae:	4201a637          	lui	a2,0x4201a
4200ddb2:	4201a5b7          	lui	a1,0x4201a
4200ddb6:	87aa                	mv	a5,a0
4200ddb8:	14c00713          	li	a4,332
4200ddbc:	9b868693          	add	a3,a3,-1608 # 4201b9b8 <__func__.0>
4200ddc0:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200ddc4:	25858593          	add	a1,a1,600 # 4201a258 <hextab+0x358c>
4200ddc8:	4511                	li	a0,4
4200ddca:	cd0f50ef          	jal	4200329a <logkf>
4200ddce:	3e0010ef          	jal	4200f1ae <panic_abort>
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200ddd2:	4201c6b7          	lui	a3,0x4201c
4200ddd6:	4201a637          	lui	a2,0x4201a
4200ddda:	4201a5b7          	lui	a1,0x4201a
4200ddde:	87a2                	mv	a5,s0
4200dde0:	14400713          	li	a4,324
4200dde4:	9b868693          	add	a3,a3,-1608 # 4201b9b8 <__func__.0>
4200dde8:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200ddec:	1f458593          	add	a1,a1,500 # 4201a1f4 <hextab+0x3528>
4200ddf0:	4511                	li	a0,4
4200ddf2:	ca8f50ef          	jal	4200329a <logkf>
4200ddf6:	3b8010ef          	jal	4200f1ae <panic_abort>
    BADGEROS_MALLOC_ASSERT_DEBUG(
4200ddfa:	4201c6b7          	lui	a3,0x4201c
4200ddfe:	4201a637          	lui	a2,0x4201a
4200de02:	4201a5b7          	lui	a1,0x4201a
4200de06:	15700713          	li	a4,343
4200de0a:	9b868693          	add	a3,a3,-1608 # 4201b9b8 <__func__.0>
4200de0e:	f9460613          	add	a2,a2,-108 # 42019f94 <hextab+0x32c8>
4200de12:	2fc58593          	add	a1,a1,764 # 4201a2fc <hextab+0x3630>
4200de16:	4511                	li	a0,4
4200de18:	c82f50ef          	jal	4200329a <logkf>
4200de1c:	392010ef          	jal	4200f1ae <panic_abort>

4200de20 <reallocarray>:

// NOLINTNEXTLINE
void *__wrap_reallocarray(void *ptr, size_t nmemb, size_t size) {
    return __wrap_realloc(ptr, nmemb * size);
4200de20:	02c585b3          	mul	a1,a1,a2
4200de24:	dafff06f          	j	4200dbd2 <realloc>

4200de28 <idle_thread_function>:
    dlist_append(&thread_alloc_pool, &thread->schedule_node);
}

static void idle_thread_function(void *arg) {
    (void)arg;
    while (true) {
4200de28:	a001                	j	4200de28 <idle_thread_function>

4200de2a <leave_critical_section>:
    assert_dev_drop(critical_section_active);
4200de2a:	4080a737          	lui	a4,0x4080a
4200de2e:	e7174783          	lbu	a5,-399(a4) # 40809e71 <critical_section_active>
4200de32:	4685                	li	a3,1
4200de34:	02f6ec63          	bltu	a3,a5,4200de6c <leave_critical_section+0x42>
4200de38:	8b85                	and	a5,a5,1
4200de3a:	cf99                	beqz	a5,4200de58 <leave_critical_section+0x2e>
    if (critical_section_had_interrupts) {
4200de3c:	4080a7b7          	lui	a5,0x4080a
4200de40:	e707c783          	lbu	a5,-400(a5) # 40809e70 <critical_section_had_interrupts>
4200de44:	02f6e463          	bltu	a3,a5,4200de6c <leave_critical_section+0x42>
4200de48:	8b85                	and	a5,a5,1
4200de4a:	c781                	beqz	a5,4200de52 <leave_critical_section+0x28>
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
}
// Enable interrupts.
static inline void isr_global_enable() {
    asm volatile("csrs mstatus, %0" ::"r"((1U << RV32_MSTATUS_MIE_BIT)));
4200de4c:	47a1                	li	a5,8
4200de4e:	3007a073          	csrs	mstatus,a5
    critical_section_active = false;
4200de52:	e60708a3          	sb	zero,-399(a4)
4200de56:	8082                	ret
    assert_dev_drop(critical_section_active);
4200de58:	4201a5b7          	lui	a1,0x4201a
static void leave_critical_section(void) {
4200de5c:	1141                	add	sp,sp,-16
    assert_dev_drop(critical_section_active);
4200de5e:	40458593          	add	a1,a1,1028 # 4201a404 <hextab+0x3738>
4200de62:	4501                	li	a0,0
static void leave_critical_section(void) {
4200de64:	c606                	sw	ra,12(sp)
    assert_dev_drop(critical_section_active);
4200de66:	beef50ef          	jal	42003254 <logk>
4200de6a:	9002                	ebreak
4200de6c:	9002                	ebreak

4200de6e <thread_alloc>:
    dlist_node_t *const node = dlist_pop_front(&thread_alloc_pool);
4200de6e:	40802537          	lui	a0,0x40802
static sched_thread_t *thread_alloc(void) {
4200de72:	1141                	add	sp,sp,-16
    dlist_node_t *const node = dlist_pop_front(&thread_alloc_pool);
4200de74:	40050513          	add	a0,a0,1024 # 40802400 <thread_alloc_pool>
static sched_thread_t *thread_alloc(void) {
4200de78:	c606                	sw	ra,12(sp)
4200de7a:	c422                	sw	s0,8(sp)
    dlist_node_t *const node = dlist_pop_front(&thread_alloc_pool);
4200de7c:	ecffe0ef          	jal	4200cd4a <dlist_pop_front>
    if (node == NULL) {
4200de80:	c929                	beqz	a0,4200ded2 <thread_alloc+0x64>
    sched_thread_t *const thread = field_parent_ptr(sched_thread_t, schedule_node, node);
4200de82:	4751                	li	a4,20
4200de84:	04e56663          	bltu	a0,a4,4200ded0 <thread_alloc+0x62>
4200de88:	fec50413          	add	s0,a0,-20
    assert_dev_drop(thread->flags == THREAD_ALLOCATOR_SENTINEL);
4200de8c:	c031                	beqz	s0,4200ded0 <thread_alloc+0x62>
4200de8e:	00347713          	and	a4,s0,3
4200de92:	ef1d                	bnez	a4,4200ded0 <thread_alloc+0x62>
4200de94:	5741                	li	a4,-16
4200de96:	02e47d63          	bgeu	s0,a4,4200ded0 <thread_alloc+0x62>
4200de9a:	ffc52703          	lw	a4,-4(a0)
4200de9e:	0badc7b7          	lui	a5,0xbadc
4200dea2:	0de78793          	add	a5,a5,222 # badc0de <__stack_size+0xbada0de>
4200dea6:	00f71e63          	bne	a4,a5,4200dec2 <thread_alloc+0x54>
    mem_set(thread, 0xAA, sizeof(sched_thread_t));
4200deaa:	19800613          	li	a2,408
4200deae:	0aa00593          	li	a1,170
4200deb2:	8522                	mv	a0,s0
4200deb4:	999f40ef          	jal	4200284c <mem_set>
}
4200deb8:	40b2                	lw	ra,12(sp)
4200deba:	8522                	mv	a0,s0
4200debc:	4422                	lw	s0,8(sp)
4200debe:	0141                	add	sp,sp,16
4200dec0:	8082                	ret
    assert_dev_drop(thread->flags == THREAD_ALLOCATOR_SENTINEL);
4200dec2:	4201a5b7          	lui	a1,0x4201a
4200dec6:	47c58593          	add	a1,a1,1148 # 4201a47c <hextab+0x37b0>
4200deca:	4501                	li	a0,0
4200decc:	b88f50ef          	jal	42003254 <logk>
4200ded0:	9002                	ebreak
        return NULL;
4200ded2:	4401                	li	s0,0
4200ded4:	b7d5                	j	4200deb8 <thread_alloc+0x4a>

4200ded6 <sched_resume_thread_inner>:
}

// Implementation for both `sched_resume_thread` and `sched_resume_thread_next`.
static void sched_resume_thread_inner(
    badge_err_t *const ec, sched_thread_t *const thread, thread_insert_position_t const position
) {
4200ded6:	1141                	add	sp,sp,-16
4200ded8:	c606                	sw	ra,12(sp)
    assert_dev_drop(thread != NULL);
4200deda:	14058463          	beqz	a1,4200e022 <sched_resume_thread_inner+0x14c>
    assert_dev_drop(!critical_section_active);
4200dede:	4080a6b7          	lui	a3,0x4080a
4200dee2:	e716c783          	lbu	a5,-399(a3) # 40809e71 <critical_section_active>
4200dee6:	4705                	li	a4,1
4200dee8:	18f76963          	bltu	a4,a5,4200e07a <sched_resume_thread_inner+0x1a4>
4200deec:	14079663          	bnez	a5,4200e038 <sched_resume_thread_inner+0x162>
4200def0:	c226                	sw	s1,4(sp)
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200def2:	47a1                	li	a5,8
4200def4:	84aa                	mv	s1,a0
4200def6:	3007b7f3          	csrrc	a5,mstatus,a5
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
4200defa:	838d                	srl	a5,a5,0x3
4200defc:	8b85                	and	a5,a5,1
    critical_section_had_interrupts = isr_global_disable();
4200defe:	4080a537          	lui	a0,0x4080a
4200df02:	e6f50823          	sb	a5,-400(a0) # 40809e70 <critical_section_had_interrupts>
    critical_section_active         = true;
4200df06:	e6e688a3          	sb	a4,-399(a3)
    enter_critical_section();

    if (is_flag_set(thread->flags, THREAD_COMPLETED)) {
4200df0a:	0035f793          	and	a5,a1,3
4200df0e:	16079363          	bnez	a5,4200e074 <sched_resume_thread_inner+0x19e>
4200df12:	57c1                	li	a5,-16
4200df14:	16f5f063          	bgeu	a1,a5,4200e074 <sched_resume_thread_inner+0x19e>
4200df18:	499c                	lw	a5,16(a1)
4200df1a:	0027f693          	and	a3,a5,2
4200df1e:	e6bd                	bnez	a3,4200df8c <sched_resume_thread_inner+0xb6>

        // thread is already completed and cannot be resumed:
        badge_err_set(ec, ELOC_THREADS, ECAUSE_ILLEGAL);
        leave_critical_section();
        return;
    } else if (!is_flag_set(thread->flags, THREAD_RUNNING)) {
4200df20:	0017f693          	and	a3,a5,1
4200df24:	e68d                	bnez	a3,4200df4e <sched_resume_thread_inner+0x78>

        // Thread is not running, but ready to run. Put it into the
        // wait queue and mark it as ready.
        set_flag(thread->flags, THREAD_RUNNING);
4200df26:	0017e793          	or	a5,a5,1
4200df2a:	c99c                	sw	a5,16(a1)

        if (position == INSERT_THREAD_FRONT) {
            dlist_prepend(&thread_wait_queue, &thread->schedule_node);
4200df2c:	57b1                	li	a5,-20
        if (position == INSERT_THREAD_FRONT) {
4200df2e:	0ee60063          	beq	a2,a4,4200e00e <sched_resume_thread_inner+0x138>
        } else {
            dlist_append(&thread_wait_queue, &thread->schedule_node);
4200df32:	14f5f163          	bgeu	a1,a5,4200e074 <sched_resume_thread_inner+0x19e>
4200df36:	40802537          	lui	a0,0x40802
4200df3a:	05d1                	add	a1,a1,20
4200df3c:	40c50513          	add	a0,a0,1036 # 4080240c <thread_wait_queue>
4200df40:	84aff0ef          	jal	4200cf8a <dlist_append>
        leave_critical_section();
4200df44:	4492                	lw	s1,4(sp)
        assert_dev_drop(dlist_contains(&thread_wait_queue, &thread->schedule_node));
        badge_err_set_ok(ec);
    }

    leave_critical_section();
}
4200df46:	40b2                	lw	ra,12(sp)
4200df48:	0141                	add	sp,sp,16
        leave_critical_section();
4200df4a:	ee1ff06f          	j	4200de2a <leave_critical_section>
    } else if (position == INSERT_THREAD_FRONT) {
4200df4e:	06e60a63          	beq	a2,a4,4200dfc2 <sched_resume_thread_inner+0xec>
        assert_dev_drop(dlist_contains(&thread_wait_queue, &thread->schedule_node));
4200df52:	57b1                	li	a5,-20
4200df54:	12f5f063          	bgeu	a1,a5,4200e074 <sched_resume_thread_inner+0x19e>
4200df58:	40802537          	lui	a0,0x40802
4200df5c:	05d1                	add	a1,a1,20
4200df5e:	40c50513          	add	a0,a0,1036 # 4080240c <thread_wait_queue>
4200df62:	fd1fe0ef          	jal	4200cf32 <dlist_contains>
4200df66:	0e050763          	beqz	a0,4200e054 <sched_resume_thread_inner+0x17e>
        badge_err_set_ok(ec);
4200df6a:	dce9                	beqz	s1,4200df44 <sched_resume_thread_inner+0x6e>
4200df6c:	0034f793          	and	a5,s1,3
4200df70:	10079263          	bnez	a5,4200e074 <sched_resume_thread_inner+0x19e>
4200df74:	57f1                	li	a5,-4
4200df76:	0ef4ff63          	bgeu	s1,a5,4200e074 <sched_resume_thread_inner+0x19e>
}
4200df7a:	40b2                	lw	ra,12(sp)
        badge_err_set_ok(ec);
4200df7c:	0004a223          	sw	zero,4(s1)
4200df80:	0004a023          	sw	zero,0(s1)
        leave_critical_section();
4200df84:	4492                	lw	s1,4(sp)
}
4200df86:	0141                	add	sp,sp,16
        leave_critical_section();
4200df88:	ea3ff06f          	j	4200de2a <leave_critical_section>
        badge_err_set(ec, ELOC_THREADS, ECAUSE_ILLEGAL);
4200df8c:	dcc5                	beqz	s1,4200df44 <sched_resume_thread_inner+0x6e>
4200df8e:	420175b7          	lui	a1,0x42017
4200df92:	46d9                	li	a3,22
4200df94:	4631                	li	a2,12
4200df96:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200df9a:	4511                	li	a0,4
4200df9c:	00000717          	auipc	a4,0x0
4200dfa0:	afaf50ef          	jal	4200329a <logkf>
4200dfa4:	0034f793          	and	a5,s1,3
4200dfa8:	e7f1                	bnez	a5,4200e074 <sched_resume_thread_inner+0x19e>
4200dfaa:	57f1                	li	a5,-4
4200dfac:	0cf4f463          	bgeu	s1,a5,4200e074 <sched_resume_thread_inner+0x19e>
4200dfb0:	47b1                	li	a5,12
4200dfb2:	c0dc                	sw	a5,4(s1)
4200dfb4:	47d9                	li	a5,22
}
4200dfb6:	40b2                	lw	ra,12(sp)
        badge_err_set(ec, ELOC_THREADS, ECAUSE_ILLEGAL);
4200dfb8:	c09c                	sw	a5,0(s1)
        leave_critical_section();
4200dfba:	4492                	lw	s1,4(sp)
}
4200dfbc:	0141                	add	sp,sp,16
        leave_critical_section();
4200dfbe:	e6dff06f          	j	4200de2a <leave_critical_section>
4200dfc2:	c422                	sw	s0,8(sp)
4200dfc4:	c04a                	sw	s2,0(sp)
        assert_dev_drop(dlist_contains(&thread_wait_queue, &thread->schedule_node));
4200dfc6:	57b1                	li	a5,-20
4200dfc8:	0af5f863          	bgeu	a1,a5,4200e078 <sched_resume_thread_inner+0x1a2>
4200dfcc:	40802937          	lui	s2,0x40802
4200dfd0:	01458413          	add	s0,a1,20
4200dfd4:	40c90913          	add	s2,s2,1036 # 4080240c <thread_wait_queue>
4200dfd8:	85a2                	mv	a1,s0
4200dfda:	854a                	mv	a0,s2
4200dfdc:	f57fe0ef          	jal	4200cf32 <dlist_contains>
4200dfe0:	c159                	beqz	a0,4200e066 <sched_resume_thread_inner+0x190>
        dlist_remove(&thread_wait_queue, &thread->schedule_node);
4200dfe2:	85a2                	mv	a1,s0
4200dfe4:	854a                	mv	a0,s2
4200dfe6:	920ff0ef          	jal	4200d106 <dlist_remove>
        dlist_prepend(&thread_wait_queue, &thread->schedule_node);
4200dfea:	85a2                	mv	a1,s0
4200dfec:	854a                	mv	a0,s2
4200dfee:	854ff0ef          	jal	4200d042 <dlist_prepend>
        badge_err_set_ok(ec);
4200dff2:	ccb1                	beqz	s1,4200e04e <sched_resume_thread_inner+0x178>
4200dff4:	0034f793          	and	a5,s1,3
4200dff8:	e3c1                	bnez	a5,4200e078 <sched_resume_thread_inner+0x1a2>
4200dffa:	57f1                	li	a5,-4
4200dffc:	06f4fe63          	bgeu	s1,a5,4200e078 <sched_resume_thread_inner+0x1a2>
4200e000:	4422                	lw	s0,8(sp)
4200e002:	4902                	lw	s2,0(sp)
4200e004:	0004a223          	sw	zero,4(s1)
4200e008:	0004a023          	sw	zero,0(s1)
4200e00c:	bf25                	j	4200df44 <sched_resume_thread_inner+0x6e>
            dlist_prepend(&thread_wait_queue, &thread->schedule_node);
4200e00e:	06f5f363          	bgeu	a1,a5,4200e074 <sched_resume_thread_inner+0x19e>
4200e012:	40802537          	lui	a0,0x40802
4200e016:	05d1                	add	a1,a1,20
4200e018:	40c50513          	add	a0,a0,1036 # 4080240c <thread_wait_queue>
4200e01c:	826ff0ef          	jal	4200d042 <dlist_prepend>
4200e020:	b715                	j	4200df44 <sched_resume_thread_inner+0x6e>
    assert_dev_drop(thread != NULL);
4200e022:	4201a5b7          	lui	a1,0x4201a
4200e026:	50458593          	add	a1,a1,1284 # 4201a504 <hextab+0x3838>
4200e02a:	4501                	li	a0,0
4200e02c:	c422                	sw	s0,8(sp)
4200e02e:	c226                	sw	s1,4(sp)
4200e030:	c04a                	sw	s2,0(sp)
4200e032:	a22f50ef          	jal	42003254 <logk>
4200e036:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200e038:	4201a5b7          	lui	a1,0x4201a
4200e03c:	57858593          	add	a1,a1,1400 # 4201a578 <hextab+0x38ac>
4200e040:	4501                	li	a0,0
4200e042:	c422                	sw	s0,8(sp)
4200e044:	c226                	sw	s1,4(sp)
4200e046:	c04a                	sw	s2,0(sp)
4200e048:	a0cf50ef          	jal	42003254 <logk>
4200e04c:	9002                	ebreak
4200e04e:	4422                	lw	s0,8(sp)
4200e050:	4902                	lw	s2,0(sp)
4200e052:	bdcd                	j	4200df44 <sched_resume_thread_inner+0x6e>
        assert_dev_drop(dlist_contains(&thread_wait_queue, &thread->schedule_node));
4200e054:	4201a5b7          	lui	a1,0x4201a
4200e058:	68858593          	add	a1,a1,1672 # 4201a688 <hextab+0x39bc>
4200e05c:	c422                	sw	s0,8(sp)
4200e05e:	c04a                	sw	s2,0(sp)
4200e060:	9f4f50ef          	jal	42003254 <logk>
4200e064:	9002                	ebreak
        assert_dev_drop(dlist_contains(&thread_wait_queue, &thread->schedule_node));
4200e066:	4201a5b7          	lui	a1,0x4201a
4200e06a:	5f058593          	add	a1,a1,1520 # 4201a5f0 <hextab+0x3924>
4200e06e:	9e6f50ef          	jal	42003254 <logk>
4200e072:	9002                	ebreak
4200e074:	c422                	sw	s0,8(sp)
4200e076:	c04a                	sw	s2,0(sp)
        badge_err_set_ok(ec);
4200e078:	9002                	ebreak
4200e07a:	c422                	sw	s0,8(sp)
4200e07c:	c226                	sw	s1,4(sp)
4200e07e:	c04a                	sw	s2,0(sp)
    assert_dev_drop(!critical_section_active);
4200e080:	9002                	ebreak

4200e082 <sched_get_current_thread_unsafe>:
    if (!scheduler_enabled) {
4200e082:	4080a7b7          	lui	a5,0x4080a
4200e086:	e737c783          	lbu	a5,-397(a5) # 40809e73 <scheduler_enabled>
4200e08a:	4705                	li	a4,1
4200e08c:	02f76363          	bltu	a4,a5,4200e0b2 <sched_get_current_thread_unsafe+0x30>
4200e090:	8b85                	and	a5,a5,1
4200e092:	cf91                	beqz	a5,4200e0ae <sched_get_current_thread_unsafe+0x2c>
};

// Get the current kernel context.
static inline isr_ctx_t *isr_ctx_get() {
    isr_ctx_t *kctx;
    asm("csrr %0, mscratch" : "=r"(kctx));
4200e094:	340027f3          	csrr	a5,mscratch
    return isr_ctx_get()->thread;
4200e098:	cf89                	beqz	a5,4200e0b2 <sched_get_current_thread_unsafe+0x30>
4200e09a:	0037f713          	and	a4,a5,3
4200e09e:	eb11                	bnez	a4,4200e0b2 <sched_get_current_thread_unsafe+0x30>
4200e0a0:	f5c00713          	li	a4,-164
4200e0a4:	00e7f763          	bgeu	a5,a4,4200e0b2 <sched_get_current_thread_unsafe+0x30>
4200e0a8:	0a47a503          	lw	a0,164(a5)
4200e0ac:	8082                	ret
        return NULL;
4200e0ae:	4501                	li	a0,0
}
4200e0b0:	8082                	ret
    return isr_ctx_get()->thread;
4200e0b2:	9002                	ebreak

4200e0b4 <sched_get_current_thread>:
    assert_dev_drop(!critical_section_active);
4200e0b4:	4080a637          	lui	a2,0x4080a
4200e0b8:	e7164783          	lbu	a5,-399(a2) # 40809e71 <critical_section_active>
4200e0bc:	4685                	li	a3,1
4200e0be:	06f6ef63          	bltu	a3,a5,4200e13c <sched_get_current_thread+0x88>
sched_thread_t *sched_get_current_thread(void) {
4200e0c2:	1141                	add	sp,sp,-16
4200e0c4:	c606                	sw	ra,12(sp)
4200e0c6:	c422                	sw	s0,8(sp)
    assert_dev_drop(!critical_section_active);
4200e0c8:	efb9                	bnez	a5,4200e126 <sched_get_current_thread+0x72>
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200e0ca:	47a1                	li	a5,8
4200e0cc:	3007b7f3          	csrrc	a5,mstatus,a5
    if (!scheduler_enabled) {
4200e0d0:	4080a737          	lui	a4,0x4080a
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
4200e0d4:	838d                	srl	a5,a5,0x3
4200e0d6:	e7374703          	lbu	a4,-397(a4) # 40809e73 <scheduler_enabled>
4200e0da:	8b85                	and	a5,a5,1
    critical_section_had_interrupts = isr_global_disable();
4200e0dc:	4080a5b7          	lui	a1,0x4080a
4200e0e0:	e6f58823          	sb	a5,-400(a1) # 40809e70 <critical_section_had_interrupts>
    critical_section_active         = true;
4200e0e4:	e6d608a3          	sb	a3,-399(a2)
    if (!scheduler_enabled) {
4200e0e8:	04e6e963          	bltu	a3,a4,4200e13a <sched_get_current_thread+0x86>
4200e0ec:	8b05                	and	a4,a4,1
4200e0ee:	c705                	beqz	a4,4200e116 <sched_get_current_thread+0x62>
4200e0f0:	340027f3          	csrr	a5,mscratch
    return isr_ctx_get()->thread;
4200e0f4:	c3b1                	beqz	a5,4200e138 <sched_get_current_thread+0x84>
4200e0f6:	0037f713          	and	a4,a5,3
4200e0fa:	ef1d                	bnez	a4,4200e138 <sched_get_current_thread+0x84>
4200e0fc:	f5c00713          	li	a4,-164
4200e100:	02e7fb63          	bgeu	a5,a4,4200e136 <sched_get_current_thread+0x82>
4200e104:	0a47a403          	lw	s0,164(a5)
    leave_critical_section();
4200e108:	d23ff0ef          	jal	4200de2a <leave_critical_section>
}
4200e10c:	40b2                	lw	ra,12(sp)
4200e10e:	8522                	mv	a0,s0
4200e110:	4422                	lw	s0,8(sp)
4200e112:	0141                	add	sp,sp,16
4200e114:	8082                	ret
    leave_critical_section();
4200e116:	d15ff0ef          	jal	4200de2a <leave_critical_section>
        return NULL;
4200e11a:	4401                	li	s0,0
}
4200e11c:	40b2                	lw	ra,12(sp)
4200e11e:	8522                	mv	a0,s0
4200e120:	4422                	lw	s0,8(sp)
4200e122:	0141                	add	sp,sp,16
4200e124:	8082                	ret
    assert_dev_drop(!critical_section_active);
4200e126:	4201a5b7          	lui	a1,0x4201a
4200e12a:	57858593          	add	a1,a1,1400 # 4201a578 <hextab+0x38ac>
4200e12e:	4501                	li	a0,0
4200e130:	924f50ef          	jal	42003254 <logk>
4200e134:	9002                	ebreak
    return isr_ctx_get()->thread;
4200e136:	9002                	ebreak
4200e138:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200e13a:	9002                	ebreak
4200e13c:	9002                	ebreak

4200e13e <sched_init>:
void sched_init() {
4200e13e:	7179                	add	sp,sp,-48
    sched_prepare_kernel_entry(&idle_thread, idle_thread_function, NULL);
4200e140:	4200e5b7          	lui	a1,0x4200e
void sched_init() {
4200e144:	d226                	sw	s1,36(sp)
4200e146:	ce4e                	sw	s3,28(sp)
4200e148:	c85a                	sw	s6,16(sp)
4200e14a:	c65e                	sw	s7,12(sp)
    sched_prepare_kernel_entry(&idle_thread, idle_thread_function, NULL);
4200e14c:	4601                	li	a2,0
4200e14e:	e2858593          	add	a1,a1,-472 # 4200de28 <idle_thread_function>
4200e152:	10818513          	add	a0,gp,264 # 40800108 <idle_thread>
        thread_alloc_pool_storage[i] = (sched_thread_t){
4200e156:	6b09                	lui	s6,0x2
4200e158:	0badcbb7          	lui	s7,0xbadc
4200e15c:	408029b7          	lui	s3,0x40802
4200e160:	408024b7          	lui	s1,0x40802
void sched_init() {
4200e164:	d422                	sw	s0,40(sp)
4200e166:	d04a                	sw	s2,32(sp)
4200e168:	cc52                	sw	s4,24(sp)
4200e16a:	c462                	sw	s8,8(sp)
4200e16c:	c266                	sw	s9,4(sp)
4200e16e:	d606                	sw	ra,44(sp)
4200e170:	ca56                	sw	s5,20(sp)
4200e172:	42898993          	add	s3,s3,1064 # 40802428 <thread_alloc_pool_storage+0x10>
    sched_prepare_kernel_entry(&idle_thread, idle_thread_function, NULL);
4200e176:	552010ef          	jal	4200f6c8 <sched_prepare_kernel_entry>
4200e17a:	4401                	li	s0,0
    for (size_t i = 0; i < SCHEDULER_MAX_THREADS; i++) {
4200e17c:	4901                	li	s2,0
        thread_alloc_pool_storage[i] = (sched_thread_t){
4200e17e:	4a41                	li	s4,16
4200e180:	980b0b13          	add	s6,s6,-1664 # 1980 <isr_ctx_t_is_kernel_thread+0x18d8>
4200e184:	41848493          	add	s1,s1,1048 # 40802418 <thread_alloc_pool_storage>
4200e188:	19800c93          	li	s9,408
4200e18c:	0deb8b93          	add	s7,s7,222 # badc0de <__stack_size+0xbada0de>
        dlist_append(&thread_alloc_pool, &thread_alloc_pool_storage[i].schedule_node);
4200e190:	40802c37          	lui	s8,0x40802
        thread_alloc_pool_storage[i] = (sched_thread_t){
4200e194:	09497163          	bgeu	s2,s4,4200e216 <sched_init+0xd8>
4200e198:	19840a93          	add	s5,s0,408
4200e19c:	ff098793          	add	a5,s3,-16
4200e1a0:	075b6763          	bltu	s6,s5,4200e20e <sched_init+0xd0>
4200e1a4:	008487b3          	add	a5,s1,s0
4200e1a8:	0697e763          	bltu	a5,s1,4200e216 <sched_init+0xd8>
4200e1ac:	03990533          	mul	a0,s2,s9
4200e1b0:	19800613          	li	a2,408
4200e1b4:	4581                	li	a1,0
4200e1b6:	9526                	add	a0,a0,s1
4200e1b8:	f5ef40ef          	jal	42002916 <memset>
4200e1bc:	01440793          	add	a5,s0,20
4200e1c0:	0441                	add	s0,s0,16
4200e1c2:	04fb6b63          	bltu	s6,a5,4200e218 <sched_init+0xda>
4200e1c6:	9426                	add	s0,s0,s1
4200e1c8:	04946763          	bltu	s0,s1,4200e216 <sched_init+0xd8>
4200e1cc:	0179a023          	sw	s7,0(s3)
        dlist_append(&thread_alloc_pool, &thread_alloc_pool_storage[i].schedule_node);
4200e1d0:	05497363          	bgeu	s2,s4,4200e216 <sched_init+0xd8>
4200e1d4:	97a6                	add	a5,a5,s1
4200e1d6:	0497e063          	bltu	a5,s1,4200e216 <sched_init+0xd8>
4200e1da:	00498593          	add	a1,s3,4
4200e1de:	400c0513          	add	a0,s8,1024 # 40802400 <thread_alloc_pool>
    for (size_t i = 0; i < SCHEDULER_MAX_THREADS; i++) {
4200e1e2:	0905                	add	s2,s2,1
        dlist_append(&thread_alloc_pool, &thread_alloc_pool_storage[i].schedule_node);
4200e1e4:	da7fe0ef          	jal	4200cf8a <dlist_append>
    for (size_t i = 0; i < SCHEDULER_MAX_THREADS; i++) {
4200e1e8:	19898993          	add	s3,s3,408
4200e1ec:	01490463          	beq	s2,s4,4200e1f4 <sched_init+0xb6>
4200e1f0:	8456                	mv	s0,s5
4200e1f2:	b74d                	j	4200e194 <sched_init+0x56>
}
4200e1f4:	50b2                	lw	ra,44(sp)
4200e1f6:	5422                	lw	s0,40(sp)
4200e1f8:	5492                	lw	s1,36(sp)
4200e1fa:	5902                	lw	s2,32(sp)
4200e1fc:	49f2                	lw	s3,28(sp)
4200e1fe:	4a62                	lw	s4,24(sp)
4200e200:	4ad2                	lw	s5,20(sp)
4200e202:	4b42                	lw	s6,16(sp)
4200e204:	4bb2                	lw	s7,12(sp)
4200e206:	4c22                	lw	s8,8(sp)
4200e208:	4c92                	lw	s9,4(sp)
4200e20a:	6145                	add	sp,sp,48
4200e20c:	8082                	ret
        thread_alloc_pool_storage[i] = (sched_thread_t){
4200e20e:	01578733          	add	a4,a5,s5
4200e212:	f8f769e3          	bltu	a4,a5,4200e1a4 <sched_init+0x66>
        dlist_append(&thread_alloc_pool, &thread_alloc_pool_storage[i].schedule_node);
4200e216:	9002                	ebreak
        thread_alloc_pool_storage[i] = (sched_thread_t){
4200e218:	00f98733          	add	a4,s3,a5
4200e21c:	fb3765e3          	bltu	a4,s3,4200e1c6 <sched_init+0x88>
        dlist_append(&thread_alloc_pool, &thread_alloc_pool_storage[i].schedule_node);
4200e220:	9002                	ebreak

4200e222 <sched_create_userland_thread>:
) {
4200e222:	7179                	add	sp,sp,-48
4200e224:	d606                	sw	ra,44(sp)
4200e226:	d422                	sw	s0,40(sp)
4200e228:	d226                	sw	s1,36(sp)
4200e22a:	d04a                	sw	s2,32(sp)
4200e22c:	ce4e                	sw	s3,28(sp)
4200e22e:	cc52                	sw	s4,24(sp)
4200e230:	ca56                	sw	s5,20(sp)
4200e232:	c85a                	sw	s6,16(sp)
4200e234:	c65e                	sw	s7,12(sp)
    assert_dev_drop(entry_point != NULL);
4200e236:	c66d                	beqz	a2,4200e320 <sched_create_userland_thread+0xfe>
4200e238:	893e                	mv	s2,a5
    assert_dev_drop(is_aligned(kernel_stack_bottom_addr, STACK_ALIGNMENT));
4200e23a:	00f77793          	and	a5,a4,15
4200e23e:	89ba                	mv	s3,a4
4200e240:	0e079863          	bnez	a5,4200e330 <sched_create_userland_thread+0x10e>
    assert_dev_drop(is_aligned(stack_size, STACK_ALIGNMENT));
4200e244:	00f97793          	and	a5,s2,15
4200e248:	0e079c63          	bnez	a5,4200e340 <sched_create_userland_thread+0x11e>
4200e24c:	8a32                	mv	s4,a2
4200e24e:	84aa                	mv	s1,a0
4200e250:	8b2e                	mv	s6,a1
4200e252:	8ab6                	mv	s5,a3
4200e254:	8bc2                	mv	s7,a6
    sched_thread_t *const thread = thread_alloc();
4200e256:	c19ff0ef          	jal	4200de6e <thread_alloc>
4200e25a:	842a                	mv	s0,a0
    if (thread == NULL) {
4200e25c:	c959                	beqz	a0,4200e2f2 <sched_create_userland_thread+0xd0>
    *thread = (sched_thread_t){
4200e25e:	00357793          	and	a5,a0,3
        .kernel_stack_top    = kernel_stack_bottom_addr + stack_size,
4200e262:	994e                	add	s2,s2,s3
    *thread = (sched_thread_t){
4200e264:	0e079663          	bnez	a5,4200e350 <sched_create_userland_thread+0x12e>
4200e268:	19800613          	li	a2,408
4200e26c:	4581                	li	a1,0
4200e26e:	ea8f40ef          	jal	42002916 <memset>
4200e272:	57f1                	li	a5,-4
4200e274:	01642023          	sw	s6,0(s0)
4200e278:	0cf47c63          	bgeu	s0,a5,4200e350 <sched_create_userland_thread+0x12e>
4200e27c:	01342223          	sw	s3,4(s0)
4200e280:	57e1                	li	a5,-8
4200e282:	0cf47763          	bgeu	s0,a5,4200e350 <sched_create_userland_thread+0x12e>
4200e286:	01242423          	sw	s2,8(s0)
4200e28a:	57d1                	li	a5,-12
4200e28c:	0cf47263          	bgeu	s0,a5,4200e350 <sched_create_userland_thread+0x12e>
4200e290:	01742623          	sw	s7,12(s0)
4200e294:	f3c00793          	li	a5,-196
4200e298:	0af47c63          	bgeu	s0,a5,4200e350 <sched_create_userland_thread+0x12e>
4200e29c:	0c842223          	sw	s0,196(s0)
4200e2a0:	f3800793          	li	a5,-200
4200e2a4:	0af47663          	bgeu	s0,a5,4200e350 <sched_create_userland_thread+0x12e>
4200e2a8:	4785                	li	a5,1
4200e2aa:	0cf42423          	sw	a5,200(s0)
4200e2ae:	e9000793          	li	a5,-368
4200e2b2:	08f47f63          	bgeu	s0,a5,4200e350 <sched_create_userland_thread+0x12e>
4200e2b6:	16842823          	sw	s0,368(s0)
    sched_prepare_user_entry(thread, entry_point, arg);
4200e2ba:	8656                	mv	a2,s5
4200e2bc:	85d2                	mv	a1,s4
4200e2be:	8522                	mv	a0,s0
4200e2c0:	474010ef          	jal	4200f734 <sched_prepare_user_entry>
    badge_err_set_ok(ec);
4200e2c4:	c899                	beqz	s1,4200e2da <sched_create_userland_thread+0xb8>
4200e2c6:	0034f793          	and	a5,s1,3
4200e2ca:	e3d9                	bnez	a5,4200e350 <sched_create_userland_thread+0x12e>
4200e2cc:	57f1                	li	a5,-4
4200e2ce:	08f4f163          	bgeu	s1,a5,4200e350 <sched_create_userland_thread+0x12e>
4200e2d2:	0004a223          	sw	zero,4(s1)
4200e2d6:	0004a023          	sw	zero,0(s1)
}
4200e2da:	50b2                	lw	ra,44(sp)
4200e2dc:	8522                	mv	a0,s0
4200e2de:	5422                	lw	s0,40(sp)
4200e2e0:	5492                	lw	s1,36(sp)
4200e2e2:	5902                	lw	s2,32(sp)
4200e2e4:	49f2                	lw	s3,28(sp)
4200e2e6:	4a62                	lw	s4,24(sp)
4200e2e8:	4ad2                	lw	s5,20(sp)
4200e2ea:	4b42                	lw	s6,16(sp)
4200e2ec:	4bb2                	lw	s7,12(sp)
4200e2ee:	6145                	add	sp,sp,48
4200e2f0:	8082                	ret
        badge_err_set(ec, ELOC_THREADS, ECAUSE_NOMEM);
4200e2f2:	d4e5                	beqz	s1,4200e2da <sched_create_userland_thread+0xb8>
4200e2f4:	420175b7          	lui	a1,0x42017
4200e2f8:	4699                	li	a3,6
4200e2fa:	4631                	li	a2,12
4200e2fc:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200e300:	4511                	li	a0,4
4200e302:	00000717          	auipc	a4,0x0
4200e306:	f95f40ef          	jal	4200329a <logkf>
4200e30a:	0034f793          	and	a5,s1,3
4200e30e:	e3a9                	bnez	a5,4200e350 <sched_create_userland_thread+0x12e>
4200e310:	57f1                	li	a5,-4
4200e312:	02f4ff63          	bgeu	s1,a5,4200e350 <sched_create_userland_thread+0x12e>
4200e316:	47b1                	li	a5,12
4200e318:	c0dc                	sw	a5,4(s1)
4200e31a:	4799                	li	a5,6
4200e31c:	c09c                	sw	a5,0(s1)
4200e31e:	bf75                	j	4200e2da <sched_create_userland_thread+0xb8>
    assert_dev_drop(entry_point != NULL);
4200e320:	4201a5b7          	lui	a1,0x4201a
4200e324:	72058593          	add	a1,a1,1824 # 4201a720 <hextab+0x3a54>
4200e328:	4501                	li	a0,0
4200e32a:	f2bf40ef          	jal	42003254 <logk>
4200e32e:	9002                	ebreak
    assert_dev_drop(is_aligned(kernel_stack_bottom_addr, STACK_ALIGNMENT));
4200e330:	4201a5b7          	lui	a1,0x4201a
4200e334:	79858593          	add	a1,a1,1944 # 4201a798 <hextab+0x3acc>
4200e338:	4501                	li	a0,0
4200e33a:	f1bf40ef          	jal	42003254 <logk>
4200e33e:	9002                	ebreak
    assert_dev_drop(is_aligned(stack_size, STACK_ALIGNMENT));
4200e340:	4201b5b7          	lui	a1,0x4201b
4200e344:	83458593          	add	a1,a1,-1996 # 4201a834 <hextab+0x3b68>
4200e348:	4501                	li	a0,0
4200e34a:	f0bf40ef          	jal	42003254 <logk>
4200e34e:	9002                	ebreak
    badge_err_set_ok(ec);
4200e350:	9002                	ebreak

4200e352 <sched_create_kernel_thread>:
) {
4200e352:	1101                	add	sp,sp,-32
4200e354:	ce06                	sw	ra,28(sp)
4200e356:	cc22                	sw	s0,24(sp)
4200e358:	ca26                	sw	s1,20(sp)
4200e35a:	c84a                	sw	s2,16(sp)
4200e35c:	c64e                	sw	s3,12(sp)
4200e35e:	c452                	sw	s4,8(sp)
4200e360:	c256                	sw	s5,4(sp)
4200e362:	c05a                	sw	s6,0(sp)
    assert_dev_drop(entry_point != NULL);
4200e364:	cdf1                	beqz	a1,4200e440 <sched_create_kernel_thread+0xee>
4200e366:	8b3e                	mv	s6,a5
    assert_dev_drop(is_aligned(kernel_stack_bottom_addr, STACK_ALIGNMENT));
4200e368:	00f6f793          	and	a5,a3,15
4200e36c:	89b6                	mv	s3,a3
4200e36e:	e3ed                	bnez	a5,4200e450 <sched_create_kernel_thread+0xfe>
    assert_dev_drop(is_aligned(stack_size, STACK_ALIGNMENT));
4200e370:	00f77793          	and	a5,a4,15
4200e374:	893a                	mv	s2,a4
4200e376:	0e079563          	bnez	a5,4200e460 <sched_create_kernel_thread+0x10e>
4200e37a:	8a2e                	mv	s4,a1
4200e37c:	84aa                	mv	s1,a0
4200e37e:	8ab2                	mv	s5,a2
    sched_thread_t *const thread = thread_alloc();
4200e380:	aefff0ef          	jal	4200de6e <thread_alloc>
4200e384:	842a                	mv	s0,a0
    if (thread == NULL) {
4200e386:	c551                	beqz	a0,4200e412 <sched_create_kernel_thread+0xc0>
    *thread = (sched_thread_t){
4200e388:	00357713          	and	a4,a0,3
        .kernel_stack_top    = kernel_stack_bottom_addr + stack_size,
4200e38c:	994e                	add	s2,s2,s3
    *thread = (sched_thread_t){
4200e38e:	e36d                	bnez	a4,4200e470 <sched_create_kernel_thread+0x11e>
4200e390:	19800613          	li	a2,408
4200e394:	4581                	li	a1,0
4200e396:	d80f40ef          	jal	42002916 <memset>
4200e39a:	57f1                	li	a5,-4
4200e39c:	0cf47a63          	bgeu	s0,a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e3a0:	01342223          	sw	s3,4(s0)
4200e3a4:	57e1                	li	a5,-8
4200e3a6:	0cf47563          	bgeu	s0,a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e3aa:	01242423          	sw	s2,8(s0)
4200e3ae:	57d1                	li	a5,-12
4200e3b0:	0cf47063          	bgeu	s0,a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e3b4:	01642623          	sw	s6,12(s0)
4200e3b8:	57c1                	li	a5,-16
4200e3ba:	0af47b63          	bgeu	s0,a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e3be:	47e1                	li	a5,24
4200e3c0:	c81c                	sw	a5,16(s0)
4200e3c2:	f3c00793          	li	a5,-196
4200e3c6:	0af47563          	bgeu	s0,a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e3ca:	0c842223          	sw	s0,196(s0)
4200e3ce:	f3800793          	li	a5,-200
4200e3d2:	08f47f63          	bgeu	s0,a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e3d6:	4785                	li	a5,1
4200e3d8:	0cf42423          	sw	a5,200(s0)
    sched_prepare_kernel_entry(thread, entry_point, arg);
4200e3dc:	8656                	mv	a2,s5
4200e3de:	85d2                	mv	a1,s4
4200e3e0:	8522                	mv	a0,s0
4200e3e2:	2e6010ef          	jal	4200f6c8 <sched_prepare_kernel_entry>
    badge_err_set_ok(ec);
4200e3e6:	c899                	beqz	s1,4200e3fc <sched_create_kernel_thread+0xaa>
4200e3e8:	0034f793          	and	a5,s1,3
4200e3ec:	e3d1                	bnez	a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e3ee:	57f1                	li	a5,-4
4200e3f0:	08f4f063          	bgeu	s1,a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e3f4:	0004a223          	sw	zero,4(s1)
4200e3f8:	0004a023          	sw	zero,0(s1)
}
4200e3fc:	40f2                	lw	ra,28(sp)
4200e3fe:	8522                	mv	a0,s0
4200e400:	4462                	lw	s0,24(sp)
4200e402:	44d2                	lw	s1,20(sp)
4200e404:	4942                	lw	s2,16(sp)
4200e406:	49b2                	lw	s3,12(sp)
4200e408:	4a22                	lw	s4,8(sp)
4200e40a:	4a92                	lw	s5,4(sp)
4200e40c:	4b02                	lw	s6,0(sp)
4200e40e:	6105                	add	sp,sp,32
4200e410:	8082                	ret
        badge_err_set(ec, ELOC_THREADS, ECAUSE_NOMEM);
4200e412:	d4ed                	beqz	s1,4200e3fc <sched_create_kernel_thread+0xaa>
4200e414:	420175b7          	lui	a1,0x42017
4200e418:	4699                	li	a3,6
4200e41a:	4631                	li	a2,12
4200e41c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200e420:	4511                	li	a0,4
4200e422:	00000717          	auipc	a4,0x0
4200e426:	e75f40ef          	jal	4200329a <logkf>
4200e42a:	0034f793          	and	a5,s1,3
4200e42e:	e3a9                	bnez	a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e430:	57f1                	li	a5,-4
4200e432:	02f4ff63          	bgeu	s1,a5,4200e470 <sched_create_kernel_thread+0x11e>
4200e436:	47b1                	li	a5,12
4200e438:	c0dc                	sw	a5,4(s1)
4200e43a:	4799                	li	a5,6
4200e43c:	c09c                	sw	a5,0(s1)
4200e43e:	bf7d                	j	4200e3fc <sched_create_kernel_thread+0xaa>
    assert_dev_drop(entry_point != NULL);
4200e440:	4201b5b7          	lui	a1,0x4201b
4200e444:	8c058593          	add	a1,a1,-1856 # 4201a8c0 <hextab+0x3bf4>
4200e448:	4501                	li	a0,0
4200e44a:	e0bf40ef          	jal	42003254 <logk>
4200e44e:	9002                	ebreak
    assert_dev_drop(is_aligned(kernel_stack_bottom_addr, STACK_ALIGNMENT));
4200e450:	4201b5b7          	lui	a1,0x4201b
4200e454:	93858593          	add	a1,a1,-1736 # 4201a938 <hextab+0x3c6c>
4200e458:	4501                	li	a0,0
4200e45a:	dfbf40ef          	jal	42003254 <logk>
4200e45e:	9002                	ebreak
    assert_dev_drop(is_aligned(stack_size, STACK_ALIGNMENT));
4200e460:	4201b5b7          	lui	a1,0x4201b
4200e464:	9d458593          	add	a1,a1,-1580 # 4201a9d4 <hextab+0x3d08>
4200e468:	4501                	li	a0,0
4200e46a:	debf40ef          	jal	42003254 <logk>
4200e46e:	9002                	ebreak
    badge_err_set_ok(ec);
4200e470:	9002                	ebreak

4200e472 <sched_detach_thread>:
void sched_detach_thread(badge_err_t *ec, sched_thread_t *thread) {
4200e472:	1141                	add	sp,sp,-16
4200e474:	c606                	sw	ra,12(sp)
4200e476:	c422                	sw	s0,8(sp)
    assert_dev_drop(thread != NULL);
4200e478:	c1a5                	beqz	a1,4200e4d8 <sched_detach_thread+0x66>
    assert_dev_drop(!critical_section_active);
4200e47a:	4080a737          	lui	a4,0x4080a
4200e47e:	e7174783          	lbu	a5,-399(a4) # 40809e71 <critical_section_active>
4200e482:	4685                	li	a3,1
4200e484:	06f6e963          	bltu	a3,a5,4200e4f6 <sched_detach_thread+0x84>
4200e488:	e3a5                	bnez	a5,4200e4e8 <sched_detach_thread+0x76>
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200e48a:	47a1                	li	a5,8
4200e48c:	3007b7f3          	csrrc	a5,mstatus,a5
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
4200e490:	838d                	srl	a5,a5,0x3
4200e492:	8b85                	and	a5,a5,1
    critical_section_had_interrupts = isr_global_disable();
4200e494:	4080a637          	lui	a2,0x4080a
4200e498:	e6f60823          	sb	a5,-400(a2) # 40809e70 <critical_section_had_interrupts>
    critical_section_active         = true;
4200e49c:	e6d708a3          	sb	a3,-399(a4)
    set_flag(thread->flags, THREAD_DETACHED);
4200e4a0:	0035f793          	and	a5,a1,3
4200e4a4:	eba9                	bnez	a5,4200e4f6 <sched_detach_thread+0x84>
4200e4a6:	57c1                	li	a5,-16
4200e4a8:	04f5f763          	bgeu	a1,a5,4200e4f6 <sched_detach_thread+0x84>
4200e4ac:	499c                	lw	a5,16(a1)
4200e4ae:	842a                	mv	s0,a0
4200e4b0:	0047e793          	or	a5,a5,4
4200e4b4:	c99c                	sw	a5,16(a1)
    leave_critical_section();
4200e4b6:	975ff0ef          	jal	4200de2a <leave_critical_section>
    badge_err_set_ok(ec);
4200e4ba:	c819                	beqz	s0,4200e4d0 <sched_detach_thread+0x5e>
4200e4bc:	00347793          	and	a5,s0,3
4200e4c0:	eb9d                	bnez	a5,4200e4f6 <sched_detach_thread+0x84>
4200e4c2:	57f1                	li	a5,-4
4200e4c4:	02f47963          	bgeu	s0,a5,4200e4f6 <sched_detach_thread+0x84>
4200e4c8:	00042223          	sw	zero,4(s0)
4200e4cc:	00042023          	sw	zero,0(s0)
}
4200e4d0:	40b2                	lw	ra,12(sp)
4200e4d2:	4422                	lw	s0,8(sp)
4200e4d4:	0141                	add	sp,sp,16
4200e4d6:	8082                	ret
    assert_dev_drop(thread != NULL);
4200e4d8:	4201b5b7          	lui	a1,0x4201b
4200e4dc:	a6058593          	add	a1,a1,-1440 # 4201aa60 <hextab+0x3d94>
4200e4e0:	4501                	li	a0,0
4200e4e2:	d73f40ef          	jal	42003254 <logk>
4200e4e6:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200e4e8:	4201a5b7          	lui	a1,0x4201a
4200e4ec:	57858593          	add	a1,a1,1400 # 4201a578 <hextab+0x38ac>
4200e4f0:	4501                	li	a0,0
4200e4f2:	d63f40ef          	jal	42003254 <logk>
4200e4f6:	9002                	ebreak

4200e4f8 <sched_resume_thread>:

void sched_resume_thread(badge_err_t *const ec, sched_thread_t *const thread) {
    sched_resume_thread_inner(ec, thread, INSERT_THREAD_BACK);
4200e4f8:	4601                	li	a2,0
4200e4fa:	9ddff06f          	j	4200ded6 <sched_resume_thread_inner>

4200e4fe <sched_resume_thread_next>:
}

void sched_resume_thread_next(badge_err_t *const ec, sched_thread_t *const thread) {
    sched_resume_thread_inner(ec, thread, INSERT_THREAD_FRONT);
4200e4fe:	4605                	li	a2,1
4200e500:	9d7ff06f          	j	4200ded6 <sched_resume_thread_inner>

4200e504 <sched_thread_is_running>:
}

bool sched_thread_is_running(badge_err_t *ec, sched_thread_t *thread) {
    assert_dev_drop(thread != NULL);
4200e504:	c595                	beqz	a1,4200e530 <sched_thread_is_running+0x2c>
    badge_err_set_ok(ec);
4200e506:	c919                	beqz	a0,4200e51c <sched_thread_is_running+0x18>
4200e508:	00357793          	and	a5,a0,3
4200e50c:	ef9d                	bnez	a5,4200e54a <sched_thread_is_running+0x46>
4200e50e:	57f1                	li	a5,-4
4200e510:	02f57c63          	bgeu	a0,a5,4200e548 <sched_thread_is_running+0x44>
4200e514:	00052223          	sw	zero,4(a0)
4200e518:	00052023          	sw	zero,0(a0)
    return is_flag_set(thread->flags, THREAD_RUNNING);
4200e51c:	c585                	beqz	a1,4200e544 <sched_thread_is_running+0x40>
4200e51e:	0035f793          	and	a5,a1,3
4200e522:	e38d                	bnez	a5,4200e544 <sched_thread_is_running+0x40>
4200e524:	57c1                	li	a5,-16
4200e526:	02f5f063          	bgeu	a1,a5,4200e546 <sched_thread_is_running+0x42>
4200e52a:	4988                	lw	a0,16(a1)
}
4200e52c:	8905                	and	a0,a0,1
4200e52e:	8082                	ret
    assert_dev_drop(thread != NULL);
4200e530:	4201b5b7          	lui	a1,0x4201b
bool sched_thread_is_running(badge_err_t *ec, sched_thread_t *thread) {
4200e534:	1141                	add	sp,sp,-16
    assert_dev_drop(thread != NULL);
4200e536:	ad458593          	add	a1,a1,-1324 # 4201aad4 <hextab+0x3e08>
4200e53a:	4501                	li	a0,0
bool sched_thread_is_running(badge_err_t *ec, sched_thread_t *thread) {
4200e53c:	c606                	sw	ra,12(sp)
    assert_dev_drop(thread != NULL);
4200e53e:	d17f40ef          	jal	42003254 <logk>
4200e542:	9002                	ebreak
    return is_flag_set(thread->flags, THREAD_RUNNING);
4200e544:	9002                	ebreak
4200e546:	9002                	ebreak
    badge_err_set_ok(ec);
4200e548:	9002                	ebreak
4200e54a:	9002                	ebreak

4200e54c <sched_get_associated_process>:
    assert_dev_drop(!critical_section_active);
4200e54c:	4080a737          	lui	a4,0x4080a
4200e550:	e7174783          	lbu	a5,-399(a4) # 40809e71 <critical_section_active>
4200e554:	4685                	li	a3,1
4200e556:	04f6ee63          	bltu	a3,a5,4200e5b2 <sched_get_associated_process+0x66>

process_t *sched_get_associated_process(sched_thread_t const *const thread) {
4200e55a:	1141                	add	sp,sp,-16
4200e55c:	c606                	sw	ra,12(sp)
4200e55e:	c422                	sw	s0,8(sp)
    assert_dev_drop(!critical_section_active);
4200e560:	e3a1                	bnez	a5,4200e5a0 <sched_get_associated_process+0x54>
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200e562:	47a1                	li	a5,8
4200e564:	3007b7f3          	csrrc	a5,mstatus,a5
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
4200e568:	838d                	srl	a5,a5,0x3
4200e56a:	8b85                	and	a5,a5,1
    critical_section_had_interrupts = isr_global_disable();
4200e56c:	4080a637          	lui	a2,0x4080a
4200e570:	e6f60823          	sb	a5,-400(a2) # 40809e70 <critical_section_had_interrupts>
    critical_section_active         = true;
4200e574:	e6d708a3          	sb	a3,-399(a4)
    enter_critical_section();
    process_t *process = NULL;
    if (thread != NULL) {
4200e578:	cd01                	beqz	a0,4200e590 <sched_get_associated_process+0x44>
        process = thread->process;
4200e57a:	00357793          	and	a5,a0,3
4200e57e:	eb8d                	bnez	a5,4200e5b0 <sched_get_associated_process+0x64>
4200e580:	4100                	lw	s0,0(a0)
    }
    leave_critical_section();
4200e582:	8a9ff0ef          	jal	4200de2a <leave_critical_section>
    return process;
}
4200e586:	40b2                	lw	ra,12(sp)
4200e588:	8522                	mv	a0,s0
4200e58a:	4422                	lw	s0,8(sp)
4200e58c:	0141                	add	sp,sp,16
4200e58e:	8082                	ret
    leave_critical_section();
4200e590:	89bff0ef          	jal	4200de2a <leave_critical_section>
    process_t *process = NULL;
4200e594:	4401                	li	s0,0
}
4200e596:	40b2                	lw	ra,12(sp)
4200e598:	8522                	mv	a0,s0
4200e59a:	4422                	lw	s0,8(sp)
4200e59c:	0141                	add	sp,sp,16
4200e59e:	8082                	ret
    assert_dev_drop(!critical_section_active);
4200e5a0:	4201a5b7          	lui	a1,0x4201a
4200e5a4:	57858593          	add	a1,a1,1400 # 4201a578 <hextab+0x38ac>
4200e5a8:	4501                	li	a0,0
4200e5aa:	cabf40ef          	jal	42003254 <logk>
4200e5ae:	9002                	ebreak
        process = thread->process;
4200e5b0:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200e5b2:	9002                	ebreak

4200e5b4 <sched_yield>:
4200e5b4:	4080a637          	lui	a2,0x4080a
4200e5b8:	e7164783          	lbu	a5,-399(a2) # 40809e71 <critical_section_active>
4200e5bc:	4685                	li	a3,1
4200e5be:	08f6e763          	bltu	a3,a5,4200e64c <sched_yield+0x98>

void sched_yield(void) {
4200e5c2:	1141                	add	sp,sp,-16
4200e5c4:	c606                	sw	ra,12(sp)
4200e5c6:	c422                	sw	s0,8(sp)
4200e5c8:	c226                	sw	s1,4(sp)
    assert_dev_drop(!critical_section_active);
4200e5ca:	e7b5                	bnez	a5,4200e636 <sched_yield+0x82>
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200e5cc:	4421                	li	s0,8
4200e5ce:	300437f3          	csrrc	a5,mstatus,s0
    if (!scheduler_enabled) {
4200e5d2:	4080a737          	lui	a4,0x4080a
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
4200e5d6:	838d                	srl	a5,a5,0x3
4200e5d8:	e7374703          	lbu	a4,-397(a4) # 40809e73 <scheduler_enabled>
4200e5dc:	8b85                	and	a5,a5,1
    critical_section_had_interrupts = isr_global_disable();
4200e5de:	4080a5b7          	lui	a1,0x4080a
4200e5e2:	e6f58823          	sb	a5,-400(a1) # 40809e70 <critical_section_had_interrupts>
    critical_section_active         = true;
4200e5e6:	e6d608a3          	sb	a3,-399(a2)
    if (!scheduler_enabled) {
4200e5ea:	06e6e063          	bltu	a3,a4,4200e64a <sched_yield+0x96>
4200e5ee:	8b05                	and	a4,a4,1
4200e5f0:	cb0d                	beqz	a4,4200e622 <sched_yield+0x6e>
4200e5f2:	340027f3          	csrr	a5,mscratch
    return isr_ctx_get()->thread;
4200e5f6:	cba1                	beqz	a5,4200e646 <sched_yield+0x92>
4200e5f8:	0037f713          	and	a4,a5,3
4200e5fc:	e729                	bnez	a4,4200e646 <sched_yield+0x92>
4200e5fe:	f5c00713          	li	a4,-164
4200e602:	04e7f363          	bgeu	a5,a4,4200e648 <sched_yield+0x94>
4200e606:	0a47a483          	lw	s1,164(a5)
    leave_critical_section();
4200e60a:	821ff0ef          	jal	4200de2a <leave_critical_section>
    sched_thread_t *const current_thread = sched_get_current_thread();
    assert_always(current_thread != NULL);
4200e60e:	cc81                	beqz	s1,4200e626 <sched_yield+0x72>
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200e610:	30043473          	csrrc	s0,mstatus,s0
    if (!scheduler_enabled) {
4200e614:	22cd                	jal	4200e7f6 <sched_request_switch_from_isr.part.0>

    isr_global_disable();
    sched_request_switch_from_isr();
    isr_context_switch();
}
4200e616:	4422                	lw	s0,8(sp)
4200e618:	40b2                	lw	ra,12(sp)
4200e61a:	4492                	lw	s1,4(sp)
4200e61c:	0141                	add	sp,sp,16
    isr_context_switch();
4200e61e:	e63f106f          	j	42000480 <isr_context_switch>
    leave_critical_section();
4200e622:	809ff0ef          	jal	4200de2a <leave_critical_section>
    assert_always(current_thread != NULL);
4200e626:	4201b5b7          	lui	a1,0x4201b
4200e62a:	b4858593          	add	a1,a1,-1208 # 4201ab48 <hextab+0x3e7c>
4200e62e:	4501                	li	a0,0
4200e630:	c25f40ef          	jal	42003254 <logk>
4200e634:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200e636:	4201a5b7          	lui	a1,0x4201a
4200e63a:	57858593          	add	a1,a1,1400 # 4201a578 <hextab+0x38ac>
4200e63e:	4501                	li	a0,0
4200e640:	c15f40ef          	jal	42003254 <logk>
4200e644:	9002                	ebreak
    return isr_ctx_get()->thread;
4200e646:	9002                	ebreak
4200e648:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200e64a:	9002                	ebreak
4200e64c:	9002                	ebreak

4200e64e <sched_suspend_thread>:
void sched_suspend_thread(badge_err_t *const ec, sched_thread_t *const thread) {
4200e64e:	1141                	add	sp,sp,-16
4200e650:	c606                	sw	ra,12(sp)
4200e652:	c422                	sw	s0,8(sp)
    assert_dev_drop(thread != NULL);
4200e654:	c1ed                	beqz	a1,4200e736 <sched_suspend_thread+0xe8>
    assert_dev_drop(!critical_section_active);
4200e656:	4080a6b7          	lui	a3,0x4080a
4200e65a:	e716c783          	lbu	a5,-399(a3) # 40809e71 <critical_section_active>
4200e65e:	4705                	li	a4,1
4200e660:	0ef76a63          	bltu	a4,a5,4200e754 <sched_suspend_thread+0x106>
4200e664:	e3ed                	bnez	a5,4200e746 <sched_suspend_thread+0xf8>
4200e666:	47a1                	li	a5,8
4200e668:	3007b7f3          	csrrc	a5,mstatus,a5
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
4200e66c:	838d                	srl	a5,a5,0x3
4200e66e:	8b85                	and	a5,a5,1
    critical_section_had_interrupts = isr_global_disable();
4200e670:	4080a637          	lui	a2,0x4080a
4200e674:	e6f60823          	sb	a5,-400(a2) # 40809e70 <critical_section_had_interrupts>
    critical_section_active         = true;
4200e678:	e6e688a3          	sb	a4,-399(a3)
    if (is_flag_set(thread->flags, THREAD_COMPLETED)) {
4200e67c:	0035f793          	and	a5,a1,3
4200e680:	ebf1                	bnez	a5,4200e754 <sched_suspend_thread+0x106>
4200e682:	57c1                	li	a5,-16
4200e684:	0cf5f863          	bgeu	a1,a5,4200e754 <sched_suspend_thread+0x106>
4200e688:	499c                	lw	a5,16(a1)
4200e68a:	842a                	mv	s0,a0
4200e68c:	0027f693          	and	a3,a5,2
4200e690:	ce85                	beqz	a3,4200e6c8 <sched_suspend_thread+0x7a>
        badge_err_set(ec, ELOC_THREADS, ECAUSE_ILLEGAL);
4200e692:	c515                	beqz	a0,4200e6be <sched_suspend_thread+0x70>
4200e694:	420175b7          	lui	a1,0x42017
4200e698:	46d9                	li	a3,22
4200e69a:	4631                	li	a2,12
4200e69c:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200e6a0:	4511                	li	a0,4
4200e6a2:	00000717          	auipc	a4,0x0
4200e6a6:	bf5f40ef          	jal	4200329a <logkf>
4200e6aa:	00347793          	and	a5,s0,3
4200e6ae:	e3dd                	bnez	a5,4200e754 <sched_suspend_thread+0x106>
4200e6b0:	57f1                	li	a5,-4
4200e6b2:	0af47163          	bgeu	s0,a5,4200e754 <sched_suspend_thread+0x106>
4200e6b6:	47b1                	li	a5,12
4200e6b8:	c05c                	sw	a5,4(s0)
4200e6ba:	47d9                	li	a5,22
4200e6bc:	c01c                	sw	a5,0(s0)
}
4200e6be:	4422                	lw	s0,8(sp)
4200e6c0:	40b2                	lw	ra,12(sp)
4200e6c2:	0141                	add	sp,sp,16
    leave_critical_section();
4200e6c4:	f66ff06f          	j	4200de2a <leave_critical_section>
    if (!scheduler_enabled) {
4200e6c8:	4080a6b7          	lui	a3,0x4080a
4200e6cc:	e736c683          	lbu	a3,-397(a3) # 40809e73 <scheduler_enabled>
4200e6d0:	08d76263          	bltu	a4,a3,4200e754 <sched_suspend_thread+0x106>
4200e6d4:	8a85                	and	a3,a3,1
4200e6d6:	ce99                	beqz	a3,4200e6f4 <sched_suspend_thread+0xa6>
4200e6d8:	34002773          	csrr	a4,mscratch
    return isr_ctx_get()->thread;
4200e6dc:	cf25                	beqz	a4,4200e754 <sched_suspend_thread+0x106>
4200e6de:	00377693          	and	a3,a4,3
4200e6e2:	eaad                	bnez	a3,4200e754 <sched_suspend_thread+0x106>
4200e6e4:	f5c00693          	li	a3,-164
4200e6e8:	06d77663          	bgeu	a4,a3,4200e754 <sched_suspend_thread+0x106>
    } else if (thread == sched_get_current_thread_unsafe()) {
4200e6ec:	0a472703          	lw	a4,164(a4) # 4200e746 <sched_suspend_thread+0xf8>
4200e6f0:	06e58363          	beq	a1,a4,4200e756 <sched_suspend_thread+0x108>
    } else if (is_flag_set(thread->flags, THREAD_RUNNING)) {
4200e6f4:	0017f713          	and	a4,a5,1
4200e6f8:	e30d                	bnez	a4,4200e71a <sched_suspend_thread+0xcc>
        badge_err_set_ok(ec);
4200e6fa:	d071                	beqz	s0,4200e6be <sched_suspend_thread+0x70>
4200e6fc:	00347793          	and	a5,s0,3
4200e700:	ebb1                	bnez	a5,4200e754 <sched_suspend_thread+0x106>
4200e702:	57f1                	li	a5,-4
4200e704:	04f47863          	bgeu	s0,a5,4200e754 <sched_suspend_thread+0x106>
4200e708:	00042223          	sw	zero,4(s0)
4200e70c:	00042023          	sw	zero,0(s0)
}
4200e710:	4422                	lw	s0,8(sp)
4200e712:	40b2                	lw	ra,12(sp)
4200e714:	0141                	add	sp,sp,16
    leave_critical_section();
4200e716:	f14ff06f          	j	4200de2a <leave_critical_section>
        reset_flag(thread->flags, THREAD_RUNNING);
4200e71a:	9bf9                	and	a5,a5,-2
4200e71c:	c99c                	sw	a5,16(a1)
        dlist_remove(&thread_wait_queue, &thread->schedule_node);
4200e71e:	57b1                	li	a5,-20
4200e720:	02f5fa63          	bgeu	a1,a5,4200e754 <sched_suspend_thread+0x106>
4200e724:	40802537          	lui	a0,0x40802
4200e728:	05d1                	add	a1,a1,20
4200e72a:	40c50513          	add	a0,a0,1036 # 4080240c <thread_wait_queue>
4200e72e:	9d9fe0ef          	jal	4200d106 <dlist_remove>
        badge_err_set_ok(ec);
4200e732:	f469                	bnez	s0,4200e6fc <sched_suspend_thread+0xae>
4200e734:	b769                	j	4200e6be <sched_suspend_thread+0x70>
    assert_dev_drop(thread != NULL);
4200e736:	4201b5b7          	lui	a1,0x4201b
4200e73a:	bbc58593          	add	a1,a1,-1092 # 4201abbc <hextab+0x3ef0>
4200e73e:	4501                	li	a0,0
4200e740:	b15f40ef          	jal	42003254 <logk>
4200e744:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200e746:	4201a5b7          	lui	a1,0x4201a
4200e74a:	57858593          	add	a1,a1,1400 # 4201a578 <hextab+0x38ac>
4200e74e:	4501                	li	a0,0
4200e750:	b05f40ef          	jal	42003254 <logk>
4200e754:	9002                	ebreak
        reset_flag(thread->flags, THREAD_RUNNING);
4200e756:	9bf9                	and	a5,a5,-2
4200e758:	c99c                	sw	a5,16(a1)
        badge_err_set_ok(ec);
4200e75a:	c919                	beqz	a0,4200e770 <sched_suspend_thread+0x122>
4200e75c:	00357793          	and	a5,a0,3
4200e760:	fbf5                	bnez	a5,4200e754 <sched_suspend_thread+0x106>
4200e762:	57f1                	li	a5,-4
4200e764:	fef578e3          	bgeu	a0,a5,4200e754 <sched_suspend_thread+0x106>
4200e768:	00052223          	sw	zero,4(a0)
4200e76c:	00052023          	sw	zero,0(a0)
        leave_critical_section();
4200e770:	ebaff0ef          	jal	4200de2a <leave_critical_section>
}
4200e774:	4422                	lw	s0,8(sp)
4200e776:	40b2                	lw	ra,12(sp)
4200e778:	0141                	add	sp,sp,16
        sched_yield();
4200e77a:	e3bff06f          	j	4200e5b4 <sched_yield>

4200e77e <destroy_thread>:
static void destroy_thread(sched_thread_t *thread) {
4200e77e:	1141                	add	sp,sp,-16
4200e780:	c606                	sw	ra,12(sp)
4200e782:	c422                	sw	s0,8(sp)
    assert_dev_drop(thread != NULL);
4200e784:	c12d                	beqz	a0,4200e7e6 <destroy_thread+0x68>
    if (is_flag_set(thread->flags, THREAD_RUNNING)) {
4200e786:	00357793          	and	a5,a0,3
4200e78a:	842a                	mv	s0,a0
4200e78c:	e7a5                	bnez	a5,4200e7f4 <destroy_thread+0x76>
4200e78e:	57c1                	li	a5,-16
4200e790:	06f57263          	bgeu	a0,a5,4200e7f4 <destroy_thread+0x76>
4200e794:	491c                	lw	a5,16(a0)
4200e796:	8b85                	and	a5,a5,1
4200e798:	e3b1                	bnez	a5,4200e7dc <destroy_thread+0x5e>
    mem_set(thread, 0xAA, sizeof(sched_thread_t));
4200e79a:	19800613          	li	a2,408
4200e79e:	0aa00593          	li	a1,170
4200e7a2:	8522                	mv	a0,s0
4200e7a4:	8a8f40ef          	jal	4200284c <mem_set>
    thread->flags         = THREAD_ALLOCATOR_SENTINEL;
4200e7a8:	0badc7b7          	lui	a5,0xbadc
4200e7ac:	0de78793          	add	a5,a5,222 # badc0de <__stack_size+0xbada0de>
4200e7b0:	c81c                	sw	a5,16(s0)
    thread->schedule_node = DLIST_NODE_EMPTY;
4200e7b2:	57b1                	li	a5,-20
4200e7b4:	04f47063          	bgeu	s0,a5,4200e7f4 <destroy_thread+0x76>
4200e7b8:	00042a23          	sw	zero,20(s0)
4200e7bc:	57a1                	li	a5,-24
4200e7be:	02f47b63          	bgeu	s0,a5,4200e7f4 <destroy_thread+0x76>
4200e7c2:	00042c23          	sw	zero,24(s0)
    dlist_append(&thread_alloc_pool, &thread->schedule_node);
4200e7c6:	01440593          	add	a1,s0,20
}
4200e7ca:	4422                	lw	s0,8(sp)
4200e7cc:	40b2                	lw	ra,12(sp)
    dlist_append(&thread_alloc_pool, &thread->schedule_node);
4200e7ce:	40802537          	lui	a0,0x40802
4200e7d2:	40050513          	add	a0,a0,1024 # 40802400 <thread_alloc_pool>
}
4200e7d6:	0141                	add	sp,sp,16
    dlist_append(&thread_alloc_pool, &thread->schedule_node);
4200e7d8:	fb2fe06f          	j	4200cf8a <dlist_append>
        sched_suspend_thread(NULL, thread);
4200e7dc:	85aa                	mv	a1,a0
4200e7de:	4501                	li	a0,0
4200e7e0:	e6fff0ef          	jal	4200e64e <sched_suspend_thread>
4200e7e4:	bf5d                	j	4200e79a <destroy_thread+0x1c>
    assert_dev_drop(thread != NULL);
4200e7e6:	4201b5b7          	lui	a1,0x4201b
4200e7ea:	c3058593          	add	a1,a1,-976 # 4201ac30 <hextab+0x3f64>
4200e7ee:	a67f40ef          	jal	42003254 <logk>
4200e7f2:	9002                	ebreak
    thread->schedule_node = DLIST_NODE_EMPTY;
4200e7f4:	9002                	ebreak

4200e7f6 <sched_request_switch_from_isr.part.0>:
void sched_request_switch_from_isr(void) {
4200e7f6:	1101                	add	sp,sp,-32
4200e7f8:	ce06                	sw	ra,28(sp)
4200e7fa:	cc22                	sw	s0,24(sp)
4200e7fc:	ca26                	sw	s1,20(sp)
4200e7fe:	c84a                	sw	s2,16(sp)
4200e800:	c64e                	sw	s3,12(sp)
4200e802:	c452                	sw	s4,8(sp)
4200e804:	c256                	sw	s5,4(sp)
4200e806:	c05a                	sw	s6,0(sp)
    timestamp_us_t const now = time_us();
4200e808:	761010ef          	jal	42010768 <time_us>
    if (scheduler_bootstrapped) {
4200e80c:	4080a6b7          	lui	a3,0x4080a
4200e810:	e726c783          	lbu	a5,-398(a3) # 40809e72 <scheduler_bootstrapped>
4200e814:	4705                	li	a4,1
4200e816:	16f76863          	bltu	a4,a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e81a:	8b85                	and	a5,a5,1
4200e81c:	8b2a                	mv	s6,a0
4200e81e:	8aae                	mv	s5,a1
4200e820:	0e079763          	bnez	a5,4200e90e <sched_request_switch_from_isr.part.0+0x118>
        scheduler_bootstrapped = true;
4200e824:	e6e68923          	sb	a4,-398(a3)
4200e828:	40802937          	lui	s2,0x40802
4200e82c:	40c90913          	add	s2,s2,1036 # 4080240c <thread_wait_queue>
        sched_thread_t *const next_thread = field_parent_ptr(sched_thread_t, schedule_node, next_thread_node);
4200e830:	4a51                	li	s4,20
        if (next_thread->flags & THREAD_PRIVILEGED) {
4200e832:	59c1                	li	s3,-16
4200e834:	a82d                	j	4200e86e <sched_request_switch_from_isr.part.0+0x78>
        sched_thread_t *const next_thread = field_parent_ptr(sched_thread_t, schedule_node, next_thread_node);
4200e836:	15456863          	bltu	a0,s4,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e83a:	fec50493          	add	s1,a0,-20
        if (next_thread->flags & THREAD_PRIVILEGED) {
4200e83e:	14048463          	beqz	s1,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e842:	0034f793          	and	a5,s1,3
4200e846:	14079063          	bnez	a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e84a:	1334fe63          	bgeu	s1,s3,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e84e:	ffc52783          	lw	a5,-4(a0)
4200e852:	8bc1                	and	a5,a5,16
4200e854:	ebad                	bnez	a5,4200e8c6 <sched_request_switch_from_isr.part.0+0xd0>
            if (proc_getflags_raw(next_thread->process) & PROC_EXITING) {
4200e856:	fec52503          	lw	a0,-20(a0)
4200e85a:	d07fc0ef          	jal	4200b560 <proc_getflags_raw>
4200e85e:	8909                	and	a0,a0,2
4200e860:	10050a63          	beqz	a0,4200e974 <sched_request_switch_from_isr.part.0+0x17e>
                reset_flag(next_thread->flags, THREAD_RUNNING);
4200e864:	ffc42783          	lw	a5,-4(s0)
4200e868:	9bf9                	and	a5,a5,-2
4200e86a:	fef42e23          	sw	a5,-4(s0)
    next_thread_node = dlist_pop_front(&thread_wait_queue);
4200e86e:	854a                	mv	a0,s2
4200e870:	cdafe0ef          	jal	4200cd4a <dlist_pop_front>
4200e874:	842a                	mv	s0,a0
    if (next_thread_node != NULL) {
4200e876:	f161                	bnez	a0,4200e836 <sched_request_switch_from_isr.part.0+0x40>
    return kctx->ctxswitch;
}
// Set the context swap target to swap to before exiting the trap/interrupt handler.
static inline void isr_ctx_switch_set(isr_ctx_t *switch_to) {
    isr_ctx_t *kctx;
    asm("csrr %0, mscratch" : "=r"(kctx));
4200e878:	340027f3          	csrr	a5,mscratch
    kctx->ctxswitch = switch_to;
4200e87c:	10078563          	beqz	a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e880:	0037f713          	and	a4,a5,3
4200e884:	10071163          	bnez	a4,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e888:	f6000713          	li	a4,-160
4200e88c:	0ee7fd63          	bgeu	a5,a4,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e890:	000f4537          	lui	a0,0xf4
4200e894:	12818713          	add	a4,gp,296 # 40800128 <idle_thread+0x20>
4200e898:	0ae7a023          	sw	a4,160(a5)
4200e89c:	24050513          	add	a0,a0,576 # f4240 <__stack_size+0xf2240>
    next_isr_invocation_time = now + task_time_quota;
4200e8a0:	955a                	add	a0,a0,s6
4200e8a2:	016535b3          	sltu	a1,a0,s6
4200e8a6:	95d6                	add	a1,a1,s5
4200e8a8:	0d55cf63          	blt	a1,s5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e8ac:	0eba8b63          	beq	s5,a1,4200e9a2 <sched_request_switch_from_isr.part.0+0x1ac>
}
4200e8b0:	4462                	lw	s0,24(sp)
4200e8b2:	40f2                	lw	ra,28(sp)
4200e8b4:	44d2                	lw	s1,20(sp)
4200e8b6:	4942                	lw	s2,16(sp)
4200e8b8:	49b2                	lw	s3,12(sp)
4200e8ba:	4a22                	lw	s4,8(sp)
4200e8bc:	4a92                	lw	s5,4(sp)
4200e8be:	4b02                	lw	s6,0(sp)
4200e8c0:	6105                	add	sp,sp,32
    time_set_next_task_switch(next_isr_invocation_time);
4200e8c2:	6130106f          	j	420106d4 <time_set_next_task_switch>
            isr_ctx_switch_set(&next_thread->kernel_isr_ctx);
4200e8c6:	5781                	li	a5,-32
4200e8c8:	0af4ff63          	bgeu	s1,a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e8cc:	00c50713          	add	a4,a0,12
    asm("csrr %0, mscratch" : "=r"(kctx));
4200e8d0:	340027f3          	csrr	a5,mscratch
    kctx->ctxswitch = switch_to;
4200e8d4:	cbcd                	beqz	a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e8d6:	0037f693          	and	a3,a5,3
4200e8da:	e6d5                	bnez	a3,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e8dc:	f6000693          	li	a3,-160
4200e8e0:	0ad7f363          	bgeu	a5,a3,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e8e4:	0ae7a023          	sw	a4,160(a5)
        task_time_quota = SCHEDULER_MIN_TASK_TIME_US + (uint32_t)next_thread->priority * SCHEDULER_TIME_QUOTA_INCR_US;
4200e8e8:	ff842703          	lw	a4,-8(s0)
4200e8ec:	1f400513          	li	a0,500
4200e8f0:	6785                	lui	a5,0x1
4200e8f2:	02e50533          	mul	a0,a0,a4
4200e8f6:	38878793          	add	a5,a5,904 # 1388 <isr_ctx_t_is_kernel_thread+0x12e0>
4200e8fa:	953e                	add	a0,a0,a5
    assert_dev_drop(task_time_quota > 0);
4200e8fc:	f155                	bnez	a0,4200e8a0 <sched_request_switch_from_isr.part.0+0xaa>
4200e8fe:	4201b5b7          	lui	a1,0x4201b
4200e902:	ca458593          	add	a1,a1,-860 # 4201aca4 <hextab+0x3fd8>
4200e906:	4501                	li	a0,0
4200e908:	94df40ef          	jal	42003254 <logk>
4200e90c:	9002                	ebreak
    if (!scheduler_enabled) {
4200e90e:	4080a7b7          	lui	a5,0x4080a
4200e912:	e737c783          	lbu	a5,-397(a5) # 40809e73 <scheduler_enabled>
4200e916:	06f76863          	bltu	a4,a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e91a:	8b85                	and	a5,a5,1
4200e91c:	f00786e3          	beqz	a5,4200e828 <sched_request_switch_from_isr.part.0+0x32>
    asm("csrr %0, mscratch" : "=r"(kctx));
4200e920:	340027f3          	csrr	a5,mscratch
    return isr_ctx_get()->thread;
4200e924:	c3ad                	beqz	a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e926:	0037f713          	and	a4,a5,3
4200e92a:	ef31                	bnez	a4,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e92c:	f5c00713          	li	a4,-164
4200e930:	04e7fb63          	bgeu	a5,a4,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e934:	0a47a503          	lw	a0,164(a5)
        if (current_thread == &idle_thread) {
4200e938:	10818793          	add	a5,gp,264 # 40800108 <idle_thread>
4200e93c:	eef506e3          	beq	a0,a5,4200e828 <sched_request_switch_from_isr.part.0+0x32>
        } else if (current_thread != NULL) {
4200e940:	ee0504e3          	beqz	a0,4200e828 <sched_request_switch_from_isr.part.0+0x32>
            if (is_flag_set(current_thread->flags, THREAD_RUNNING)) {
4200e944:	00357793          	and	a5,a0,3
4200e948:	ef9d                	bnez	a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e94a:	57c1                	li	a5,-16
4200e94c:	02f57d63          	bgeu	a0,a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e950:	491c                	lw	a5,16(a0)
4200e952:	0017f713          	and	a4,a5,1
4200e956:	eb0d                	bnez	a4,4200e988 <sched_request_switch_from_isr.part.0+0x192>
                if (is_flag_set(current_thread->flags, THREAD_COMPLETED)) {
4200e958:	0027f713          	and	a4,a5,2
4200e95c:	ec0706e3          	beqz	a4,4200e828 <sched_request_switch_from_isr.part.0+0x32>
                    if (is_flag_set(current_thread->flags, THREAD_DETACHED)) {
4200e960:	8b91                	and	a5,a5,4
4200e962:	ec0783e3          	beqz	a5,4200e828 <sched_request_switch_from_isr.part.0+0x32>
                        destroy_thread(current_thread);
4200e966:	40802937          	lui	s2,0x40802
4200e96a:	e15ff0ef          	jal	4200e77e <destroy_thread>
4200e96e:	40c90913          	add	s2,s2,1036 # 4080240c <thread_wait_queue>
4200e972:	bd7d                	j	4200e830 <sched_request_switch_from_isr.part.0+0x3a>
            isr_ctx_switch_set(&next_thread->user_isr_ctx);
4200e974:	f3400793          	li	a5,-204
4200e978:	00f4f763          	bgeu	s1,a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e97c:	0b840713          	add	a4,s0,184
    asm("csrr %0, mscratch" : "=r"(kctx));
4200e980:	340027f3          	csrr	a5,mscratch
    kctx->ctxswitch = switch_to;
4200e984:	fba9                	bnez	a5,4200e8d6 <sched_request_switch_from_isr.part.0+0xe0>
    next_isr_invocation_time = now + task_time_quota;
4200e986:	9002                	ebreak
                dlist_append(&thread_wait_queue, &current_thread->schedule_node);
4200e988:	57b1                	li	a5,-20
4200e98a:	fef57ee3          	bgeu	a0,a5,4200e986 <sched_request_switch_from_isr.part.0+0x190>
4200e98e:	40802937          	lui	s2,0x40802
4200e992:	40c90913          	add	s2,s2,1036 # 4080240c <thread_wait_queue>
4200e996:	01450593          	add	a1,a0,20
4200e99a:	854a                	mv	a0,s2
4200e99c:	deefe0ef          	jal	4200cf8a <dlist_append>
4200e9a0:	bd41                	j	4200e830 <sched_request_switch_from_isr.part.0+0x3a>
    next_isr_invocation_time = now + task_time_quota;
4200e9a2:	f16577e3          	bgeu	a0,s6,4200e8b0 <sched_request_switch_from_isr.part.0+0xba>
4200e9a6:	b7c5                	j	4200e986 <sched_request_switch_from_isr.part.0+0x190>

4200e9a8 <sched_request_switch_from_isr>:
    if (!scheduler_enabled) {
4200e9a8:	4080a7b7          	lui	a5,0x4080a
4200e9ac:	e737c783          	lbu	a5,-397(a5) # 40809e73 <scheduler_enabled>
4200e9b0:	4705                	li	a4,1
4200e9b2:	00f76763          	bltu	a4,a5,4200e9c0 <sched_request_switch_from_isr+0x18>
4200e9b6:	8b85                	and	a5,a5,1
4200e9b8:	e391                	bnez	a5,4200e9bc <sched_request_switch_from_isr+0x14>
}
4200e9ba:	8082                	ret
4200e9bc:	e3bff06f          	j	4200e7f6 <sched_request_switch_from_isr.part.0>
    if (!scheduler_enabled) {
4200e9c0:	9002                	ebreak

4200e9c2 <sched_exec>:
void sched_exec() {
4200e9c2:	1141                	add	sp,sp,-16
4200e9c4:	c606                	sw	ra,12(sp)
    next_isr_invocation_time = time_us();
4200e9c6:	5a3010ef          	jal	42010768 <time_us>
    scheduler_enabled = true;
4200e9ca:	4080a7b7          	lui	a5,0x4080a
4200e9ce:	4705                	li	a4,1
4200e9d0:	e6e789a3          	sb	a4,-397(a5) # 40809e73 <scheduler_enabled>
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200e9d4:	47a1                	li	a5,8
4200e9d6:	3007b7f3          	csrrc	a5,mstatus,a5
    sched_request_switch_from_isr();
4200e9da:	fcfff0ef          	jal	4200e9a8 <sched_request_switch_from_isr>
    isr_context_switch();
4200e9de:	aa3f10ef          	jal	42000480 <isr_context_switch>
    __builtin_unreachable();
4200e9e2:	9002                	ebreak

4200e9e4 <sched_exit>:
    assert_dev_drop(!critical_section_active);
4200e9e4:	4080a737          	lui	a4,0x4080a
4200e9e8:	e7174783          	lbu	a5,-399(a4) # 40809e71 <critical_section_active>
4200e9ec:	4685                	li	a3,1
4200e9ee:	06f6e763          	bltu	a3,a5,4200ea5c <sched_exit+0x78>

void sched_exit(uint32_t const exit_code) {
4200e9f2:	1141                	add	sp,sp,-16
4200e9f4:	c606                	sw	ra,12(sp)
4200e9f6:	c422                	sw	s0,8(sp)
    assert_dev_drop(!critical_section_active);
4200e9f8:	e3a9                	bnez	a5,4200ea3a <sched_exit+0x56>
4200e9fa:	842a                	mv	s0,a0
4200e9fc:	47a1                	li	a5,8
4200e9fe:	3007b7f3          	csrrc	a5,mstatus,a5
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
4200ea02:	838d                	srl	a5,a5,0x3
4200ea04:	8b85                	and	a5,a5,1
    critical_section_had_interrupts = isr_global_disable();
4200ea06:	4080a637          	lui	a2,0x4080a
4200ea0a:	e6f60823          	sb	a5,-400(a2) # 40809e70 <critical_section_had_interrupts>
    critical_section_active         = true;
4200ea0e:	e6d708a3          	sb	a3,-399(a4)
    enter_critical_section();

    sched_thread_t *const current_thread = sched_get_current_thread_unsafe();
4200ea12:	e70ff0ef          	jal	4200e082 <sched_get_current_thread_unsafe>
    assert_always(current_thread != NULL);
4200ea16:	c915                	beqz	a0,4200ea4a <sched_exit+0x66>

    current_thread->exit_code = exit_code;
4200ea18:	00357713          	and	a4,a0,3
4200ea1c:	ef15                	bnez	a4,4200ea58 <sched_exit+0x74>
4200ea1e:	5711                	li	a4,-28
4200ea20:	02e57d63          	bgeu	a0,a4,4200ea5a <sched_exit+0x76>
    set_flag(current_thread->flags, THREAD_COMPLETED);
4200ea24:	4918                	lw	a4,16(a0)
    current_thread->exit_code = exit_code;
4200ea26:	cd40                	sw	s0,28(a0)
    reset_flag(current_thread->flags, THREAD_RUNNING);
4200ea28:	9b79                	and	a4,a4,-2
4200ea2a:	00276713          	or	a4,a4,2
4200ea2e:	c918                	sw	a4,16(a0)

    leave_critical_section();
4200ea30:	bfaff0ef          	jal	4200de2a <leave_critical_section>

    sched_yield();
4200ea34:	b81ff0ef          	jal	4200e5b4 <sched_yield>

    // hint the compiler that we cannot reach this part of the code and
    // it will never be reached:
    __builtin_unreachable();
4200ea38:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200ea3a:	4201a5b7          	lui	a1,0x4201a
4200ea3e:	57858593          	add	a1,a1,1400 # 4201a578 <hextab+0x38ac>
4200ea42:	4501                	li	a0,0
4200ea44:	811f40ef          	jal	42003254 <logk>
4200ea48:	9002                	ebreak
    assert_always(current_thread != NULL);
4200ea4a:	4201b5b7          	lui	a1,0x4201b
4200ea4e:	d1858593          	add	a1,a1,-744 # 4201ad18 <hextab+0x404c>
4200ea52:	803f40ef          	jal	42003254 <logk>
4200ea56:	9002                	ebreak
    current_thread->exit_code = exit_code;
4200ea58:	9002                	ebreak
4200ea5a:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200ea5c:	9002                	ebreak

4200ea5e <sched_destroy_thread>:
void sched_destroy_thread(badge_err_t *ec, sched_thread_t *thread) {
4200ea5e:	1141                	add	sp,sp,-16
4200ea60:	c606                	sw	ra,12(sp)
    assert_dev_drop(thread != NULL);
4200ea62:	c9c5                	beqz	a1,4200eb12 <sched_destroy_thread+0xb4>
    assert_dev_drop(!critical_section_active);
4200ea64:	4080a637          	lui	a2,0x4080a
4200ea68:	e7164783          	lbu	a5,-399(a2) # 40809e71 <critical_section_active>
4200ea6c:	4685                	li	a3,1
4200ea6e:	0cf6ed63          	bltu	a3,a5,4200eb48 <sched_destroy_thread+0xea>
4200ea72:	ebdd                	bnez	a5,4200eb28 <sched_destroy_thread+0xca>
4200ea74:	c226                	sw	s1,4(sp)
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200ea76:	47a1                	li	a5,8
4200ea78:	84ae                	mv	s1,a1
4200ea7a:	3007b7f3          	csrrc	a5,mstatus,a5
    if (!scheduler_enabled) {
4200ea7e:	4080a737          	lui	a4,0x4080a
    return mstatus & (1U << RV32_MSTATUS_MIE_BIT);
4200ea82:	838d                	srl	a5,a5,0x3
4200ea84:	e7374703          	lbu	a4,-397(a4) # 40809e73 <scheduler_enabled>
4200ea88:	8b85                	and	a5,a5,1
    critical_section_had_interrupts = isr_global_disable();
4200ea8a:	4080a5b7          	lui	a1,0x4080a
4200ea8e:	e6f58823          	sb	a5,-400(a1) # 40809e70 <critical_section_had_interrupts>
    critical_section_active         = true;
4200ea92:	e6d608a3          	sb	a3,-399(a2)
    if (!scheduler_enabled) {
4200ea96:	0ae6ea63          	bltu	a3,a4,4200eb4a <sched_destroy_thread+0xec>
4200ea9a:	c422                	sw	s0,8(sp)
4200ea9c:	8b05                	and	a4,a4,1
4200ea9e:	842a                	mv	s0,a0
4200eaa0:	c735                	beqz	a4,4200eb0c <sched_destroy_thread+0xae>
4200eaa2:	c04a                	sw	s2,0(sp)
    asm("csrr %0, mscratch" : "=r"(kctx));
4200eaa4:	340027f3          	csrr	a5,mscratch
    return isr_ctx_get()->thread;
4200eaa8:	cfc1                	beqz	a5,4200eb40 <sched_destroy_thread+0xe2>
4200eaaa:	0037f713          	and	a4,a5,3
4200eaae:	eb49                	bnez	a4,4200eb40 <sched_destroy_thread+0xe2>
4200eab0:	f5c00713          	li	a4,-164
4200eab4:	08e7f663          	bgeu	a5,a4,4200eb40 <sched_destroy_thread+0xe2>
4200eab8:	0a47a903          	lw	s2,164(a5)
    leave_critical_section();
4200eabc:	b6eff0ef          	jal	4200de2a <leave_critical_section>
    if (thread == sched_get_current_thread()) {
4200eac0:	03248663          	beq	s1,s2,4200eaec <sched_destroy_thread+0x8e>
4200eac4:	4902                	lw	s2,0(sp)
    destroy_thread(thread);
4200eac6:	8526                	mv	a0,s1
4200eac8:	cb7ff0ef          	jal	4200e77e <destroy_thread>
    badge_err_set_ok(ec);
4200eacc:	c819                	beqz	s0,4200eae2 <sched_destroy_thread+0x84>
4200eace:	00347793          	and	a5,s0,3
4200ead2:	e7b5                	bnez	a5,4200eb3e <sched_destroy_thread+0xe0>
4200ead4:	57f1                	li	a5,-4
4200ead6:	06f47463          	bgeu	s0,a5,4200eb3e <sched_destroy_thread+0xe0>
4200eada:	00042223          	sw	zero,4(s0)
4200eade:	00042023          	sw	zero,0(s0)
4200eae2:	4422                	lw	s0,8(sp)
}
4200eae4:	40b2                	lw	ra,12(sp)
4200eae6:	4492                	lw	s1,4(sp)
4200eae8:	0141                	add	sp,sp,16
4200eaea:	8082                	ret
        sched_detach_thread(ec, thread);
4200eaec:	85a6                	mv	a1,s1
4200eaee:	8522                	mv	a0,s0
4200eaf0:	983ff0ef          	jal	4200e472 <sched_detach_thread>
        if (!badge_err_is_ok(ec)) {
4200eaf4:	c439                	beqz	s0,4200eb42 <sched_destroy_thread+0xe4>
4200eaf6:	00347793          	and	a5,s0,3
4200eafa:	e3b9                	bnez	a5,4200eb40 <sched_destroy_thread+0xe2>
4200eafc:	401c                	lw	a5,0(s0)
4200eafe:	c3b1                	beqz	a5,4200eb42 <sched_destroy_thread+0xe4>
4200eb00:	4422                	lw	s0,8(sp)
}
4200eb02:	40b2                	lw	ra,12(sp)
4200eb04:	4902                	lw	s2,0(sp)
4200eb06:	4492                	lw	s1,4(sp)
4200eb08:	0141                	add	sp,sp,16
4200eb0a:	8082                	ret
    leave_critical_section();
4200eb0c:	b1eff0ef          	jal	4200de2a <leave_critical_section>
    return thread;
4200eb10:	bf5d                	j	4200eac6 <sched_destroy_thread+0x68>
    assert_dev_drop(thread != NULL);
4200eb12:	4201b5b7          	lui	a1,0x4201b
4200eb16:	d8c58593          	add	a1,a1,-628 # 4201ad8c <hextab+0x40c0>
4200eb1a:	4501                	li	a0,0
4200eb1c:	c422                	sw	s0,8(sp)
4200eb1e:	c226                	sw	s1,4(sp)
4200eb20:	c04a                	sw	s2,0(sp)
4200eb22:	f32f40ef          	jal	42003254 <logk>
4200eb26:	9002                	ebreak
    assert_dev_drop(!critical_section_active);
4200eb28:	4201a5b7          	lui	a1,0x4201a
4200eb2c:	57858593          	add	a1,a1,1400 # 4201a578 <hextab+0x38ac>
4200eb30:	4501                	li	a0,0
4200eb32:	c422                	sw	s0,8(sp)
4200eb34:	c226                	sw	s1,4(sp)
4200eb36:	c04a                	sw	s2,0(sp)
4200eb38:	f1cf40ef          	jal	42003254 <logk>
4200eb3c:	9002                	ebreak
4200eb3e:	c04a                	sw	s2,0(sp)
    badge_err_set_ok(ec);
4200eb40:	9002                	ebreak
        sched_exit(0);
4200eb42:	4501                	li	a0,0
4200eb44:	ea1ff0ef          	jal	4200e9e4 <sched_exit>
4200eb48:	c226                	sw	s1,4(sp)
4200eb4a:	c422                	sw	s0,8(sp)
4200eb4c:	c04a                	sw	s2,0(sp)
    assert_dev_drop(!critical_section_active);
4200eb4e:	9002                	ebreak

4200eb50 <sched_set_name>:
}


void sched_set_name(badge_err_t *ec, sched_thread_t *thread, char const *name) {
4200eb50:	1141                	add	sp,sp,-16
4200eb52:	c422                	sw	s0,8(sp)
4200eb54:	c226                	sw	s1,4(sp)
4200eb56:	c04a                	sw	s2,0(sp)
4200eb58:	8732                	mv	a4,a2
#if NDEBUG
    badge_err_set(ec, ELOC_THREADS, ECAUSE_UNSUPPORTED);
#else
    size_t l = 0;
    for (l = 0; name[l]; l++) {
4200eb5a:	4401                	li	s0,0
void sched_set_name(badge_err_t *ec, sched_thread_t *thread, char const *name) {
4200eb5c:	c606                	sw	ra,12(sp)
4200eb5e:	892a                	mv	s2,a0
4200eb60:	84ae                	mv	s1,a1
4200eb62:	87b2                	mv	a5,a2
    for (l = 0; name[l]; l++) {
4200eb64:	008706b3          	add	a3,a4,s0
4200eb68:	02044063          	bltz	s0,4200eb88 <sched_set_name+0x38>
4200eb6c:	02e6e063          	bltu	a3,a4,4200eb8c <sched_set_name+0x3c>
4200eb70:	cf91                	beqz	a5,4200eb8c <sched_set_name+0x3c>
4200eb72:	0007c603          	lbu	a2,0(a5)
4200eb76:	00140693          	add	a3,s0,1
4200eb7a:	0785                	add	a5,a5,1
4200eb7c:	ca09                	beqz	a2,4200eb8e <sched_set_name+0x3e>
4200eb7e:	8436                	mv	s0,a3
4200eb80:	008706b3          	add	a3,a4,s0
4200eb84:	fe0454e3          	bgez	s0,4200eb6c <sched_set_name+0x1c>
4200eb88:	fed774e3          	bgeu	a4,a3,4200eb70 <sched_set_name+0x20>
    if (l + 1 >= sizeof(thread->name)) {
        badge_err_set(ec, ELOC_THREADS, ECAUSE_TOOLONG);
        return;
    }
    mem_copy(thread->name, name, l);
    thread->name[l] = 0;
4200eb8c:	9002                	ebreak
    if (l + 1 >= sizeof(thread->name)) {
4200eb8e:	47fd                	li	a5,31
4200eb90:	04d7f163          	bgeu	a5,a3,4200ebd2 <sched_set_name+0x82>
        badge_err_set(ec, ELOC_THREADS, ECAUSE_TOOLONG);
4200eb94:	02090963          	beqz	s2,4200ebc6 <sched_set_name+0x76>
4200eb98:	420175b7          	lui	a1,0x42017
4200eb9c:	4691                	li	a3,4
4200eb9e:	4631                	li	a2,12
4200eba0:	20458593          	add	a1,a1,516 # 42017204 <hextab+0x538>
4200eba4:	4511                	li	a0,4
4200eba6:	00000717          	auipc	a4,0x0
4200ebaa:	ef0f40ef          	jal	4200329a <logkf>
4200ebae:	00397793          	and	a5,s2,3
4200ebb2:	ffe9                	bnez	a5,4200eb8c <sched_set_name+0x3c>
4200ebb4:	57f1                	li	a5,-4
4200ebb6:	fcf97be3          	bgeu	s2,a5,4200eb8c <sched_set_name+0x3c>
4200ebba:	47b1                	li	a5,12
4200ebbc:	00f92223          	sw	a5,4(s2)
4200ebc0:	4791                	li	a5,4
4200ebc2:	00f92023          	sw	a5,0(s2)
#endif
}
4200ebc6:	40b2                	lw	ra,12(sp)
4200ebc8:	4422                	lw	s0,8(sp)
4200ebca:	4492                	lw	s1,4(sp)
4200ebcc:	4902                	lw	s2,0(sp)
4200ebce:	0141                	add	sp,sp,16
4200ebd0:	8082                	ret
    mem_copy(thread->name, name, l);
4200ebd2:	dccd                	beqz	s1,4200eb8c <sched_set_name+0x3c>
4200ebd4:	0034f793          	and	a5,s1,3
4200ebd8:	fbd5                	bnez	a5,4200eb8c <sched_set_name+0x3c>
4200ebda:	e8800793          	li	a5,-376
4200ebde:	faf4f7e3          	bgeu	s1,a5,4200eb8c <sched_set_name+0x3c>
4200ebe2:	8622                	mv	a2,s0
4200ebe4:	85ba                	mv	a1,a4
4200ebe6:	17848513          	add	a0,s1,376
4200ebea:	f82f30ef          	jal	4200236c <mem_copy>
    thread->name[l] = 0;
4200ebee:	17840793          	add	a5,s0,376
4200ebf2:	97a6                	add	a5,a5,s1
4200ebf4:	f897ece3          	bltu	a5,s1,4200eb8c <sched_set_name+0x3c>
4200ebf8:	94a2                	add	s1,s1,s0
4200ebfa:	16048c23          	sb	zero,376(s1)
}
4200ebfe:	40b2                	lw	ra,12(sp)
4200ec00:	4422                	lw	s0,8(sp)
4200ec02:	4492                	lw	s1,4(sp)
4200ec04:	4902                	lw	s2,0(sp)
4200ec06:	0141                	add	sp,sp,16
4200ec08:	8082                	ret

4200ec0a <sched_get_name>:

char const *sched_get_name(sched_thread_t *thread) {
#if NDEBUG
    return "<optimized out>";
#else
    return thread->name;
4200ec0a:	c919                	beqz	a0,4200ec20 <sched_get_name+0x16>
4200ec0c:	00357793          	and	a5,a0,3
4200ec10:	eb81                	bnez	a5,4200ec20 <sched_get_name+0x16>
4200ec12:	e8800793          	li	a5,-376
4200ec16:	00f57563          	bgeu	a0,a5,4200ec20 <sched_get_name+0x16>
#endif
}
4200ec1a:	17850513          	add	a0,a0,376
4200ec1e:	8082                	ret
    return thread->name;
4200ec20:	9002                	ebreak

4200ec22 <__syscall_handler>:

// Shutdown system call implementation.
extern void syscall_sys_shutdown(bool is_reboot);

// System call handler jump table thing.
__SYSCALL_HANDLER_SIGNATURE {
4200ec22:	1101                	add	sp,sp,-32
4200ec24:	cc22                	sw	s0,24(sp)
4200ec26:	ca26                	sw	s1,20(sp)
4200ec28:	ce06                	sw	ra,28(sp)
4200ec2a:	c84a                	sw	s2,16(sp)
    __SYSCALL_HANDLER_IGNORE_UNUSED;

    long long retval = 0;
    switch (sysnum) {
4200ec2c:	30400713          	li	a4,772
__SYSCALL_HANDLER_SIGNATURE {
4200ec30:	842a                	mv	s0,a0
4200ec32:	84ae                	mv	s1,a1
    switch (sysnum) {
4200ec34:	03174f63          	blt	a4,a7,4200ec72 <__syscall_handler+0x50>
4200ec38:	2ff00713          	li	a4,767
4200ec3c:	03175063          	bge	a4,a7,4200ec5c <__syscall_handler+0x3a>
4200ec40:	cff88893          	add	a7,a7,-769 # 40809cff <__stack_bottom+0x1edf>
4200ec44:	470d                	li	a4,3
4200ec46:	09176f63          	bltu	a4,a7,4200ece4 <__syscall_handler+0xc2>
4200ec4a:	42017737          	lui	a4,0x42017
4200ec4e:	bfc70713          	add	a4,a4,-1028 # 42016bfc <__func__.2+0xc>
4200ec52:	088a                	sll	a7,a7,0x2
4200ec54:	98ba                	add	a7,a7,a4
4200ec56:	0008a703          	lw	a4,0(a7)
4200ec5a:	8702                	jr	a4
4200ec5c:	10000793          	li	a5,256
4200ec60:	06f88f63          	beq	a7,a5,4200ecde <__syscall_handler+0xbc>
4200ec64:	20000793          	li	a5,512
4200ec68:	08f89363          	bne	a7,a5,4200ecee <__syscall_handler+0xcc>
            mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
            rawprint_substr((char const *)a0, (size_t)a1);
            mutex_release(NULL, &log_mtx);
            break;
        case SYSCALL_THREAD_YIELD: sched_yield(); break;
        case SYSCALL_SELF_EXIT: syscall_self_exit(a0); break;
4200ec6c:	b97fd0ef          	jal	4200c802 <syscall_self_exit>
4200ec70:	a825                	j	4200eca8 <__syscall_handler+0x86>
    switch (sysnum) {
4200ec72:	40000793          	li	a5,1024
4200ec76:	04f88663          	beq	a7,a5,4200ecc2 <__syscall_handler+0xa0>
4200ec7a:	67c1                	lui	a5,0x10
4200ec7c:	f0078793          	add	a5,a5,-256 # ff00 <__stack_size+0xdf00>
4200ec80:	06f89763          	bne	a7,a5,4200ecee <__syscall_handler+0xcc>
            mutex_acquire(NULL, &log_mtx, TIMESTAMP_US_MAX);
4200ec84:	800006b7          	lui	a3,0x80000
4200ec88:	567d                	li	a2,-1
4200ec8a:	16fd                	add	a3,a3,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
4200ec8c:	0b818593          	add	a1,gp,184 # 408000b8 <log_mtx>
4200ec90:	4501                	li	a0,0
4200ec92:	9e1f40ef          	jal	42003672 <mutex_acquire>
            rawprint_substr((char const *)a0, (size_t)a1);
4200ec96:	85a6                	mv	a1,s1
4200ec98:	8522                	mv	a0,s0
4200ec9a:	5dc010ef          	jal	42010276 <rawprint_substr>
            mutex_release(NULL, &log_mtx);
4200ec9e:	0b818593          	add	a1,gp,184 # 408000b8 <log_mtx>
4200eca2:	4501                	li	a0,0
4200eca4:	b61f40ef          	jal	42003804 <mutex_release>
    long long retval = 0;
4200eca8:	4501                	li	a0,0
4200ecaa:	4581                	li	a1,0
        case SYSCALL_FS_READ: retval = syscall_fs_read(a0, (void *)a1, a2); break;
        case SYSCALL_FS_WRITE: retval = syscall_fs_write(a0, (void const *)a1, a2); break;
        case SYSCALL_FS_GETDENTS: retval = syscall_fs_getdents(a0, (void *)a1, a2); break;
        default: invalid_syscall(sysnum); break;
    }
    __syscall_return(retval);
4200ecac:	2641                	jal	4200f02c <__syscall_return>
        case SYSCALL_FS_WRITE: retval = syscall_fs_write(a0, (void const *)a1, a2); break;
4200ecae:	d27f90ef          	jal	420089d4 <syscall_fs_write>
4200ecb2:	41f55593          	sra	a1,a0,0x1f
4200ecb6:	bfdd                	j	4200ecac <__syscall_handler+0x8a>
        case SYSCALL_FS_GETDENTS: retval = syscall_fs_getdents(a0, (void *)a1, a2); break;
4200ecb8:	d63f90ef          	jal	42008a1a <syscall_fs_getdents>
4200ecbc:	41f55593          	sra	a1,a0,0x1f
4200ecc0:	b7f5                	j	4200ecac <__syscall_handler+0x8a>
        case SYSCALL_SYS_SHUTDOWN: syscall_sys_shutdown(a0); break;
4200ecc2:	00a03533          	snez	a0,a0
4200ecc6:	e56fe0ef          	jal	4200d31c <syscall_sys_shutdown>
4200ecca:	bff9                	j	4200eca8 <__syscall_handler+0x86>
        case SYSCALL_FS_READ: retval = syscall_fs_read(a0, (void *)a1, a2); break;
4200eccc:	cc3f90ef          	jal	4200898e <syscall_fs_read>
4200ecd0:	41f55593          	sra	a1,a0,0x1f
4200ecd4:	bfe1                	j	4200ecac <__syscall_handler+0x8a>
        case SYSCALL_FS_CLOSE: retval = syscall_fs_close(a0); break;
4200ecd6:	c69f90ef          	jal	4200893e <syscall_fs_close>
4200ecda:	4581                	li	a1,0
4200ecdc:	bfc1                	j	4200ecac <__syscall_handler+0x8a>
        case SYSCALL_THREAD_YIELD: sched_yield(); break;
4200ecde:	8d7ff0ef          	jal	4200e5b4 <sched_yield>
4200ece2:	b7d9                	j	4200eca8 <__syscall_handler+0x86>
        case SYSCALL_FS_OPEN: retval = syscall_fs_open((char const *)a0, a1, a2); break;
4200ece4:	c07f90ef          	jal	420088ea <syscall_fs_open>
4200ece8:	41f55593          	sra	a1,a0,0x1f
4200ecec:	b7c1                	j	4200ecac <__syscall_handler+0x8a>
    rawprint("Invalid syscall ");
4200ecee:	4201b537          	lui	a0,0x4201b
4200ecf2:	e0050513          	add	a0,a0,-512 # 4201ae00 <hextab+0x4134>
4200ecf6:	c646                	sw	a7,12(sp)
4200ecf8:	586010ef          	jal	4201027e <rawprint>
    rawprintdec(sysno, 0);
4200ecfc:	48b2                	lw	a7,12(sp)
4200ecfe:	4601                	li	a2,0
4200ed00:	34002473          	csrr	s0,mscratch
4200ed04:	8546                	mv	a0,a7
4200ed06:	41f8d593          	sra	a1,a7,0x1f
4200ed0a:	6ca010ef          	jal	420103d4 <rawprintdec>
    rawprint(" at PC 0x");
4200ed0e:	4201b537          	lui	a0,0x4201b
4200ed12:	e1450513          	add	a0,a0,-492 # 4201ae14 <hextab+0x4148>
4200ed16:	568010ef          	jal	4201027e <rawprint>
    rawprinthex(ctx->regs.pc, sizeof(ctx->regs.pc) * 2);
4200ed1a:	c805                	beqz	s0,4200ed4a <__syscall_handler+0x128>
4200ed1c:	00347793          	and	a5,s0,3
4200ed20:	e78d                	bnez	a5,4200ed4a <__syscall_handler+0x128>
4200ed22:	5781                	li	a5,-32
4200ed24:	02f47363          	bgeu	s0,a5,4200ed4a <__syscall_handler+0x128>
4200ed28:	5008                	lw	a0,32(s0)
4200ed2a:	4621                	li	a2,8
4200ed2c:	4581                	li	a1,0
4200ed2e:	5b6010ef          	jal	420102e4 <rawprinthex>
    rawprint("\n");
4200ed32:	4201b537          	lui	a0,0x4201b
4200ed36:	e2050513          	add	a0,a0,-480 # 4201ae20 <hextab+0x4154>
4200ed3a:	544010ef          	jal	4201027e <rawprint>
    isr_ctx_dump(ctx);
4200ed3e:	8522                	mv	a0,s0
4200ed40:	2925                	jal	4200f178 <isr_ctx_dump>
    proc_exit_self(-1);
4200ed42:	557d                	li	a0,-1
4200ed44:	c78fc0ef          	jal	4200b1bc <proc_exit_self>
}
4200ed48:	b785                	j	4200eca8 <__syscall_handler+0x86>
    rawprinthex(ctx->regs.pc, sizeof(ctx->regs.pc) * 2);
4200ed4a:	9002                	ebreak

4200ed4c <proc_riscv_pmp_gen>:
// Generate RISC-V PMP configurations cache for a given process.
// Returns `true` if the memory map can be represented with the configured amount of PMPs.
bool proc_riscv_pmp_gen(proc_memmap_t *memmap) {
    // TODO.
    (void)memmap;
    logkf(LOG_DEBUG, "Memory map: %{size;d} regions:", memmap->regions_len);
4200ed4c:	10050163          	beqz	a0,4200ee4e <proc_riscv_pmp_gen+0x102>
bool proc_riscv_pmp_gen(proc_memmap_t *memmap) {
4200ed50:	1101                	add	sp,sp,-32
4200ed52:	cc22                	sw	s0,24(sp)
4200ed54:	ce06                	sw	ra,28(sp)
4200ed56:	c452                	sw	s4,8(sp)
4200ed58:	c256                	sw	s5,4(sp)
    logkf(LOG_DEBUG, "Memory map: %{size;d} regions:", memmap->regions_len);
4200ed5a:	00357793          	and	a5,a0,3
4200ed5e:	842a                	mv	s0,a0
4200ed60:	e3f5                	bnez	a5,4200ee44 <proc_riscv_pmp_gen+0xf8>
4200ed62:	fd800793          	li	a5,-40
4200ed66:	0cf57a63          	bgeu	a0,a5,4200ee3a <proc_riscv_pmp_gen+0xee>
4200ed6a:	5510                	lw	a2,40(a0)
4200ed6c:	4201b5b7          	lui	a1,0x4201b
4200ed70:	e2458593          	add	a1,a1,-476 # 4201ae24 <hextab+0x4158>
4200ed74:	4511                	li	a0,4
4200ed76:	d24f40ef          	jal	4200329a <logkf>
    for (size_t i = 0; i < memmap->regions_len; i++) {
4200ed7a:	541c                	lw	a5,40(s0)
4200ed7c:	8a22                	mv	s4,s0
4200ed7e:	4a81                	li	s5,0
4200ed80:	c7d5                	beqz	a5,4200ee2c <proc_riscv_pmp_gen+0xe0>
4200ed82:	ca26                	sw	s1,20(sp)
4200ed84:	c84a                	sw	s2,16(sp)
4200ed86:	03000493          	li	s1,48
4200ed8a:	02c00913          	li	s2,44
4200ed8e:	c64e                	sw	s3,12(sp)
4200ed90:	c05a                	sw	s6,0(sp)
4200ed92:	40890933          	sub	s2,s2,s0
4200ed96:	8c81                	sub	s1,s1,s0
            LOG_DEBUG,
            "%{size;d}: 0x%{size;x} - 0x%{size;x} r%{c}%{c}",
            i,
            memmap->regions[i].base,
            memmap->regions[i].base + memmap->regions[i].size,
            memmap->regions[i].write ? 'w' : '-',
4200ed98:	4b05                	li	s6,1
        logkf(
4200ed9a:	4201b9b7          	lui	s3,0x4201b
4200ed9e:	a0a5                	j	4200ee06 <proc_riscv_pmp_gen+0xba>
4200eda0:	0687eb63          	bltu	a5,s0,4200ee16 <proc_riscv_pmp_gen+0xca>
4200eda4:	02ca2683          	lw	a3,44(s4)
            memmap->regions[i].base + memmap->regions[i].size,
4200eda8:	06074b63          	bltz	a4,4200ee1e <proc_riscv_pmp_gen+0xd2>
4200edac:	0687eb63          	bltu	a5,s0,4200ee22 <proc_riscv_pmp_gen+0xd6>
4200edb0:	014487b3          	add	a5,s1,s4
4200edb4:	00f40733          	add	a4,s0,a5
4200edb8:	0607c063          	bltz	a5,4200ee18 <proc_riscv_pmp_gen+0xcc>
4200edbc:	06876063          	bltu	a4,s0,4200ee1c <proc_riscv_pmp_gen+0xd0>
        logkf(
4200edc0:	030a2703          	lw	a4,48(s4)
            memmap->regions[i].write ? 'w' : '-',
4200edc4:	034a4783          	lbu	a5,52(s4)
        logkf(
4200edc8:	9736                	add	a4,a4,a3
            memmap->regions[i].write ? 'w' : '-',
4200edca:	08fb6363          	bltu	s6,a5,4200ee50 <proc_riscv_pmp_gen+0x104>
        logkf(
4200edce:	8b85                	and	a5,a5,1
            memmap->regions[i].exec ? 'x' : '-'
4200edd0:	035a4803          	lbu	a6,53(s4)
        logkf(
4200edd4:	17fd                	add	a5,a5,-1
4200edd6:	fb67f793          	and	a5,a5,-74
4200edda:	07778793          	add	a5,a5,119
            memmap->regions[i].exec ? 'x' : '-'
4200edde:	070b6963          	bltu	s6,a6,4200ee50 <proc_riscv_pmp_gen+0x104>
        logkf(
4200ede2:	00187813          	and	a6,a6,1
4200ede6:	187d                	add	a6,a6,-1
4200ede8:	fb587813          	and	a6,a6,-75
4200edec:	8656                	mv	a2,s5
4200edee:	07880813          	add	a6,a6,120
4200edf2:	e4498593          	add	a1,s3,-444 # 4201ae44 <hextab+0x4178>
4200edf6:	4511                	li	a0,4
4200edf8:	ca2f40ef          	jal	4200329a <logkf>
    for (size_t i = 0; i < memmap->regions_len; i++) {
4200edfc:	541c                	lw	a5,40(s0)
4200edfe:	0a85                	add	s5,s5,1
4200ee00:	0a31                	add	s4,s4,12
4200ee02:	02faf163          	bgeu	s5,a5,4200ee24 <proc_riscv_pmp_gen+0xd8>
        logkf(
4200ee06:	01490733          	add	a4,s2,s4
4200ee0a:	00e407b3          	add	a5,s0,a4
4200ee0e:	f80759e3          	bgez	a4,4200eda0 <proc_riscv_pmp_gen+0x54>
4200ee12:	f8f479e3          	bgeu	s0,a5,4200eda4 <proc_riscv_pmp_gen+0x58>
4200ee16:	9002                	ebreak
            memmap->regions[i].base + memmap->regions[i].size,
4200ee18:	fae474e3          	bgeu	s0,a4,4200edc0 <proc_riscv_pmp_gen+0x74>
4200ee1c:	9002                	ebreak
4200ee1e:	f8f479e3          	bgeu	s0,a5,4200edb0 <proc_riscv_pmp_gen+0x64>
4200ee22:	9002                	ebreak
4200ee24:	44d2                	lw	s1,20(sp)
4200ee26:	4942                	lw	s2,16(sp)
4200ee28:	49b2                	lw	s3,12(sp)
4200ee2a:	4b02                	lw	s6,0(sp)
        );
    }
    return true;
}
4200ee2c:	40f2                	lw	ra,28(sp)
4200ee2e:	4462                	lw	s0,24(sp)
4200ee30:	4a22                	lw	s4,8(sp)
4200ee32:	4a92                	lw	s5,4(sp)
4200ee34:	4505                	li	a0,1
4200ee36:	6105                	add	sp,sp,32
4200ee38:	8082                	ret
4200ee3a:	ca26                	sw	s1,20(sp)
4200ee3c:	c84a                	sw	s2,16(sp)
4200ee3e:	c64e                	sw	s3,12(sp)
4200ee40:	c05a                	sw	s6,0(sp)
    logkf(LOG_DEBUG, "Memory map: %{size;d} regions:", memmap->regions_len);
4200ee42:	9002                	ebreak
4200ee44:	ca26                	sw	s1,20(sp)
4200ee46:	c84a                	sw	s2,16(sp)
4200ee48:	c64e                	sw	s3,12(sp)
4200ee4a:	c05a                	sw	s6,0(sp)
4200ee4c:	9002                	ebreak
4200ee4e:	9002                	ebreak
            memmap->regions[i].write ? 'w' : '-',
4200ee50:	9002                	ebreak

4200ee52 <proc_riscv_pmp_swap>:

// Swap in RISC-V PMP configurations for a given process.
void proc_riscv_pmp_swap(proc_memmap_t const *memmap) {
    // TODO.
    (void)memmap;
}
4200ee52:	8082                	ret

4200ee54 <kill_proc_on_trap>:

// Bitmask of traps that have associated memory addresses.
#define MEM_ADDR_TRAPS 0x00050f0

// Kill a process from a trap / ISR.
static void kill_proc_on_trap() {
4200ee54:	1141                	add	sp,sp,-16
    proc_exit_self(-1);
4200ee56:	557d                	li	a0,-1
static void kill_proc_on_trap() {
4200ee58:	c606                	sw	ra,12(sp)
    proc_exit_self(-1);
4200ee5a:	b62fc0ef          	jal	4200b1bc <proc_exit_self>
    asm volatile("csrrc %0, mstatus, %1" : "=r"(mstatus) : "r"((1U << RV32_MSTATUS_MIE_BIT)));
4200ee5e:	47a1                	li	a5,8
4200ee60:	3007b7f3          	csrrc	a5,mstatus,a5
    isr_global_disable();
    sched_lower_from_isr();
4200ee64:	7d2000ef          	jal	4200f636 <sched_lower_from_isr>
    isr_context_switch();
4200ee68:	e18f10ef          	jal	42000480 <isr_context_switch>
    __builtin_unreachable();
4200ee6c:	9002                	ebreak

4200ee6e <__trap_handler>:
}

// Called from ASM on non-system call trap.
void __trap_handler() {
4200ee6e:	1141                	add	sp,sp,-16
4200ee70:	c606                	sw	ra,12(sp)
4200ee72:	c422                	sw	s0,8(sp)
4200ee74:	c226                	sw	s1,4(sp)
    uint32_t mcause, mstatus, mtval, mepc;
    asm volatile("csrr %0, mstatus" : "=r"(mstatus));
4200ee76:	300024f3          	csrr	s1,mstatus
    asm volatile("csrr %0, mcause" : "=r"(mcause));
4200ee7a:	34202473          	csrr	s0,mcause

    if (mcause == RV_TRAP_U_ECALL) {
4200ee7e:	47a1                	li	a5,8
4200ee80:	18f40263          	beq	s0,a5,4200f004 <__trap_handler+0x196>
4200ee84:	c04a                	sw	s2,0(sp)
        sched_raise_from_isr(true, __syscall_handler);
        return;
    }

    // Print trap name.
    if (mcause < TRAPNAMES_LEN && trapnames[mcause]) {
4200ee86:	47bd                	li	a5,15
4200ee88:	0487e663          	bltu	a5,s0,4200eed4 <__trap_handler+0x66>
4200ee8c:	47c1                	li	a5,16
4200ee8e:	18f47963          	bgeu	s0,a5,4200f020 <__trap_handler+0x1b2>
4200ee92:	00241713          	sll	a4,s0,0x2
4200ee96:	420177b7          	lui	a5,0x42017
4200ee9a:	c0c78793          	add	a5,a5,-1012 # 42016c0c <trapnames>
4200ee9e:	00470613          	add	a2,a4,4
4200eea2:	04000693          	li	a3,64
4200eea6:	00e785b3          	add	a1,a5,a4
4200eeaa:	16c6e763          	bltu	a3,a2,4200f018 <__trap_handler+0x1aa>
4200eeae:	00e786b3          	add	a3,a5,a4
4200eeb2:	16f6e763          	bltu	a3,a5,4200f020 <__trap_handler+0x1b2>
4200eeb6:	4288                	lw	a0,0(a3)
4200eeb8:	cd11                	beqz	a0,4200eed4 <__trap_handler+0x66>
        rawprint(trapnames[mcause]);
4200eeba:	46c1                	li	a3,16
4200eebc:	16d47263          	bgeu	s0,a3,4200f020 <__trap_handler+0x1b2>
4200eec0:	04000693          	li	a3,64
4200eec4:	16c6e063          	bltu	a3,a2,4200f024 <__trap_handler+0x1b6>
4200eec8:	973e                	add	a4,a4,a5
4200eeca:	14f76b63          	bltu	a4,a5,4200f020 <__trap_handler+0x1b2>
4200eece:	3b0010ef          	jal	4201027e <rawprint>
4200eed2:	a821                	j	4200eeea <__trap_handler+0x7c>
    } else {
        rawprint("Trap 0x");
4200eed4:	4201b537          	lui	a0,0x4201b
4200eed8:	e7450513          	add	a0,a0,-396 # 4201ae74 <hextab+0x41a8>
4200eedc:	3a2010ef          	jal	4201027e <rawprint>
        rawprinthex(mcause, 8);
4200eee0:	4621                	li	a2,8
4200eee2:	8522                	mv	a0,s0
4200eee4:	4581                	li	a1,0
4200eee6:	3fe010ef          	jal	420102e4 <rawprinthex>
    }

    // Print PC.
    asm volatile("csrr %0, mepc" : "=r"(mepc));
4200eeea:	34102973          	csrr	s2,mepc
    rawprint(" at PC 0x");
4200eeee:	4201b537          	lui	a0,0x4201b
4200eef2:	e1450513          	add	a0,a0,-492 # 4201ae14 <hextab+0x4148>
4200eef6:	388010ef          	jal	4201027e <rawprint>
    rawprinthex(mepc, 8);
4200eefa:	4621                	li	a2,8
4200eefc:	854a                	mv	a0,s2
4200eefe:	4581                	li	a1,0
4200ef00:	3e4010ef          	jal	420102e4 <rawprinthex>

    // Print trap value.
    asm volatile("csrr %0, mtval" : "=r"(mtval));
4200ef04:	34302973          	csrr	s2,mtval
    if (mtval && ((1 << mcause) & MEM_ADDR_TRAPS)) {
4200ef08:	02090563          	beqz	s2,4200ef32 <__trap_handler+0xc4>
4200ef0c:	477d                	li	a4,31
4200ef0e:	8f01                	sub	a4,a4,s0
4200ef10:	4785                	li	a5,1
4200ef12:	00e7d7b3          	srl	a5,a5,a4
4200ef16:	8b85                	and	a5,a5,1
4200ef18:	10079463          	bnez	a5,4200f020 <__trap_handler+0x1b2>
4200ef1c:	02043793          	sltiu	a5,s0,32
4200ef20:	10078063          	beqz	a5,4200f020 <__trap_handler+0x1b2>
4200ef24:	6795                	lui	a5,0x5
4200ef26:	0f078793          	add	a5,a5,240 # 50f0 <__stack_size+0x30f0>
4200ef2a:	4087d7b3          	sra	a5,a5,s0
4200ef2e:	8b85                	and	a5,a5,1
4200ef30:	efd5                	bnez	a5,4200efec <__trap_handler+0x17e>
        rawprint(" while accessing 0x");
        rawprinthex(mtval, 8);
    }

    rawputc('\r');
4200ef32:	4535                	li	a0,13
4200ef34:	234010ef          	jal	42010168 <rawputc>
    rawputc('\n');
4200ef38:	4529                	li	a0,10
4200ef3a:	22e010ef          	jal	42010168 <rawputc>

    // Print privilige mode.
    if (mstatus & (3 << RV32_MSTATUS_MPP_BASE_BIT)) {
4200ef3e:	6789                	lui	a5,0x2
4200ef40:	80078793          	add	a5,a5,-2048 # 1800 <isr_ctx_t_is_kernel_thread+0x1758>
4200ef44:	8cfd                	and	s1,s1,a5
4200ef46:	e0ad                	bnez	s1,4200efa8 <__trap_handler+0x13a>
        rawprint("Running in kernel mode");
    } else {
        rawprint("Running in user mode");
4200ef48:	4201b537          	lui	a0,0x4201b
4200ef4c:	ea850513          	add	a0,a0,-344 # 4201aea8 <hextab+0x41dc>
4200ef50:	32e010ef          	jal	4201027e <rawprint>
    }

    isr_ctx_t *kctx;
    asm volatile("csrr %0, mscratch" : "=r"(kctx));
4200ef54:	34002473          	csrr	s0,mscratch

    // Print current process.
    if (!(kctx->thread->flags & THREAD_KERNEL)) {
4200ef58:	c461                	beqz	s0,4200f020 <__trap_handler+0x1b2>
4200ef5a:	00347793          	and	a5,s0,3
4200ef5e:	e3e9                	bnez	a5,4200f020 <__trap_handler+0x1b2>
4200ef60:	f5c00793          	li	a5,-164
4200ef64:	0af47e63          	bgeu	s0,a5,4200f020 <__trap_handler+0x1b2>
4200ef68:	0a442783          	lw	a5,164(s0)
4200ef6c:	cbd5                	beqz	a5,4200f020 <__trap_handler+0x1b2>
4200ef6e:	0037f713          	and	a4,a5,3
4200ef72:	e75d                	bnez	a4,4200f020 <__trap_handler+0x1b2>
4200ef74:	5741                	li	a4,-16
4200ef76:	0ae7f563          	bgeu	a5,a4,4200f020 <__trap_handler+0x1b2>
4200ef7a:	4b9c                	lw	a5,16(a5)
4200ef7c:	8ba1                	and	a5,a5,8
4200ef7e:	cf85                	beqz	a5,4200efb6 <__trap_handler+0x148>
        rawprint(" in process ");
        rawprintdec(kctx->thread->process->pid, 1);
    }
    rawprint("\n");
4200ef80:	4201b537          	lui	a0,0x4201b
4200ef84:	e2050513          	add	a0,a0,-480 # 4201ae20 <hextab+0x4154>
4200ef88:	2f6010ef          	jal	4201027e <rawprint>

    isr_ctx_dump(kctx);
4200ef8c:	8522                	mv	a0,s0
4200ef8e:	22ed                	jal	4200f178 <isr_ctx_dump>

    if (mstatus & (3 << RV32_MSTATUS_MPP_BASE_BIT)) {
4200ef90:	e8c9                	bnez	s1,4200f022 <__trap_handler+0x1b4>
        panic_poweroff();
    } else {
        // When the user traps just stop the process.
        sched_raise_from_isr(false, kill_proc_on_trap);
    }
}
4200ef92:	4422                	lw	s0,8(sp)
        sched_raise_from_isr(false, kill_proc_on_trap);
4200ef94:	4902                	lw	s2,0(sp)
}
4200ef96:	40b2                	lw	ra,12(sp)
4200ef98:	4492                	lw	s1,4(sp)
        sched_raise_from_isr(false, kill_proc_on_trap);
4200ef9a:	4200f5b7          	lui	a1,0x4200f
4200ef9e:	e5458593          	add	a1,a1,-428 # 4200ee54 <kill_proc_on_trap>
4200efa2:	4501                	li	a0,0
}
4200efa4:	0141                	add	sp,sp,16
        sched_raise_from_isr(false, kill_proc_on_trap);
4200efa6:	a345                	j	4200f546 <sched_raise_from_isr>
        rawprint("Running in kernel mode");
4200efa8:	4201b537          	lui	a0,0x4201b
4200efac:	e9050513          	add	a0,a0,-368 # 4201ae90 <hextab+0x41c4>
4200efb0:	2ce010ef          	jal	4201027e <rawprint>
4200efb4:	b745                	j	4200ef54 <__trap_handler+0xe6>
        rawprint(" in process ");
4200efb6:	4201b537          	lui	a0,0x4201b
4200efba:	ec050513          	add	a0,a0,-320 # 4201aec0 <hextab+0x41f4>
4200efbe:	2c0010ef          	jal	4201027e <rawprint>
        rawprintdec(kctx->thread->process->pid, 1);
4200efc2:	0a442783          	lw	a5,164(s0)
4200efc6:	cfa9                	beqz	a5,4200f020 <__trap_handler+0x1b2>
4200efc8:	0037f713          	and	a4,a5,3
4200efcc:	eb31                	bnez	a4,4200f020 <__trap_handler+0x1b2>
4200efce:	439c                	lw	a5,0(a5)
4200efd0:	cba1                	beqz	a5,4200f020 <__trap_handler+0x1b2>
4200efd2:	0037f713          	and	a4,a5,3
4200efd6:	e729                	bnez	a4,4200f020 <__trap_handler+0x1b2>
4200efd8:	5721                	li	a4,-24
4200efda:	04e7f363          	bgeu	a5,a4,4200f020 <__trap_handler+0x1b2>
4200efde:	4f88                	lw	a0,24(a5)
4200efe0:	4605                	li	a2,1
4200efe2:	41f55593          	sra	a1,a0,0x1f
4200efe6:	3ee010ef          	jal	420103d4 <rawprintdec>
4200efea:	bf59                	j	4200ef80 <__trap_handler+0x112>
        rawprint(" while accessing 0x");
4200efec:	4201b537          	lui	a0,0x4201b
4200eff0:	e7c50513          	add	a0,a0,-388 # 4201ae7c <hextab+0x41b0>
4200eff4:	28a010ef          	jal	4201027e <rawprint>
        rawprinthex(mtval, 8);
4200eff8:	4621                	li	a2,8
4200effa:	854a                	mv	a0,s2
4200effc:	4581                	li	a1,0
4200effe:	2e6010ef          	jal	420102e4 <rawprinthex>
4200f002:	bf05                	j	4200ef32 <__trap_handler+0xc4>
}
4200f004:	4422                	lw	s0,8(sp)
4200f006:	40b2                	lw	ra,12(sp)
4200f008:	4492                	lw	s1,4(sp)
        sched_raise_from_isr(true, __syscall_handler);
4200f00a:	4200f5b7          	lui	a1,0x4200f
4200f00e:	c2258593          	add	a1,a1,-990 # 4200ec22 <__syscall_handler>
4200f012:	4505                	li	a0,1
}
4200f014:	0141                	add	sp,sp,16
        sched_raise_from_isr(false, kill_proc_on_trap);
4200f016:	ab05                	j	4200f546 <sched_raise_from_isr>
    if (mcause < TRAPNAMES_LEN && trapnames[mcause]) {
4200f018:	00c586b3          	add	a3,a1,a2
4200f01c:	e8b6e9e3          	bltu	a3,a1,4200eeae <__trap_handler+0x40>
        rawprintdec(kctx->thread->process->pid, 1);
4200f020:	9002                	ebreak
        panic_poweroff();
4200f022:	22bd                	jal	4200f190 <panic_poweroff>
        rawprint(trapnames[mcause]);
4200f024:	962e                	add	a2,a2,a1
4200f026:	eab661e3          	bltu	a2,a1,4200eec8 <__trap_handler+0x5a>
        rawprintdec(kctx->thread->process->pid, 1);
4200f02a:	9002                	ebreak

4200f02c <__syscall_return>:
4200f02c:	47a1                	li	a5,8
4200f02e:	3007b7f3          	csrrc	a5,mstatus,a5
4200f032:	340027f3          	csrr	a5,mscratch

// Return a value from the syscall handler.
void __syscall_return(long long value) {
    isr_global_disable();
    isr_ctx_t *usr  = &isr_ctx_get()->thread->user_isr_ctx;
4200f036:	cfb9                	beqz	a5,4200f094 <__syscall_return+0x68>
4200f038:	0037f713          	and	a4,a5,3
4200f03c:	ef21                	bnez	a4,4200f094 <__syscall_return+0x68>
4200f03e:	f5c00713          	li	a4,-164
4200f042:	04e7ff63          	bgeu	a5,a4,4200f0a0 <__syscall_return+0x74>
4200f046:	0a47a783          	lw	a5,164(a5)
4200f04a:	cbb1                	beqz	a5,4200f09e <__syscall_return+0x72>
4200f04c:	0037f713          	and	a4,a5,3
4200f050:	e739                	bnez	a4,4200f09e <__syscall_return+0x72>
4200f052:	f3400713          	li	a4,-204
4200f056:	04e7f363          	bgeu	a5,a4,4200f09c <__syscall_return+0x70>
4200f05a:	0cc78713          	add	a4,a5,204
    usr->regs.a0    = value;
4200f05e:	cf15                	beqz	a4,4200f09a <__syscall_return+0x6e>
4200f060:	00377693          	and	a3,a4,3
4200f064:	ea9d                	bnez	a3,4200f09a <__syscall_return+0x6e>
4200f066:	fb800693          	li	a3,-72
4200f06a:	02d77763          	bgeu	a4,a3,4200f098 <__syscall_return+0x6c>
4200f06e:	10a7aa23          	sw	a0,276(a5)
    usr->regs.a1    = value >> 32;
4200f072:	fb400693          	li	a3,-76
4200f076:	02d77063          	bgeu	a4,a3,4200f096 <__syscall_return+0x6a>
    usr->regs.pc   += 4;
4200f07a:	0ec7a703          	lw	a4,236(a5)
void __syscall_return(long long value) {
4200f07e:	1141                	add	sp,sp,-16
4200f080:	c606                	sw	ra,12(sp)
    usr->regs.pc   += 4;
4200f082:	0711                	add	a4,a4,4
    usr->regs.a1    = value >> 32;
4200f084:	10b7ac23          	sw	a1,280(a5)
    usr->regs.pc   += 4;
4200f088:	0ee7a623          	sw	a4,236(a5)
    sched_lower_from_isr();
4200f08c:	236d                	jal	4200f636 <sched_lower_from_isr>
    isr_context_switch();
4200f08e:	bf2f10ef          	jal	42000480 <isr_context_switch>
    __builtin_unreachable();
4200f092:	9002                	ebreak
    isr_ctx_t *usr  = &isr_ctx_get()->thread->user_isr_ctx;
4200f094:	9002                	ebreak
    usr->regs.a1    = value >> 32;
4200f096:	9002                	ebreak
    usr->regs.a0    = value;
4200f098:	9002                	ebreak
4200f09a:	9002                	ebreak
    isr_ctx_t *usr  = &isr_ctx_get()->thread->user_isr_ctx;
4200f09c:	9002                	ebreak
4200f09e:	9002                	ebreak
4200f0a0:	9002                	ebreak

4200f0a2 <kernel_reg_dump_arr>:
    "PC ", "RA ", "SP ", "GP ", "TP ", "T0 ", "T1 ", "T2 ", "S0 ", "S1 ", "A0 ", "A1 ", "A2 ", "A3 ", "A4 ", "A5 ",
    "A6 ", "A7 ", "S2 ", "S3 ", "S4 ", "S5 ", "S6 ", "S7 ", "S8 ", "S9 ", "S10", "S11", "T3 ", "T4 ", "T5 ", "T6 ",
};

// Print a register dump given cpu_regs_t.
void kernel_reg_dump_arr(uint32_t const *arr) {
4200f0a2:	7139                	add	sp,sp,-64
4200f0a4:	d452                	sw	s4,40(sp)
4200f0a6:	8a2a                	mv	s4,a0
    // Print all registers.
    rawprint("Register dump:\n");
4200f0a8:	4201b537          	lui	a0,0x4201b
void kernel_reg_dump_arr(uint32_t const *arr) {
4200f0ac:	ca66                	sw	s9,20(sp)
    rawprint("Register dump:\n");
4200f0ae:	00050513          	mv	a0,a0
4200f0b2:	42017cb7          	lui	s9,0x42017
void kernel_reg_dump_arr(uint32_t const *arr) {
4200f0b6:	d256                	sw	s5,36(sp)
4200f0b8:	d05a                	sw	s6,32(sp)
4200f0ba:	ce5e                	sw	s7,28(sp)
4200f0bc:	cc62                	sw	s8,24(sp)
4200f0be:	c86a                	sw	s10,16(sp)
4200f0c0:	c66e                	sw	s11,12(sp)
4200f0c2:	de06                	sw	ra,60(sp)
4200f0c4:	dc22                	sw	s0,56(sp)
4200f0c6:	da26                	sw	s1,52(sp)
4200f0c8:	d84a                	sw	s2,48(sp)
4200f0ca:	d64e                	sw	s3,44(sp)
4200f0cc:	c4cc8a93          	add	s5,s9,-948 # 42016c4c <regnames>
    rawprint("Register dump:\n");
4200f0d0:	1ae010ef          	jal	4201027e <rawprint>
    for (int y = 0; y < 32; y += COLS) {
4200f0d4:	c4cc8c93          	add	s9,s9,-948
4200f0d8:	8d52                	mv	s10,s4
    rawprint("Register dump:\n");
4200f0da:	4b11                	li	s6,4
        for (int x = 0; x < COLS; x++) {
            rawputc(' ');
            rawputc(' ');
            rawprint(regnames[y + x]);
4200f0dc:	02100c13          	li	s8,33
            rawprint(" 0x");
4200f0e0:	4201bbb7          	lui	s7,0x4201b
    for (int y = 0; y < 32; y += COLS) {
4200f0e4:	02400d93          	li	s11,36
        for (int x = 0; x < COLS; x++) {
4200f0e8:	ffcb0413          	add	s0,s6,-4
void kernel_reg_dump_arr(uint32_t const *arr) {
4200f0ec:	84ea                	mv	s1,s10
4200f0ee:	89e6                	mv	s3,s9
            rawputc(' ');
4200f0f0:	02000513          	li	a0,32
4200f0f4:	074010ef          	jal	42010168 <rawputc>
            rawputc(' ');
4200f0f8:	02000513          	li	a0,32
4200f0fc:	06c010ef          	jal	42010168 <rawputc>
            rawprint(regnames[y + x]);
4200f100:	07847b63          	bgeu	s0,s8,4200f176 <kernel_reg_dump_arr+0xd4>
4200f104:	00241913          	sll	s2,s0,0x2
4200f108:	012a87b3          	add	a5,s5,s2
4200f10c:	0757e563          	bltu	a5,s5,4200f176 <kernel_reg_dump_arr+0xd4>
4200f110:	854e                	mv	a0,s3
4200f112:	16c010ef          	jal	4201027e <rawprint>
            rawprint(" 0x");
4200f116:	010b8513          	add	a0,s7,16 # 4201b010 <hextab+0x4344>
            rawprinthex(arr[y + x], 8);
4200f11a:	9952                	add	s2,s2,s4
            rawprint(" 0x");
4200f11c:	162010ef          	jal	4201027e <rawprint>
            rawprinthex(arr[y + x], 8);
4200f120:	05496b63          	bltu	s2,s4,4200f176 <kernel_reg_dump_arr+0xd4>
4200f124:	c8a9                	beqz	s1,4200f176 <kernel_reg_dump_arr+0xd4>
4200f126:	0034f793          	and	a5,s1,3
4200f12a:	e7b1                	bnez	a5,4200f176 <kernel_reg_dump_arr+0xd4>
4200f12c:	4088                	lw	a0,0(s1)
4200f12e:	4621                	li	a2,8
4200f130:	4581                	li	a1,0
        for (int x = 0; x < COLS; x++) {
4200f132:	0405                	add	s0,s0,1
            rawprinthex(arr[y + x], 8);
4200f134:	1b0010ef          	jal	420102e4 <rawprinthex>
        for (int x = 0; x < COLS; x++) {
4200f138:	0991                	add	s3,s3,4
4200f13a:	0491                	add	s1,s1,4
4200f13c:	fb641ae3          	bne	s0,s6,4200f0f0 <kernel_reg_dump_arr+0x4e>
        }
        rawputc('\r');
4200f140:	4535                	li	a0,13
4200f142:	026010ef          	jal	42010168 <rawputc>
        rawputc('\n');
4200f146:	4529                	li	a0,10
    for (int y = 0; y < 32; y += COLS) {
4200f148:	00440b13          	add	s6,s0,4
        rawputc('\n');
4200f14c:	01c010ef          	jal	42010168 <rawputc>
    for (int y = 0; y < 32; y += COLS) {
4200f150:	0cc1                	add	s9,s9,16
4200f152:	0d41                	add	s10,s10,16
4200f154:	f9bb1ae3          	bne	s6,s11,4200f0e8 <kernel_reg_dump_arr+0x46>
    }
}
4200f158:	50f2                	lw	ra,60(sp)
4200f15a:	5462                	lw	s0,56(sp)
4200f15c:	54d2                	lw	s1,52(sp)
4200f15e:	5942                	lw	s2,48(sp)
4200f160:	59b2                	lw	s3,44(sp)
4200f162:	5a22                	lw	s4,40(sp)
4200f164:	5a92                	lw	s5,36(sp)
4200f166:	5b02                	lw	s6,32(sp)
4200f168:	4bf2                	lw	s7,28(sp)
4200f16a:	4c62                	lw	s8,24(sp)
4200f16c:	4cd2                	lw	s9,20(sp)
4200f16e:	4d42                	lw	s10,16(sp)
4200f170:	4db2                	lw	s11,12(sp)
4200f172:	6121                	add	sp,sp,64
4200f174:	8082                	ret
            rawprinthex(arr[y + x], 8);
4200f176:	9002                	ebreak

4200f178 <isr_ctx_dump>:

// Print a register dump given isr_ctx_t.
void isr_ctx_dump(isr_ctx_t const *ctx) {
    kernel_reg_dump_arr((uint32_t const *)&ctx->regs);
4200f178:	c919                	beqz	a0,4200f18e <isr_ctx_dump+0x16>
4200f17a:	00357793          	and	a5,a0,3
4200f17e:	eb81                	bnez	a5,4200f18e <isr_ctx_dump+0x16>
4200f180:	5781                	li	a5,-32
4200f182:	00f57663          	bgeu	a0,a5,4200f18e <isr_ctx_dump+0x16>
4200f186:	02050513          	add	a0,a0,32 # 4201b020 <hextab+0x4354>
4200f18a:	f19ff06f          	j	4200f0a2 <kernel_reg_dump_arr>
4200f18e:	9002                	ebreak

4200f190 <panic_poweroff>:
}

// Call this function when and only when the kernel has encountered a fatal error.
// Immediately power off or reset the system.
void panic_poweroff() {
    rawprint("**** KERNEL PANIC ****\nhalted\n");
4200f190:	4201b537          	lui	a0,0x4201b
void panic_poweroff() {
4200f194:	1141                	add	sp,sp,-16
    rawprint("**** KERNEL PANIC ****\nhalted\n");
4200f196:	01450513          	add	a0,a0,20 # 4201b014 <hextab+0x4348>
void panic_poweroff() {
4200f19a:	c606                	sw	ra,12(sp)
    rawprint("**** KERNEL PANIC ****\nhalted\n");
4200f19c:	0e2010ef          	jal	4201027e <rawprint>
    asm volatile("csrci mstatus, 0xa");
4200f1a0:	30057073          	csrc	mstatus,10
    while (1) asm volatile("wfi");
4200f1a4:	10500073          	wfi
4200f1a8:	10500073          	wfi
4200f1ac:	bfe5                	j	4200f1a4 <panic_poweroff+0x14>

4200f1ae <panic_abort>:
    logk(LOG_FATAL, "`panic_abort()` called!");
4200f1ae:	4201b5b7          	lui	a1,0x4201b
void panic_abort() {
4200f1b2:	1141                	add	sp,sp,-16
    logk(LOG_FATAL, "`panic_abort()` called!");
4200f1b4:	03458593          	add	a1,a1,52 # 4201b034 <hextab+0x4368>
4200f1b8:	4501                	li	a0,0
void panic_abort() {
4200f1ba:	c606                	sw	ra,12(sp)
    logk(LOG_FATAL, "`panic_abort()` called!");
4200f1bc:	898f40ef          	jal	42003254 <logk>
    kernel_cur_regs_dump();
4200f1c0:	eb2f10ef          	jal	42000872 <kernel_cur_regs_dump>
    panic_poweroff();
4200f1c4:	fcdff0ef          	jal	4200f190 <panic_poweroff>

4200f1c8 <riscv_pmp_init>:

#include "cpu/panic.h"
#include "log.h"

// Initialise memory protection driver.
void riscv_pmp_init() {
4200f1c8:	7179                	add	sp,sp,-48
4200f1ca:	d606                	sw	ra,44(sp)
4200f1cc:	d422                	sw	s0,40(sp)
4200f1ce:	d226                	sw	s1,36(sp)
4200f1d0:	d04a                	sw	s2,32(sp)
4200f1d2:	ce4e                	sw	s3,28(sp)
4200f1d4:	cc52                	sw	s4,24(sp)
// Read all raw PMP configurations.
void riscv_pmpcfg_read_all(riscv_pmpcfg_t cfg_out[RISCV_PMP_REGION_COUNT]) {
    long *word_out = (void *)cfg_out;

#if __riscv_xlen == 32
    asm volatile("csrr %0, pmpcfg0" : "=r"(word_out[0]));
4200f1d6:	3a0027f3          	csrr	a5,pmpcfg0
4200f1da:	c03e                	sw	a5,0(sp)
    asm volatile("csrr %0, pmpcfg1" : "=r"(word_out[1]));
4200f1dc:	3a1027f3          	csrr	a5,pmpcfg1
4200f1e0:	c23e                	sw	a5,4(sp)
    asm volatile("csrr %0, pmpcfg2" : "=r"(word_out[2]));
4200f1e2:	3a2027f3          	csrr	a5,pmpcfg2
4200f1e6:	c43e                	sw	a5,8(sp)
    asm volatile("csrr %0, pmpcfg3" : "=r"(word_out[3]));
4200f1e8:	3a3027f3          	csrr	a5,pmpcfg3
4200f1ec:	890a                	mv	s2,sp
4200f1ee:	c63e                	sw	a5,12(sp)
    for (int i = 0; i < RISCV_PMP_REGION_COUNT; i++) {
4200f1f0:	89ca                	mv	s3,s2
4200f1f2:	4781                	li	a5,0
        if (cfg[i].lock) {
4200f1f4:	4441                	li	s0,16
            logkf(LOG_FATAL, "RISC-V pmp%{d}cfg is locked!");
4200f1f6:	4201ba37          	lui	s4,0x4201b
        if (cfg[i].lock) {
4200f1fa:	0487fe63          	bgeu	a5,s0,4200f256 <riscv_pmp_init+0x8e>
4200f1fe:	00178493          	add	s1,a5,1
4200f202:	04946663          	bltu	s0,s1,4200f24e <riscv_pmp_init+0x86>
4200f206:	00f90733          	add	a4,s2,a5
4200f20a:	05276663          	bltu	a4,s2,4200f256 <riscv_pmp_init+0x8e>
4200f20e:	07c1                	add	a5,a5,16
4200f210:	978a                	add	a5,a5,sp
4200f212:	ff07c783          	lbu	a5,-16(a5)
4200f216:	839d                	srl	a5,a5,0x7
4200f218:	e78d                	bnez	a5,4200f242 <riscv_pmp_init+0x7a>
    for (int i = 0; i < RISCV_PMP_REGION_COUNT; i++) {
4200f21a:	87a6                	mv	a5,s1
4200f21c:	0985                	add	s3,s3,1
4200f21e:	fc849ee3          	bne	s1,s0,4200f1fa <riscv_pmp_init+0x32>
    asm volatile("csrw pmpcfg0, x0");
4200f222:	3a001073          	csrw	pmpcfg0,zero
    asm volatile("csrw pmpcfg1, x0");
4200f226:	3a101073          	csrw	pmpcfg1,zero
    asm volatile("csrw pmpcfg2, x0");
4200f22a:	3a201073          	csrw	pmpcfg2,zero
    asm volatile("csrw pmpcfg3, x0");
4200f22e:	3a301073          	csrw	pmpcfg3,zero
}
4200f232:	50b2                	lw	ra,44(sp)
4200f234:	5422                	lw	s0,40(sp)
4200f236:	5492                	lw	s1,36(sp)
4200f238:	5902                	lw	s2,32(sp)
4200f23a:	49f2                	lw	s3,28(sp)
4200f23c:	4a62                	lw	s4,24(sp)
4200f23e:	6145                	add	sp,sp,48
4200f240:	8082                	ret
            logkf(LOG_FATAL, "RISC-V pmp%{d}cfg is locked!");
4200f242:	04ca0593          	add	a1,s4,76 # 4201b04c <hextab+0x4380>
4200f246:	4501                	li	a0,0
4200f248:	852f40ef          	jal	4200329a <logkf>
4200f24c:	b7f9                	j	4200f21a <riscv_pmp_init+0x52>
        if (cfg[i].lock) {
4200f24e:	00998733          	add	a4,s3,s1
4200f252:	fb376ae3          	bltu	a4,s3,4200f206 <riscv_pmp_init+0x3e>
4200f256:	9002                	ebreak

4200f258 <riscv_pmpcfg_read_all>:
    asm volatile("csrr %0, pmpcfg0" : "=r"(word_out[0]));
4200f258:	3a002773          	csrr	a4,pmpcfg0
    asm volatile("csrr %0, pmpcfg1" : "=r"(word_out[1]));
4200f25c:	57f1                	li	a5,-4
    asm volatile("csrr %0, pmpcfg0" : "=r"(word_out[0]));
4200f25e:	c118                	sw	a4,0(a0)
    asm volatile("csrr %0, pmpcfg1" : "=r"(word_out[1]));
4200f260:	02f57263          	bgeu	a0,a5,4200f284 <riscv_pmpcfg_read_all+0x2c>
4200f264:	3a102773          	csrr	a4,pmpcfg1
    asm volatile("csrr %0, pmpcfg2" : "=r"(word_out[2]));
4200f268:	57e1                	li	a5,-8
    asm volatile("csrr %0, pmpcfg1" : "=r"(word_out[1]));
4200f26a:	c158                	sw	a4,4(a0)
    asm volatile("csrr %0, pmpcfg2" : "=r"(word_out[2]));
4200f26c:	00f57c63          	bgeu	a0,a5,4200f284 <riscv_pmpcfg_read_all+0x2c>
4200f270:	3a202773          	csrr	a4,pmpcfg2
    asm volatile("csrr %0, pmpcfg3" : "=r"(word_out[3]));
4200f274:	57d1                	li	a5,-12
    asm volatile("csrr %0, pmpcfg2" : "=r"(word_out[2]));
4200f276:	c518                	sw	a4,8(a0)
    asm volatile("csrr %0, pmpcfg3" : "=r"(word_out[3]));
4200f278:	00f57663          	bgeu	a0,a5,4200f284 <riscv_pmpcfg_read_all+0x2c>
4200f27c:	3a3027f3          	csrr	a5,pmpcfg3
4200f280:	c55c                	sw	a5,12(a0)
    asm volatile("csrr %0, pmpcfg8" : "=r"(word_out[4]));
    asm volatile("csrr %0, pmpcfg10" : "=r"(word_out[5]));
    asm volatile("csrr %0, pmpcfg12" : "=r"(word_out[6]));
    asm volatile("csrr %0, pmpcfg14" : "=r"(word_out[7]));
#endif
}
4200f282:	8082                	ret
    asm volatile("csrr %0, pmpcfg3" : "=r"(word_out[3]));
4200f284:	9002                	ebreak

4200f286 <riscv_pmpaddr_read_all>:

// Read all raw PMP addresses.
void riscv_pmpaddr_read_all(size_t addr_out[RISCV_PMP_REGION_COUNT]) {
    asm volatile("csrr %0, pmpaddr0" : "=r"(addr_out[0]));
4200f286:	3b002773          	csrr	a4,pmpaddr0
    asm volatile("csrr %0, pmpaddr1" : "=r"(addr_out[1]));
4200f28a:	57f1                	li	a5,-4
    asm volatile("csrr %0, pmpaddr0" : "=r"(addr_out[0]));
4200f28c:	c118                	sw	a4,0(a0)
    asm volatile("csrr %0, pmpaddr1" : "=r"(addr_out[1]));
4200f28e:	0cf57163          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f292:	3b102773          	csrr	a4,pmpaddr1
    asm volatile("csrr %0, pmpaddr2" : "=r"(addr_out[2]));
4200f296:	57e1                	li	a5,-8
    asm volatile("csrr %0, pmpaddr1" : "=r"(addr_out[1]));
4200f298:	c158                	sw	a4,4(a0)
    asm volatile("csrr %0, pmpaddr2" : "=r"(addr_out[2]));
4200f29a:	0af57b63          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f29e:	3b202773          	csrr	a4,pmpaddr2
    asm volatile("csrr %0, pmpaddr3" : "=r"(addr_out[3]));
4200f2a2:	57d1                	li	a5,-12
    asm volatile("csrr %0, pmpaddr2" : "=r"(addr_out[2]));
4200f2a4:	c518                	sw	a4,8(a0)
    asm volatile("csrr %0, pmpaddr3" : "=r"(addr_out[3]));
4200f2a6:	0af57563          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f2aa:	3b302773          	csrr	a4,pmpaddr3
    asm volatile("csrr %0, pmpaddr4" : "=r"(addr_out[4]));
4200f2ae:	57c1                	li	a5,-16
    asm volatile("csrr %0, pmpaddr3" : "=r"(addr_out[3]));
4200f2b0:	c558                	sw	a4,12(a0)
    asm volatile("csrr %0, pmpaddr4" : "=r"(addr_out[4]));
4200f2b2:	08f57f63          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f2b6:	3b402773          	csrr	a4,pmpaddr4
    asm volatile("csrr %0, pmpaddr5" : "=r"(addr_out[5]));
4200f2ba:	57b1                	li	a5,-20
    asm volatile("csrr %0, pmpaddr4" : "=r"(addr_out[4]));
4200f2bc:	c918                	sw	a4,16(a0)
    asm volatile("csrr %0, pmpaddr5" : "=r"(addr_out[5]));
4200f2be:	08f57963          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f2c2:	3b502773          	csrr	a4,pmpaddr5
    asm volatile("csrr %0, pmpaddr6" : "=r"(addr_out[6]));
4200f2c6:	57a1                	li	a5,-24
    asm volatile("csrr %0, pmpaddr5" : "=r"(addr_out[5]));
4200f2c8:	c958                	sw	a4,20(a0)
    asm volatile("csrr %0, pmpaddr6" : "=r"(addr_out[6]));
4200f2ca:	08f57363          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f2ce:	3b602773          	csrr	a4,pmpaddr6
    asm volatile("csrr %0, pmpaddr7" : "=r"(addr_out[7]));
4200f2d2:	5791                	li	a5,-28
    asm volatile("csrr %0, pmpaddr6" : "=r"(addr_out[6]));
4200f2d4:	cd18                	sw	a4,24(a0)
    asm volatile("csrr %0, pmpaddr7" : "=r"(addr_out[7]));
4200f2d6:	06f57d63          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f2da:	3b702773          	csrr	a4,pmpaddr7
    asm volatile("csrr %0, pmpaddr8" : "=r"(addr_out[8]));
4200f2de:	5781                	li	a5,-32
    asm volatile("csrr %0, pmpaddr7" : "=r"(addr_out[7]));
4200f2e0:	cd58                	sw	a4,28(a0)
    asm volatile("csrr %0, pmpaddr8" : "=r"(addr_out[8]));
4200f2e2:	06f57763          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f2e6:	3b802773          	csrr	a4,pmpaddr8
    asm volatile("csrr %0, pmpaddr9" : "=r"(addr_out[9]));
4200f2ea:	fdc00793          	li	a5,-36
    asm volatile("csrr %0, pmpaddr8" : "=r"(addr_out[8]));
4200f2ee:	d118                	sw	a4,32(a0)
    asm volatile("csrr %0, pmpaddr9" : "=r"(addr_out[9]));
4200f2f0:	06f57063          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f2f4:	3b902773          	csrr	a4,pmpaddr9
    asm volatile("csrr %0, pmpaddr10" : "=r"(addr_out[10]));
4200f2f8:	fd800793          	li	a5,-40
    asm volatile("csrr %0, pmpaddr9" : "=r"(addr_out[9]));
4200f2fc:	d158                	sw	a4,36(a0)
    asm volatile("csrr %0, pmpaddr10" : "=r"(addr_out[10]));
4200f2fe:	04f57963          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f302:	3ba02773          	csrr	a4,pmpaddr10
    asm volatile("csrr %0, pmpaddr11" : "=r"(addr_out[11]));
4200f306:	fd400793          	li	a5,-44
    asm volatile("csrr %0, pmpaddr10" : "=r"(addr_out[10]));
4200f30a:	d518                	sw	a4,40(a0)
    asm volatile("csrr %0, pmpaddr11" : "=r"(addr_out[11]));
4200f30c:	04f57263          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f310:	3bb02773          	csrr	a4,pmpaddr11
    asm volatile("csrr %0, pmpaddr12" : "=r"(addr_out[12]));
4200f314:	fd000793          	li	a5,-48
    asm volatile("csrr %0, pmpaddr11" : "=r"(addr_out[11]));
4200f318:	d558                	sw	a4,44(a0)
    asm volatile("csrr %0, pmpaddr12" : "=r"(addr_out[12]));
4200f31a:	02f57b63          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f31e:	3bc02773          	csrr	a4,pmpaddr12
    asm volatile("csrr %0, pmpaddr13" : "=r"(addr_out[13]));
4200f322:	fcc00793          	li	a5,-52
    asm volatile("csrr %0, pmpaddr12" : "=r"(addr_out[12]));
4200f326:	d918                	sw	a4,48(a0)
    asm volatile("csrr %0, pmpaddr13" : "=r"(addr_out[13]));
4200f328:	02f57463          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f32c:	3bd02773          	csrr	a4,pmpaddr13
    asm volatile("csrr %0, pmpaddr14" : "=r"(addr_out[14]));
4200f330:	fc800793          	li	a5,-56
    asm volatile("csrr %0, pmpaddr13" : "=r"(addr_out[13]));
4200f334:	d958                	sw	a4,52(a0)
    asm volatile("csrr %0, pmpaddr14" : "=r"(addr_out[14]));
4200f336:	00f57d63          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f33a:	3be02773          	csrr	a4,pmpaddr14
    asm volatile("csrr %0, pmpaddr15" : "=r"(addr_out[15]));
4200f33e:	fc400793          	li	a5,-60
    asm volatile("csrr %0, pmpaddr14" : "=r"(addr_out[14]));
4200f342:	dd18                	sw	a4,56(a0)
    asm volatile("csrr %0, pmpaddr15" : "=r"(addr_out[15]));
4200f344:	00f57663          	bgeu	a0,a5,4200f350 <riscv_pmpaddr_read_all+0xca>
4200f348:	3bf027f3          	csrr	a5,pmpaddr15
4200f34c:	dd5c                	sw	a5,60(a0)
    asm volatile("csrr %0, pmpaddr60" : "=r"(addr_out[60]));
    asm volatile("csrr %0, pmpaddr61" : "=r"(addr_out[61]));
    asm volatile("csrr %0, pmpaddr62" : "=r"(addr_out[62]));
    asm volatile("csrr %0, pmpaddr63" : "=r"(addr_out[63]));
#endif
}
4200f34e:	8082                	ret
    asm volatile("csrr %0, pmpaddr15" : "=r"(addr_out[15]));
4200f350:	9002                	ebreak

4200f352 <riscv_pmpcfg_write_all>:
// Write all raw PMP configurations.
void riscv_pmpcfg_write_all(riscv_pmpcfg_t const cfg_in[RISCV_PMP_REGION_COUNT]) {
    long const *word_in = (void *)cfg_in;

#if __riscv_xlen == 32
    asm volatile("csrw pmpcfg0, %0" ::"r"(word_in[0]));
4200f352:	c929                	beqz	a0,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f354:	00357793          	and	a5,a0,3
4200f358:	e7b1                	bnez	a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f35a:	411c                	lw	a5,0(a0)
4200f35c:	3a079073          	csrw	pmpcfg0,a5
    asm volatile("csrw pmpcfg1, %0" ::"r"(word_in[1]));
4200f360:	57f1                	li	a5,-4
4200f362:	04f57163          	bgeu	a0,a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f366:	00450793          	add	a5,a0,4
4200f36a:	cf8d                	beqz	a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f36c:	8b8d                	and	a5,a5,3
4200f36e:	eb9d                	bnez	a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f370:	415c                	lw	a5,4(a0)
4200f372:	3a179073          	csrw	pmpcfg1,a5
    asm volatile("csrw pmpcfg2, %0" ::"r"(word_in[2]));
4200f376:	57e1                	li	a5,-8
4200f378:	02f57663          	bgeu	a0,a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f37c:	00850793          	add	a5,a0,8
4200f380:	c395                	beqz	a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f382:	8b8d                	and	a5,a5,3
4200f384:	e385                	bnez	a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f386:	451c                	lw	a5,8(a0)
4200f388:	3a279073          	csrw	pmpcfg2,a5
    asm volatile("csrw pmpcfg3, %0" ::"r"(word_in[3]));
4200f38c:	57d1                	li	a5,-12
4200f38e:	00f57b63          	bgeu	a0,a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f392:	00c50793          	add	a5,a0,12
4200f396:	c799                	beqz	a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f398:	8b8d                	and	a5,a5,3
4200f39a:	e789                	bnez	a5,4200f3a4 <riscv_pmpcfg_write_all+0x52>
4200f39c:	455c                	lw	a5,12(a0)
4200f39e:	3a379073          	csrw	pmpcfg3,a5
    asm volatile("csrw pmpcfg8, %0" ::"r"(word_in[4]));
    asm volatile("csrw pmpcfg10, %0" ::"r"(word_in[5]));
    asm volatile("csrw pmpcfg12, %0" ::"r"(word_in[6]));
    asm volatile("csrw pmpcfg14, %0" ::"r"(word_in[7]));
#endif
}
4200f3a2:	8082                	ret
    asm volatile("csrw pmpcfg3, %0" ::"r"(word_in[3]));
4200f3a4:	9002                	ebreak

4200f3a6 <riscv_pmpaddr_write_all>:

// Write all raw PMP addresses.
void riscv_pmpaddr_write_all(size_t const addr_in[RISCV_PMP_REGION_COUNT]) {
    asm volatile("csrw pmpaddr0, %0" ::"r"(addr_in[0]));
4200f3a6:	16050e63          	beqz	a0,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3aa:	00357793          	and	a5,a0,3
4200f3ae:	16079a63          	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3b2:	411c                	lw	a5,0(a0)
4200f3b4:	3b079073          	csrw	pmpaddr0,a5
    asm volatile("csrw pmpaddr1, %0" ::"r"(addr_in[1]));
4200f3b8:	57f1                	li	a5,-4
4200f3ba:	16f57463          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3be:	00450793          	add	a5,a0,4
4200f3c2:	16078063          	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3c6:	8b8d                	and	a5,a5,3
4200f3c8:	14079d63          	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3cc:	415c                	lw	a5,4(a0)
4200f3ce:	3b179073          	csrw	pmpaddr1,a5
    asm volatile("csrw pmpaddr2, %0" ::"r"(addr_in[2]));
4200f3d2:	57e1                	li	a5,-8
4200f3d4:	14f57763          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3d8:	00850793          	add	a5,a0,8
4200f3dc:	14078363          	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3e0:	8b8d                	and	a5,a5,3
4200f3e2:	14079063          	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3e6:	451c                	lw	a5,8(a0)
4200f3e8:	3b279073          	csrw	pmpaddr2,a5
    asm volatile("csrw pmpaddr3, %0" ::"r"(addr_in[3]));
4200f3ec:	57d1                	li	a5,-12
4200f3ee:	12f57a63          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3f2:	00c50793          	add	a5,a0,12
4200f3f6:	12078663          	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f3fa:	8b8d                	and	a5,a5,3
4200f3fc:	12079363          	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f400:	455c                	lw	a5,12(a0)
4200f402:	3b379073          	csrw	pmpaddr3,a5
    asm volatile("csrw pmpaddr4, %0" ::"r"(addr_in[4]));
4200f406:	57c1                	li	a5,-16
4200f408:	10f57d63          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f40c:	01050793          	add	a5,a0,16
4200f410:	10078963          	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f414:	8b8d                	and	a5,a5,3
4200f416:	10079663          	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f41a:	491c                	lw	a5,16(a0)
4200f41c:	3b479073          	csrw	pmpaddr4,a5
    asm volatile("csrw pmpaddr5, %0" ::"r"(addr_in[5]));
4200f420:	57b1                	li	a5,-20
4200f422:	10f57063          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f426:	01450793          	add	a5,a0,20
4200f42a:	cfe5                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f42c:	8b8d                	and	a5,a5,3
4200f42e:	ebf5                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f430:	495c                	lw	a5,20(a0)
4200f432:	3b579073          	csrw	pmpaddr5,a5
    asm volatile("csrw pmpaddr6, %0" ::"r"(addr_in[6]));
4200f436:	57a1                	li	a5,-24
4200f438:	0ef57563          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f43c:	01850793          	add	a5,a0,24
4200f440:	c3ed                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f442:	8b8d                	and	a5,a5,3
4200f444:	eff9                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f446:	4d1c                	lw	a5,24(a0)
4200f448:	3b679073          	csrw	pmpaddr6,a5
    asm volatile("csrw pmpaddr7, %0" ::"r"(addr_in[7]));
4200f44c:	5791                	li	a5,-28
4200f44e:	0cf57a63          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f452:	01c50793          	add	a5,a0,28
4200f456:	c7f1                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f458:	8b8d                	and	a5,a5,3
4200f45a:	e7e1                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f45c:	4d5c                	lw	a5,28(a0)
4200f45e:	3b779073          	csrw	pmpaddr7,a5
    asm volatile("csrw pmpaddr8, %0" ::"r"(addr_in[8]));
4200f462:	5781                	li	a5,-32
4200f464:	0af57f63          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f468:	02050793          	add	a5,a0,32
4200f46c:	cbdd                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f46e:	8b8d                	and	a5,a5,3
4200f470:	ebcd                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f472:	511c                	lw	a5,32(a0)
4200f474:	3b879073          	csrw	pmpaddr8,a5
    asm volatile("csrw pmpaddr9, %0" ::"r"(addr_in[9]));
4200f478:	fdc00793          	li	a5,-36
4200f47c:	0af57363          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f480:	02450793          	add	a5,a0,36
4200f484:	cfd9                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f486:	8b8d                	and	a5,a5,3
4200f488:	efc9                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f48a:	515c                	lw	a5,36(a0)
4200f48c:	3b979073          	csrw	pmpaddr9,a5
    asm volatile("csrw pmpaddr10, %0" ::"r"(addr_in[10]));
4200f490:	fd800793          	li	a5,-40
4200f494:	08f57763          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f498:	02850793          	add	a5,a0,40
4200f49c:	c3d9                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f49e:	8b8d                	and	a5,a5,3
4200f4a0:	e3c9                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4a2:	551c                	lw	a5,40(a0)
4200f4a4:	3ba79073          	csrw	pmpaddr10,a5
    asm volatile("csrw pmpaddr11, %0" ::"r"(addr_in[11]));
4200f4a8:	fd400793          	li	a5,-44
4200f4ac:	06f57b63          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4b0:	02c50793          	add	a5,a0,44
4200f4b4:	c7bd                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4b6:	8b8d                	and	a5,a5,3
4200f4b8:	e7ad                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4ba:	555c                	lw	a5,44(a0)
4200f4bc:	3bb79073          	csrw	pmpaddr11,a5
    asm volatile("csrw pmpaddr12, %0" ::"r"(addr_in[12]));
4200f4c0:	fd000793          	li	a5,-48
4200f4c4:	04f57f63          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4c8:	03050793          	add	a5,a0,48
4200f4cc:	cbb9                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4ce:	8b8d                	and	a5,a5,3
4200f4d0:	eba9                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4d2:	591c                	lw	a5,48(a0)
4200f4d4:	3bc79073          	csrw	pmpaddr12,a5
    asm volatile("csrw pmpaddr13, %0" ::"r"(addr_in[13]));
4200f4d8:	fcc00793          	li	a5,-52
4200f4dc:	04f57363          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4e0:	03450793          	add	a5,a0,52
4200f4e4:	cf9d                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4e6:	8b8d                	and	a5,a5,3
4200f4e8:	ef8d                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4ea:	595c                	lw	a5,52(a0)
4200f4ec:	3bd79073          	csrw	pmpaddr13,a5
    asm volatile("csrw pmpaddr14, %0" ::"r"(addr_in[14]));
4200f4f0:	fc800793          	li	a5,-56
4200f4f4:	02f57763          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4f8:	03850793          	add	a5,a0,56
4200f4fc:	c39d                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f4fe:	8b8d                	and	a5,a5,3
4200f500:	e38d                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f502:	5d1c                	lw	a5,56(a0)
4200f504:	3be79073          	csrw	pmpaddr14,a5
    asm volatile("csrw pmpaddr15, %0" ::"r"(addr_in[15]));
4200f508:	fc400793          	li	a5,-60
4200f50c:	00f57b63          	bgeu	a0,a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f510:	03c50793          	add	a5,a0,60
4200f514:	c799                	beqz	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f516:	8b8d                	and	a5,a5,3
4200f518:	e789                	bnez	a5,4200f522 <riscv_pmpaddr_write_all+0x17c>
4200f51a:	5d5c                	lw	a5,60(a0)
4200f51c:	3bf79073          	csrw	pmpaddr15,a5
    asm volatile("csrw pmpaddr60, %0" ::"r"(addr_in[60]));
    asm volatile("csrw pmpaddr61, %0" ::"r"(addr_in[61]));
    asm volatile("csrw pmpaddr62, %0" ::"r"(addr_in[62]));
    asm volatile("csrw pmpaddr63, %0" ::"r"(addr_in[63]));
#endif
}
4200f520:	8082                	ret
    asm volatile("csrw pmpaddr15, %0" ::"r"(addr_in[15]));
4200f522:	9002                	ebreak

4200f524 <sched_exit_self>:
        isr_ctx_switch_set(&thread->user_isr_ctx);
    }
}

// Return to exit the thread.
static void sched_exit_self() {
4200f524:	1141                	add	sp,sp,-16
4200f526:	c606                	sw	ra,12(sp)
#ifndef NDEBUG
    sched_thread_t *const this_thread = sched_get_current_thread();
4200f528:	b8dfe0ef          	jal	4200e0b4 <sched_get_current_thread>
    logkf(LOG_INFO, "Kernel thread '%{cs}' returned", sched_get_name(this_thread));
4200f52c:	edeff0ef          	jal	4200ec0a <sched_get_name>
4200f530:	4201b5b7          	lui	a1,0x4201b
4200f534:	862a                	mv	a2,a0
4200f536:	06c58593          	add	a1,a1,108 # 4201b06c <hextab+0x43a0>
4200f53a:	450d                	li	a0,3
4200f53c:	d5ff30ef          	jal	4200329a <logkf>
#endif
    sched_exit(0);
4200f540:	4501                	li	a0,0
4200f542:	ca2ff0ef          	jal	4200e9e4 <sched_exit>

4200f546 <sched_raise_from_isr>:
void sched_raise_from_isr(bool syscall, void *entry_point) {
4200f546:	1141                	add	sp,sp,-16
4200f548:	c422                	sw	s0,8(sp)
4200f54a:	c226                	sw	s1,4(sp)
4200f54c:	c606                	sw	ra,12(sp)
4200f54e:	84aa                	mv	s1,a0
4200f550:	842e                	mv	s0,a1
    sched_thread_t *thread = sched_get_current_thread_unsafe();
4200f552:	b31fe0ef          	jal	4200e082 <sched_get_current_thread_unsafe>
    assert_dev_drop(!(thread->flags & THREAD_KERNEL) && !(thread->flags & THREAD_PRIVILEGED));
4200f556:	cd79                	beqz	a0,4200f634 <sched_raise_from_isr+0xee>
4200f558:	00357793          	and	a5,a0,3
4200f55c:	efe1                	bnez	a5,4200f634 <sched_raise_from_isr+0xee>
4200f55e:	57c1                	li	a5,-16
4200f560:	0cf57a63          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f564:	491c                	lw	a5,16(a0)
4200f566:	0187f713          	and	a4,a5,24
4200f56a:	ef4d                	bnez	a4,4200f624 <sched_raise_from_isr+0xde>
    thread->flags |= THREAD_PRIVILEGED;
4200f56c:	0107e793          	or	a5,a5,16
4200f570:	c91c                	sw	a5,16(a0)
    thread->kernel_isr_ctx.regs.pc = (uint32_t)entry_point;
4200f572:	fc000793          	li	a5,-64
4200f576:	0af57f63          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f57a:	c120                	sw	s0,64(a0)
    thread->kernel_isr_ctx.regs.sp = thread->kernel_stack_top;
4200f57c:	fb800713          	li	a4,-72
4200f580:	451c                	lw	a5,8(a0)
4200f582:	0ae57963          	bgeu	a0,a4,4200f634 <sched_raise_from_isr+0xee>
4200f586:	c53c                	sw	a5,72(a0)
    if (syscall) {
4200f588:	c8bd                	beqz	s1,4200f5fe <sched_raise_from_isr+0xb8>
        thread->kernel_isr_ctx.regs.a0 = thread->user_isr_ctx.regs.a0;
4200f58a:	eec00793          	li	a5,-276
4200f58e:	0af57363          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f592:	11452703          	lw	a4,276(a0)
        thread->kernel_isr_ctx.regs.a1 = thread->user_isr_ctx.regs.a1;
4200f596:	ee800793          	li	a5,-280
        thread->kernel_isr_ctx.regs.a0 = thread->user_isr_ctx.regs.a0;
4200f59a:	d538                	sw	a4,104(a0)
        thread->kernel_isr_ctx.regs.a1 = thread->user_isr_ctx.regs.a1;
4200f59c:	08f57c63          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f5a0:	11852703          	lw	a4,280(a0)
        thread->kernel_isr_ctx.regs.a2 = thread->user_isr_ctx.regs.a2;
4200f5a4:	ee400793          	li	a5,-284
        thread->kernel_isr_ctx.regs.a1 = thread->user_isr_ctx.regs.a1;
4200f5a8:	d578                	sw	a4,108(a0)
        thread->kernel_isr_ctx.regs.a2 = thread->user_isr_ctx.regs.a2;
4200f5aa:	08f57563          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f5ae:	11c52703          	lw	a4,284(a0)
        thread->kernel_isr_ctx.regs.a3 = thread->user_isr_ctx.regs.a3;
4200f5b2:	ee000793          	li	a5,-288
        thread->kernel_isr_ctx.regs.a2 = thread->user_isr_ctx.regs.a2;
4200f5b6:	d938                	sw	a4,112(a0)
        thread->kernel_isr_ctx.regs.a3 = thread->user_isr_ctx.regs.a3;
4200f5b8:	06f57e63          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f5bc:	12052703          	lw	a4,288(a0)
        thread->kernel_isr_ctx.regs.a4 = thread->user_isr_ctx.regs.a4;
4200f5c0:	edc00793          	li	a5,-292
        thread->kernel_isr_ctx.regs.a3 = thread->user_isr_ctx.regs.a3;
4200f5c4:	d978                	sw	a4,116(a0)
        thread->kernel_isr_ctx.regs.a4 = thread->user_isr_ctx.regs.a4;
4200f5c6:	06f57763          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f5ca:	12452703          	lw	a4,292(a0)
        thread->kernel_isr_ctx.regs.a5 = thread->user_isr_ctx.regs.a5;
4200f5ce:	ed800793          	li	a5,-296
        thread->kernel_isr_ctx.regs.a4 = thread->user_isr_ctx.regs.a4;
4200f5d2:	dd38                	sw	a4,120(a0)
        thread->kernel_isr_ctx.regs.a5 = thread->user_isr_ctx.regs.a5;
4200f5d4:	06f57063          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f5d8:	12852703          	lw	a4,296(a0)
        thread->kernel_isr_ctx.regs.a6 = thread->user_isr_ctx.regs.a6;
4200f5dc:	ed400793          	li	a5,-300
        thread->kernel_isr_ctx.regs.a5 = thread->user_isr_ctx.regs.a5;
4200f5e0:	dd78                	sw	a4,124(a0)
        thread->kernel_isr_ctx.regs.a6 = thread->user_isr_ctx.regs.a6;
4200f5e2:	04f57963          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f5e6:	12c52703          	lw	a4,300(a0)
        thread->kernel_isr_ctx.regs.a7 = thread->user_isr_ctx.regs.a7;
4200f5ea:	ed000793          	li	a5,-304
        thread->kernel_isr_ctx.regs.a6 = thread->user_isr_ctx.regs.a6;
4200f5ee:	08e52023          	sw	a4,128(a0)
        thread->kernel_isr_ctx.regs.a7 = thread->user_isr_ctx.regs.a7;
4200f5f2:	04f57163          	bgeu	a0,a5,4200f634 <sched_raise_from_isr+0xee>
4200f5f6:	13052783          	lw	a5,304(a0)
4200f5fa:	08f52223          	sw	a5,132(a0)
    isr_ctx_switch_set(&thread->kernel_isr_ctx);
4200f5fe:	02050513          	add	a0,a0,32
    asm("csrr %0, mscratch" : "=r"(kctx));
4200f602:	340027f3          	csrr	a5,mscratch
    kctx->ctxswitch = switch_to;
4200f606:	c79d                	beqz	a5,4200f634 <sched_raise_from_isr+0xee>
4200f608:	0037f713          	and	a4,a5,3
4200f60c:	e705                	bnez	a4,4200f634 <sched_raise_from_isr+0xee>
4200f60e:	f6000713          	li	a4,-160
4200f612:	02e7f163          	bgeu	a5,a4,4200f634 <sched_raise_from_isr+0xee>
}
4200f616:	40b2                	lw	ra,12(sp)
4200f618:	4422                	lw	s0,8(sp)
4200f61a:	0aa7a023          	sw	a0,160(a5)
4200f61e:	4492                	lw	s1,4(sp)
4200f620:	0141                	add	sp,sp,16
4200f622:	8082                	ret
    assert_dev_drop(!(thread->flags & THREAD_KERNEL) && !(thread->flags & THREAD_PRIVILEGED));
4200f624:	4201b5b7          	lui	a1,0x4201b
4200f628:	08c58593          	add	a1,a1,140 # 4201b08c <hextab+0x43c0>
4200f62c:	4501                	li	a0,0
4200f62e:	c27f30ef          	jal	42003254 <logk>
4200f632:	9002                	ebreak
4200f634:	9002                	ebreak

4200f636 <sched_lower_from_isr>:
void sched_lower_from_isr() {
4200f636:	1141                	add	sp,sp,-16
4200f638:	c606                	sw	ra,12(sp)
    sched_thread_t *thread  = sched_get_current_thread_unsafe();
4200f63a:	a49fe0ef          	jal	4200e082 <sched_get_current_thread_unsafe>
    process_t      *process = thread->process;
4200f63e:	c541                	beqz	a0,4200f6c6 <sched_lower_from_isr+0x90>
4200f640:	00357793          	and	a5,a0,3
4200f644:	e3c9                	bnez	a5,4200f6c6 <sched_lower_from_isr+0x90>
    assert_dev_drop(!(thread->flags & THREAD_KERNEL) && (thread->flags & THREAD_PRIVILEGED));
4200f646:	57c1                	li	a5,-16
    process_t      *process = thread->process;
4200f648:	4118                	lw	a4,0(a0)
    assert_dev_drop(!(thread->flags & THREAD_KERNEL) && (thread->flags & THREAD_PRIVILEGED));
4200f64a:	06f57e63          	bgeu	a0,a5,4200f6c6 <sched_lower_from_isr+0x90>
4200f64e:	491c                	lw	a5,16(a0)
4200f650:	46c1                	li	a3,16
4200f652:	0187f613          	and	a2,a5,24
4200f656:	06d61063          	bne	a2,a3,4200f6b6 <sched_lower_from_isr+0x80>
    thread->flags &= ~THREAD_PRIVILEGED;
4200f65a:	9bbd                	and	a5,a5,-17
4200f65c:	c91c                	sw	a5,16(a0)
    if (atomic_load(&process->flags) & PROC_EXITING) {
4200f65e:	c725                	beqz	a4,4200f6c6 <sched_lower_from_isr+0x90>
4200f660:	00377793          	and	a5,a4,3
4200f664:	e3ad                	bnez	a5,4200f6c6 <sched_lower_from_isr+0x90>
4200f666:	f4c00793          	li	a5,-180
4200f66a:	04f77e63          	bgeu	a4,a5,4200f6c6 <sched_lower_from_isr+0x90>
4200f66e:	0ff0000f          	fence
4200f672:	0b472783          	lw	a5,180(a4)
4200f676:	0ff0000f          	fence
4200f67a:	8b89                	and	a5,a5,2
4200f67c:	e795                	bnez	a5,4200f6a8 <sched_lower_from_isr+0x72>
        isr_ctx_switch_set(&thread->user_isr_ctx);
4200f67e:	f3400793          	li	a5,-204
4200f682:	04f57263          	bgeu	a0,a5,4200f6c6 <sched_lower_from_isr+0x90>
4200f686:	0cc50513          	add	a0,a0,204
    asm("csrr %0, mscratch" : "=r"(kctx));
4200f68a:	340027f3          	csrr	a5,mscratch
    kctx->ctxswitch = switch_to;
4200f68e:	cf85                	beqz	a5,4200f6c6 <sched_lower_from_isr+0x90>
4200f690:	0037f713          	and	a4,a5,3
4200f694:	eb0d                	bnez	a4,4200f6c6 <sched_lower_from_isr+0x90>
4200f696:	f6000713          	li	a4,-160
4200f69a:	02e7f663          	bgeu	a5,a4,4200f6c6 <sched_lower_from_isr+0x90>
}
4200f69e:	40b2                	lw	ra,12(sp)
4200f6a0:	0aa7a023          	sw	a0,160(a5)
4200f6a4:	0141                	add	sp,sp,16
4200f6a6:	8082                	ret
        thread->flags &= ~THREAD_RUNNING;
4200f6a8:	491c                	lw	a5,16(a0)
}
4200f6aa:	40b2                	lw	ra,12(sp)
        thread->flags &= ~THREAD_RUNNING;
4200f6ac:	9bf9                	and	a5,a5,-2
4200f6ae:	c91c                	sw	a5,16(a0)
}
4200f6b0:	0141                	add	sp,sp,16
        sched_request_switch_from_isr();
4200f6b2:	af6ff06f          	j	4200e9a8 <sched_request_switch_from_isr>
    assert_dev_drop(!(thread->flags & THREAD_KERNEL) && (thread->flags & THREAD_PRIVILEGED));
4200f6b6:	4201b5b7          	lui	a1,0x4201b
4200f6ba:	13c58593          	add	a1,a1,316 # 4201b13c <hextab+0x4470>
4200f6be:	4501                	li	a0,0
4200f6c0:	b95f30ef          	jal	42003254 <logk>
4200f6c4:	9002                	ebreak
4200f6c6:	9002                	ebreak

4200f6c8 <sched_prepare_kernel_entry>:
}

// Prepares a context to be invoked as a kernel thread.
void sched_prepare_kernel_entry(sched_thread_t *thread, sched_entry_point_t entry_point, void *arg) {
    // Initialize registers.
    mem_set(&thread->kernel_isr_ctx.regs, 0, sizeof(thread->kernel_isr_ctx.regs));
4200f6c8:	c52d                	beqz	a0,4200f732 <sched_prepare_kernel_entry+0x6a>
void sched_prepare_kernel_entry(sched_thread_t *thread, sched_entry_point_t entry_point, void *arg) {
4200f6ca:	1141                	add	sp,sp,-16
4200f6cc:	c422                	sw	s0,8(sp)
4200f6ce:	c606                	sw	ra,12(sp)
4200f6d0:	c226                	sw	s1,4(sp)
4200f6d2:	c04a                	sw	s2,0(sp)
    mem_set(&thread->kernel_isr_ctx.regs, 0, sizeof(thread->kernel_isr_ctx.regs));
4200f6d4:	00357793          	and	a5,a0,3
4200f6d8:	842a                	mv	s0,a0
4200f6da:	eba1                	bnez	a5,4200f72a <sched_prepare_kernel_entry+0x62>
4200f6dc:	fc000793          	li	a5,-64
4200f6e0:	04f57863          	bgeu	a0,a5,4200f730 <sched_prepare_kernel_entry+0x68>
4200f6e4:	892e                	mv	s2,a1
4200f6e6:	84b2                	mv	s1,a2
4200f6e8:	4581                	li	a1,0
4200f6ea:	08000613          	li	a2,128
4200f6ee:	04050513          	add	a0,a0,64
4200f6f2:	95af30ef          	jal	4200284c <mem_set>
    thread->kernel_isr_ctx.regs.pc = (uint32_t)entry_point;
    thread->kernel_isr_ctx.regs.sp = thread->kernel_stack_top;
4200f6f6:	fb800713          	li	a4,-72
    thread->kernel_isr_ctx.regs.pc = (uint32_t)entry_point;
4200f6fa:	05242023          	sw	s2,64(s0)
    thread->kernel_isr_ctx.regs.sp = thread->kernel_stack_top;
4200f6fe:	441c                	lw	a5,8(s0)
4200f700:	02e47763          	bgeu	s0,a4,4200f72e <sched_prepare_kernel_entry+0x66>
4200f704:	c43c                	sw	a5,72(s0)
    thread->kernel_isr_ctx.regs.a0 = (uint32_t)arg;
4200f706:	f9800793          	li	a5,-104
4200f70a:	02f47163          	bgeu	s0,a5,4200f72c <sched_prepare_kernel_entry+0x64>
    thread->kernel_isr_ctx.regs.ra = (uint32_t)sched_exit_self;
4200f70e:	4200f7b7          	lui	a5,0x4200f
4200f712:	52478793          	add	a5,a5,1316 # 4200f524 <sched_exit_self>
    thread->kernel_isr_ctx.regs.a0 = (uint32_t)arg;
4200f716:	d424                	sw	s1,104(s0)
    thread->kernel_isr_ctx.regs.ra = (uint32_t)sched_exit_self;
4200f718:	c07c                	sw	a5,68(s0)
    asm("sw gp, %0" ::"m"(thread->kernel_isr_ctx.regs.gp));
4200f71a:	04342623          	sw	gp,76(s0)
}
4200f71e:	40b2                	lw	ra,12(sp)
4200f720:	4422                	lw	s0,8(sp)
4200f722:	4492                	lw	s1,4(sp)
4200f724:	4902                	lw	s2,0(sp)
4200f726:	0141                	add	sp,sp,16
4200f728:	8082                	ret
    mem_set(&thread->kernel_isr_ctx.regs, 0, sizeof(thread->kernel_isr_ctx.regs));
4200f72a:	9002                	ebreak
    thread->kernel_isr_ctx.regs.a0 = (uint32_t)arg;
4200f72c:	9002                	ebreak
    thread->kernel_isr_ctx.regs.sp = thread->kernel_stack_top;
4200f72e:	9002                	ebreak
    mem_set(&thread->kernel_isr_ctx.regs, 0, sizeof(thread->kernel_isr_ctx.regs));
4200f730:	9002                	ebreak
4200f732:	9002                	ebreak

4200f734 <sched_prepare_user_entry>:

// Prepares a pair of contexts to be invoked as a userland thread.
// Kernel-side in these threads is always started by an ISR and the entry point is given at that time.
void sched_prepare_user_entry(sched_thread_t *thread, sched_entry_point_t entry_point, void *arg) {
    // Initialize kernel registers.
    mem_set(&thread->kernel_isr_ctx.regs, 0, sizeof(thread->kernel_isr_ctx.regs));
4200f734:	cd2d                	beqz	a0,4200f7ae <sched_prepare_user_entry+0x7a>
void sched_prepare_user_entry(sched_thread_t *thread, sched_entry_point_t entry_point, void *arg) {
4200f736:	1141                	add	sp,sp,-16
4200f738:	c422                	sw	s0,8(sp)
4200f73a:	c606                	sw	ra,12(sp)
4200f73c:	c226                	sw	s1,4(sp)
4200f73e:	c04a                	sw	s2,0(sp)
    mem_set(&thread->kernel_isr_ctx.regs, 0, sizeof(thread->kernel_isr_ctx.regs));
4200f740:	00357793          	and	a5,a0,3
4200f744:	842a                	mv	s0,a0
4200f746:	efb9                	bnez	a5,4200f7a4 <sched_prepare_user_entry+0x70>
4200f748:	fc000793          	li	a5,-64
4200f74c:	06f57063          	bgeu	a0,a5,4200f7ac <sched_prepare_user_entry+0x78>
4200f750:	892e                	mv	s2,a1
4200f752:	84b2                	mv	s1,a2
4200f754:	4581                	li	a1,0
4200f756:	08000613          	li	a2,128
4200f75a:	04050513          	add	a0,a0,64
4200f75e:	8eef30ef          	jal	4200284c <mem_set>
    thread->kernel_isr_ctx.regs.sp = thread->kernel_stack_top;
4200f762:	fb800713          	li	a4,-72
4200f766:	441c                	lw	a5,8(s0)
4200f768:	04e47163          	bgeu	s0,a4,4200f7aa <sched_prepare_user_entry+0x76>
4200f76c:	c43c                	sw	a5,72(s0)
    asm("sw gp, %0" ::"m"(thread->kernel_isr_ctx.regs.gp));
4200f76e:	04342623          	sw	gp,76(s0)

    // Initialize userland registers.
    mem_set(&thread->user_isr_ctx.regs, 0, sizeof(thread->user_isr_ctx.regs));
4200f772:	f1400793          	li	a5,-236
4200f776:	02f47963          	bgeu	s0,a5,4200f7a8 <sched_prepare_user_entry+0x74>
4200f77a:	08000613          	li	a2,128
4200f77e:	4581                	li	a1,0
4200f780:	0ec40513          	add	a0,s0,236
4200f784:	8c8f30ef          	jal	4200284c <mem_set>
    thread->user_isr_ctx.regs.pc = (uint32_t)entry_point;
    thread->user_isr_ctx.regs.a0 = (uint32_t)arg;
4200f788:	eec00793          	li	a5,-276
    thread->user_isr_ctx.regs.pc = (uint32_t)entry_point;
4200f78c:	0f242623          	sw	s2,236(s0)
    thread->user_isr_ctx.regs.a0 = (uint32_t)arg;
4200f790:	00f47b63          	bgeu	s0,a5,4200f7a6 <sched_prepare_user_entry+0x72>
4200f794:	10942a23          	sw	s1,276(s0)
}
4200f798:	40b2                	lw	ra,12(sp)
4200f79a:	4422                	lw	s0,8(sp)
4200f79c:	4492                	lw	s1,4(sp)
4200f79e:	4902                	lw	s2,0(sp)
4200f7a0:	0141                	add	sp,sp,16
4200f7a2:	8082                	ret
    mem_set(&thread->kernel_isr_ctx.regs, 0, sizeof(thread->kernel_isr_ctx.regs));
4200f7a4:	9002                	ebreak
    thread->user_isr_ctx.regs.a0 = (uint32_t)arg;
4200f7a6:	9002                	ebreak
    mem_set(&thread->user_isr_ctx.regs, 0, sizeof(thread->user_isr_ctx.regs));
4200f7a8:	9002                	ebreak
    thread->kernel_isr_ctx.regs.sp = thread->kernel_stack_top;
4200f7aa:	9002                	ebreak
    mem_set(&thread->kernel_isr_ctx.regs, 0, sizeof(thread->kernel_isr_ctx.regs));
4200f7ac:	9002                	ebreak
4200f7ae:	9002                	ebreak

4200f7b0 <clkconfig_i2c0>:
// frequency.
static uint32_t clk_compute_div(uint32_t source_hz, uint32_t target_hz) PURE;

static uint32_t clk_compute_div(uint32_t source_hz, uint32_t target_hz) {
    // Divider integral part.
    uint32_t integral   = source_hz / target_hz;
4200f7b0:	cd55                	beqz	a0,4200f86c <clkconfig_i2c0+0xbc>
4200f7b2:	026267b7          	lui	a5,0x2626
    return ((integral - 1) << PCR_CONF_SCLK_DIV_INT_POS) | (closest_num << PCR_CONF_SCLK_DIV_NUM_POS) |
           (closest_den << PCR_CONF_SCLK_DIV_DEN_POS);
}

// Configure I2C0 clock.
void clkconfig_i2c0(uint32_t freq_hz, bool enable, bool reset) {
4200f7b6:	1141                	add	sp,sp,-16
    uint32_t integral   = source_hz / target_hz;
4200f7b8:	a0078793          	add	a5,a5,-1536 # 2625a00 <__stack_size+0x2623a00>
void clkconfig_i2c0(uint32_t freq_hz, bool enable, bool reset) {
4200f7bc:	c04a                	sw	s2,0(sp)
4200f7be:	01659913          	sll	s2,a1,0x16
    uint32_t fractional = (source_hz % target_hz) * 0x01000000LLU / target_hz;
4200f7c2:	02a7f5b3          	remu	a1,a5,a0
void clkconfig_i2c0(uint32_t freq_hz, bool enable, bool reset) {
4200f7c6:	c422                	sw	s0,8(sp)
4200f7c8:	c226                	sw	s1,4(sp)
4200f7ca:	842a                	mv	s0,a0
4200f7cc:	84b2                	mv	s1,a2
    uint32_t fractional = (source_hz % target_hz) * 0x01000000LLU / target_hz;
4200f7ce:	4681                	li	a3,0
4200f7d0:	862a                	mv	a2,a0
void clkconfig_i2c0(uint32_t freq_hz, bool enable, bool reset) {
4200f7d2:	c606                	sw	ra,12(sp)
    uint32_t fractional = (source_hz % target_hz) * 0x01000000LLU / target_hz;
4200f7d4:	01859513          	sll	a0,a1,0x18
4200f7d8:	81a1                	srl	a1,a1,0x8
    uint32_t integral   = source_hz / target_hz;
4200f7da:	0287d433          	divu	s0,a5,s0
    uint32_t fractional = (source_hz % target_hz) * 0x01000000LLU / target_hz;
4200f7de:	c70f30ef          	jal	42002c4e <__udivdi3>
        uint_fast8_t den  = (fractional * num) >> 24;
4200f7e2:	00151713          	sll	a4,a0,0x1
4200f7e6:	01875813          	srl	a6,a4,0x18
        uint32_t     frac = (den << 24) / num;
4200f7ea:	04074363          	bltz	a4,4200f830 <clkconfig_i2c0+0x80>
    int32_t      closest_err = INT32_MAX;
4200f7ee:	800005b7          	lui	a1,0x80000
        uint32_t     frac = (den << 24) / num;
4200f7f2:	4689                	li	a3,2
    uint_fast8_t closest_num = 0;
4200f7f4:	4f01                	li	t5,0
    uint_fast8_t closest_den = 0;
4200f7f6:	4e81                	li	t4,0
    int32_t      closest_err = INT32_MAX;
4200f7f8:	15fd                	add	a1,a1,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
        uint32_t     frac = (den << 24) / num;
4200f7fa:	ff000337          	lui	t1,0xff000
            err = -err;
4200f7fe:	80000fb7          	lui	t6,0x80000
    for (uint_fast8_t num = 2; num < 64; num++) {
4200f802:	03f00893          	li	a7,63
        uint32_t     frac = (den << 24) / num;
4200f806:	006777b3          	and	a5,a4,t1
4200f80a:	02d7c7b3          	div	a5,a5,a3
        int32_t      err  = (int32_t)(frac - fractional);
4200f80e:	8f89                	sub	a5,a5,a0
        if (err < 0)
4200f810:	0207c163          	bltz	a5,4200f832 <clkconfig_i2c0+0x82>
        if (err < closest_err) {
4200f814:	00b7d663          	bge	a5,a1,4200f820 <clkconfig_i2c0+0x70>
4200f818:	0ff6ff13          	zext.b	t5,a3
            closest_den = den;
4200f81c:	8ec2                	mv	t4,a6
            closest_err = err;
4200f81e:	85be                	mv	a1,a5
    for (uint_fast8_t num = 2; num < 64; num++) {
4200f820:	01168f63          	beq	a3,a7,4200f83e <clkconfig_i2c0+0x8e>
        uint_fast8_t den  = (fractional * num) >> 24;
4200f824:	972a                	add	a4,a4,a0
4200f826:	01875813          	srl	a6,a4,0x18
        uint32_t     frac = (den << 24) / num;
4200f82a:	0685                	add	a3,a3,1
4200f82c:	fc075de3          	bgez	a4,4200f806 <clkconfig_i2c0+0x56>
    uint32_t integral   = source_hz / target_hz;
4200f830:	9002                	ebreak
            err = -err;
4200f832:	40f00e33          	neg	t3,a5
4200f836:	03f78a63          	beq	a5,t6,4200f86a <clkconfig_i2c0+0xba>
4200f83a:	87f2                	mv	a5,t3
4200f83c:	bfe1                	j	4200f814 <clkconfig_i2c0+0x64>
    return ((integral - 1) << PCR_CONF_SCLK_DIV_INT_POS) | (closest_num << PCR_CONF_SCLK_DIV_NUM_POS) |
4200f83e:	fff40793          	add	a5,s0,-1
4200f842:	07b2                	sll	a5,a5,0xc
4200f844:	01e7e7b3          	or	a5,a5,t5
           (closest_den << PCR_CONF_SCLK_DIV_DEN_POS);
4200f848:	0e9a                	sll	t4,t4,0x6
    return ((integral - 1) << PCR_CONF_SCLK_DIV_INT_POS) | (closest_num << PCR_CONF_SCLK_DIV_NUM_POS) |
4200f84a:	01d7e7b3          	or	a5,a5,t4
    // I2C0 is configured on XTAL_CLK.
    WRITE_REG(PCR_I2C_SCLK_CONF_REG, enable * PCR_CONF_SCLK_ENABLE_BIT + clk_compute_div(FREQ_XTAL_CLK, freq_hz));
    WRITE_REG(PCR_I2C_CONF_REG, PCR_CONF_ENABLE_BIT + reset * PCR_CONF_RESET_BIT);
}
4200f84e:	40b2                	lw	ra,12(sp)
4200f850:	4422                	lw	s0,8(sp)
    WRITE_REG(PCR_I2C_SCLK_CONF_REG, enable * PCR_CONF_SCLK_ENABLE_BIT + clk_compute_div(FREQ_XTAL_CLK, freq_hz));
4200f852:	97ca                	add	a5,a5,s2
4200f854:	600966b7          	lui	a3,0x60096
    WRITE_REG(PCR_I2C_CONF_REG, PCR_CONF_ENABLE_BIT + reset * PCR_CONF_RESET_BIT);
4200f858:	0489                	add	s1,s1,2
    WRITE_REG(PCR_I2C_SCLK_CONF_REG, enable * PCR_CONF_SCLK_ENABLE_BIT + clk_compute_div(FREQ_XTAL_CLK, freq_hz));
4200f85a:	d2dc                	sw	a5,36(a3)
    WRITE_REG(PCR_I2C_CONF_REG, PCR_CONF_ENABLE_BIT + reset * PCR_CONF_RESET_BIT);
4200f85c:	60096737          	lui	a4,0x60096
4200f860:	d304                	sw	s1,32(a4)
}
4200f862:	4902                	lw	s2,0(sp)
4200f864:	4492                	lw	s1,4(sp)
4200f866:	0141                	add	sp,sp,16
4200f868:	8082                	ret
            err = -err;
4200f86a:	9002                	ebreak
    uint32_t integral   = source_hz / target_hz;
4200f86c:	9002                	ebreak

4200f86e <io_mode>:
static uint32_t gpio_is_output     = 0;


void io_mode(badge_err_t *err, int pin, io_mode_t mode) {
    // Check pin bounds.
    if (pin < 0 || pin > io_count()) {
4200f86e:	46fd                	li	a3,31
4200f870:	0ab6e563          	bltu	a3,a1,4200f91a <io_mode+0xac>
            err->location = ELOC_GPIO;
        return;
    }

    // Check pin capabilities.
    if (mode != IO_MODE_INPUT && mode != IO_MODE_OUTPUT) {
4200f874:	fff60713          	add	a4,a2,-1
4200f878:	4785                	li	a5,1
4200f87a:	08e7e563          	bltu	a5,a4,4200f904 <io_mode+0x96>
            err->location = ELOC_GPIO;
        return;
    }

    // Assert pin is configured as a GPIO.
    if ((gpio_is_peripheral >> pin) & 1) {
4200f87e:	4080a737          	lui	a4,0x4080a
4200f882:	e7872703          	lw	a4,-392(a4) # 40809e78 <gpio_is_peripheral>
4200f886:	00b75733          	srl	a4,a4,a1
4200f88a:	8b05                	and	a4,a4,1
4200f88c:	e369                	bnez	a4,4200f94e <io_mode+0xe0>
            err->location = ELOC_GPIO;
        return;
    }

    // Configure IOMUX to GPIO.
    uint32_t mux  = READ_REG(IO_MUX_GPIO_N_REG(pin));
4200f88e:	18024737          	lui	a4,0x18024
4200f892:	0705                	add	a4,a4,1 # 18024001 <__stack_size+0x18022001>
4200f894:	972e                	add	a4,a4,a1
4200f896:	070a                	sll	a4,a4,0x2
4200f898:	c761                	beqz	a4,4200f960 <io_mode+0xf2>
4200f89a:	00072803          	lw	a6,0(a4)
    mux          &= ~IO_MUX_GPIO_N_MCU_SEL_MASK;
4200f89e:	78e5                	lui	a7,0xffff9
4200f8a0:	18fd                	add	a7,a7,-1 # ffff8fff <__stop_free_lpsram+0xafff4fff>
4200f8a2:	01187833          	and	a6,a6,a7
    mux          |= ESP32C6_IOMUX_FUNC_GPIO << IO_MUX_GPIO_N_MCU_SEL_POS;
4200f8a6:	6305                	lui	t1,0x1
    WRITE_REG(IO_MUX_GPIO_N_REG(pin), mux);

    // Configure FUNC_OUT_SEL to GPIO_OUT_REG.
    WRITE_REG(GPIO_FUNC_N_OUT_SEL_CFG_REG(pin), 128);
4200f8a8:	6885                	lui	a7,0x1
    mux          |= ESP32C6_IOMUX_FUNC_GPIO << IO_MUX_GPIO_N_MCU_SEL_POS;
4200f8aa:	00686833          	or	a6,a6,t1
    WRITE_REG(GPIO_FUNC_N_OUT_SEL_CFG_REG(pin), 128);
4200f8ae:	55088893          	add	a7,a7,1360 # 1550 <isr_ctx_t_is_kernel_thread+0x14a8>
    WRITE_REG(IO_MUX_GPIO_N_REG(pin), mux);
4200f8b2:	01072023          	sw	a6,0(a4)
    WRITE_REG(GPIO_FUNC_N_OUT_SEL_CFG_REG(pin), 128);
4200f8b6:	9746                	add	a4,a4,a7
4200f8b8:	c745                	beqz	a4,4200f960 <io_mode+0xf2>
4200f8ba:	08000893          	li	a7,128
4200f8be:	01172023          	sw	a7,0(a4)

    // Configure output enable bit.
    uint32_t out = READ_REG(GPIO_ENABLE_REG);
4200f8c2:	60091837          	lui	a6,0x60091
4200f8c6:	02082703          	lw	a4,32(a6) # 60091020 <__stop_free_lpsram+0x1008d020>
    if (mode == IO_MODE_INPUT) {
        out            &= ~(1 << pin);
4200f8ca:	8e8d                	sub	a3,a3,a1
    if (mode == IO_MODE_INPUT) {
4200f8cc:	4889                	li	a7,2
        out            &= ~(1 << pin);
4200f8ce:	00d7d6b3          	srl	a3,a5,a3
    if (mode == IO_MODE_INPUT) {
4200f8d2:	07160063          	beq	a2,a7,4200f932 <io_mode+0xc4>
        gpio_is_output &= ~(1 << pin);
    } else {
        out            |= 1 << pin;
4200f8d6:	e6c9                	bnez	a3,4200f960 <io_mode+0xf2>
        gpio_is_output |= 1 << pin;
4200f8d8:	4080a637          	lui	a2,0x4080a
4200f8dc:	e7462803          	lw	a6,-396(a2) # 40809e74 <gpio_is_output>
        out            |= 1 << pin;
4200f8e0:	00b797b3          	sll	a5,a5,a1
4200f8e4:	00e7e6b3          	or	a3,a5,a4
        gpio_is_output |= 1 << pin;
4200f8e8:	0107e7b3          	or	a5,a5,a6
    }
    WRITE_REG(GPIO_ENABLE_REG, out);
4200f8ec:	60091737          	lui	a4,0x60091
        gpio_is_output &= ~(1 << pin);
4200f8f0:	e6f62a23          	sw	a5,-396(a2)
    WRITE_REG(GPIO_ENABLE_REG, out);
4200f8f4:	d314                	sw	a3,32(a4)

    // Clear error status.
    if (err)
4200f8f6:	c511                	beqz	a0,4200f902 <io_mode+0x94>
        err->cause = 0;
4200f8f8:	00357793          	and	a5,a0,3
4200f8fc:	e3b5                	bnez	a5,4200f960 <io_mode+0xf2>
4200f8fe:	00052023          	sw	zero,0(a0)
}
4200f902:	8082                	ret
        if (err)
4200f904:	dd7d                	beqz	a0,4200f902 <io_mode+0x94>
            err->cause = ECAUSE_UNSUPPORTED;
4200f906:	00357713          	and	a4,a0,3
4200f90a:	eb39                	bnez	a4,4200f960 <io_mode+0xf2>
4200f90c:	474d                	li	a4,19
4200f90e:	c118                	sw	a4,0(a0)
            err->location = ELOC_GPIO;
4200f910:	5771                	li	a4,-4
4200f912:	04e57763          	bgeu	a0,a4,4200f960 <io_mode+0xf2>
            err->location = ELOC_GPIO;
4200f916:	c15c                	sw	a5,4(a0)
4200f918:	8082                	ret
        if (err)
4200f91a:	d565                	beqz	a0,4200f902 <io_mode+0x94>
            err->cause = ECAUSE_RANGE;
4200f91c:	00357793          	and	a5,a0,3
4200f920:	e3a1                	bnez	a5,4200f960 <io_mode+0xf2>
4200f922:	478d                	li	a5,3
4200f924:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200f926:	57f1                	li	a5,-4
4200f928:	02f57c63          	bgeu	a0,a5,4200f960 <io_mode+0xf2>
4200f92c:	4785                	li	a5,1
4200f92e:	c15c                	sw	a5,4(a0)
4200f930:	8082                	ret
        out            &= ~(1 << pin);
4200f932:	e69d                	bnez	a3,4200f960 <io_mode+0xf2>
        gpio_is_output &= ~(1 << pin);
4200f934:	4080a637          	lui	a2,0x4080a
4200f938:	e7462803          	lw	a6,-396(a2) # 40809e74 <gpio_is_output>
        out            &= ~(1 << pin);
4200f93c:	00b797b3          	sll	a5,a5,a1
4200f940:	fff7c793          	not	a5,a5
4200f944:	00e7f6b3          	and	a3,a5,a4
        gpio_is_output &= ~(1 << pin);
4200f948:	0107f7b3          	and	a5,a5,a6
4200f94c:	b745                	j	4200f8ec <io_mode+0x7e>
        if (err)
4200f94e:	d955                	beqz	a0,4200f902 <io_mode+0x94>
            err->cause = ECAUSE_INUSE;
4200f950:	00357713          	and	a4,a0,3
4200f954:	e711                	bnez	a4,4200f960 <io_mode+0xf2>
4200f956:	4739                	li	a4,14
4200f958:	c118                	sw	a4,0(a0)
            err->location = ELOC_GPIO;
4200f95a:	5771                	li	a4,-4
4200f95c:	fae56de3          	bltu	a0,a4,4200f916 <io_mode+0xa8>
        err->cause = 0;
4200f960:	9002                	ebreak

4200f962 <io_pull>:

void io_pull(badge_err_t *err, int pin, io_pull_t pull) {
    // Check pin bounds.
    if (pin < 0 || pin > io_count()) {
4200f962:	47fd                	li	a5,31
4200f964:	04b7e863          	bltu	a5,a1,4200f9b4 <io_pull+0x52>
            err->location = ELOC_GPIO;
        return;
    }

    // Configure pull bits.
    uint32_t mux = READ_REG(IO_MUX_GPIO_N_REG(pin));
4200f968:	180247b7          	lui	a5,0x18024
4200f96c:	0785                	add	a5,a5,1 # 18024001 <__stack_size+0x18022001>
4200f96e:	95be                	add	a1,a1,a5
4200f970:	058a                	sll	a1,a1,0x2
4200f972:	c1b5                	beqz	a1,4200f9d6 <io_pull+0x74>
4200f974:	419c                	lw	a5,0(a1)
    if (pull == IO_PULL_UP) {
4200f976:	4705                	li	a4,1
4200f978:	02e60263          	beq	a2,a4,4200f99c <io_pull+0x3a>
        mux |= IO_MUX_GPIO_N_FUN_WPU_BIT;
        mux &= ~IO_MUX_GPIO_N_FUN_WPD_BIT;
    } else if (pull == IO_PULL_DOWN) {
4200f97c:	4689                	li	a3,2
4200f97e:	04d60763          	beq	a2,a3,4200f9cc <io_pull+0x6a>
        mux |= IO_MUX_GPIO_N_FUN_WPD_BIT;
        mux &= ~IO_MUX_GPIO_N_FUN_WPU_BIT;
    } else if (pull == IO_PULL_NONE) {
        mux &= ~IO_MUX_GPIO_N_FUN_WPU_BIT;
        mux &= ~IO_MUX_GPIO_N_FUN_WPD_BIT;
4200f982:	e7f7f793          	and	a5,a5,-385
    } else if (pull == IO_PULL_NONE) {
4200f986:	ce19                	beqz	a2,4200f9a4 <io_pull+0x42>
    } else {
        if (err)
4200f988:	c50d                	beqz	a0,4200f9b2 <io_pull+0x50>
            err->cause = ECAUSE_PARAM;
4200f98a:	00357793          	and	a5,a0,3
4200f98e:	e7a1                	bnez	a5,4200f9d6 <io_pull+0x74>
4200f990:	c114                	sw	a3,0(a0)
        if (err)
            err->location = ELOC_GPIO;
4200f992:	57f1                	li	a5,-4
4200f994:	04f57163          	bgeu	a0,a5,4200f9d6 <io_pull+0x74>
4200f998:	c158                	sw	a4,4(a0)
4200f99a:	8082                	ret
        mux &= ~IO_MUX_GPIO_N_FUN_WPD_BIT;
4200f99c:	f7f7f793          	and	a5,a5,-129
4200f9a0:	1007e793          	or	a5,a5,256
        return;
    }
    WRITE_REG(IO_MUX_GPIO_N_REG(pin), mux);
4200f9a4:	c19c                	sw	a5,0(a1)

    // Clear error status.
    if (err)
4200f9a6:	c511                	beqz	a0,4200f9b2 <io_pull+0x50>
        err->cause = 0;
4200f9a8:	00357793          	and	a5,a0,3
4200f9ac:	e78d                	bnez	a5,4200f9d6 <io_pull+0x74>
4200f9ae:	00052023          	sw	zero,0(a0)
}
4200f9b2:	8082                	ret
        if (err)
4200f9b4:	dd7d                	beqz	a0,4200f9b2 <io_pull+0x50>
            err->cause = ECAUSE_RANGE;
4200f9b6:	00357793          	and	a5,a0,3
4200f9ba:	ef91                	bnez	a5,4200f9d6 <io_pull+0x74>
4200f9bc:	478d                	li	a5,3
4200f9be:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200f9c0:	57f1                	li	a5,-4
4200f9c2:	00f57a63          	bgeu	a0,a5,4200f9d6 <io_pull+0x74>
4200f9c6:	4785                	li	a5,1
4200f9c8:	c15c                	sw	a5,4(a0)
4200f9ca:	8082                	ret
        mux &= ~IO_MUX_GPIO_N_FUN_WPU_BIT;
4200f9cc:	eff7f793          	and	a5,a5,-257
4200f9d0:	0807e793          	or	a5,a5,128
4200f9d4:	bfc1                	j	4200f9a4 <io_pull+0x42>
        err->cause = 0;
4200f9d6:	9002                	ebreak

4200f9d8 <io_write>:

void io_write(badge_err_t *err, int pin, bool level) {
    // Check pin bounds.
    if (pin < 0 || pin > io_count()) {
4200f9d8:	47fd                	li	a5,31
4200f9da:	04b7e663          	bltu	a5,a1,4200fa26 <io_write+0x4e>
            err->location = ELOC_GPIO;
        return;
    }

    // Assert pin is an output.
    if (!((gpio_is_output >> pin) & 1)) {
4200f9de:	4080a737          	lui	a4,0x4080a
4200f9e2:	e7472703          	lw	a4,-396(a4) # 40809e74 <gpio_is_output>
4200f9e6:	00b75733          	srl	a4,a4,a1
4200f9ea:	8b05                	and	a4,a4,1
4200f9ec:	c31d                	beqz	a4,4200fa12 <io_write+0x3a>
        return;
    }

    // Write to the GPIO output register.
    if (level)
        WRITE_REG(GPIO_OUT_W1TS_REG, 1 << pin);
4200f9ee:	8f8d                	sub	a5,a5,a1
4200f9f0:	4705                	li	a4,1
4200f9f2:	00f757b3          	srl	a5,a4,a5
    if (level)
4200f9f6:	c621                	beqz	a2,4200fa3e <io_write+0x66>
        WRITE_REG(GPIO_OUT_W1TS_REG, 1 << pin);
4200f9f8:	e795                	bnez	a5,4200fa24 <io_write+0x4c>
4200f9fa:	600917b7          	lui	a5,0x60091
4200f9fe:	00b71733          	sll	a4,a4,a1
4200fa02:	c798                	sw	a4,8(a5)
    else
        WRITE_REG(GPIO_OUT_W1TC_REG, 1 << pin);

    // Clear error status.
    if (err)
4200fa04:	c511                	beqz	a0,4200fa10 <io_write+0x38>
        err->cause = 0;
4200fa06:	00357793          	and	a5,a0,3
4200fa0a:	ef89                	bnez	a5,4200fa24 <io_write+0x4c>
4200fa0c:	00052023          	sw	zero,0(a0)
}
4200fa10:	8082                	ret
        if (err)
4200fa12:	dd7d                	beqz	a0,4200fa10 <io_write+0x38>
            err->cause = ECAUSE_NOTCONFIG;
4200fa14:	00357793          	and	a5,a0,3
4200fa18:	e791                	bnez	a5,4200fa24 <io_write+0x4c>
4200fa1a:	47bd                	li	a5,15
4200fa1c:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fa1e:	57f1                	li	a5,-4
4200fa20:	00f56c63          	bltu	a0,a5,4200fa38 <io_write+0x60>
        err->cause = 0;
4200fa24:	9002                	ebreak
        if (err)
4200fa26:	d56d                	beqz	a0,4200fa10 <io_write+0x38>
            err->cause = ECAUSE_RANGE;
4200fa28:	00357793          	and	a5,a0,3
4200fa2c:	ffe5                	bnez	a5,4200fa24 <io_write+0x4c>
4200fa2e:	478d                	li	a5,3
4200fa30:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fa32:	57f1                	li	a5,-4
4200fa34:	fef578e3          	bgeu	a0,a5,4200fa24 <io_write+0x4c>
            err->location = ELOC_GPIO;
4200fa38:	4785                	li	a5,1
4200fa3a:	c15c                	sw	a5,4(a0)
4200fa3c:	8082                	ret
        WRITE_REG(GPIO_OUT_W1TC_REG, 1 << pin);
4200fa3e:	f3fd                	bnez	a5,4200fa24 <io_write+0x4c>
4200fa40:	600917b7          	lui	a5,0x60091
4200fa44:	00b71733          	sll	a4,a4,a1
4200fa48:	c7d8                	sw	a4,12(a5)
4200fa4a:	bf6d                	j	4200fa04 <io_write+0x2c>

4200fa4c <io_read>:

bool io_read(badge_err_t *err, int pin) {
    // Check pin bounds.
    if (pin < 0 || pin > io_count()) {
4200fa4c:	47fd                	li	a5,31
4200fa4e:	00b7ef63          	bltu	a5,a1,4200fa6c <io_read+0x20>
            err->location = ELOC_GPIO;
        return 0;
    }

    // Clear error status.
    if (err)
4200fa52:	c511                	beqz	a0,4200fa5e <io_read+0x12>
        err->cause = 0;
4200fa54:	00357793          	and	a5,a0,3
4200fa58:	e79d                	bnez	a5,4200fa86 <io_read+0x3a>
4200fa5a:	00052023          	sw	zero,0(a0)

    // Read GPIO input register.
    return (READ_REG(GPIO_IN_REG) >> pin) & 1;
4200fa5e:	600917b7          	lui	a5,0x60091
4200fa62:	5fc8                	lw	a0,60(a5)
4200fa64:	00b55533          	srl	a0,a0,a1
4200fa68:	8905                	and	a0,a0,1
}
4200fa6a:	8082                	ret
        if (err)
4200fa6c:	c919                	beqz	a0,4200fa82 <io_read+0x36>
            err->cause = ECAUSE_RANGE;
4200fa6e:	00357793          	and	a5,a0,3
4200fa72:	eb91                	bnez	a5,4200fa86 <io_read+0x3a>
4200fa74:	478d                	li	a5,3
4200fa76:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fa78:	57f1                	li	a5,-4
4200fa7a:	00f57663          	bgeu	a0,a5,4200fa86 <io_read+0x3a>
4200fa7e:	4785                	li	a5,1
4200fa80:	c15c                	sw	a5,4(a0)
        return 0;
4200fa82:	4501                	li	a0,0
4200fa84:	8082                	ret
        err->cause = 0;
4200fa86:	9002                	ebreak

4200fa88 <io_is_peripheral>:

// Determine whether GPIO `pin` is claimed by a peripheral.
// Returns false on error.
bool io_is_peripheral(badge_err_t *err, int pin) {
    // Check pin bounds.
    if (pin < 0 || pin > io_count()) {
4200fa88:	47fd                	li	a5,31
4200fa8a:	02b7e063          	bltu	a5,a1,4200faaa <io_is_peripheral+0x22>
            err->location = ELOC_GPIO;
        return 0;
    }

    // Clear error status.
    if (err)
4200fa8e:	c511                	beqz	a0,4200fa9a <io_is_peripheral+0x12>
        err->cause = 0;
4200fa90:	00357793          	and	a5,a0,3
4200fa94:	eb85                	bnez	a5,4200fac4 <io_is_peripheral+0x3c>
4200fa96:	00052023          	sw	zero,0(a0)

    return (gpio_is_peripheral >> pin) & 1;
4200fa9a:	4080a7b7          	lui	a5,0x4080a
4200fa9e:	e787a503          	lw	a0,-392(a5) # 40809e78 <gpio_is_peripheral>
4200faa2:	00b55533          	srl	a0,a0,a1
4200faa6:	8905                	and	a0,a0,1
}
4200faa8:	8082                	ret
        if (err)
4200faaa:	c919                	beqz	a0,4200fac0 <io_is_peripheral+0x38>
            err->cause = ECAUSE_RANGE;
4200faac:	00357793          	and	a5,a0,3
4200fab0:	eb91                	bnez	a5,4200fac4 <io_is_peripheral+0x3c>
4200fab2:	478d                	li	a5,3
4200fab4:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fab6:	57f1                	li	a5,-4
4200fab8:	00f57663          	bgeu	a0,a5,4200fac4 <io_is_peripheral+0x3c>
4200fabc:	4785                	li	a5,1
4200fabe:	c15c                	sw	a5,4(a0)
        return 0;
4200fac0:	4501                	li	a0,0
4200fac2:	8082                	ret
        err->cause = 0;
4200fac4:	9002                	ebreak

4200fac6 <rawgpio_set_peripheral>:


// Enable or disable "claimed by peripheral" mode for GPIO `pin`.
void rawgpio_set_peripheral(badge_err_t *err, int pin, bool claim_as_peripheral) {
    // Check pin bounds.
    if (pin < 0 || pin > io_count()) {
4200fac6:	47fd                	li	a5,31
4200fac8:	04b7ef63          	bltu	a5,a1,4200fb26 <rawgpio_set_peripheral+0x60>
        return;
    }

    // Set claimed flag.
    if (claim_as_peripheral) {
        gpio_is_peripheral |= 1 << pin;
4200facc:	8f8d                	sub	a5,a5,a1
4200face:	4705                	li	a4,1
4200fad0:	00f757b3          	srl	a5,a4,a5
    if (claim_as_peripheral) {
4200fad4:	ce05                	beqz	a2,4200fb0c <rawgpio_set_peripheral+0x46>
        gpio_is_peripheral |= 1 << pin;
4200fad6:	e7a5                	bnez	a5,4200fb3e <rawgpio_set_peripheral+0x78>
4200fad8:	4080a837          	lui	a6,0x4080a
        gpio_is_output     &= ~(1 << pin);
4200fadc:	4080a637          	lui	a2,0x4080a
        gpio_is_peripheral |= 1 << pin;
4200fae0:	e7882683          	lw	a3,-392(a6) # 40809e78 <gpio_is_peripheral>
        gpio_is_output     &= ~(1 << pin);
4200fae4:	e7462883          	lw	a7,-396(a2) # 40809e74 <gpio_is_output>
        gpio_is_peripheral |= 1 << pin;
4200fae8:	00b71733          	sll	a4,a4,a1
        gpio_is_output     &= ~(1 << pin);
4200faec:	fff74793          	not	a5,a4
4200faf0:	0117f7b3          	and	a5,a5,a7
        gpio_is_peripheral |= 1 << pin;
4200faf4:	8f55                	or	a4,a4,a3
4200faf6:	e6e82c23          	sw	a4,-392(a6)
        gpio_is_output     &= ~(1 << pin);
4200fafa:	e6f62a23          	sw	a5,-396(a2)
    } else {
        gpio_is_peripheral &= ~(1 << pin);
    }

    // Clear error status.
    if (err)
4200fafe:	c511                	beqz	a0,4200fb0a <rawgpio_set_peripheral+0x44>
        err->cause = 0;
4200fb00:	00357793          	and	a5,a0,3
4200fb04:	ef8d                	bnez	a5,4200fb3e <rawgpio_set_peripheral+0x78>
4200fb06:	00052023          	sw	zero,0(a0)
}
4200fb0a:	8082                	ret
        gpio_is_peripheral &= ~(1 << pin);
4200fb0c:	eb8d                	bnez	a5,4200fb3e <rawgpio_set_peripheral+0x78>
4200fb0e:	4080a7b7          	lui	a5,0x4080a
4200fb12:	e787a683          	lw	a3,-392(a5) # 40809e78 <gpio_is_peripheral>
4200fb16:	00b71733          	sll	a4,a4,a1
4200fb1a:	fff74713          	not	a4,a4
4200fb1e:	8f75                	and	a4,a4,a3
4200fb20:	e6e7ac23          	sw	a4,-392(a5)
4200fb24:	bfe9                	j	4200fafe <rawgpio_set_peripheral+0x38>
        if (err)
4200fb26:	d175                	beqz	a0,4200fb0a <rawgpio_set_peripheral+0x44>
            err->cause = ECAUSE_RANGE;
4200fb28:	00357793          	and	a5,a0,3
4200fb2c:	eb89                	bnez	a5,4200fb3e <rawgpio_set_peripheral+0x78>
4200fb2e:	478d                	li	a5,3
4200fb30:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fb32:	57f1                	li	a5,-4
4200fb34:	00f57563          	bgeu	a0,a5,4200fb3e <rawgpio_set_peripheral+0x78>
4200fb38:	4785                	li	a5,1
4200fb3a:	c15c                	sw	a5,4(a0)
4200fb3c:	8082                	ret
        err->cause = 0;
4200fb3e:	9002                	ebreak

4200fb40 <rawgpio_route_input>:

// Route GPIO `pin` to input signal `signo`.
void rawgpio_route_input(badge_err_t *err, int pin, int signo) {
    // Check bounds.
    if (pin < 0 || pin > io_count() || signo < 0 || signo > 127) {
4200fb40:	47fd                	li	a5,31
4200fb42:	02b7ed63          	bltu	a5,a1,4200fb7c <rawgpio_route_input+0x3c>
4200fb46:	07f00793          	li	a5,127
4200fb4a:	02c7e963          	bltu	a5,a2,4200fb7c <rawgpio_route_input+0x3c>
            err->location = ELOC_GPIO;
        return;
    }

    // Assert that pin is claimed for peripheral use.
    if (!((gpio_is_peripheral >> pin) & 1)) {
4200fb4e:	4080a7b7          	lui	a5,0x4080a
4200fb52:	e787a783          	lw	a5,-392(a5) # 40809e78 <gpio_is_peripheral>
4200fb56:	00b7d7b3          	srl	a5,a5,a1
4200fb5a:	8b85                	and	a5,a5,1
4200fb5c:	cf85                	beqz	a5,4200fb94 <rawgpio_route_input+0x54>
            err->location = ELOC_GPIO;
        return;
    }

    // Configure FUNC_OUT_SEL.
    WRITE_REG(GPIO_FUNC_N_OUT_SEL_CFG_REG(pin), signo);
4200fb5e:	180247b7          	lui	a5,0x18024
4200fb62:	55578793          	add	a5,a5,1365 # 18024555 <__stack_size+0x18022555>
4200fb66:	95be                	add	a1,a1,a5
4200fb68:	058a                	sll	a1,a1,0x2
4200fb6a:	cd95                	beqz	a1,4200fba6 <rawgpio_route_input+0x66>
4200fb6c:	c190                	sw	a2,0(a1)

    // Clear error status.
    if (err)
4200fb6e:	c511                	beqz	a0,4200fb7a <rawgpio_route_input+0x3a>
        err->cause = 0;
4200fb70:	00357793          	and	a5,a0,3
4200fb74:	eb8d                	bnez	a5,4200fba6 <rawgpio_route_input+0x66>
4200fb76:	00052023          	sw	zero,0(a0)
}
4200fb7a:	8082                	ret
        if (err)
4200fb7c:	dd7d                	beqz	a0,4200fb7a <rawgpio_route_input+0x3a>
            err->cause = ECAUSE_RANGE;
4200fb7e:	00357793          	and	a5,a0,3
4200fb82:	e395                	bnez	a5,4200fba6 <rawgpio_route_input+0x66>
4200fb84:	478d                	li	a5,3
4200fb86:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fb88:	57f1                	li	a5,-4
4200fb8a:	00f57e63          	bgeu	a0,a5,4200fba6 <rawgpio_route_input+0x66>
            err->location = ELOC_GPIO;
4200fb8e:	4785                	li	a5,1
4200fb90:	c15c                	sw	a5,4(a0)
4200fb92:	8082                	ret
        if (err)
4200fb94:	d17d                	beqz	a0,4200fb7a <rawgpio_route_input+0x3a>
            err->cause = ECAUSE_NOTCONFIG;
4200fb96:	00357793          	and	a5,a0,3
4200fb9a:	e791                	bnez	a5,4200fba6 <rawgpio_route_input+0x66>
4200fb9c:	47bd                	li	a5,15
4200fb9e:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fba0:	57f1                	li	a5,-4
4200fba2:	fef566e3          	bltu	a0,a5,4200fb8e <rawgpio_route_input+0x4e>
        err->cause = 0;
4200fba6:	9002                	ebreak

4200fba8 <rawgpio_route_output>:

// Route GPIO `pin` to output signal `signo`.
void rawgpio_route_output(badge_err_t *err, int pin, int signo) {
    // Check bounds.
    if (pin < 0 || pin > io_count() || signo < 0 || signo > 127) {
4200fba8:	47fd                	li	a5,31
4200fbaa:	02b7ed63          	bltu	a5,a1,4200fbe4 <rawgpio_route_output+0x3c>
4200fbae:	07f00793          	li	a5,127
4200fbb2:	02c7e963          	bltu	a5,a2,4200fbe4 <rawgpio_route_output+0x3c>
            err->location = ELOC_GPIO;
        return;
    }

    // Assert that pin is claimed for peripheral use.
    if (!((gpio_is_peripheral >> pin) & 1)) {
4200fbb6:	4080a7b7          	lui	a5,0x4080a
4200fbba:	e787a783          	lw	a5,-392(a5) # 40809e78 <gpio_is_peripheral>
4200fbbe:	00b7d7b3          	srl	a5,a5,a1
4200fbc2:	8b85                	and	a5,a5,1
4200fbc4:	cf85                	beqz	a5,4200fbfc <rawgpio_route_output+0x54>
            err->location = ELOC_GPIO;
        return;
    }

    // Configure FUNC_IN_SEL.
    WRITE_REG(GPIO_FUNC_N_IN_SEL_CFG_REG(signo), pin);
4200fbc6:	180247b7          	lui	a5,0x18024
4200fbca:	45578793          	add	a5,a5,1109 # 18024455 <__stack_size+0x18022455>
4200fbce:	963e                	add	a2,a2,a5
4200fbd0:	060a                	sll	a2,a2,0x2
4200fbd2:	ce15                	beqz	a2,4200fc0e <rawgpio_route_output+0x66>
4200fbd4:	c20c                	sw	a1,0(a2)

    // Clear error status.
    if (err)
4200fbd6:	c511                	beqz	a0,4200fbe2 <rawgpio_route_output+0x3a>
        err->cause = 0;
4200fbd8:	00357793          	and	a5,a0,3
4200fbdc:	eb8d                	bnez	a5,4200fc0e <rawgpio_route_output+0x66>
4200fbde:	00052023          	sw	zero,0(a0)
}
4200fbe2:	8082                	ret
        if (err)
4200fbe4:	dd7d                	beqz	a0,4200fbe2 <rawgpio_route_output+0x3a>
            err->cause = ECAUSE_RANGE;
4200fbe6:	00357793          	and	a5,a0,3
4200fbea:	e395                	bnez	a5,4200fc0e <rawgpio_route_output+0x66>
4200fbec:	478d                	li	a5,3
4200fbee:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fbf0:	57f1                	li	a5,-4
4200fbf2:	00f57e63          	bgeu	a0,a5,4200fc0e <rawgpio_route_output+0x66>
            err->location = ELOC_GPIO;
4200fbf6:	4785                	li	a5,1
4200fbf8:	c15c                	sw	a5,4(a0)
4200fbfa:	8082                	ret
        if (err)
4200fbfc:	d17d                	beqz	a0,4200fbe2 <rawgpio_route_output+0x3a>
            err->cause = ECAUSE_NOTCONFIG;
4200fbfe:	00357793          	and	a5,a0,3
4200fc02:	e791                	bnez	a5,4200fc0e <rawgpio_route_output+0x66>
4200fc04:	47bd                	li	a5,15
4200fc06:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fc08:	57f1                	li	a5,-4
4200fc0a:	fef566e3          	bltu	a0,a5,4200fbf6 <rawgpio_route_output+0x4e>
        err->cause = 0;
4200fc0e:	9002                	ebreak

4200fc10 <rawgpio_unroute>:

// Disable the signal routing and turn GPIO `pin` into a regular GPIO.
void rawgpio_unroute(badge_err_t *err, int pin) {
    // Check pin bounds.
    if (pin < 0 || pin > io_count()) {
4200fc10:	47fd                	li	a5,31
4200fc12:	06b7e963          	bltu	a5,a1,4200fc84 <rawgpio_unroute+0x74>
            err->location = ELOC_GPIO;
        return;
    }

    // Assert that pin is claimed for peripheral use.
    if (!((gpio_is_peripheral >> pin) & 1)) {
4200fc16:	4080a7b7          	lui	a5,0x4080a
4200fc1a:	e787a783          	lw	a5,-392(a5) # 40809e78 <gpio_is_peripheral>
4200fc1e:	00b7d7b3          	srl	a5,a5,a1
4200fc22:	8b85                	and	a5,a5,1
4200fc24:	c7b1                	beqz	a5,4200fc70 <rawgpio_unroute+0x60>
            err->location = ELOC_GPIO;
        return;
    }

    // Configure FUNC_OUT_SEL.
    WRITE_REG(GPIO_FUNC_N_OUT_SEL_CFG_REG(pin), 128);
4200fc26:	180247b7          	lui	a5,0x18024
4200fc2a:	55578793          	add	a5,a5,1365 # 18024555 <__stack_size+0x18022555>
4200fc2e:	97ae                	add	a5,a5,a1
4200fc30:	00279713          	sll	a4,a5,0x2
4200fc34:	c739                	beqz	a4,4200fc82 <rawgpio_unroute+0x72>
4200fc36:	08000613          	li	a2,128
4200fc3a:	600917b7          	lui	a5,0x60091

    // Search FUNC_IN_SEL registers.
    for (int i = 0; i < 128; i++) {
4200fc3e:	600916b7          	lui	a3,0x60091
    WRITE_REG(GPIO_FUNC_N_OUT_SEL_CFG_REG(pin), 128);
4200fc42:	c310                	sw	a2,0(a4)
4200fc44:	15478793          	add	a5,a5,340 # 60091154 <__stop_free_lpsram+0x1008d154>
        int fpin = READ_REG(GPIO_FUNC_N_IN_SEL_CFG_REG(i)) & 31;
        if (fpin == pin) {
            WRITE_REG(GPIO_FUNC_N_IN_SEL_CFG_REG(i), 0x3C);
4200fc48:	03c00613          	li	a2,60
    for (int i = 0; i < 128; i++) {
4200fc4c:	35468693          	add	a3,a3,852 # 60091354 <__stop_free_lpsram+0x1008d354>
        int fpin = READ_REG(GPIO_FUNC_N_IN_SEL_CFG_REG(i)) & 31;
4200fc50:	cb8d                	beqz	a5,4200fc82 <rawgpio_unroute+0x72>
4200fc52:	4398                	lw	a4,0(a5)
4200fc54:	8b7d                	and	a4,a4,31
        if (fpin == pin) {
4200fc56:	00e59363          	bne	a1,a4,4200fc5c <rawgpio_unroute+0x4c>
            WRITE_REG(GPIO_FUNC_N_IN_SEL_CFG_REG(i), 0x3C);
4200fc5a:	c390                	sw	a2,0(a5)
    for (int i = 0; i < 128; i++) {
4200fc5c:	0791                	add	a5,a5,4
4200fc5e:	fed799e3          	bne	a5,a3,4200fc50 <rawgpio_unroute+0x40>
        }
    }

    // Clear error status.
    if (err)
4200fc62:	c511                	beqz	a0,4200fc6e <rawgpio_unroute+0x5e>
        err->cause = 0;
4200fc64:	00357793          	and	a5,a0,3
4200fc68:	ef89                	bnez	a5,4200fc82 <rawgpio_unroute+0x72>
4200fc6a:	00052023          	sw	zero,0(a0)
}
4200fc6e:	8082                	ret
        if (err)
4200fc70:	dd7d                	beqz	a0,4200fc6e <rawgpio_unroute+0x5e>
            err->cause = ECAUSE_NOTCONFIG;
4200fc72:	00357793          	and	a5,a0,3
4200fc76:	e791                	bnez	a5,4200fc82 <rawgpio_unroute+0x72>
4200fc78:	47bd                	li	a5,15
4200fc7a:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fc7c:	57f1                	li	a5,-4
4200fc7e:	00f56c63          	bltu	a0,a5,4200fc96 <rawgpio_unroute+0x86>
        err->cause = 0;
4200fc82:	9002                	ebreak
        if (err)
4200fc84:	d56d                	beqz	a0,4200fc6e <rawgpio_unroute+0x5e>
            err->cause = ECAUSE_RANGE;
4200fc86:	00357793          	and	a5,a0,3
4200fc8a:	ffe5                	bnez	a5,4200fc82 <rawgpio_unroute+0x72>
4200fc8c:	478d                	li	a5,3
4200fc8e:	c11c                	sw	a5,0(a0)
            err->location = ELOC_GPIO;
4200fc90:	57f1                	li	a5,-4
4200fc92:	fef578e3          	bgeu	a0,a5,4200fc82 <rawgpio_unroute+0x72>
            err->location = ELOC_GPIO;
4200fc96:	4785                	li	a5,1
4200fc98:	c15c                	sw	a5,4(a0)
4200fc9a:	8082                	ret

4200fc9c <i2c_master_init>:


// Initialises I²C peripheral i2c_num in slave mode with SDA pin `sda_pin`, SCL pin `scl_pin` and clock speed/bitrate
// bitrate. When initialised as an I²C master, the modes of the SDA and SCL pins are changed automatically. This
// function may be used again to change the settings on an initialised I²C peripheral in master mode.
void i2c_master_init(badge_err_t *ec, int i2c_num, int sda_pin, int scl_pin, int32_t bitrate) {
4200fc9c:	7179                	add	sp,sp,-48
4200fc9e:	d422                	sw	s0,40(sp)
4200fca0:	d226                	sw	s1,36(sp)
4200fca2:	d04a                	sw	s2,32(sp)
4200fca4:	ce4e                	sw	s3,28(sp)
4200fca6:	d606                	sw	ra,44(sp)
4200fca8:	84b2                	mv	s1,a2
4200fcaa:	89b6                	mv	s3,a3
4200fcac:	893a                	mv	s2,a4
    badge_err_t ec_dummy;
    if (!ec)
        ec = &ec_dummy;
4200fcae:	840a                	mv	s0,sp
    if (!ec)
4200fcb0:	c111                	beqz	a0,4200fcb4 <i2c_master_init+0x18>
4200fcb2:	842a                	mv	s0,a0

    // Check pin bounds.
    if (sda_pin < 0 || scl_pin > io_count() || scl_pin < 0 || scl_pin > io_count()) {
4200fcb4:	0204ca63          	bltz	s1,4200fce8 <i2c_master_init+0x4c>
4200fcb8:	47fd                	li	a5,31
4200fcba:	0337e763          	bltu	a5,s3,4200fce8 <i2c_master_init+0x4c>
        ec->location = ELOC_GPIO;
        return;
    }

    // Check I²C peripheral bounds.
    if (i2c_num != 0) {
4200fcbe:	c9a9                	beqz	a1,4200fd10 <i2c_master_init+0x74>
        ec->cause    = ECAUSE_RANGE;
4200fcc0:	10040f63          	beqz	s0,4200fdde <i2c_master_init+0x142>
4200fcc4:	00347793          	and	a5,s0,3
4200fcc8:	10079b63          	bnez	a5,4200fdde <i2c_master_init+0x142>
4200fccc:	478d                	li	a5,3
4200fcce:	c01c                	sw	a5,0(s0)
        ec->location = ELOC_I2C;
4200fcd0:	57f1                	li	a5,-4
4200fcd2:	10f47663          	bgeu	s0,a5,4200fdde <i2c_master_init+0x142>
4200fcd6:	4789                	li	a5,2
    if (ec->cause)
        return;
    rawgpio_route_output(ec, scl_pin, I2C_0_SCL_SIGNAL);
    if (ec->cause)
        return;
}
4200fcd8:	50b2                	lw	ra,44(sp)
        ec->location = ELOC_I2C;
4200fcda:	c05c                	sw	a5,4(s0)
}
4200fcdc:	5422                	lw	s0,40(sp)
4200fcde:	5492                	lw	s1,36(sp)
4200fce0:	5902                	lw	s2,32(sp)
4200fce2:	49f2                	lw	s3,28(sp)
4200fce4:	6145                	add	sp,sp,48
4200fce6:	8082                	ret
        ec->cause    = ECAUSE_RANGE;
4200fce8:	0e040b63          	beqz	s0,4200fdde <i2c_master_init+0x142>
4200fcec:	00347793          	and	a5,s0,3
4200fcf0:	0e079763          	bnez	a5,4200fdde <i2c_master_init+0x142>
4200fcf4:	478d                	li	a5,3
4200fcf6:	c01c                	sw	a5,0(s0)
        ec->location = ELOC_GPIO;
4200fcf8:	57f1                	li	a5,-4
4200fcfa:	0ef47263          	bgeu	s0,a5,4200fdde <i2c_master_init+0x142>
        ec->location = ELOC_GPIO;
4200fcfe:	4785                	li	a5,1
4200fd00:	c05c                	sw	a5,4(s0)
}
4200fd02:	50b2                	lw	ra,44(sp)
4200fd04:	5422                	lw	s0,40(sp)
4200fd06:	5492                	lw	s1,36(sp)
4200fd08:	5902                	lw	s2,32(sp)
4200fd0a:	49f2                	lw	s3,28(sp)
4200fd0c:	6145                	add	sp,sp,48
4200fd0e:	8082                	ret
    if (io_is_peripheral(NULL, sda_pin) || io_is_peripheral(NULL, scl_pin)) {
4200fd10:	85a6                	mv	a1,s1
4200fd12:	4501                	li	a0,0
4200fd14:	d75ff0ef          	jal	4200fa88 <io_is_peripheral>
4200fd18:	e955                	bnez	a0,4200fdcc <i2c_master_init+0x130>
4200fd1a:	85ce                	mv	a1,s3
4200fd1c:	d6dff0ef          	jal	4200fa88 <io_is_peripheral>
4200fd20:	e555                	bnez	a0,4200fdcc <i2c_master_init+0x130>
4200fd22:	cc52                	sw	s4,24(sp)
    clkconfig_i2c0(bitrate * 20, 1, 1);
4200fd24:	4a51                	li	s4,20
4200fd26:	03490533          	mul	a0,s2,s4
4200fd2a:	03491733          	mulh	a4,s2,s4
4200fd2e:	41f55793          	sra	a5,a0,0x1f
4200fd32:	0af71a63          	bne	a4,a5,4200fde6 <i2c_master_init+0x14a>
4200fd36:	4605                	li	a2,1
4200fd38:	4585                	li	a1,1
4200fd3a:	a77ff0ef          	jal	4200f7b0 <clkconfig_i2c0>
    WRITE_REG(I2C_SCL_LOW_PERIOD_REG, 10);
4200fd3e:	4629                	li	a2,10
4200fd40:	600047b7          	lui	a5,0x60004
4200fd44:	c390                	sw	a2,0(a5)
    WRITE_REG(I2C_SDA_HOLD_REG, 3);
4200fd46:	60004737          	lui	a4,0x60004
4200fd4a:	468d                	li	a3,3
4200fd4c:	db14                	sw	a3,48(a4)
    WRITE_REG(I2C_SDA_SAMPLE_REG, 5);
4200fd4e:	4715                	li	a4,5
4200fd50:	dbd8                	sw	a4,52(a5)
    WRITE_REG(I2C_SCL_HIGH_PERIOD_REG, 10);
4200fd52:	60004837          	lui	a6,0x60004
4200fd56:	02c82c23          	sw	a2,56(a6) # 60004038 <__stop_free_lpsram+0x10000038>
    WRITE_REG(I2C_SCL_STOP_HOLD_REG, 20);
4200fd5a:	600046b7          	lui	a3,0x60004
4200fd5e:	0546a423          	sw	s4,72(a3) # 60004048 <__stop_free_lpsram+0x10000048>
    WRITE_REG(I2C_SCL_STOP_SETUP_REG, 40);
4200fd62:	600047b7          	lui	a5,0x60004
4200fd66:	02800613          	li	a2,40
4200fd6a:	c7f0                	sw	a2,76(a5)
    WRITE_REG(I2C_SCL_ST_TIME_OUT_REG, 22);
4200fd6c:	45d9                	li	a1,22
4200fd6e:	60004737          	lui	a4,0x60004
4200fd72:	df2c                	sw	a1,120(a4)
    WRITE_REG(I2C_SCL_MAIN_ST_TIME_OUT_REG, 22);
4200fd74:	600047b7          	lui	a5,0x60004
    WRITE_REG(I2C_TO_REG, (1 << 5) | 9);
4200fd78:	60004637          	lui	a2,0x60004
    WRITE_REG(I2C_SCL_MAIN_ST_TIME_OUT_REG, 22);
4200fd7c:	dfec                	sw	a1,124(a5)
    WRITE_REG(I2C_TO_REG, (1 << 5) | 9);
4200fd7e:	02900593          	li	a1,41
4200fd82:	c64c                	sw	a1,12(a2)
    rawgpio_route_input(ec, sda_pin, I2C_0_SDA_SIGNAL);
4200fd84:	8522                	mv	a0,s0
4200fd86:	02e00613          	li	a2,46
4200fd8a:	85a6                	mv	a1,s1
4200fd8c:	db5ff0ef          	jal	4200fb40 <rawgpio_route_input>
    if (ec->cause)
4200fd90:	c839                	beqz	s0,4200fde6 <i2c_master_init+0x14a>
4200fd92:	00347793          	and	a5,s0,3
4200fd96:	eba1                	bnez	a5,4200fde6 <i2c_master_init+0x14a>
4200fd98:	401c                	lw	a5,0(s0)
4200fd9a:	e7a1                	bnez	a5,4200fde2 <i2c_master_init+0x146>
    rawgpio_route_output(ec, sda_pin, I2C_0_SDA_SIGNAL);
4200fd9c:	02e00613          	li	a2,46
4200fda0:	85a6                	mv	a1,s1
4200fda2:	8522                	mv	a0,s0
4200fda4:	e05ff0ef          	jal	4200fba8 <rawgpio_route_output>
    if (ec->cause)
4200fda8:	401c                	lw	a5,0(s0)
4200fdaa:	ef85                	bnez	a5,4200fde2 <i2c_master_init+0x146>
    rawgpio_route_input(ec, scl_pin, I2C_0_SCL_SIGNAL);
4200fdac:	02d00613          	li	a2,45
4200fdb0:	85ce                	mv	a1,s3
4200fdb2:	8522                	mv	a0,s0
4200fdb4:	d8dff0ef          	jal	4200fb40 <rawgpio_route_input>
    if (ec->cause)
4200fdb8:	401c                	lw	a5,0(s0)
4200fdba:	e785                	bnez	a5,4200fde2 <i2c_master_init+0x146>
    rawgpio_route_output(ec, scl_pin, I2C_0_SCL_SIGNAL);
4200fdbc:	02d00613          	li	a2,45
4200fdc0:	85ce                	mv	a1,s3
4200fdc2:	8522                	mv	a0,s0
4200fdc4:	de5ff0ef          	jal	4200fba8 <rawgpio_route_output>
4200fdc8:	4a62                	lw	s4,24(sp)
4200fdca:	bf25                	j	4200fd02 <i2c_master_init+0x66>
        ec->cause    = ECAUSE_INUSE;
4200fdcc:	c809                	beqz	s0,4200fdde <i2c_master_init+0x142>
4200fdce:	00347793          	and	a5,s0,3
4200fdd2:	e791                	bnez	a5,4200fdde <i2c_master_init+0x142>
4200fdd4:	47b9                	li	a5,14
4200fdd6:	c01c                	sw	a5,0(s0)
        ec->location = ELOC_GPIO;
4200fdd8:	57f1                	li	a5,-4
4200fdda:	f2f462e3          	bltu	s0,a5,4200fcfe <i2c_master_init+0x62>
4200fdde:	cc52                	sw	s4,24(sp)
4200fde0:	9002                	ebreak
4200fde2:	4a62                	lw	s4,24(sp)
4200fde4:	bf39                	j	4200fd02 <i2c_master_init+0x66>
    if (ec->cause)
4200fde6:	9002                	ebreak

4200fde8 <i2c_master_deinit>:

// De-initialises I²C peripheral i2c_num in master mode.
void i2c_master_deinit(badge_err_t *ec, int i2c_num) {
    (void)ec;
    (void)i2c_num;
}
4200fde8:	8082                	ret

4200fdea <i2c_master_read_from>:
    (void)i2c_num;
    (void)slave_id;
    (void)buf;
    (void)len;
    return 0;
}
4200fdea:	4501                	li	a0,0
4200fdec:	8082                	ret

4200fdee <i2c_master_write_to>:

// Writes len bytes from buffer buf to I²C slave with ID slave_id.
// This function blocks until the entire transaction is completed and returns the number of acknowledged written bytes.
size_t i2c_master_write_to(badge_err_t *ec, int i2c_num, int slave_id, uint8_t const *buf, size_t len) {
4200fdee:	4501                	li	a0,0
4200fdf0:	8082                	ret

4200fdf2 <interrupt_init>:
#include "port/intmtx.h"
#include "rawprint.h"
#include "time.h"

// Install interrupt and trap handlers.
void interrupt_init(isr_ctx_t *ctx) {
4200fdf2:	1141                	add	sp,sp,-16
4200fdf4:	c606                	sw	ra,12(sp)
4200fdf6:	c422                	sw	s0,8(sp)
    return mstatus & 8;
}
// Disable interrupts and return whether they were enabled.
static inline bool interrupt_disable() {
    uint32_t mstatus;
    asm volatile("csrrci %0, mstatus, 8" : "=r"(mstatus));
4200fdf8:	30047473          	csrrc	s0,mstatus,8
    // Disable interrupts.
    bool mie = interrupt_disable();

    // Disable interrupt delegation.
    asm volatile("csrw mideleg, x0");
4200fdfc:	30301073          	csrw	mideleg,zero

    // Set up trap handler (vectored mode; 256 byte-aligned).
    asm volatile("csrw mtvec, %0" ::"r"((size_t)&__interrupt_vector_table | 1));
4200fe00:	420007b7          	lui	a5,0x42000
4200fe04:	40078793          	add	a5,a5,1024 # 42000400 <__interrupt_vector_table>
4200fe08:	0017e793          	or	a5,a5,1
4200fe0c:	30579073          	csrw	mtvec,a5

    // Set up trap context.
    asm volatile("csrw mscratch, %0" ::"r"(ctx));
4200fe10:	34051073          	csrw	mscratch,a0

    // Mark this thread as privileged.
    ctx->is_kernel_thread = true;
4200fe14:	cd21                	beqz	a0,4200fe6c <interrupt_init+0x7a>
4200fe16:	00357793          	and	a5,a0,3
4200fe1a:	eba9                	bnez	a5,4200fe6c <interrupt_init+0x7a>
4200fe1c:	f5800793          	li	a5,-168
4200fe20:	04f57663          	bgeu	a0,a5,4200fe6c <interrupt_init+0x7a>
4200fe24:	4785                	li	a5,1
4200fe26:	0af52423          	sw	a5,168(a0)

    // Configure interrupt matrix.
    intmtx_init();
4200fe2a:	2051                	jal	4200feae <intmtx_init>

    intmtx_set_prio(INT_CHANNEL_TIMER_ALARM, INT_PRIO_TIMER_ALARM);
4200fe2c:	45ad                	li	a1,11
4200fe2e:	4541                	li	a0,16
4200fe30:	2a99                	jal	4200ff86 <intmtx_set_prio>
    intmtx_set_prio(INT_CHANNEL_WATCHDOG_ALARM, INT_PRIO_WATCHDOG_ALARM);
4200fe32:	45bd                	li	a1,15
4200fe34:	4545                	li	a0,17
4200fe36:	2a81                	jal	4200ff86 <intmtx_set_prio>
    intmtx_set_prio(INT_CHANNEL_UART, INT_PRIO_UART);
4200fe38:	45b9                	li	a1,14
4200fe3a:	4549                	li	a0,18
4200fe3c:	22a9                	jal	4200ff86 <intmtx_set_prio>
    intmtx_set_prio(INT_CHANNEL_I2C, INT_PRIO_I2C);
4200fe3e:	45b5                	li	a1,13
4200fe40:	454d                	li	a0,19
4200fe42:	2291                	jal	4200ff86 <intmtx_set_prio>
    intmtx_set_prio(INT_CHANNEL_SPI, INT_PRIO_SPI);
4200fe44:	45b1                	li	a1,12
4200fe46:	4551                	li	a0,20
4200fe48:	2a3d                	jal	4200ff86 <intmtx_set_prio>

    intmtx_enable(INT_CHANNEL_TIMER_ALARM);
4200fe4a:	4541                	li	a0,16
4200fe4c:	2a55                	jal	42010000 <intmtx_enable>
    // intmtx_enable(INT_CHANNEL_UART);
    // intmtx_enable(INT_CHANNEL_I2C);
    // intmtx_enable(INT_CHANNEL_SPI);

    // Enable interrupt channels.
    asm volatile("csrw mie, %0" ::"r"(
4200fe4e:	8821                	and	s0,s0,8
4200fe50:	001f07b7          	lui	a5,0x1f0
4200fe54:	30479073          	csrw	mie,a5
        (1 << INT_CHANNEL_TIMER_ALARM) | (1 << INT_CHANNEL_WATCHDOG_ALARM) | (1 << INT_CHANNEL_UART) |
        (1 << INT_CHANNEL_I2C) | (1 << INT_CHANNEL_SPI)
    ));

    asm volatile("fence");
4200fe58:	0ff0000f          	fence

    // Re-enable interrupts.
    if (mie) {
4200fe5c:	c401                	beqz	s0,4200fe64 <interrupt_init+0x72>
    return mstatus & 8;
}
// Enable interrupts.
static inline void interrupt_enable() {
    asm volatile("csrs mstatus, %0" ::"r"(8));
4200fe5e:	47a1                	li	a5,8
4200fe60:	3007a073          	csrs	mstatus,a5
        interrupt_enable();
    }
}
4200fe64:	40b2                	lw	ra,12(sp)
4200fe66:	4422                	lw	s0,8(sp)
4200fe68:	0141                	add	sp,sp,16
4200fe6a:	8082                	ret
    ctx->is_kernel_thread = true;
4200fe6c:	9002                	ebreak

4200fe6e <interrupt_channel_get_prio>:



// Get the priority of an interrupt channel.
int interrupt_channel_get_prio(int channel) {
    return intmtx_get_prio(channel);
4200fe6e:	aa35                	j	4200ffaa <intmtx_get_prio>

4200fe70 <interrupt_channel_set_prio>:
}

// Set the priority of an interrupt channel.
void interrupt_channel_set_prio(int channel, int priority) {
    intmtx_set_prio(channel, priority);
4200fe70:	aa19                	j	4200ff86 <intmtx_set_prio>

4200fe72 <interrupt_channel_is_enabled>:
}

// Query whether a specific interrupt channel is enabled.
bool interrupt_channel_is_enabled(int channel) {
    return intmtx_is_enabled(channel);
4200fe72:	a29d                	j	4200ffd8 <intmtx_is_enabled>

4200fe74 <interrupt_channel_disable>:
}

// Disable a specific interrupt channel and return whether it was enabled.
bool interrupt_channel_disable(int channel) {
    return intmtx_disable(channel);
4200fe74:	aa4d                	j	42010026 <intmtx_disable>

4200fe76 <interrupt_channel_enable>:
}

// Enable a specific interrupt channel.
void interrupt_channel_enable(int channel) {
    intmtx_enable(channel);
4200fe76:	a269                	j	42010000 <intmtx_enable>

4200fe78 <__interrupt_handler>:
}



// Callback from ASM to platform-specific interrupt handler.
void __interrupt_handler() {
4200fe78:	1141                	add	sp,sp,-16
4200fe7a:	c422                	sw	s0,8(sp)
4200fe7c:	c606                	sw	ra,12(sp)
    // Get interrupt cause.
    int mcause;
    asm("csrr %0, mcause" : "=r"(mcause));
4200fe7e:	34202473          	csrr	s0,mcause
    mcause &= 31;

    // Jump to ISRs.
    switch (mcause) {
4200fe82:	47c1                	li	a5,16
    mcause &= 31;
4200fe84:	887d                	and	s0,s0,31
    switch (mcause) {
4200fe86:	00f40c63          	beq	s0,a5,4200fe9e <__interrupt_handler+0x26>
4200fe8a:	47c5                	li	a5,17
4200fe8c:	02f41063          	bne	s0,a5,4200feac <__interrupt_handler+0x34>
        case INT_CHANNEL_TIMER_ALARM: timer_isr_timer_alarm(); break;
        case INT_CHANNEL_WATCHDOG_ALARM: timer_isr_watchdog_alarm(); break;
4200fe90:	16b000ef          	jal	420107fa <timer_isr_watchdog_alarm>
        default: __builtin_unreachable();
    }

    // Acknowledge interrupt.
    intmtx_ack(mcause);
4200fe94:	8522                	mv	a0,s0
}
4200fe96:	4422                	lw	s0,8(sp)
4200fe98:	40b2                	lw	ra,12(sp)
4200fe9a:	0141                	add	sp,sp,16
    intmtx_ack(mcause);
4200fe9c:	aa6d                	j	42010056 <intmtx_ack>
        case INT_CHANNEL_TIMER_ALARM: timer_isr_timer_alarm(); break;
4200fe9e:	129000ef          	jal	420107c6 <timer_isr_timer_alarm>
    intmtx_ack(mcause);
4200fea2:	8522                	mv	a0,s0
}
4200fea4:	4422                	lw	s0,8(sp)
4200fea6:	40b2                	lw	ra,12(sp)
4200fea8:	0141                	add	sp,sp,16
    intmtx_ack(mcause);
4200feaa:	a275                	j	42010056 <intmtx_ack>
        default: __builtin_unreachable();
4200feac:	9002                	ebreak

4200feae <intmtx_init>:


// Initialise the interrupt matrix with defaults.
void intmtx_init() {
    // Unroute all interrupt channels.
    for (size_t i = 0; i < sizeof(offsets) / sizeof(uint16_t); i++) {
4200feae:	2a018613          	add	a2,gp,672 # 408002a0 <offsets>
4200feb2:	4809                	li	a6,2
4200feb4:	2a018693          	add	a3,gp,672 # 408002a0 <offsets>
4200feb8:	40c80833          	sub	a6,a6,a2
4200febc:	4701                	li	a4,0
        WRITE_REG(INTMTX_BASE + offsets[i], 0);
4200febe:	03f00593          	li	a1,63
4200fec2:	07e00313          	li	t1,126
4200fec6:	600108b7          	lui	a7,0x60010
4200feca:	0ab77663          	bgeu	a4,a1,4200ff76 <intmtx_init+0xc8>
4200fece:	00d80533          	add	a0,a6,a3
4200fed2:	00171793          	sll	a5,a4,0x1
4200fed6:	08a36d63          	bltu	t1,a0,4200ff70 <intmtx_init+0xc2>
4200feda:	97b2                	add	a5,a5,a2
4200fedc:	08c7ed63          	bltu	a5,a2,4200ff76 <intmtx_init+0xc8>
4200fee0:	0006d783          	lhu	a5,0(a3)
4200fee4:	97c6                	add	a5,a5,a7
4200fee6:	cbc1                	beqz	a5,4200ff76 <intmtx_init+0xc8>
4200fee8:	0037f513          	and	a0,a5,3
4200feec:	e549                	bnez	a0,4200ff76 <intmtx_init+0xc8>
4200feee:	0007a023          	sw	zero,0(a5) # 1f0000 <__stack_size+0x1ee000>
    for (size_t i = 0; i < sizeof(offsets) / sizeof(uint16_t); i++) {
4200fef2:	0705                	add	a4,a4,1 # 60004001 <__stop_free_lpsram+0x10000001>
4200fef4:	0689                	add	a3,a3,2
4200fef6:	fcb71ae3          	bne	a4,a1,4200feca <intmtx_init+0x1c>
4200fefa:	200017b7          	lui	a5,0x20001
    }

    // Reset PLIC.
    for (size_t i = 0; i < 32; i++) {
4200fefe:	20001737          	lui	a4,0x20001
4200ff02:	07c1                	add	a5,a5,16 # 20001010 <__stack_size+0x1ffff010>
4200ff04:	09070713          	add	a4,a4,144 # 20001090 <__stack_size+0x1ffff090>
        WRITE_REG(PLIC_MX_INT_PRI_N_REG(i), 0);
4200ff08:	c7bd                	beqz	a5,4200ff76 <intmtx_init+0xc8>
4200ff0a:	0007a023          	sw	zero,0(a5)
    for (size_t i = 0; i < 32; i++) {
4200ff0e:	0791                	add	a5,a5,4
4200ff10:	fee79ce3          	bne	a5,a4,4200ff08 <intmtx_init+0x5a>
    }
    WRITE_REG(PLIC_MX_INT_TYPE_REG, 0);
4200ff14:	20001637          	lui	a2,0x20001
4200ff18:	00062223          	sw	zero,4(a2) # 20001004 <__stack_size+0x1ffff004>
    WRITE_REG(PLIC_MX_INT_ENABLE_REG, 0);
4200ff1c:	20001737          	lui	a4,0x20001
4200ff20:	00072023          	sw	zero,0(a4) # 20001000 <__stack_size+0x1ffff000>
    WRITE_REG(PLIC_MX_INT_THRESH_REG, 0);
    WRITE_REG(PLIC_MX_INT_CLEAR_REG, 0xffffffff);
4200ff24:	200016b7          	lui	a3,0x20001
    WRITE_REG(PLIC_MX_INT_THRESH_REG, 0);
4200ff28:	0007a023          	sw	zero,0(a5)
    WRITE_REG(PLIC_MX_INT_CLEAR_REG, 0xffffffff);
4200ff2c:	06a1                	add	a3,a3,8 # 20001008 <__stack_size+0x1ffff008>
4200ff2e:	57fd                	li	a5,-1
4200ff30:	c29c                	sw	a5,0(a3)
    WRITE_REG(PLIC_MX_INT_CLEAR_REG, 0);

    // Reset INTPRI.
    for (size_t i = 0; i < 32; i++) {
4200ff32:	600c5737          	lui	a4,0x600c5
    WRITE_REG(PLIC_MX_INT_CLEAR_REG, 0);
4200ff36:	600c57b7          	lui	a5,0x600c5
4200ff3a:	0006a023          	sw	zero,0(a3)
4200ff3e:	07b1                	add	a5,a5,12 # 600c500c <__stop_free_lpsram+0x100c100c>
    for (size_t i = 0; i < 32; i++) {
4200ff40:	08c70713          	add	a4,a4,140 # 600c508c <__stop_free_lpsram+0x100c108c>
        WRITE_REG(INTPRI_CORE0_CPU_INT_PRI_N_REG(i), 0);
4200ff44:	cb8d                	beqz	a5,4200ff76 <intmtx_init+0xc8>
4200ff46:	0007a023          	sw	zero,0(a5)
    for (size_t i = 0; i < 32; i++) {
4200ff4a:	0791                	add	a5,a5,4
4200ff4c:	fee79ce3          	bne	a5,a4,4200ff44 <intmtx_init+0x96>
    }
    WRITE_REG(INTPRI_CORE0_CPU_INT_TYPE_REG, 0);
4200ff50:	600c56b7          	lui	a3,0x600c5
4200ff54:	0006a223          	sw	zero,4(a3) # 600c5004 <__stop_free_lpsram+0x100c1004>
    WRITE_REG(INTPRI_CORE0_CPU_INT_ENABLE_REG, 0);
4200ff58:	600c5737          	lui	a4,0x600c5
4200ff5c:	00072023          	sw	zero,0(a4) # 600c5000 <__stop_free_lpsram+0x100c1000>
    WRITE_REG(INTPRI_CORE0_CPU_INT_THRESH_REG, 0);
4200ff60:	0007a023          	sw	zero,0(a5)
    WRITE_REG(INTPRI_CORE0_CPU_INT_CLEAR_REG, 0xffffffff);
4200ff64:	57fd                	li	a5,-1
4200ff66:	0af72423          	sw	a5,168(a4)
    WRITE_REG(INTPRI_CORE0_CPU_INT_CLEAR_REG, 0);
4200ff6a:	0a072423          	sw	zero,168(a4)
}
4200ff6e:	8082                	ret
        WRITE_REG(INTMTX_BASE + offsets[i], 0);
4200ff70:	9536                	add	a0,a0,a3
4200ff72:	f6d564e3          	bltu	a0,a3,4200feda <intmtx_init+0x2c>
        WRITE_REG(INTPRI_CORE0_CPU_INT_PRI_N_REG(i), 0);
4200ff76:	9002                	ebreak

4200ff78 <intmtx_route>:

// Route interrupt source `source_map_reg` to interrupt channel `channel`.
void intmtx_route(int source_map_reg, int channel) {
    WRITE_REG(source_map_reg, channel);
4200ff78:	c511                	beqz	a0,4200ff84 <intmtx_route+0xc>
4200ff7a:	00357793          	and	a5,a0,3
4200ff7e:	e399                	bnez	a5,4200ff84 <intmtx_route+0xc>
4200ff80:	c10c                	sw	a1,0(a0)
}
4200ff82:	8082                	ret
    WRITE_REG(source_map_reg, channel);
4200ff84:	9002                	ebreak

4200ff86 <intmtx_set_prio>:

// Set interrupt channel `channel` priority to `prio`.
void intmtx_set_prio(int channel, int prio) {
    WRITE_REG(PLIC_MX_INT_PRI_N_REG(channel), prio);
4200ff86:	080007b7          	lui	a5,0x8000
4200ff8a:	40478793          	add	a5,a5,1028 # 8000404 <__stack_size+0x7ffe404>
4200ff8e:	97aa                	add	a5,a5,a0
4200ff90:	00a7cc63          	blt	a5,a0,4200ffa8 <intmtx_set_prio+0x22>
4200ff94:	00279713          	sll	a4,a5,0x2
4200ff98:	41f75693          	sra	a3,a4,0x1f
4200ff9c:	87f9                	sra	a5,a5,0x1e
4200ff9e:	00d79563          	bne	a5,a3,4200ffa8 <intmtx_set_prio+0x22>
4200ffa2:	c319                	beqz	a4,4200ffa8 <intmtx_set_prio+0x22>
4200ffa4:	c30c                	sw	a1,0(a4)
}
4200ffa6:	8082                	ret
    WRITE_REG(PLIC_MX_INT_PRI_N_REG(channel), prio);
4200ffa8:	9002                	ebreak

4200ffaa <intmtx_get_prio>:

// Set interrupt channel `channel` priority to `prio`.
int intmtx_get_prio(int channel) {
    return READ_REG(PLIC_MX_INT_PRI_N_REG(channel));
4200ffaa:	080007b7          	lui	a5,0x8000
4200ffae:	40478793          	add	a5,a5,1028 # 8000404 <__stack_size+0x7ffe404>
4200ffb2:	97aa                	add	a5,a5,a0
4200ffb4:	00a7cc63          	blt	a5,a0,4200ffcc <intmtx_get_prio+0x22>
4200ffb8:	00279713          	sll	a4,a5,0x2
4200ffbc:	41f75693          	sra	a3,a4,0x1f
4200ffc0:	87f9                	sra	a5,a5,0x1e
4200ffc2:	00d79563          	bne	a5,a3,4200ffcc <intmtx_get_prio+0x22>
4200ffc6:	c319                	beqz	a4,4200ffcc <intmtx_get_prio+0x22>
4200ffc8:	4308                	lw	a0,0(a4)
}
4200ffca:	8082                	ret
    return READ_REG(PLIC_MX_INT_PRI_N_REG(channel));
4200ffcc:	9002                	ebreak

4200ffce <intmtx_set_thresh>:

// Set interrupt threshold value.
void intmtx_set_thresh(int thresh) {
    WRITE_REG(PLIC_MX_INT_THRESH_REG, thresh);
4200ffce:	200017b7          	lui	a5,0x20001
4200ffd2:	08a7a823          	sw	a0,144(a5) # 20001090 <__stack_size+0x1ffff090>
}
4200ffd6:	8082                	ret

4200ffd8 <intmtx_is_enabled>:

// Query whether interrupt channel `channel` is enabled.
bool intmtx_is_enabled(int channel) {
    return READ_REG(PLIC_MX_INT_ENABLE_REG) & (1 << channel);
4200ffd8:	47fd                	li	a5,31
4200ffda:	8f89                	sub	a5,a5,a0
4200ffdc:	4705                	li	a4,1
4200ffde:	00f757b3          	srl	a5,a4,a5
4200ffe2:	8b85                	and	a5,a5,1
4200ffe4:	ef89                	bnez	a5,4200fffe <intmtx_is_enabled+0x26>
4200ffe6:	02053793          	sltiu	a5,a0,32
4200ffea:	cb91                	beqz	a5,4200fffe <intmtx_is_enabled+0x26>
4200ffec:	200017b7          	lui	a5,0x20001
4200fff0:	439c                	lw	a5,0(a5)
4200fff2:	00a71533          	sll	a0,a4,a0
4200fff6:	8d7d                	and	a0,a0,a5
}
4200fff8:	00a03533          	snez	a0,a0
4200fffc:	8082                	ret
    return READ_REG(PLIC_MX_INT_ENABLE_REG) & (1 << channel);
4200fffe:	9002                	ebreak

42010000 <intmtx_enable>:

// Enable or disable interrupt channel `channel`.
void intmtx_enable(int channel) {
    WRITE_REG(PLIC_MX_INT_ENABLE_REG, READ_REG(PLIC_MX_INT_ENABLE_REG) | (1 << channel));
42010000:	47fd                	li	a5,31
42010002:	8f89                	sub	a5,a5,a0
42010004:	4705                	li	a4,1
42010006:	00f757b3          	srl	a5,a4,a5
4201000a:	8b85                	and	a5,a5,1
4201000c:	ef81                	bnez	a5,42010024 <intmtx_enable+0x24>
4201000e:	02053793          	sltiu	a5,a0,32
42010012:	cb89                	beqz	a5,42010024 <intmtx_enable+0x24>
42010014:	200017b7          	lui	a5,0x20001
42010018:	4394                	lw	a3,0(a5)
4201001a:	00a71733          	sll	a4,a4,a0
4201001e:	8f55                	or	a4,a4,a3
42010020:	c398                	sw	a4,0(a5)
}
42010022:	8082                	ret
    WRITE_REG(PLIC_MX_INT_ENABLE_REG, READ_REG(PLIC_MX_INT_ENABLE_REG) | (1 << channel));
42010024:	9002                	ebreak

42010026 <intmtx_disable>:

// Enable or disable interrupt channel `channel`.
bool intmtx_disable(int channel) {
    uint32_t orig = READ_REG(PLIC_MX_INT_ENABLE_REG);
    WRITE_REG(PLIC_MX_INT_ENABLE_REG, orig & ~(1 << channel));
42010026:	477d                	li	a4,31
    uint32_t orig = READ_REG(PLIC_MX_INT_ENABLE_REG);
42010028:	200016b7          	lui	a3,0x20001
    WRITE_REG(PLIC_MX_INT_ENABLE_REG, orig & ~(1 << channel));
4201002c:	8f09                	sub	a4,a4,a0
4201002e:	4785                	li	a5,1
42010030:	00e7d733          	srl	a4,a5,a4
    uint32_t orig = READ_REG(PLIC_MX_INT_ENABLE_REG);
42010034:	4290                	lw	a2,0(a3)
    WRITE_REG(PLIC_MX_INT_ENABLE_REG, orig & ~(1 << channel));
42010036:	8b05                	and	a4,a4,1
42010038:	ef11                	bnez	a4,42010054 <intmtx_disable+0x2e>
4201003a:	02053713          	sltiu	a4,a0,32
4201003e:	cb19                	beqz	a4,42010054 <intmtx_disable+0x2e>
42010040:	00a79533          	sll	a0,a5,a0
42010044:	fff54793          	not	a5,a0
42010048:	8ff1                	and	a5,a5,a2
    return orig & (1 << channel);
4201004a:	8d71                	and	a0,a0,a2
    WRITE_REG(PLIC_MX_INT_ENABLE_REG, orig & ~(1 << channel));
4201004c:	c29c                	sw	a5,0(a3)
}
4201004e:	00a03533          	snez	a0,a0
42010052:	8082                	ret
    WRITE_REG(PLIC_MX_INT_ENABLE_REG, orig & ~(1 << channel));
42010054:	9002                	ebreak

42010056 <intmtx_ack>:

// Acknowledge an interrupt.
void intmtx_ack(int channel) {
    WRITE_REG(INTPRI_CORE0_CPU_INT_CLEAR_REG, 1 << channel);
42010056:	47fd                	li	a5,31
42010058:	8f89                	sub	a5,a5,a0
4201005a:	4705                	li	a4,1
4201005c:	00f757b3          	srl	a5,a4,a5
42010060:	8b85                	and	a5,a5,1
42010062:	ef89                	bnez	a5,4201007c <intmtx_ack+0x26>
42010064:	02053793          	sltiu	a5,a0,32
42010068:	cb91                	beqz	a5,4201007c <intmtx_ack+0x26>
4201006a:	600c57b7          	lui	a5,0x600c5
4201006e:	00a71733          	sll	a4,a4,a0
42010072:	0ae7a423          	sw	a4,168(a5) # 600c50a8 <__stop_free_lpsram+0x100c10a8>
    WRITE_REG(INTPRI_CORE0_CPU_INT_CLEAR_REG, 0);
42010076:	0a07a423          	sw	zero,168(a5)
}
4201007a:	8082                	ret
    WRITE_REG(INTPRI_CORE0_CPU_INT_CLEAR_REG, 1 << channel);
4201007c:	9002                	ebreak

4201007e <memprotect_init>:
#include "cpu/riscv_pmp.h"
#include "port/hardware_allocation.h"
#include "port/interrupt.h"

// Initialise memory protection driver.
void memprotect_init() {
4201007e:	1141                	add	sp,sp,-16
42010080:	c606                	sw	ra,12(sp)
    // Initialise PMP driver.
    riscv_pmp_init();
42010082:	946ff0ef          	jal	4200f1c8 <riscv_pmp_init>

    // Add lower NULLPTR protection range.
    riscv_pmpaddr_write(PMP_ENTRY_NULLPTR_LOW_NAPOT, riscv_pmpaddr_calc_napot(0, PMP_SIZE_NULLPTR));
42010086:	020007b7          	lui	a5,0x2000
4201008a:	17fd                	add	a5,a5,-1 # 1ffffff <__stack_size+0x1ffdfff>
4201008c:	3bc79073          	csrw	pmpaddr12,a5
    riscv_pmpcfg_set(
42010090:	09800793          	li	a5,152
42010094:	3a37a073          	csrs	pmpcfg3,a5
            .lock            = true,
        })
    );

    // Add upper NULLPTR protection range.
    riscv_pmpaddr_write(PMP_ENTRY_NULLPTR_HIGH_NAPOT, riscv_pmpaddr_calc_napot(-PMP_SIZE_NULLPTR, PMP_SIZE_NULLPTR));
42010098:	3e0007b7          	lui	a5,0x3e000
4201009c:	17fd                	add	a5,a5,-1 # 3dffffff <__stack_size+0x3dffdfff>
4201009e:	3bd79073          	csrw	pmpaddr13,a5
    riscv_pmpcfg_set(
420100a2:	67a9                	lui	a5,0xa
420100a4:	80078793          	add	a5,a5,-2048 # 9800 <__stack_size+0x7800>
420100a8:	3a37a073          	csrs	pmpcfg3,a5
            .lock            = true,
        })
    );

    // Add ROM write-protect range.
    riscv_pmpaddr_write(PMP_ENTRY_ROM_WP_NAPOT, riscv_pmpaddr_calc_napot(PMP_BASE_ROM_WP, PMP_SIZE_ROM_WP));
420100ac:	100107b7          	lui	a5,0x10010
420100b0:	17fd                	add	a5,a5,-1 # 1000ffff <__stack_size+0x1000dfff>
420100b2:	3be79073          	csrw	pmpaddr14,a5
    riscv_pmpcfg_set(
420100b6:	009d07b7          	lui	a5,0x9d0
420100ba:	3a37a073          	csrs	pmpcfg3,a5
            .lock            = true,
        })
    );

    // Add FLASH write-protect range.
    riscv_pmpaddr_write(PMP_ENTRY_FLASH_WP_NAPOT, riscv_pmpaddr_calc_napot(PMP_BASE_FLASH_WP, PMP_SIZE_FLASH_WP));
420100be:	10a007b7          	lui	a5,0x10a00
420100c2:	17fd                	add	a5,a5,-1 # 109fffff <__stack_size+0x109fdfff>
420100c4:	3bf79073          	csrw	pmpaddr15,a5
    riscv_pmpcfg_set(
420100c8:	9d0007b7          	lui	a5,0x9d000
420100cc:	3a37a073          	csrs	pmpcfg3,a5
        })
    );

    // Add user global permissions.
    // TODO: These permissions will be NONE later, but are ALL for now.
    riscv_pmpaddr_write(PMP_ENTRY_USER_GLOBAL_NAPOT, RISCV_PMPADDR_NAPOT_GLOBAL);
420100d0:	200007b7          	lui	a5,0x20000
420100d4:	17fd                	add	a5,a5,-1 # 1fffffff <__stack_size+0x1fffdfff>
420100d6:	3bb79073          	csrw	pmpaddr11,a5
    riscv_pmpcfg_set(
420100da:	1f0007b7          	lui	a5,0x1f000
420100de:	3a27a073          	csrs	pmpcfg2,a5
            .addr_match_mode = RISCV_PMPCFG_NAPOT,
            ._reserved       = 0,
            .lock            = false,
        })
    );
}
420100e2:	40b2                	lw	ra,12(sp)
420100e4:	0141                	add	sp,sp,16
420100e6:	8082                	ret

420100e8 <memprotect_set_user_extram>:
    asm volatile("csrrci %0, mstatus, 8" : "=r"(mstatus));
420100e8:	300477f3          	csrrc	a5,mstatus,8
// Set the range of external RAM currently assigned to userland.
void memprotect_set_user_extram(size_t base, size_t top) {
    bool mie = interrupt_disable();

    // Disable existing entry.
    riscv_pmpcfg_clear(PMP_ENTRY_USER_EXTRAM_TOR);
420100ec:	6741                	lui	a4,0x10
420100ee:	f0070713          	add	a4,a4,-256 # ff00 <__stack_size+0xdf00>
420100f2:	3a173073          	csrc	pmpcfg1,a4
    // Write new addresses.
    riscv_pmpaddr_write(PMP_ENTRY_USER_EXTRAM_BASE, base);
420100f6:	3b451073          	csrw	pmpaddr4,a0
    riscv_pmpaddr_write(PMP_ENTRY_USER_EXTRAM_TOR, top);
420100fa:	3b559073          	csrw	pmpaddr5,a1
    // Set PMP region type.
    riscv_pmpcfg_set(
420100fe:	6705                	lui	a4,0x1
42010100:	f0070713          	add	a4,a4,-256 # f00 <isr_ctx_t_is_kernel_thread+0xe58>
42010104:	3a172073          	csrs	pmpcfg1,a4
    return mstatus & 8;
42010108:	8ba1                	and	a5,a5,8
            ._reserved       = 0,
            .lock            = false,
        })
    );

    if (mie)
4201010a:	c781                	beqz	a5,42010112 <memprotect_set_user_extram+0x2a>
    asm volatile("csrs mstatus, %0" ::"r"(8));
4201010c:	47a1                	li	a5,8
4201010e:	3007a073          	csrs	mstatus,a5
        interrupt_enable();
}
42010112:	8082                	ret

42010114 <memprotect_set_user_sram>:
    asm volatile("csrrci %0, mstatus, 8" : "=r"(mstatus));
42010114:	300477f3          	csrrc	a5,mstatus,8
// Set the range of SRAM currently assigned to userland.
void memprotect_set_user_sram(size_t base, size_t top) {
    bool mie = interrupt_disable();

    // Disable existing entry.
    riscv_pmpcfg_clear(PMP_ENTRY_USER_SRAM_TOR);
42010118:	ff000737          	lui	a4,0xff000
4201011c:	3a173073          	csrc	pmpcfg1,a4
    // Write new addresses.
    riscv_pmpaddr_write(PMP_ENTRY_USER_SRAM_BASE, base);
42010120:	3b651073          	csrw	pmpaddr6,a0
    riscv_pmpaddr_write(PMP_ENTRY_USER_SRAM_TOR, top);
42010124:	3b759073          	csrw	pmpaddr7,a1
    // Set PMP region type.
    riscv_pmpcfg_set(
42010128:	0f000737          	lui	a4,0xf000
4201012c:	3a172073          	csrs	pmpcfg1,a4
    return mstatus & 8;
42010130:	8ba1                	and	a5,a5,8
            ._reserved       = 0,
            .lock            = false,
        })
    );

    if (mie)
42010132:	c781                	beqz	a5,4201013a <memprotect_set_user_sram+0x26>
    asm volatile("csrs mstatus, %0" ::"r"(8));
42010134:	47a1                	li	a5,8
42010136:	3007a073          	csrs	mstatus,a5
        interrupt_enable();
}
4201013a:	8082                	ret

4201013c <memprotect_set_user_flash>:
    asm volatile("csrrci %0, mstatus, 8" : "=r"(mstatus));
4201013c:	300477f3          	csrrc	a5,mstatus,8
// Set the range of flash currently assigned to userland.
void memprotect_set_user_flash(size_t base, size_t top) {
    bool mie = interrupt_disable();

    // Disable existing entry.
    riscv_pmpcfg_clear(PMP_ENTRY_USER_FLASH_TOR);
42010140:	6741                	lui	a4,0x10
42010142:	f0070713          	add	a4,a4,-256 # ff00 <__stack_size+0xdf00>
42010146:	3a273073          	csrc	pmpcfg2,a4
    // Write new addresses.
    riscv_pmpaddr_write(PMP_ENTRY_USER_FLASH_BASE, base);
4201014a:	3b851073          	csrw	pmpaddr8,a0
    riscv_pmpaddr_write(PMP_ENTRY_USER_FLASH_TOR, top);
4201014e:	3b959073          	csrw	pmpaddr9,a1
    // Set PMP region type.
    riscv_pmpcfg_set(
42010152:	6705                	lui	a4,0x1
42010154:	f0070713          	add	a4,a4,-256 # f00 <isr_ctx_t_is_kernel_thread+0xe58>
42010158:	3a272073          	csrs	pmpcfg2,a4
    return mstatus & 8;
4201015c:	8ba1                	and	a5,a5,8
            ._reserved       = 0,
            .lock            = false,
        })
    );

    if (mie)
4201015e:	c781                	beqz	a5,42010166 <memprotect_set_user_flash+0x2a>
    asm volatile("csrs mstatus, %0" ::"r"(8));
42010160:	47a1                	li	a5,8
42010162:	3007a073          	csrs	mstatus,a5
        interrupt_enable();
}
42010166:	8082                	ret

42010168 <rawputc>:
        msg++;
    }
}

// Simple printer.
void rawputc(char msg) {
42010168:	1101                	add	sp,sp,-32
4201016a:	c64e                	sw	s3,12(sp)
    static bool    discon   = false;
    timestamp_us_t timeout  = time_us() + 5000;
4201016c:	6985                	lui	s3,0x1
void rawputc(char msg) {
4201016e:	c452                	sw	s4,8(sp)
42010170:	c256                	sw	s5,4(sp)
42010172:	ce06                	sw	ra,28(sp)
42010174:	cc22                	sw	s0,24(sp)
42010176:	ca26                	sw	s1,20(sp)
42010178:	c84a                	sw	s2,16(sp)
4201017a:	8a2a                	mv	s4,a0
    timestamp_us_t timeout  = time_us() + 5000;
4201017c:	38898993          	add	s3,s3,904 # 1388 <isr_ctx_t_is_kernel_thread+0x12e0>
42010180:	23e5                	jal	42010768 <time_us>
42010182:	99aa                	add	s3,s3,a0
42010184:	00a9bab3          	sltu	s5,s3,a0
42010188:	9aae                	add	s5,s5,a1
4201018a:	06bacf63          	blt	s5,a1,42010208 <rawputc+0xa0>
4201018e:	07558b63          	beq	a1,s5,42010204 <rawputc+0x9c>
    discon                 &= !(READ_REG(USB_JTAG_BASE + 4) & 2);
42010192:	6000f437          	lui	s0,0x6000f
42010196:	405c                	lw	a5,4(s0)
42010198:	4080a4b7          	lui	s1,0x4080a
4201019c:	e7c4c703          	lbu	a4,-388(s1) # 40809e7c <discon.0>
420101a0:	8385                	srl	a5,a5,0x1
420101a2:	0017c793          	xor	a5,a5,1
420101a6:	4685                	li	a3,1
420101a8:	0411                	add	s0,s0,4 # 6000f004 <__stop_free_lpsram+0x1000b004>
420101aa:	8b85                	and	a5,a5,1
420101ac:	04e6ee63          	bltu	a3,a4,42010208 <rawputc+0xa0>
420101b0:	8f7d                	and	a4,a4,a5
    while (!discon && !(READ_REG(USB_JTAG_BASE + 4) & 2)) {
420101b2:	87ba                	mv	a5,a4
420101b4:	4905                	li	s2,1
    discon                 &= !(READ_REG(USB_JTAG_BASE + 4) & 2);
420101b6:	e6e48e23          	sb	a4,-388(s1)
    while (!discon && !(READ_REG(USB_JTAG_BASE + 4) & 2)) {
420101ba:	04f96763          	bltu	s2,a5,42010208 <rawputc+0xa0>
420101be:	8b85                	and	a5,a5,1
420101c0:	ef91                	bnez	a5,420101dc <rawputc+0x74>
420101c2:	401c                	lw	a5,0(s0)
420101c4:	8b89                	and	a5,a5,2
420101c6:	eb99                	bnez	a5,420101dc <rawputc+0x74>
        if (time_us() > timeout)
420101c8:	2345                	jal	42010768 <time_us>
420101ca:	4785                	li	a5,1
420101cc:	4705                	li	a4,1
420101ce:	febac4e3          	blt	s5,a1,420101b6 <rawputc+0x4e>
420101d2:	03558663          	beq	a1,s5,420101fe <rawputc+0x96>
    while (!discon && !(READ_REG(USB_JTAG_BASE + 4) & 2)) {
420101d6:	e7c4c783          	lbu	a5,-388(s1)
420101da:	b7c5                	j	420101ba <rawputc+0x52>
            discon = true;
    }
    WRITE_REG(USB_JTAG_BASE, msg);
    WRITE_REG(UART0_BASE, msg);
}
420101dc:	40f2                	lw	ra,28(sp)
420101de:	4462                	lw	s0,24(sp)
    WRITE_REG(USB_JTAG_BASE, msg);
420101e0:	6000f7b7          	lui	a5,0x6000f
420101e4:	0147a023          	sw	s4,0(a5) # 6000f000 <__stop_free_lpsram+0x1000b000>
    WRITE_REG(UART0_BASE, msg);
420101e8:	600007b7          	lui	a5,0x60000
420101ec:	0147a023          	sw	s4,0(a5) # 60000000 <__stop_free_lpsram+0xfffc000>
}
420101f0:	44d2                	lw	s1,20(sp)
420101f2:	4942                	lw	s2,16(sp)
420101f4:	49b2                	lw	s3,12(sp)
420101f6:	4a22                	lw	s4,8(sp)
420101f8:	4a92                	lw	s5,4(sp)
420101fa:	6105                	add	sp,sp,32
420101fc:	8082                	ret
        if (time_us() > timeout)
420101fe:	fca9fce3          	bgeu	s3,a0,420101d6 <rawputc+0x6e>
42010202:	bf55                	j	420101b6 <rawputc+0x4e>
    timestamp_us_t timeout  = time_us() + 5000;
42010204:	f8a9f7e3          	bgeu	s3,a0,42010192 <rawputc+0x2a>
    discon                 &= !(READ_REG(USB_JTAG_BASE + 4) & 2);
42010208:	9002                	ebreak

4201020a <rawprint_substr.part.0>:
    while (length--) {
4201020a:	c1bd                	beqz	a1,42010270 <rawprint_substr.part.0+0x66>
void rawprint_substr(char const *msg, size_t length) {
4201020c:	1101                	add	sp,sp,-32
4201020e:	cc22                	sw	s0,24(sp)
42010210:	ca26                	sw	s1,20(sp)
42010212:	c84a                	sw	s2,16(sp)
42010214:	c64e                	sw	s3,12(sp)
42010216:	c452                	sw	s4,8(sp)
42010218:	ce06                	sw	ra,28(sp)
4201021a:	842a                	mv	s0,a0
4201021c:	00b504b3          	add	s1,a0,a1
    char prev = 0;
42010220:	4781                	li	a5,0
        if (*msg == '\r') {
42010222:	4935                	li	s2,13
        } else if (*msg == '\n') {
42010224:	4a29                	li	s4,10
        msg++;
42010226:	59fd                	li	s3,-1
        if (*msg == '\r') {
42010228:	c429                	beqz	s0,42010272 <rawprint_substr.part.0+0x68>
4201022a:	00044503          	lbu	a0,0(s0)
4201022e:	01250663          	beq	a0,s2,4201023a <rawprint_substr.part.0+0x30>
        } else if (*msg == '\n') {
42010232:	03451a63          	bne	a0,s4,42010266 <rawprint_substr.part.0+0x5c>
            if (prev != '\r') {
42010236:	01278a63          	beq	a5,s2,4201024a <rawprint_substr.part.0+0x40>
            rawputc('\r');
4201023a:	4535                	li	a0,13
4201023c:	f2dff0ef          	jal	42010168 <rawputc>
            rawputc('\n');
42010240:	4529                	li	a0,10
42010242:	f27ff0ef          	jal	42010168 <rawputc>
42010246:	00044503          	lbu	a0,0(s0)
        prev = *msg;
4201024a:	87aa                	mv	a5,a0
        msg++;
4201024c:	03347463          	bgeu	s0,s3,42010274 <rawprint_substr.part.0+0x6a>
42010250:	0405                	add	s0,s0,1
    while (length--) {
42010252:	fc941be3          	bne	s0,s1,42010228 <rawprint_substr.part.0+0x1e>
}
42010256:	40f2                	lw	ra,28(sp)
42010258:	4462                	lw	s0,24(sp)
4201025a:	44d2                	lw	s1,20(sp)
4201025c:	4942                	lw	s2,16(sp)
4201025e:	49b2                	lw	s3,12(sp)
42010260:	4a22                	lw	s4,8(sp)
42010262:	6105                	add	sp,sp,32
42010264:	8082                	ret
            rawputc(*msg);
42010266:	f03ff0ef          	jal	42010168 <rawputc>
4201026a:	00044503          	lbu	a0,0(s0)
4201026e:	bff1                	j	4201024a <rawprint_substr.part.0+0x40>
42010270:	8082                	ret
        if (*msg == '\r') {
42010272:	9002                	ebreak
        msg++;
42010274:	9002                	ebreak

42010276 <rawprint_substr>:
    if (!msg)
42010276:	c119                	beqz	a0,4201027c <rawprint_substr+0x6>
42010278:	f93ff06f          	j	4201020a <rawprint_substr.part.0>
}
4201027c:	8082                	ret

4201027e <rawprint>:
    if (!msg)
4201027e:	cd39                	beqz	a0,420102dc <rawprint+0x5e>
void rawprint(char const *msg) {
42010280:	1101                	add	sp,sp,-32
42010282:	cc22                	sw	s0,24(sp)
42010284:	ce06                	sw	ra,28(sp)
42010286:	842a                	mv	s0,a0
    while (*msg) {
42010288:	00054503          	lbu	a0,0(a0)
4201028c:	c129                	beqz	a0,420102ce <rawprint+0x50>
4201028e:	ca26                	sw	s1,20(sp)
42010290:	c84a                	sw	s2,16(sp)
42010292:	c64e                	sw	s3,12(sp)
    char prev = 0;
42010294:	4781                	li	a5,0
        if (*msg == '\r') {
42010296:	44b5                	li	s1,13
        } else if (*msg == '\n') {
42010298:	49a9                	li	s3,10
        msg++;
4201029a:	597d                	li	s2,-1
        if (*msg == '\r') {
4201029c:	c029                	beqz	s0,420102de <rawprint+0x60>
4201029e:	00950663          	beq	a0,s1,420102aa <rawprint+0x2c>
        } else if (*msg == '\n') {
420102a2:	03351a63          	bne	a0,s3,420102d6 <rawprint+0x58>
            if (prev != '\r') {
420102a6:	00978863          	beq	a5,s1,420102b6 <rawprint+0x38>
            rawputc('\r');
420102aa:	4535                	li	a0,13
420102ac:	ebdff0ef          	jal	42010168 <rawputc>
            rawputc('\n');
420102b0:	4529                	li	a0,10
420102b2:	eb7ff0ef          	jal	42010168 <rawputc>
        prev = *msg;
420102b6:	00044783          	lbu	a5,0(s0)
        msg++;
420102ba:	03247463          	bgeu	s0,s2,420102e2 <rawprint+0x64>
420102be:	0405                	add	s0,s0,1
    while (*msg) {
420102c0:	c005                	beqz	s0,420102e0 <rawprint+0x62>
420102c2:	00044503          	lbu	a0,0(s0)
420102c6:	f979                	bnez	a0,4201029c <rawprint+0x1e>
420102c8:	44d2                	lw	s1,20(sp)
420102ca:	4942                	lw	s2,16(sp)
420102cc:	49b2                	lw	s3,12(sp)
}
420102ce:	40f2                	lw	ra,28(sp)
420102d0:	4462                	lw	s0,24(sp)
420102d2:	6105                	add	sp,sp,32
420102d4:	8082                	ret
            rawputc(*msg);
420102d6:	e93ff0ef          	jal	42010168 <rawputc>
420102da:	bff1                	j	420102b6 <rawprint+0x38>
420102dc:	8082                	ret
        if (*msg == '\r') {
420102de:	9002                	ebreak
    while (*msg) {
420102e0:	9002                	ebreak
        msg++;
420102e2:	9002                	ebreak

420102e4 <rawprinthex>:

// Bin 2 hex printer.
void rawprinthex(uint64_t val, int digits) {
    for (; digits > 0; digits--) {
420102e4:	0ac05563          	blez	a2,4201038e <rawprinthex+0xaa>
void rawprinthex(uint64_t val, int digits) {
420102e8:	7179                	add	sp,sp,-48
420102ea:	c85a                	sw	s6,16(sp)
        rawputc(hextab[(val >> (digits * 4 - 4)) & 15]);
420102ec:	fff60b13          	add	s6,a2,-1
420102f0:	002b1713          	sll	a4,s6,0x2
void rawprinthex(uint64_t val, int digits) {
420102f4:	d606                	sw	ra,44(sp)
420102f6:	d422                	sw	s0,40(sp)
420102f8:	d226                	sw	s1,36(sp)
420102fa:	d04a                	sw	s2,32(sp)
420102fc:	ce4e                	sw	s3,28(sp)
420102fe:	cc52                	sw	s4,24(sp)
42010300:	ca56                	sw	s5,20(sp)
42010302:	c65e                	sw	s7,12(sp)
        rawputc(hextab[(val >> (digits * 4 - 4)) & 15]);
42010304:	41eb5693          	sra	a3,s6,0x1e
42010308:	41f75793          	sra	a5,a4,0x1f
4201030c:	08f69463          	bne	a3,a5,42010394 <rawprinthex+0xb0>
42010310:	03f00793          	li	a5,63
42010314:	08e7e163          	bltu	a5,a4,42010396 <rawprinthex+0xb2>
42010318:	42017bb7          	lui	s7,0x42017
4201031c:	89aa                	mv	s3,a0
4201031e:	842e                	mv	s0,a1
42010320:	cccb8b93          	add	s7,s7,-820 # 42016ccc <hextab>
42010324:	00159a93          	sll	s5,a1,0x1
42010328:	4a7d                	li	s4,31
4201032a:	4491                	li	s1,4
4201032c:	03f00913          	li	s2,63
42010330:	a805                	j	42010360 <rawprinthex+0x7c>
42010332:	00f457b3          	srl	a5,s0,a5
42010336:	8bbd                	and	a5,a5,15
42010338:	97de                	add	a5,a5,s7
4201033a:	0577eb63          	bltu	a5,s7,42010390 <rawprinthex+0xac>
4201033e:	0007c503          	lbu	a0,0(a5)
42010342:	e27ff0ef          	jal	42010168 <rawputc>
    for (; digits > 0; digits--) {
42010346:	020b0963          	beqz	s6,42010378 <rawprinthex+0x94>
        rawputc(hextab[(val >> (digits * 4 - 4)) & 15]);
4201034a:	1b7d                	add	s6,s6,-1
4201034c:	029b16b3          	mulh	a3,s6,s1
42010350:	002b1713          	sll	a4,s6,0x2
42010354:	41f75793          	sra	a5,a4,0x1f
42010358:	02f69d63          	bne	a3,a5,42010392 <rawprinthex+0xae>
4201035c:	02e96d63          	bltu	s2,a4,42010396 <rawprinthex+0xb2>
42010360:	fe070793          	add	a5,a4,-32
42010364:	fc07d7e3          	bgez	a5,42010332 <rawprinthex+0x4e>
42010368:	40ea06b3          	sub	a3,s4,a4
4201036c:	00da96b3          	sll	a3,s5,a3
42010370:	00e9d7b3          	srl	a5,s3,a4
42010374:	8fd5                	or	a5,a5,a3
42010376:	b7c1                	j	42010336 <rawprinthex+0x52>
    }
}
42010378:	50b2                	lw	ra,44(sp)
4201037a:	5422                	lw	s0,40(sp)
4201037c:	5492                	lw	s1,36(sp)
4201037e:	5902                	lw	s2,32(sp)
42010380:	49f2                	lw	s3,28(sp)
42010382:	4a62                	lw	s4,24(sp)
42010384:	4ad2                	lw	s5,20(sp)
42010386:	4b42                	lw	s6,16(sp)
42010388:	4bb2                	lw	s7,12(sp)
4201038a:	6145                	add	sp,sp,48
4201038c:	8082                	ret
4201038e:	8082                	ret
        rawputc(hextab[(val >> (digits * 4 - 4)) & 15]);
42010390:	9002                	ebreak
42010392:	9002                	ebreak
42010394:	9002                	ebreak
42010396:	9002                	ebreak

42010398 <rawprintudec>:

// Bin 2 dec printer.
void rawprintudec(uint64_t val, int digits) {
42010398:	7179                	add	sp,sp,-48
4201039a:	d422                	sw	s0,40(sp)
    char   buf[20];
    size_t buf_digits = uint_to_cstr_packed(val, buf, sizeof(buf));
4201039c:	46d1                	li	a3,20
void rawprintudec(uint64_t val, int digits) {
4201039e:	8432                	mv	s0,a2
    size_t buf_digits = uint_to_cstr_packed(val, buf, sizeof(buf));
420103a0:	0070                	add	a2,sp,12
void rawprintudec(uint64_t val, int digits) {
420103a2:	d606                	sw	ra,44(sp)
    size_t buf_digits = uint_to_cstr_packed(val, buf, sizeof(buf));
420103a4:	e9bf30ef          	jal	4200423e <uint_to_cstr_packed>
420103a8:	85aa                	mv	a1,a0
    if (digits < (int)buf_digits)
420103aa:	00a44663          	blt	s0,a0,420103b6 <rawprintudec+0x1e>
        digits = (int)buf_digits;
    else if (digits > (int)sizeof(buf))
420103ae:	47d1                	li	a5,20
420103b0:	85a2                	mv	a1,s0
420103b2:	0087c963          	blt	a5,s0,420103c4 <rawprintudec+0x2c>
    if (!msg)
420103b6:	0068                	add	a0,sp,12
420103b8:	e53ff0ef          	jal	4201020a <rawprint_substr.part.0>
        digits = sizeof(buf);
    rawprint_substr(buf, digits);
}
420103bc:	50b2                	lw	ra,44(sp)
420103be:	5422                	lw	s0,40(sp)
420103c0:	6145                	add	sp,sp,48
420103c2:	8082                	ret
420103c4:	0068                	add	a0,sp,12
    else if (digits > (int)sizeof(buf))
420103c6:	45d1                	li	a1,20
    if (!msg)
420103c8:	e43ff0ef          	jal	4201020a <rawprint_substr.part.0>
}
420103cc:	50b2                	lw	ra,44(sp)
420103ce:	5422                	lw	s0,40(sp)
420103d0:	6145                	add	sp,sp,48
420103d2:	8082                	ret

420103d4 <rawprintdec>:

// Bin 2 dec printer.
void rawprintdec(int64_t val, int digits) {
420103d4:	7139                	add	sp,sp,-64
420103d6:	dc22                	sw	s0,56(sp)
420103d8:	da26                	sw	s1,52(sp)
420103da:	de06                	sw	ra,60(sp)
420103dc:	842a                	mv	s0,a0
420103de:	84b2                	mv	s1,a2
    if (val < 0) {
420103e0:	0205cf63          	bltz	a1,4201041e <rawprintdec+0x4a>
    size_t buf_digits = uint_to_cstr_packed(val, buf, sizeof(buf));
420103e4:	46d1                	li	a3,20
420103e6:	0870                	add	a2,sp,28
420103e8:	8522                	mv	a0,s0
420103ea:	e55f30ef          	jal	4200423e <uint_to_cstr_packed>
420103ee:	85aa                	mv	a1,a0
    if (digits < (int)buf_digits)
420103f0:	00a4c663          	blt	s1,a0,420103fc <rawprintdec+0x28>
    else if (digits > (int)sizeof(buf))
420103f4:	47d1                	li	a5,20
420103f6:	85a6                	mv	a1,s1
420103f8:	0097ca63          	blt	a5,s1,4201040c <rawprintdec+0x38>
    if (!msg)
420103fc:	0868                	add	a0,sp,28
420103fe:	e0dff0ef          	jal	4201020a <rawprint_substr.part.0>
        rawputc('-');
        val = -val;
    }
    rawprintudec(val, digits);
}
42010402:	50f2                	lw	ra,60(sp)
42010404:	5462                	lw	s0,56(sp)
42010406:	54d2                	lw	s1,52(sp)
42010408:	6121                	add	sp,sp,64
4201040a:	8082                	ret
4201040c:	0868                	add	a0,sp,28
    else if (digits > (int)sizeof(buf))
4201040e:	45d1                	li	a1,20
    if (!msg)
42010410:	dfbff0ef          	jal	4201020a <rawprint_substr.part.0>
}
42010414:	50f2                	lw	ra,60(sp)
42010416:	5462                	lw	s0,56(sp)
42010418:	54d2                	lw	s1,52(sp)
4201041a:	6121                	add	sp,sp,64
4201041c:	8082                	ret
        rawputc('-');
4201041e:	02d00513          	li	a0,45
42010422:	c62e                	sw	a1,12(sp)
42010424:	d45ff0ef          	jal	42010168 <rawputc>
        val = -val;
42010428:	45b2                	lw	a1,12(sp)
4201042a:	008036b3          	snez	a3,s0
4201042e:	40800733          	neg	a4,s0
42010432:	40b007b3          	neg	a5,a1
42010436:	8f95                	sub	a5,a5,a3
42010438:	c401                	beqz	s0,42010440 <rawprintdec+0x6c>
4201043a:	843a                	mv	s0,a4
4201043c:	85be                	mv	a1,a5
4201043e:	b75d                	j	420103e4 <rawprintdec+0x10>
42010440:	800006b7          	lui	a3,0x80000
42010444:	fed59be3          	bne	a1,a3,4201043a <rawprintdec+0x66>
42010448:	9002                	ebreak

4201044a <rawprintuptime>:

// Current uptime printer for logging.
void rawprintuptime() {
4201044a:	7179                	add	sp,sp,-48
4201044c:	d606                	sw	ra,44(sp)
4201044e:	d422                	sw	s0,40(sp)
42010450:	d226                	sw	s1,36(sp)
    char   buf[20];
    size_t digits = num_uint_to_str(time_us() / 1000, buf);
42010452:	2e19                	jal	42010768 <time_us>
42010454:	3e800613          	li	a2,1000
42010458:	4681                	li	a3,0
4201045a:	9f1f20ef          	jal	42002e4a <__divdi3>
4201045e:	0060                	add	s0,sp,12
42010460:	8622                	mv	a2,s0
42010462:	acbf30ef          	jal	42003f2c <num_uint_to_str>
    if (digits < 8)
42010466:	47a1                	li	a5,8
42010468:	44a1                	li	s1,8
4201046a:	00f56363          	bltu	a0,a5,42010470 <rawprintuptime+0x26>
4201046e:	84aa                	mv	s1,a0
        digits = 8;

    rawputc('[');
42010470:	05b00513          	li	a0,91
42010474:	cf5ff0ef          	jal	42010168 <rawputc>
    rawprint_substr(buf + 20 - digits, digits - 3);
42010478:	47d1                	li	a5,20
4201047a:	8f85                	sub	a5,a5,s1
4201047c:	00f40733          	add	a4,s0,a5
42010480:	0207cd63          	bltz	a5,420104ba <rawprintuptime+0x70>
42010484:	02876d63          	bltu	a4,s0,420104be <rawprintuptime+0x74>
42010488:	00f40533          	add	a0,s0,a5
4201048c:	ffd48593          	add	a1,s1,-3
    if (!msg)
42010490:	c119                	beqz	a0,42010496 <rawprintuptime+0x4c>
42010492:	d79ff0ef          	jal	4201020a <rawprint_substr.part.0>
    rawputc('.');
42010496:	02e00513          	li	a0,46
4201049a:	ccfff0ef          	jal	42010168 <rawputc>
    if (!msg)
4201049e:	01d10513          	add	a0,sp,29
420104a2:	458d                	li	a1,3
420104a4:	d67ff0ef          	jal	4201020a <rawprint_substr.part.0>
    rawprint_substr(buf + 17, 3);
    rawputc(']');
420104a8:	05d00513          	li	a0,93
420104ac:	cbdff0ef          	jal	42010168 <rawputc>
}
420104b0:	50b2                	lw	ra,44(sp)
420104b2:	5422                	lw	s0,40(sp)
420104b4:	5492                	lw	s1,36(sp)
420104b6:	6145                	add	sp,sp,48
420104b8:	8082                	ret
    rawprint_substr(buf + 20 - digits, digits - 3);
420104ba:	fce477e3          	bgeu	s0,a4,42010488 <rawprintuptime+0x3e>
420104be:	9002                	ebreak

420104c0 <time_init>:


// Initialise timer and watchdog subsystem.
void time_init() {
    // Disable LP WDT.
    WRITE_REG(LP_WDT_WRPROTECT_REG, LD_WDT_WRPROTECT_MAGIC);
420104c0:	50d84737          	lui	a4,0x50d84
420104c4:	600b27b7          	lui	a5,0x600b2
420104c8:	aa170713          	add	a4,a4,-1375 # 50d83aa1 <__stop_free_lpsram+0xd7faa1>
420104cc:	c0e7ac23          	sw	a4,-1000(a5) # 600b1c18 <__stop_free_lpsram+0x100adc18>
    WRITE_REG(LP_WDT_CONFIG0_REG, 0);
420104d0:	600b2337          	lui	t1,0x600b2
420104d4:	c0032023          	sw	zero,-1024(t1) # 600b1c00 <__stop_free_lpsram+0x100adc00>
}

// Disable the timer counting.
void timer_stop(int timerno) {
    size_t addr = timg_base(timerno) + T0CONFIG_REG;
    WRITE_REG(addr, READ_REG(addr) & ~0x80000000);
420104d8:	600087b7          	lui	a5,0x60008
420104dc:	4398                	lw	a4,0(a5)
420104de:	80000837          	lui	a6,0x80000
420104e2:	187d                	add	a6,a6,-1 # 7fffffff <__stop_free_lpsram+0x2fffbfff>
420104e4:	01077733          	and	a4,a4,a6
420104e8:	c398                	sw	a4,0(a5)
    WRITE_REG(addr, (READ_REG(addr) & 0xe0001fff) | (divider << 13));
420104ea:	4398                	lw	a4,0(a5)
420104ec:	e0002537          	lui	a0,0xe0002
420104f0:	157d                	add	a0,a0,-1 # e0001fff <__stop_free_lpsram+0x8fffdfff>
420104f2:	00050eb7          	lui	t4,0x50
420104f6:	8f69                	and	a4,a4,a0
420104f8:	01d76733          	or	a4,a4,t4
420104fc:	c398                	sw	a4,0(a5)
    WRITE_REG(base + T0LOADLO_REG, value);
420104fe:	600086b7          	lui	a3,0x60008
42010502:	0006ac23          	sw	zero,24(a3) # 60008018 <__stop_free_lpsram+0x10004018>
    WRITE_REG(base + T0LOADLO_REG, value >> 32);
42010506:	0006ac23          	sw	zero,24(a3)
    WRITE_REG(base + T0LOAD_REG, -1);
4201050a:	5e7d                	li	t3,-1
4201050c:	600088b7          	lui	a7,0x60008
42010510:	03c8a023          	sw	t3,32(a7) # 60008020 <__stop_free_lpsram+0x10004020>
    WRITE_REG(addr, READ_REG(addr) & ~0x80000000);
42010514:	600095b7          	lui	a1,0x60009
42010518:	4198                	lw	a4,0(a1)
    WRITE_REG(base + T0LOADLO_REG, value);
4201051a:	60009637          	lui	a2,0x60009
    WRITE_REG(addr, READ_REG(addr) | 0xc0000000);
4201051e:	c00006b7          	lui	a3,0xc0000
    WRITE_REG(addr, READ_REG(addr) & ~0x80000000);
42010522:	01077733          	and	a4,a4,a6
42010526:	c198                	sw	a4,0(a1)
    WRITE_REG(addr, (READ_REG(addr) & 0xe0001fff) | (divider << 13));
42010528:	4198                	lw	a4,0(a1)
    WRITE_REG(base + T0LOAD_REG, -1);
4201052a:	60009837          	lui	a6,0x60009
    WRITE_REG(addr, (READ_REG(addr) & 0xe0001fff) | (divider << 13));
4201052e:	8f69                	and	a4,a4,a0
42010530:	01d76733          	or	a4,a4,t4
42010534:	c198                	sw	a4,0(a1)
    WRITE_REG(base + T0LOADLO_REG, value);
42010536:	00062c23          	sw	zero,24(a2) # 60009018 <__stop_free_lpsram+0x10005018>
    WRITE_REG(base + T0LOADLO_REG, value >> 32);
4201053a:	00062c23          	sw	zero,24(a2)
    WRITE_REG(base + T0LOAD_REG, -1);
4201053e:	03c82023          	sw	t3,32(a6) # 60009020 <__stop_free_lpsram+0x10005020>
    WRITE_REG(addr, READ_REG(addr) | 0xc0000000);
42010542:	4398                	lw	a4,0(a5)
42010544:	8f55                	or	a4,a4,a3
42010546:	c398                	sw	a4,0(a5)
}
42010548:	8082                	ret

4201054a <timer_set_freq>:
void timer_set_freq(int timerno, int32_t frequency) {
4201054a:	1141                	add	sp,sp,-16
4201054c:	c422                	sw	s0,8(sp)
4201054e:	c606                	sw	ra,12(sp)
    return timerno ? TIMG1_BASE : TIMG0_BASE;
42010550:	60009437          	lui	s0,0x60009
42010554:	e119                	bnez	a0,4201055a <timer_set_freq+0x10>
42010556:	60008437          	lui	s0,0x60008
    int    divider = timer_clk_freq(timerno) / frequency;
4201055a:	c1b9                	beqz	a1,420105a0 <timer_set_freq+0x56>
4201055c:	026267b7          	lui	a5,0x2626
42010560:	a0078793          	add	a5,a5,-1536 # 2625a00 <__stack_size+0x2623a00>
42010564:	02b7c7b3          	div	a5,a5,a1
    if (divider < 2 || divider > 65535) {
42010568:	6741                	lui	a4,0x10
4201056a:	1775                	add	a4,a4,-3 # fffd <__stack_size+0xdffd>
4201056c:	ffe78693          	add	a3,a5,-2
    WRITE_REG(addr, (READ_REG(addr) & 0xe0001fff) | (divider << 13));
42010570:	07b6                	sll	a5,a5,0xd
    if (divider < 2 || divider > 65535) {
42010572:	00d76e63          	bltu	a4,a3,4201058e <timer_set_freq+0x44>
    WRITE_REG(addr, (READ_REG(addr) & 0xe0001fff) | (divider << 13));
42010576:	c40d                	beqz	s0,420105a0 <timer_set_freq+0x56>
42010578:	4018                	lw	a4,0(s0)
4201057a:	e00026b7          	lui	a3,0xe0002
4201057e:	16fd                	add	a3,a3,-1 # e0001fff <__stop_free_lpsram+0x8fffdfff>
42010580:	8f75                	and	a4,a4,a3
42010582:	8fd9                	or	a5,a5,a4
}
42010584:	40b2                	lw	ra,12(sp)
    WRITE_REG(addr, (READ_REG(addr) & 0xe0001fff) | (divider << 13));
42010586:	c01c                	sw	a5,0(s0)
}
42010588:	4422                	lw	s0,8(sp)
4201058a:	0141                	add	sp,sp,16
4201058c:	8082                	ret
        logk(LOG_ERROR, "Unachievable timer frequency requested");
4201058e:	4201b5b7          	lui	a1,0x4201b
42010592:	1ec58593          	add	a1,a1,492 # 4201b1ec <hextab+0x4520>
42010596:	4505                	li	a0,1
42010598:	cbdf20ef          	jal	42003254 <logk>
4201059c:	6791                	lui	a5,0x4
4201059e:	bfe1                	j	42010576 <timer_set_freq+0x2c>
    WRITE_REG(addr, (READ_REG(addr) & 0xe0001fff) | (divider << 13));
420105a0:	9002                	ebreak

420105a2 <timer_int_config>:
void timer_int_config(int timerno, bool enable, int channel) {
420105a2:	1141                	add	sp,sp,-16
420105a4:	c606                	sw	ra,12(sp)
420105a6:	c422                	sw	s0,8(sp)
    asm volatile("csrrci %0, mstatus, 8" : "=r"(mstatus));
420105a8:	30047473          	csrrc	s0,mstatus,8
    return mstatus & 8;
420105ac:	8821                	and	s0,s0,8
    return timerno ? TIMG1_BASE : TIMG0_BASE;
420105ae:	cd11                	beqz	a0,420105ca <timer_int_config+0x28>
    if (enable) {
420105b0:	cdb9                	beqz	a1,4201060e <timer_int_config+0x6c>
            intmtx_route(INTMTX_CORE0_TG1_T0_INTR_MAP_REG, channel);
420105b2:	60010537          	lui	a0,0x60010
420105b6:	85b2                	mv	a1,a2
420105b8:	0d850513          	add	a0,a0,216 # 600100d8 <__stop_free_lpsram+0x1000c0d8>
420105bc:	9bdff0ef          	jal	4200ff78 <intmtx_route>
420105c0:	600097b7          	lui	a5,0x60009
420105c4:	07078793          	add	a5,a5,112 # 60009070 <__stop_free_lpsram+0x10005070>
420105c8:	a835                	j	42010604 <timer_int_config+0x62>
    if (enable) {
420105ca:	e195                	bnez	a1,420105ee <timer_int_config+0x4c>
420105cc:	600087b7          	lui	a5,0x60008
420105d0:	07078793          	add	a5,a5,112 # 60008070 <__stop_free_lpsram+0x10004070>
        WRITE_REG(base + INT_ENA_TIMERS_REG, READ_REG(base + INT_ENA_TIMERS_REG) & ~TIMG_T0_INT_EN_BIT);
420105d4:	4398                	lw	a4,0(a5)
420105d6:	9b79                	and	a4,a4,-2
420105d8:	c398                	sw	a4,0(a5)
    asm volatile("fence");
420105da:	0ff0000f          	fence
    if (mie) {
420105de:	c401                	beqz	s0,420105e6 <timer_int_config+0x44>
    asm volatile("csrs mstatus, %0" ::"r"(8));
420105e0:	47a1                	li	a5,8
420105e2:	3007a073          	csrs	mstatus,a5
}
420105e6:	40b2                	lw	ra,12(sp)
420105e8:	4422                	lw	s0,8(sp)
420105ea:	0141                	add	sp,sp,16
420105ec:	8082                	ret
            intmtx_route(INTMTX_CORE0_TG0_T0_INTR_MAP_REG, channel);
420105ee:	60010537          	lui	a0,0x60010
420105f2:	85b2                	mv	a1,a2
420105f4:	0cc50513          	add	a0,a0,204 # 600100cc <__stop_free_lpsram+0x1000c0cc>
420105f8:	981ff0ef          	jal	4200ff78 <intmtx_route>
420105fc:	600087b7          	lui	a5,0x60008
42010600:	07078793          	add	a5,a5,112 # 60008070 <__stop_free_lpsram+0x10004070>
        WRITE_REG(base + INT_ENA_TIMERS_REG, READ_REG(base + INT_ENA_TIMERS_REG) | TIMG_T0_INT_EN_BIT);
42010604:	4398                	lw	a4,0(a5)
42010606:	00176713          	or	a4,a4,1
4201060a:	c398                	sw	a4,0(a5)
4201060c:	b7f9                	j	420105da <timer_int_config+0x38>
    if (enable) {
4201060e:	600097b7          	lui	a5,0x60009
42010612:	07078793          	add	a5,a5,112 # 60009070 <__stop_free_lpsram+0x10005070>
42010616:	bf7d                	j	420105d4 <timer_int_config+0x32>

42010618 <timer_alarm_config>:
void timer_alarm_config(int timerno, int64_t threshold, bool reset_on_alarm) {
42010618:	1141                	add	sp,sp,-16
4201061a:	c606                	sw	ra,12(sp)
4201061c:	c422                	sw	s0,8(sp)
4201061e:	c226                	sw	s1,4(sp)
42010620:	c04a                	sw	s2,0(sp)
    return timerno ? TIMG1_BASE : TIMG0_BASE;
42010622:	c959                	beqz	a0,420106b8 <timer_alarm_config+0xa0>
42010624:	600094b7          	lui	s1,0x60009
42010628:	60009937          	lui	s2,0x60009
4201062c:	04d1                	add	s1,s1,20 # 60009014 <__stop_free_lpsram+0x10005014>
4201062e:	0941                	add	s2,s2,16 # 60009010 <__stop_free_lpsram+0x10005010>
42010630:	60009437          	lui	s0,0x60009
    if (reset_on_alarm) {
42010634:	c6a9                	beqz	a3,4201067e <timer_alarm_config+0x66>
        WRITE_REG(base + T0CONFIG_REG, READ_REG(base + T0CONFIG_REG) | TIMG_TCONFIG_AUTORELOAD_BIT);
42010636:	cc51                	beqz	s0,420106d2 <timer_alarm_config+0xba>
42010638:	401c                	lw	a5,0(s0)
4201063a:	20000737          	lui	a4,0x20000
    if (threshold < 1 || threshold >= (1ll << 56)) {
4201063e:	fff58693          	add	a3,a1,-1
        WRITE_REG(base + T0CONFIG_REG, READ_REG(base + T0CONFIG_REG) | TIMG_TCONFIG_AUTORELOAD_BIT);
42010642:	8fd9                	or	a5,a5,a4
42010644:	c01c                	sw	a5,0(s0)
    if (threshold < 1 || threshold >= (1ll << 56)) {
42010646:	0015b793          	seqz	a5,a1
4201064a:	40f607b3          	sub	a5,a2,a5
4201064e:	01000737          	lui	a4,0x1000
42010652:	04e7f763          	bgeu	a5,a4,420106a0 <timer_alarm_config+0x88>
42010656:	177d                	add	a4,a4,-1 # ffffff <__stack_size+0xffdfff>
42010658:	06e78963          	beq	a5,a4,420106ca <timer_alarm_config+0xb2>
    WRITE_REG(base + T0ALARMLO_REG, threshold);
4201065c:	06090b63          	beqz	s2,420106d2 <timer_alarm_config+0xba>
42010660:	00b92023          	sw	a1,0(s2)
    WRITE_REG(base + T0ALARMHI_REG, threshold >> 32);
42010664:	c4bd                	beqz	s1,420106d2 <timer_alarm_config+0xba>
42010666:	c090                	sw	a2,0(s1)
    WRITE_REG(base + T0CONFIG_REG, READ_REG(base + T0CONFIG_REG) | TIMG_TCONFIG_ALARM_EN_BIT);
42010668:	c42d                	beqz	s0,420106d2 <timer_alarm_config+0xba>
4201066a:	401c                	lw	a5,0(s0)
}
4201066c:	40b2                	lw	ra,12(sp)
4201066e:	4492                	lw	s1,4(sp)
    WRITE_REG(base + T0CONFIG_REG, READ_REG(base + T0CONFIG_REG) | TIMG_TCONFIG_ALARM_EN_BIT);
42010670:	4007e793          	or	a5,a5,1024
42010674:	c01c                	sw	a5,0(s0)
}
42010676:	4422                	lw	s0,8(sp)
42010678:	4902                	lw	s2,0(sp)
4201067a:	0141                	add	sp,sp,16
4201067c:	8082                	ret
        WRITE_REG(base + T0CONFIG_REG, READ_REG(base + T0CONFIG_REG) & ~TIMG_TCONFIG_AUTORELOAD_BIT);
4201067e:	c831                	beqz	s0,420106d2 <timer_alarm_config+0xba>
42010680:	401c                	lw	a5,0(s0)
42010682:	e0000737          	lui	a4,0xe0000
42010686:	177d                	add	a4,a4,-1 # dfffffff <__stop_free_lpsram+0x8fffbfff>
42010688:	8ff9                	and	a5,a5,a4
4201068a:	c01c                	sw	a5,0(s0)
    if (threshold < 1 || threshold >= (1ll << 56)) {
4201068c:	0015b793          	seqz	a5,a1
42010690:	40f607b3          	sub	a5,a2,a5
42010694:	01000737          	lui	a4,0x1000
42010698:	fff58693          	add	a3,a1,-1
4201069c:	fae7ede3          	bltu	a5,a4,42010656 <timer_alarm_config+0x3e>
        logk(LOG_ERROR, "Unachievable timer alarm value requested");
420106a0:	4201b5b7          	lui	a1,0x4201b
420106a4:	21458593          	add	a1,a1,532 # 4201b214 <hextab+0x4548>
420106a8:	4505                	li	a0,1
420106aa:	babf20ef          	jal	42003254 <logk>
420106ae:	01000637          	lui	a2,0x1000
420106b2:	167d                	add	a2,a2,-1 # ffffff <__stack_size+0xffdfff>
420106b4:	55fd                	li	a1,-1
420106b6:	b75d                	j	4201065c <timer_alarm_config+0x44>
420106b8:	600084b7          	lui	s1,0x60008
420106bc:	60008937          	lui	s2,0x60008
420106c0:	04d1                	add	s1,s1,20 # 60008014 <__stop_free_lpsram+0x10004014>
420106c2:	0941                	add	s2,s2,16 # 60008010 <__stop_free_lpsram+0x10004010>
420106c4:	60008437          	lui	s0,0x60008
420106c8:	b7b5                	j	42010634 <timer_alarm_config+0x1c>
    if (threshold < 1 || threshold >= (1ll << 56)) {
420106ca:	57f9                	li	a5,-2
420106cc:	f8d7f8e3          	bgeu	a5,a3,4201065c <timer_alarm_config+0x44>
420106d0:	bfc1                	j	420106a0 <timer_alarm_config+0x88>
    WRITE_REG(base + T0CONFIG_REG, READ_REG(base + T0CONFIG_REG) | TIMG_TCONFIG_ALARM_EN_BIT);
420106d2:	9002                	ebreak

420106d4 <time_set_next_task_switch>:
    if (!int_cfg) {
420106d4:	4080a737          	lui	a4,0x4080a
420106d8:	e7d74783          	lbu	a5,-387(a4) # 40809e7d <int_cfg.0>
420106dc:	4685                	li	a3,1
420106de:	02f6ec63          	bltu	a3,a5,42010716 <time_set_next_task_switch+0x42>
void time_set_next_task_switch(timestamp_us_t timestamp) {
420106e2:	1141                	add	sp,sp,-16
420106e4:	c422                	sw	s0,8(sp)
420106e6:	c226                	sw	s1,4(sp)
420106e8:	c606                	sw	ra,12(sp)
    if (!int_cfg) {
420106ea:	8b85                	and	a5,a5,1
420106ec:	84aa                	mv	s1,a0
420106ee:	842e                	mv	s0,a1
420106f0:	cb99                	beqz	a5,42010706 <time_set_next_task_switch+0x32>
    timer_alarm_config(TIMER_SYSTICK_NUM, timestamp, false);
420106f2:	8622                	mv	a2,s0
}
420106f4:	4422                	lw	s0,8(sp)
420106f6:	40b2                	lw	ra,12(sp)
    timer_alarm_config(TIMER_SYSTICK_NUM, timestamp, false);
420106f8:	85a6                	mv	a1,s1
}
420106fa:	4492                	lw	s1,4(sp)
    timer_alarm_config(TIMER_SYSTICK_NUM, timestamp, false);
420106fc:	4681                	li	a3,0
420106fe:	4501                	li	a0,0
}
42010700:	0141                	add	sp,sp,16
    timer_alarm_config(TIMER_SYSTICK_NUM, timestamp, false);
42010702:	f17ff06f          	j	42010618 <timer_alarm_config>
        timer_int_config(TIMER_SYSTICK_NUM, true, INT_CHANNEL_TIMER_ALARM);
42010706:	4641                	li	a2,16
42010708:	4585                	li	a1,1
4201070a:	4501                	li	a0,0
        int_cfg = true;
4201070c:	e6d70ea3          	sb	a3,-387(a4)
        timer_int_config(TIMER_SYSTICK_NUM, true, INT_CHANNEL_TIMER_ALARM);
42010710:	e93ff0ef          	jal	420105a2 <timer_int_config>
42010714:	bff9                	j	420106f2 <time_set_next_task_switch+0x1e>
    if (!int_cfg) {
42010716:	9002                	ebreak

42010718 <timer_value_get>:
    return timerno ? TIMG1_BASE : TIMG0_BASE;
42010718:	cd0d                	beqz	a0,42010752 <timer_value_get+0x3a>
4201071a:	600096b7          	lui	a3,0x60009
4201071e:	600097b7          	lui	a5,0x60009
42010722:	60009737          	lui	a4,0x60009
42010726:	06a1                	add	a3,a3,8 # 60009008 <__stop_free_lpsram+0x10005008>
42010728:	07b1                	add	a5,a5,12 # 6000900c <__stop_free_lpsram+0x1000500c>
4201072a:	0711                	add	a4,a4,4 # 60009004 <__stop_free_lpsram+0x10005004>
    uint32_t lo   = READ_REG(base + T0LO_REG);
4201072c:	430c                	lw	a1,0(a4)
    WRITE_REG(base + T0UPDATE_REG, -1);
4201072e:	cf85                	beqz	a5,42010766 <timer_value_get+0x4e>
42010730:	567d                	li	a2,-1
42010732:	c390                	sw	a2,0(a5)
    int      div  = 32;
42010734:	02000793          	li	a5,32
    while (READ_REG(base + T0LO_REG) == lo && --div) continue;
42010738:	4310                	lw	a2,0(a4)
4201073a:	00b61863          	bne	a2,a1,4201074a <timer_value_get+0x32>
4201073e:	fff78613          	add	a2,a5,-1
42010742:	02c7c263          	blt	a5,a2,42010766 <timer_value_get+0x4e>
42010746:	87b2                	mv	a5,a2
42010748:	fa65                	bnez	a2,42010738 <timer_value_get+0x20>
    return READ_REG(base + T0LO_REG) | ((uint64_t)READ_REG(base + T0HI_REG) << 32LLU);
4201074a:	4308                	lw	a0,0(a4)
4201074c:	ce89                	beqz	a3,42010766 <timer_value_get+0x4e>
4201074e:	428c                	lw	a1,0(a3)
}
42010750:	8082                	ret
42010752:	600086b7          	lui	a3,0x60008
42010756:	600087b7          	lui	a5,0x60008
4201075a:	60008737          	lui	a4,0x60008
4201075e:	06a1                	add	a3,a3,8 # 60008008 <__stop_free_lpsram+0x10004008>
42010760:	07b1                	add	a5,a5,12 # 6000800c <__stop_free_lpsram+0x1000400c>
42010762:	0711                	add	a4,a4,4 # 60008004 <__stop_free_lpsram+0x10004004>
42010764:	b7e1                	j	4201072c <timer_value_get+0x14>
    return READ_REG(base + T0LO_REG) | ((uint64_t)READ_REG(base + T0HI_REG) << 32LLU);
42010766:	9002                	ebreak

42010768 <time_us>:
    return timer_value_get(TIMER_SYSTICK_NUM);
42010768:	4501                	li	a0,0
4201076a:	fafff06f          	j	42010718 <timer_value_get>

4201076e <timer_value_set>:
    return timerno ? TIMG1_BASE : TIMG0_BASE;
4201076e:	cd11                	beqz	a0,4201078a <timer_value_set+0x1c>
42010770:	600097b7          	lui	a5,0x60009
42010774:	60009737          	lui	a4,0x60009
42010778:	02078793          	add	a5,a5,32 # 60009020 <__stop_free_lpsram+0x10005020>
4201077c:	0761                	add	a4,a4,24 # 60009018 <__stop_free_lpsram+0x10005018>
    WRITE_REG(base + T0LOADLO_REG, value);
4201077e:	c30c                	sw	a1,0(a4)
    WRITE_REG(base + T0LOADLO_REG, value >> 32);
42010780:	c310                	sw	a2,0(a4)
    WRITE_REG(base + T0LOAD_REG, -1);
42010782:	cf81                	beqz	a5,4201079a <timer_value_set+0x2c>
42010784:	577d                	li	a4,-1
42010786:	c398                	sw	a4,0(a5)
}
42010788:	8082                	ret
4201078a:	600087b7          	lui	a5,0x60008
4201078e:	60008737          	lui	a4,0x60008
42010792:	02078793          	add	a5,a5,32 # 60008020 <__stop_free_lpsram+0x10004020>
42010796:	0761                	add	a4,a4,24 # 60008018 <__stop_free_lpsram+0x10004018>
42010798:	b7dd                	j	4201077e <timer_value_set+0x10>
    WRITE_REG(base + T0LOAD_REG, -1);
4201079a:	9002                	ebreak

4201079c <timer_start>:
    return timerno ? TIMG1_BASE : TIMG0_BASE;
4201079c:	60008737          	lui	a4,0x60008
420107a0:	c119                	beqz	a0,420107a6 <timer_start+0xa>
420107a2:	60009737          	lui	a4,0x60009
    WRITE_REG(addr, READ_REG(addr) | 0xc0000000);
420107a6:	431c                	lw	a5,0(a4)
420107a8:	c00006b7          	lui	a3,0xc0000
420107ac:	8fd5                	or	a5,a5,a3
420107ae:	c31c                	sw	a5,0(a4)
}
420107b0:	8082                	ret

420107b2 <timer_stop>:
    return timerno ? TIMG1_BASE : TIMG0_BASE;
420107b2:	60008737          	lui	a4,0x60008
420107b6:	c119                	beqz	a0,420107bc <timer_stop+0xa>
420107b8:	60009737          	lui	a4,0x60009
    WRITE_REG(addr, READ_REG(addr) & ~0x80000000);
420107bc:	431c                	lw	a5,0(a4)
420107be:	0786                	sll	a5,a5,0x1
420107c0:	8385                	srl	a5,a5,0x1
420107c2:	c31c                	sw	a5,0(a4)
}
420107c4:	8082                	ret

420107c6 <timer_isr_timer_alarm>:



// Callback to the timer driver for when a timer alarm fires.
void timer_isr_timer_alarm() {
    bool preempt = READ_REG(timg_base(TIMER_PREEMPT_NUM) + INT_ST_TIMERS_REG) & TIMG_T0_INT_ST_BIT;
420107c6:	600087b7          	lui	a5,0x60008
420107ca:	5fb8                	lw	a4,120(a5)

    // Check TIMG0 T0 interrupt.
    if (READ_REG(TIMG0_BASE + INT_ST_TIMERS_REG) & TIMG_T0_INT_ST_BIT) {
420107cc:	5fb4                	lw	a3,120(a5)
    bool preempt = READ_REG(timg_base(TIMER_PREEMPT_NUM) + INT_ST_TIMERS_REG) & TIMG_T0_INT_ST_BIT;
420107ce:	00177793          	and	a5,a4,1
    if (READ_REG(TIMG0_BASE + INT_ST_TIMERS_REG) & TIMG_T0_INT_ST_BIT) {
420107d2:	0016f713          	and	a4,a3,1
420107d6:	c709                	beqz	a4,420107e0 <timer_isr_timer_alarm+0x1a>
        // Acknowledge timer interrupt.
        WRITE_REG(TIMG0_BASE + INT_CLR_TIMERS_REG, TIMG_T0_INT_CLR_BIT);
420107d8:	60008737          	lui	a4,0x60008
420107dc:	4685                	li	a3,1
420107de:	df74                	sw	a3,124(a4)
    }

    // Check TIMG1 T0 interrupt.
    if (READ_REG(TIMG1_BASE + INT_ST_TIMERS_REG) & TIMG_T0_INT_ST_BIT) {
420107e0:	600096b7          	lui	a3,0x60009
420107e4:	5eb8                	lw	a4,120(a3)
420107e6:	8b05                	and	a4,a4,1
420107e8:	c709                	beqz	a4,420107f2 <timer_isr_timer_alarm+0x2c>
        // Acknowledge timer interrupt.
        WRITE_REG(TIMG1_BASE + INT_CLR_TIMERS_REG, TIMG_T0_INT_CLR_BIT);
420107ea:	60009737          	lui	a4,0x60009
420107ee:	4685                	li	a3,1
420107f0:	df74                	sw	a3,124(a4)
    }

    // Call back to scheduler for preemption.
    if (preempt) {
420107f2:	e391                	bnez	a5,420107f6 <timer_isr_timer_alarm+0x30>
        // Timer used for preempting had an interrupt, perform task switch.
        sched_request_switch_from_isr();
    }
}
420107f4:	8082                	ret
        sched_request_switch_from_isr();
420107f6:	9b2fe06f          	j	4200e9a8 <sched_request_switch_from_isr>

420107fa <timer_isr_watchdog_alarm>:

// Callback to the timer driver for when a watchdog alarm fires.
void timer_isr_watchdog_alarm() {
    logk(LOG_DEBUG, "Watchdog alarm ISR");
420107fa:	4201b5b7          	lui	a1,0x4201b
420107fe:	24058593          	add	a1,a1,576 # 4201b240 <hextab+0x4574>
42010802:	4511                	li	a0,4
42010804:	a51f206f          	j	42003254 <logk>

42010808 <depends_on_recursive>:
static inline bool has_init_funcs(kbelf_inst inst) {
    return kbelf_inst_preinit_len(inst) || kbelf_inst_init_len(inst) || kbelf_inst_fini_len(inst);
}

// Test whether instance A depends directly or indirectly on instance B.
static bool depends_on_recursive(kbelf_dyn dyn, kbelf_inst a, kbelf_inst b, size_t recursion_limit) {
42010808:	715d                	add	sp,sp,-80
4201080a:	c686                	sw	ra,76(sp)
4201080c:	c436                	sw	a3,8(sp)
    if (recursion_limit == 0)
4201080e:	c2d5                	beqz	a3,420108b2 <depends_on_recursive+0xaa>
42010810:	c2a6                	sw	s1,68(sp)
42010812:	84ae                	mv	s1,a1
        return true;
    for (size_t i = 0; i < a->dynamic_len; i++) {
42010814:	1a058c63          	beqz	a1,420109cc <depends_on_recursive+0x1c4>
42010818:	0035f793          	and	a5,a1,3
4201081c:	1a079863          	bnez	a5,420109cc <depends_on_recursive+0x1c4>
42010820:	fc800793          	li	a5,-56
42010824:	c4a2                	sw	s0,72(sp)
42010826:	c0ca                	sw	s2,64(sp)
42010828:	1af5f463          	bgeu	a1,a5,420109d0 <depends_on_recursive+0x1c8>
4201082c:	0385a903          	lw	s2,56(a1)
42010830:	dc52                	sw	s4,56(sp)
42010832:	da56                	sw	s5,52(sp)
42010834:	d65e                	sw	s7,44(sp)
42010836:	ce6e                	sw	s11,28(sp)
42010838:	8a2a                	mv	s4,a0
4201083a:	8ab2                	mv	s5,a2
4201083c:	4401                	li	s0,0
        kbelf_dynentry dt = a->dynamic[i];
4201083e:	fc400b93          	li	s7,-60
        if (dt.tag == DT_NEEDED) {
42010842:	4d85                	li	s11,1
    for (size_t i = 0; i < a->dynamic_len; i++) {
42010844:	02090863          	beqz	s2,42010874 <depends_on_recursive+0x6c>
        kbelf_dynentry dt = a->dynamic[i];
42010848:	0574f363          	bgeu	s1,s7,4201088e <depends_on_recursive+0x86>
4201084c:	5cd8                	lw	a4,60(s1)
4201084e:	00341813          	sll	a6,s0,0x3
42010852:	010707b3          	add	a5,a4,a6
42010856:	02084a63          	bltz	a6,4201088a <depends_on_recursive+0x82>
4201085a:	02e7ea63          	bltu	a5,a4,4201088e <depends_on_recursive+0x86>
4201085e:	cb85                	beqz	a5,4201088e <depends_on_recursive+0x86>
42010860:	0037f713          	and	a4,a5,3
42010864:	e70d                	bnez	a4,4201088e <depends_on_recursive+0x86>
        if (dt.tag == DT_NEEDED) {
42010866:	4398                	lw	a4,0(a5)
        kbelf_dynentry dt = a->dynamic[i];
42010868:	43dc                	lw	a5,4(a5)
        if (dt.tag == DT_NEEDED) {
4201086a:	05b70863          	beq	a4,s11,420108ba <depends_on_recursive+0xb2>
    for (size_t i = 0; i < a->dynamic_len; i++) {
4201086e:	0405                	add	s0,s0,1 # 60008001 <__stop_free_lpsram+0x10004001>
42010870:	fd246ce3          	bltu	s0,s2,42010848 <depends_on_recursive+0x40>
42010874:	4426                	lw	s0,72(sp)
                }
            }
        }
    }
    return false;
}
42010876:	40b6                	lw	ra,76(sp)
42010878:	4496                	lw	s1,68(sp)
4201087a:	4906                	lw	s2,64(sp)
4201087c:	5a62                	lw	s4,56(sp)
4201087e:	5ad2                	lw	s5,52(sp)
42010880:	5bb2                	lw	s7,44(sp)
42010882:	4df2                	lw	s11,28(sp)
    return false;
42010884:	4501                	li	a0,0
}
42010886:	6161                	add	sp,sp,80
42010888:	8082                	ret
        kbelf_dynentry dt = a->dynamic[i];
4201088a:	fcf77ae3          	bgeu	a4,a5,4201085e <depends_on_recursive+0x56>
4201088e:	de4e                	sw	s3,60(sp)
42010890:	d85a                	sw	s6,48(sp)
42010892:	d462                	sw	s8,40(sp)
42010894:	d266                	sw	s9,36(sp)
42010896:	d06a                	sw	s10,32(sp)
            for (size_t x = 0; x < dyn->libs_len; x++) {
42010898:	9002                	ebreak
4201089a:	4426                	lw	s0,72(sp)
4201089c:	4496                	lw	s1,68(sp)
4201089e:	4906                	lw	s2,64(sp)
420108a0:	59f2                	lw	s3,60(sp)
420108a2:	5a62                	lw	s4,56(sp)
420108a4:	5ad2                	lw	s5,52(sp)
420108a6:	5b42                	lw	s6,48(sp)
420108a8:	5bb2                	lw	s7,44(sp)
420108aa:	5c22                	lw	s8,40(sp)
420108ac:	5c92                	lw	s9,36(sp)
420108ae:	5d02                	lw	s10,32(sp)
420108b0:	4df2                	lw	s11,28(sp)
        return true;
420108b2:	4505                	li	a0,1
}
420108b4:	40b6                	lw	ra,76(sp)
420108b6:	6161                	add	sp,sp,80
420108b8:	8082                	ret
            char const *needed = a->dynstr + dt.value;
420108ba:	fbc00713          	li	a4,-68
420108be:	fce4f8e3          	bgeu	s1,a4,4201088e <depends_on_recursive+0x86>
420108c2:	40f8                	lw	a4,68(s1)
420108c4:	00f70533          	add	a0,a4,a5
420108c8:	0e07d463          	bgez	a5,420109b0 <depends_on_recursive+0x1a8>
420108cc:	fca761e3          	bltu	a4,a0,4201088e <depends_on_recursive+0x86>
    char const *c0 = kbelfq_strrchr(path, '/');
420108d0:	02f00593          	li	a1,47
            char const *needed = a->dynstr + dt.value;
420108d4:	c22a                	sw	a0,4(sp)
    char const *c0 = kbelfq_strrchr(path, '/');
420108d6:	b52fa0ef          	jal	4200ac28 <kbelfq_strrchr>
    if (c0)
420108da:	c519                	beqz	a0,420108e8 <depends_on_recursive+0xe0>
        path = c0 + 1;
420108dc:	57fd                	li	a5,-1
420108de:	faf578e3          	bgeu	a0,a5,4201088e <depends_on_recursive+0x86>
420108e2:	00150793          	add	a5,a0,1
420108e6:	c23e                	sw	a5,4(sp)
            if (kbelfq_streq(needed, b->name))
420108e8:	fa0a83e3          	beqz	s5,4201088e <depends_on_recursive+0x86>
420108ec:	003af793          	and	a5,s5,3
420108f0:	ffd9                	bnez	a5,4201088e <depends_on_recursive+0x86>
420108f2:	57f1                	li	a5,-4
420108f4:	f8fafde3          	bgeu	s5,a5,4201088e <depends_on_recursive+0x86>
420108f8:	004aa583          	lw	a1,4(s5)
420108fc:	4512                	lw	a0,4(sp)
420108fe:	b60fa0ef          	jal	4200ac5e <kbelfq_streq>
42010902:	ed45                	bnez	a0,420109ba <depends_on_recursive+0x1b2>
            for (size_t x = 0; x < dyn->libs_len; x++) {
42010904:	f80a05e3          	beqz	s4,4201088e <depends_on_recursive+0x86>
42010908:	003a7793          	and	a5,s4,3
4201090c:	f3c9                	bnez	a5,4201088e <depends_on_recursive+0x86>
4201090e:	57d1                	li	a5,-12
42010910:	f6fa7fe3          	bgeu	s4,a5,4201088e <depends_on_recursive+0x86>
42010914:	d462                	sw	s8,40(sp)
42010916:	00ca2c03          	lw	s8,12(s4)
4201091a:	080c0e63          	beqz	s8,420109b6 <depends_on_recursive+0x1ae>
                    if (depends_on_recursive(dyn, dyn->libs_inst[x], b, recursion_limit - 1))
4201091e:	47a2                	lw	a5,8(sp)
42010920:	d266                	sw	s9,36(sp)
42010922:	de4e                	sw	s3,60(sp)
42010924:	17fd                	add	a5,a5,-1 # 60007fff <__stop_free_lpsram+0x10003fff>
42010926:	d85a                	sw	s6,48(sp)
42010928:	d06a                	sw	s10,32(sp)
            for (size_t x = 0; x < dyn->libs_len; x++) {
4201092a:	4c81                	li	s9,0
                    if (depends_on_recursive(dyn, dyn->libs_inst[x], b, recursion_limit - 1))
4201092c:	c63e                	sw	a5,12(sp)
                if (kbelfq_streq(dyn->libs_inst[x]->name, needed)) {
4201092e:	57b1                	li	a5,-20
42010930:	04fa7e63          	bgeu	s4,a5,4201098c <depends_on_recursive+0x184>
42010934:	014a2d03          	lw	s10,20(s4)
42010938:	002c9b13          	sll	s6,s9,0x2
4201093c:	016d0933          	add	s2,s10,s6
42010940:	040b4463          	bltz	s6,42010988 <depends_on_recursive+0x180>
42010944:	05a96463          	bltu	s2,s10,4201098c <depends_on_recursive+0x184>
42010948:	04090263          	beqz	s2,4201098c <depends_on_recursive+0x184>
4201094c:	00397613          	and	a2,s2,3
42010950:	ee15                	bnez	a2,4201098c <depends_on_recursive+0x184>
42010952:	00092983          	lw	s3,0(s2)
42010956:	02098b63          	beqz	s3,4201098c <depends_on_recursive+0x184>
4201095a:	0039f613          	and	a2,s3,3
4201095e:	e61d                	bnez	a2,4201098c <depends_on_recursive+0x184>
42010960:	57f1                	li	a5,-4
42010962:	02f9f563          	bgeu	s3,a5,4201098c <depends_on_recursive+0x184>
42010966:	0049a503          	lw	a0,4(s3)
4201096a:	4592                	lw	a1,4(sp)
4201096c:	af2fa0ef          	jal	4200ac5e <kbelfq_streq>
42010970:	ed19                	bnez	a0,4201098e <depends_on_recursive+0x186>
            for (size_t x = 0; x < dyn->libs_len; x++) {
42010972:	0c85                	add	s9,s9,1
42010974:	fb8cede3          	bltu	s9,s8,4201092e <depends_on_recursive+0x126>
42010978:	0384a903          	lw	s2,56(s1)
4201097c:	59f2                	lw	s3,60(sp)
4201097e:	5b42                	lw	s6,48(sp)
42010980:	5c22                	lw	s8,40(sp)
42010982:	5c92                	lw	s9,36(sp)
42010984:	5d02                	lw	s10,32(sp)
42010986:	b5e5                	j	4201086e <depends_on_recursive+0x66>
                if (kbelfq_streq(dyn->libs_inst[x]->name, needed)) {
42010988:	fd2d70e3          	bgeu	s10,s2,42010948 <depends_on_recursive+0x140>
                    if (depends_on_recursive(dyn, dyn->libs_inst[x], b, recursion_limit - 1))
4201098c:	9002                	ebreak
4201098e:	000b4e63          	bltz	s6,420109aa <depends_on_recursive+0x1a2>
42010992:	ffa96de3          	bltu	s2,s10,4201098c <depends_on_recursive+0x184>
42010996:	46b2                	lw	a3,12(sp)
42010998:	8656                	mv	a2,s5
4201099a:	85ce                	mv	a1,s3
4201099c:	8552                	mv	a0,s4
4201099e:	35ad                	jal	42010808 <depends_on_recursive>
420109a0:	ee051de3          	bnez	a0,4201089a <depends_on_recursive+0x92>
420109a4:	00ca2c03          	lw	s8,12(s4)
420109a8:	b7e9                	j	42010972 <depends_on_recursive+0x16a>
420109aa:	ff2d76e3          	bgeu	s10,s2,42010996 <depends_on_recursive+0x18e>
420109ae:	9002                	ebreak
            char const *needed = a->dynstr + dt.value;
420109b0:	f2e570e3          	bgeu	a0,a4,420108d0 <depends_on_recursive+0xc8>
420109b4:	bde9                	j	4201088e <depends_on_recursive+0x86>
420109b6:	5c22                	lw	s8,40(sp)
420109b8:	bd5d                	j	4201086e <depends_on_recursive+0x66>
420109ba:	4426                	lw	s0,72(sp)
420109bc:	4496                	lw	s1,68(sp)
420109be:	4906                	lw	s2,64(sp)
420109c0:	5a62                	lw	s4,56(sp)
420109c2:	5ad2                	lw	s5,52(sp)
420109c4:	5bb2                	lw	s7,44(sp)
420109c6:	4df2                	lw	s11,28(sp)
        return true;
420109c8:	4505                	li	a0,1
420109ca:	b5ed                	j	420108b4 <depends_on_recursive+0xac>
420109cc:	c4a2                	sw	s0,72(sp)
420109ce:	c0ca                	sw	s2,64(sp)
420109d0:	de4e                	sw	s3,60(sp)
420109d2:	dc52                	sw	s4,56(sp)
420109d4:	da56                	sw	s5,52(sp)
420109d6:	d85a                	sw	s6,48(sp)
420109d8:	d65e                	sw	s7,44(sp)
420109da:	d462                	sw	s8,40(sp)
420109dc:	d266                	sw	s9,36(sp)
420109de:	d06a                	sw	s10,32(sp)
420109e0:	ce6e                	sw	s11,28(sp)
    for (size_t i = 0; i < a->dynamic_len; i++) {
420109e2:	9002                	ebreak

420109e4 <kbelf_dyn_unload.part.0>:
    kbelf_inst_unload(dyn->exec_inst);
420109e4:	c94d                	beqz	a0,42010a96 <kbelf_dyn_unload.part.0+0xb2>
void kbelf_dyn_unload(kbelf_dyn dyn) {
420109e6:	1101                	add	sp,sp,-32
420109e8:	cc22                	sw	s0,24(sp)
420109ea:	ce06                	sw	ra,28(sp)
    kbelf_inst_unload(dyn->exec_inst);
420109ec:	00357793          	and	a5,a0,3
420109f0:	842a                	mv	s0,a0
420109f2:	efd1                	bnez	a5,42010a8e <kbelf_dyn_unload.part.0+0xaa>
420109f4:	57f1                	li	a5,-4
420109f6:	08f57863          	bgeu	a0,a5,42010a86 <kbelf_dyn_unload.part.0+0xa2>
420109fa:	4148                	lw	a0,4(a0)
420109fc:	133010ef          	jal	4201232e <kbelf_inst_unload>
    for (size_t i = 0; i < dyn->libs_len; i++) {
42010a00:	57d1                	li	a5,-12
    dyn->exec_inst = NULL;
42010a02:	00042223          	sw	zero,4(s0)
    for (size_t i = 0; i < dyn->libs_len; i++) {
42010a06:	06f47c63          	bgeu	s0,a5,42010a7e <kbelf_dyn_unload.part.0+0x9a>
42010a0a:	445c                	lw	a5,12(s0)
42010a0c:	cfa1                	beqz	a5,42010a64 <kbelf_dyn_unload.part.0+0x80>
42010a0e:	c84a                	sw	s2,16(sp)
42010a10:	c64e                	sw	s3,12(sp)
42010a12:	ca26                	sw	s1,20(sp)
42010a14:	4901                	li	s2,0
        kbelf_inst_unload(dyn->libs_inst[i]);
42010a16:	59b1                	li	s3,-20
42010a18:	07347163          	bgeu	s0,s3,42010a7a <kbelf_dyn_unload.part.0+0x96>
42010a1c:	4858                	lw	a4,20(s0)
42010a1e:	00291493          	sll	s1,s2,0x2
42010a22:	009707b3          	add	a5,a4,s1
42010a26:	0404c363          	bltz	s1,42010a6c <kbelf_dyn_unload.part.0+0x88>
42010a2a:	04e7e363          	bltu	a5,a4,42010a70 <kbelf_dyn_unload.part.0+0x8c>
42010a2e:	c7a9                	beqz	a5,42010a78 <kbelf_dyn_unload.part.0+0x94>
42010a30:	0037f713          	and	a4,a5,3
42010a34:	e331                	bnez	a4,42010a78 <kbelf_dyn_unload.part.0+0x94>
42010a36:	4388                	lw	a0,0(a5)
42010a38:	0f7010ef          	jal	4201232e <kbelf_inst_unload>
        dyn->libs_inst[i] = NULL;
42010a3c:	4858                	lw	a4,20(s0)
42010a3e:	009707b3          	add	a5,a4,s1
42010a42:	0204c863          	bltz	s1,42010a72 <kbelf_dyn_unload.part.0+0x8e>
42010a46:	02e7e863          	bltu	a5,a4,42010a76 <kbelf_dyn_unload.part.0+0x92>
42010a4a:	cb8d                	beqz	a5,42010a7c <kbelf_dyn_unload.part.0+0x98>
42010a4c:	0037f713          	and	a4,a5,3
42010a50:	e715                	bnez	a4,42010a7c <kbelf_dyn_unload.part.0+0x98>
    for (size_t i = 0; i < dyn->libs_len; i++) {
42010a52:	4458                	lw	a4,12(s0)
42010a54:	0905                	add	s2,s2,1
        dyn->libs_inst[i] = NULL;
42010a56:	0007a023          	sw	zero,0(a5)
    for (size_t i = 0; i < dyn->libs_len; i++) {
42010a5a:	fae96fe3          	bltu	s2,a4,42010a18 <kbelf_dyn_unload.part.0+0x34>
42010a5e:	44d2                	lw	s1,20(sp)
42010a60:	4942                	lw	s2,16(sp)
42010a62:	49b2                	lw	s3,12(sp)
}
42010a64:	40f2                	lw	ra,28(sp)
42010a66:	4462                	lw	s0,24(sp)
42010a68:	6105                	add	sp,sp,32
42010a6a:	8082                	ret
        kbelf_inst_unload(dyn->libs_inst[i]);
42010a6c:	fcf771e3          	bgeu	a4,a5,42010a2e <kbelf_dyn_unload.part.0+0x4a>
42010a70:	9002                	ebreak
        dyn->libs_inst[i] = NULL;
42010a72:	fcf77ce3          	bgeu	a4,a5,42010a4a <kbelf_dyn_unload.part.0+0x66>
42010a76:	9002                	ebreak
        kbelf_inst_unload(dyn->libs_inst[i]);
42010a78:	9002                	ebreak
42010a7a:	9002                	ebreak
        dyn->libs_inst[i] = NULL;
42010a7c:	9002                	ebreak
42010a7e:	ca26                	sw	s1,20(sp)
42010a80:	c84a                	sw	s2,16(sp)
42010a82:	c64e                	sw	s3,12(sp)
    for (size_t i = 0; i < dyn->libs_len; i++) {
42010a84:	9002                	ebreak
42010a86:	ca26                	sw	s1,20(sp)
42010a88:	c84a                	sw	s2,16(sp)
42010a8a:	c64e                	sw	s3,12(sp)
    kbelf_inst_unload(dyn->exec_inst);
42010a8c:	9002                	ebreak
42010a8e:	ca26                	sw	s1,20(sp)
42010a90:	c84a                	sw	s2,16(sp)
42010a92:	c64e                	sw	s3,12(sp)
42010a94:	9002                	ebreak
42010a96:	9002                	ebreak

42010a98 <check_deps.isra.0>:
    for (size_t i = 0; i < inst->dynamic_len; i++) {
42010a98:	40058163          	beqz	a1,42010e9a <check_deps.isra.0+0x402>
static bool check_deps(kbelf_dyn dyn, kbelf_file file, kbelf_inst inst) {
42010a9c:	715d                	add	sp,sp,-80
42010a9e:	dc52                	sw	s4,56(sp)
42010aa0:	c686                	sw	ra,76(sp)
    for (size_t i = 0; i < inst->dynamic_len; i++) {
42010aa2:	0035f793          	and	a5,a1,3
42010aa6:	8a2e                	mv	s4,a1
42010aa8:	3c079d63          	bnez	a5,42010e82 <check_deps.isra.0+0x3ea>
42010aac:	fc800793          	li	a5,-56
42010ab0:	3ef5fb63          	bgeu	a1,a5,42010ea6 <check_deps.isra.0+0x40e>
42010ab4:	da56                	sw	s5,52(sp)
42010ab6:	0385aa83          	lw	s5,56(a1)
42010aba:	c0ca                	sw	s2,64(sp)
42010abc:	4901                	li	s2,0
42010abe:	060a8563          	beqz	s5,42010b28 <check_deps.isra.0+0x90>
    for (size_t i = 0; i < dyn->builtins_len; i++) {
42010ac2:	00357793          	and	a5,a0,3
42010ac6:	c4a2                	sw	s0,72(sp)
42010ac8:	d85a                	sw	s6,48(sp)
42010aca:	c2a6                	sw	s1,68(sp)
42010acc:	de4e                	sw	s3,60(sp)
42010ace:	d65e                	sw	s7,44(sp)
42010ad0:	d462                	sw	s8,40(sp)
42010ad2:	d266                	sw	s9,36(sp)
42010ad4:	d06a                	sw	s10,32(sp)
42010ad6:	ce6e                	sw	s11,28(sp)
42010ad8:	842a                	mv	s0,a0
42010ada:	c63e                	sw	a5,12(sp)
        path = c0 + 1;
42010adc:	5b7d                	li	s6,-1
        kbelf_dynentry dt = inst->dynamic[i];
42010ade:	fc400793          	li	a5,-60
42010ae2:	38fa7063          	bgeu	s4,a5,42010e62 <check_deps.isra.0+0x3ca>
42010ae6:	03ca2703          	lw	a4,60(s4)
42010aea:	00391693          	sll	a3,s2,0x3
42010aee:	00d707b3          	add	a5,a4,a3
42010af2:	0406c263          	bltz	a3,42010b36 <check_deps.isra.0+0x9e>
42010af6:	04e7e263          	bltu	a5,a4,42010b3a <check_deps.isra.0+0xa2>
42010afa:	32078a63          	beqz	a5,42010e2e <check_deps.isra.0+0x396>
42010afe:	0037f713          	and	a4,a5,3
42010b02:	32071663          	bnez	a4,42010e2e <check_deps.isra.0+0x396>
        if (dt.tag == DT_NEEDED) {
42010b06:	4394                	lw	a3,0(a5)
42010b08:	4705                	li	a4,1
        kbelf_dynentry dt = inst->dynamic[i];
42010b0a:	43dc                	lw	a5,4(a5)
        if (dt.tag == DT_NEEDED) {
42010b0c:	02e68863          	beq	a3,a4,42010b3c <check_deps.isra.0+0xa4>
    for (size_t i = 0; i < inst->dynamic_len; i++) {
42010b10:	0905                	add	s2,s2,1
42010b12:	fd5966e3          	bltu	s2,s5,42010ade <check_deps.isra.0+0x46>
42010b16:	4426                	lw	s0,72(sp)
42010b18:	4496                	lw	s1,68(sp)
42010b1a:	59f2                	lw	s3,60(sp)
42010b1c:	5b42                	lw	s6,48(sp)
42010b1e:	5bb2                	lw	s7,44(sp)
42010b20:	5c22                	lw	s8,40(sp)
42010b22:	5c92                	lw	s9,36(sp)
42010b24:	5d02                	lw	s10,32(sp)
42010b26:	4df2                	lw	s11,28(sp)
    return true;
42010b28:	4505                	li	a0,1
}
42010b2a:	40b6                	lw	ra,76(sp)
42010b2c:	4906                	lw	s2,64(sp)
42010b2e:	5ad2                	lw	s5,52(sp)
42010b30:	5a62                	lw	s4,56(sp)
42010b32:	6161                	add	sp,sp,80
42010b34:	8082                	ret
        kbelf_dynentry dt = inst->dynamic[i];
42010b36:	fcf772e3          	bgeu	a4,a5,42010afa <check_deps.isra.0+0x62>
42010b3a:	9002                	ebreak
            char const *needed = inst->dynstr + dt.value;
42010b3c:	fbc00713          	li	a4,-68
42010b40:	32ea7a63          	bgeu	s4,a4,42010e74 <check_deps.isra.0+0x3dc>
42010b44:	044a2703          	lw	a4,68(s4)
42010b48:	00f70d33          	add	s10,a4,a5
42010b4c:	1e07c163          	bltz	a5,42010d2e <check_deps.isra.0+0x296>
42010b50:	1eed6163          	bltu	s10,a4,42010d32 <check_deps.isra.0+0x29a>
    char const *c0 = kbelfq_strrchr(path, '/');
42010b54:	02f00593          	li	a1,47
42010b58:	856a                	mv	a0,s10
42010b5a:	8cefa0ef          	jal	4200ac28 <kbelfq_strrchr>
    if (c0)
42010b5e:	1c050d63          	beqz	a0,42010d38 <check_deps.isra.0+0x2a0>
        path = c0 + 1;
42010b62:	35657063          	bgeu	a0,s6,42010ea2 <check_deps.isra.0+0x40a>
42010b66:	00150993          	add	s3,a0,1
    for (size_t i = 0; i < dyn->builtins_len; i++) {
42010b6a:	30040663          	beqz	s0,42010e76 <check_deps.isra.0+0x3de>
42010b6e:	47b2                	lw	a5,12(sp)
42010b70:	30079363          	bnez	a5,42010e76 <check_deps.isra.0+0x3de>
42010b74:	57a1                	li	a5,-24
42010b76:	2ef47d63          	bgeu	s0,a5,42010e70 <check_deps.isra.0+0x3d8>
42010b7a:	01842b83          	lw	s7,24(s0)
42010b7e:	4481                	li	s1,0
        if (kbelfq_streq(path_to_filename(dyn->builtins[i]->path), needed))
42010b80:	5c11                	li	s8,-28
    for (size_t i = 0; i < dyn->builtins_len; i++) {
42010b82:	040b8e63          	beqz	s7,42010bde <check_deps.isra.0+0x146>
        if (kbelfq_streq(path_to_filename(dyn->builtins[i]->path), needed))
42010b86:	2b847263          	bgeu	s0,s8,42010e2a <check_deps.isra.0+0x392>
42010b8a:	4c58                	lw	a4,28(s0)
42010b8c:	00249693          	sll	a3,s1,0x2
42010b90:	00d707b3          	add	a5,a4,a3
42010b94:	1806c463          	bltz	a3,42010d1c <check_deps.isra.0+0x284>
42010b98:	18e7e463          	bltu	a5,a4,42010d20 <check_deps.isra.0+0x288>
42010b9c:	28078863          	beqz	a5,42010e2c <check_deps.isra.0+0x394>
42010ba0:	0037f713          	and	a4,a5,3
42010ba4:	28071463          	bnez	a4,42010e2c <check_deps.isra.0+0x394>
42010ba8:	439c                	lw	a5,0(a5)
42010baa:	26078f63          	beqz	a5,42010e28 <check_deps.isra.0+0x390>
42010bae:	0037f713          	and	a4,a5,3
42010bb2:	26071b63          	bnez	a4,42010e28 <check_deps.isra.0+0x390>
42010bb6:	0007ac83          	lw	s9,0(a5)
    char const *c0 = kbelfq_strrchr(path, '/');
42010bba:	02f00593          	li	a1,47
42010bbe:	8566                	mv	a0,s9
42010bc0:	868fa0ef          	jal	4200ac28 <kbelfq_strrchr>
    if (c0)
42010bc4:	c509                	beqz	a0,42010bce <check_deps.isra.0+0x136>
        path = c0 + 1;
42010bc6:	29657f63          	bgeu	a0,s6,42010e64 <check_deps.isra.0+0x3cc>
42010bca:	00150c93          	add	s9,a0,1
        if (kbelfq_streq(path_to_filename(dyn->builtins[i]->path), needed))
42010bce:	85ce                	mv	a1,s3
42010bd0:	8566                	mv	a0,s9
42010bd2:	88cfa0ef          	jal	4200ac5e <kbelfq_streq>
42010bd6:	fd0d                	bnez	a0,42010b10 <check_deps.isra.0+0x78>
    for (size_t i = 0; i < dyn->builtins_len; i++) {
42010bd8:	0485                	add	s1,s1,1
42010bda:	fa9b96e3          	bne	s7,s1,42010b86 <check_deps.isra.0+0xee>
    for (size_t i = 0; i < dyn->libs_len; i++) {
42010bde:	4444                	lw	s1,12(s0)
42010be0:	c4a9                	beqz	s1,42010c2a <check_deps.isra.0+0x192>
42010be2:	01042c83          	lw	s9,16(s0)
42010be6:	4c01                	li	s8,0
        if (kbelfq_streq(dyn->libs_file[i]->name, needed))
42010be8:	002c1713          	sll	a4,s8,0x2
42010bec:	00ec87b3          	add	a5,s9,a4
42010bf0:	12074963          	bltz	a4,42010d22 <check_deps.isra.0+0x28a>
42010bf4:	1397e963          	bltu	a5,s9,42010d26 <check_deps.isra.0+0x28e>
42010bf8:	26078a63          	beqz	a5,42010e6c <check_deps.isra.0+0x3d4>
42010bfc:	0037f713          	and	a4,a5,3
42010c00:	26071663          	bnez	a4,42010e6c <check_deps.isra.0+0x3d4>
42010c04:	439c                	lw	a5,0(a5)
42010c06:	26078263          	beqz	a5,42010e6a <check_deps.isra.0+0x3d2>
42010c0a:	0037f713          	and	a4,a5,3
42010c0e:	24071e63          	bnez	a4,42010e6a <check_deps.isra.0+0x3d2>
42010c12:	5761                	li	a4,-8
42010c14:	24e7fa63          	bgeu	a5,a4,42010e68 <check_deps.isra.0+0x3d0>
42010c18:	4788                	lw	a0,8(a5)
42010c1a:	85ce                	mv	a1,s3
42010c1c:	842fa0ef          	jal	4200ac5e <kbelfq_streq>
42010c20:	ee0518e3          	bnez	a0,42010b10 <check_deps.isra.0+0x78>
    for (size_t i = 0; i < dyn->libs_len; i++) {
42010c24:	0c05                	add	s8,s8,1
42010c26:	fc9c11e3          	bne	s8,s1,42010be8 <check_deps.isra.0+0x150>
    for (size_t i = 0; i < kbelfx_builtin_libs_len; i++) {
42010c2a:	3281a783          	lw	a5,808(gp) # 40800328 <kbelfx_builtin_libs_len>
42010c2e:	c43e                	sw	a5,8(sp)
42010c30:	c7ad                	beqz	a5,42010c9a <check_deps.isra.0+0x202>
        if (kbelfq_streq(path_to_filename(needed), path_to_filename(kbelfx_builtin_libs[i].path)))
42010c32:	3241ac83          	lw	s9,804(gp) # 40800324 <kbelfx_builtin_libs>
    for (size_t i = 0; i < kbelfx_builtin_libs_len; i++) {
42010c36:	4a81                	li	s5,0
42010c38:	89e6                	mv	s3,s9
    char const *c0 = kbelfq_strrchr(path, '/');
42010c3a:	02f00593          	li	a1,47
42010c3e:	856a                	mv	a0,s10
42010c40:	fe9f90ef          	jal	4200ac28 <kbelfq_strrchr>
    if (c0)
42010c44:	0e050863          	beqz	a0,42010d34 <check_deps.isra.0+0x29c>
        path = c0 + 1;
42010c48:	23657363          	bgeu	a0,s6,42010e6e <check_deps.isra.0+0x3d6>
42010c4c:	00150793          	add	a5,a0,1
42010c50:	c23e                	sw	a5,4(sp)
    return path;
42010c52:	004a9c13          	sll	s8,s5,0x4
        if (kbelfq_streq(path_to_filename(needed), path_to_filename(kbelfx_builtin_libs[i].path)))
42010c56:	018c8db3          	add	s11,s9,s8
42010c5a:	0c0c4763          	bltz	s8,42010d28 <check_deps.isra.0+0x290>
42010c5e:	0d9de763          	bltu	s11,s9,42010d2c <check_deps.isra.0+0x294>
42010c62:	20098263          	beqz	s3,42010e66 <check_deps.isra.0+0x3ce>
42010c66:	0039f793          	and	a5,s3,3
42010c6a:	1e079e63          	bnez	a5,42010e66 <check_deps.isra.0+0x3ce>
42010c6e:	0009a483          	lw	s1,0(s3)
    char const *c0 = kbelfq_strrchr(path, '/');
42010c72:	02f00593          	li	a1,47
42010c76:	8526                	mv	a0,s1
42010c78:	fb1f90ef          	jal	4200ac28 <kbelfq_strrchr>
    if (c0)
42010c7c:	c509                	beqz	a0,42010c86 <check_deps.isra.0+0x1ee>
        path = c0 + 1;
42010c7e:	1f657a63          	bgeu	a0,s6,42010e72 <check_deps.isra.0+0x3da>
42010c82:	00150493          	add	s1,a0,1
        if (kbelfq_streq(path_to_filename(needed), path_to_filename(kbelfx_builtin_libs[i].path)))
42010c86:	4512                	lw	a0,4(sp)
42010c88:	85a6                	mv	a1,s1
42010c8a:	fd5f90ef          	jal	4200ac5e <kbelfq_streq>
42010c8e:	e55d                	bnez	a0,42010d3c <check_deps.isra.0+0x2a4>
    for (size_t i = 0; i < kbelfx_builtin_libs_len; i++) {
42010c90:	47a2                	lw	a5,8(sp)
42010c92:	0a85                	add	s5,s5,1
42010c94:	09c1                	add	s3,s3,16
42010c96:	fb5792e3          	bne	a5,s5,42010c3a <check_deps.isra.0+0x1a2>
                    kbelf_file lib = kbelfx_find_lib(needed);
42010c9a:	856a                	mv	a0,s10
42010c9c:	b08fa0ef          	jal	4200afa4 <kbelfx_find_lib>
42010ca0:	84aa                	mv	s1,a0
                    if (!lib)
42010ca2:	18050763          	beqz	a0,42010e30 <check_deps.isra.0+0x398>
    if (!dyn || !file)
42010ca6:	12040063          	beqz	s0,42010dc6 <check_deps.isra.0+0x32e>
    size_t file_sz  = (1 + dyn->libs_len) * sizeof(struct struct_kbelf_file);
42010caa:	445c                	lw	a5,12(s0)
    void  *file_mem = kbelfx_realloc(dyn->libs_file, file_sz);
42010cac:	4808                	lw	a0,16(s0)
    size_t file_sz  = (1 + dyn->libs_len) * sizeof(struct struct_kbelf_file);
42010cae:	0785                	add	a5,a5,1
42010cb0:	00279993          	sll	s3,a5,0x2
42010cb4:	99be                	add	s3,s3,a5
42010cb6:	0992                	sll	s3,s3,0x4
    void  *file_mem = kbelfx_realloc(dyn->libs_file, file_sz);
42010cb8:	85ce                	mv	a1,s3
42010cba:	fb9f90ef          	jal	4200ac72 <kbelfx_realloc>
42010cbe:	87aa                	mv	a5,a0
    void  *inst_mem = kbelfx_realloc(dyn->libs_inst, inst_sz);
42010cc0:	4848                	lw	a0,20(s0)
42010cc2:	85ce                	mv	a1,s3
    void  *file_mem = kbelfx_realloc(dyn->libs_file, file_sz);
42010cc4:	89be                	mv	s3,a5
    void  *inst_mem = kbelfx_realloc(dyn->libs_inst, inst_sz);
42010cc6:	fadf90ef          	jal	4200ac72 <kbelfx_realloc>
    if (file_mem)
42010cca:	0e098c63          	beqz	s3,42010dc2 <check_deps.isra.0+0x32a>
        dyn->libs_file = file_mem;
42010cce:	01342823          	sw	s3,16(s0)
    if (inst_mem)
42010cd2:	c975                	beqz	a0,42010dc6 <check_deps.isra.0+0x32e>
    dyn->libs_file[dyn->libs_len] = file;
42010cd4:	4458                	lw	a4,12(s0)
        dyn->libs_inst = inst_mem;
42010cd6:	c848                	sw	a0,20(s0)
    dyn->libs_file[dyn->libs_len] = file;
42010cd8:	00271693          	sll	a3,a4,0x2
42010cdc:	00d987b3          	add	a5,s3,a3
42010ce0:	0c06de63          	bgez	a3,42010dbc <check_deps.isra.0+0x324>
42010ce4:	0cf9ee63          	bltu	s3,a5,42010dc0 <check_deps.isra.0+0x328>
42010ce8:	1a078c63          	beqz	a5,42010ea0 <check_deps.isra.0+0x408>
42010cec:	0037f613          	and	a2,a5,3
42010cf0:	1a061863          	bnez	a2,42010ea0 <check_deps.isra.0+0x408>
42010cf4:	c384                	sw	s1,0(a5)
    dyn->libs_inst[dyn->libs_len] = inst;
42010cf6:	00d507b3          	add	a5,a0,a3
42010cfa:	0a06de63          	bgez	a3,42010db6 <check_deps.isra.0+0x31e>
42010cfe:	0af56e63          	bltu	a0,a5,42010dba <check_deps.isra.0+0x322>
42010d02:	18078e63          	beqz	a5,42010e9e <check_deps.isra.0+0x406>
42010d06:	0037f693          	and	a3,a5,3
42010d0a:	18069a63          	bnez	a3,42010e9e <check_deps.isra.0+0x406>
42010d0e:	0007a023          	sw	zero,0(a5)
    dyn->libs_len++;
42010d12:	0705                	add	a4,a4,1 # 60009001 <__stop_free_lpsram+0x10005001>
42010d14:	038a2a83          	lw	s5,56(s4)
42010d18:	c458                	sw	a4,12(s0)
    return true;
42010d1a:	bbdd                	j	42010b10 <check_deps.isra.0+0x78>
        if (kbelfq_streq(path_to_filename(dyn->builtins[i]->path), needed))
42010d1c:	e8f770e3          	bgeu	a4,a5,42010b9c <check_deps.isra.0+0x104>
42010d20:	9002                	ebreak
        if (kbelfq_streq(dyn->libs_file[i]->name, needed))
42010d22:	ecfcfbe3          	bgeu	s9,a5,42010bf8 <check_deps.isra.0+0x160>
42010d26:	9002                	ebreak
        if (kbelfq_streq(path_to_filename(needed), path_to_filename(kbelfx_builtin_libs[i].path)))
42010d28:	f3bcfde3          	bgeu	s9,s11,42010c62 <check_deps.isra.0+0x1ca>
42010d2c:	9002                	ebreak
            char const *needed = inst->dynstr + dt.value;
42010d2e:	e3a773e3          	bgeu	a4,s10,42010b54 <check_deps.isra.0+0xbc>
42010d32:	9002                	ebreak
42010d34:	c26a                	sw	s10,4(sp)
42010d36:	bf31                	j	42010c52 <check_deps.isra.0+0x1ba>
42010d38:	89ea                	mv	s3,s10
42010d3a:	bd05                	j	42010b6a <check_deps.isra.0+0xd2>
            return &kbelfx_builtin_libs[i];
42010d3c:	040c4863          	bltz	s8,42010d8c <check_deps.isra.0+0x2f4>
42010d40:	059de863          	bltu	s11,s9,42010d90 <check_deps.isra.0+0x2f8>
                if (builtin) {
42010d44:	f4098be3          	beqz	s3,42010c9a <check_deps.isra.0+0x202>
    if (!dyn || !lib)
42010d48:	c821                	beqz	s0,42010d98 <check_deps.isra.0+0x300>
    size_t cap = (1 + dyn->builtins_len) * sizeof(kbelf_builtin_lib *);
42010d4a:	001b8593          	add	a1,s7,1
    void  *mem = kbelfx_realloc(dyn->builtins, cap);
42010d4e:	5791                	li	a5,-28
    size_t cap = (1 + dyn->builtins_len) * sizeof(kbelf_builtin_lib *);
42010d50:	058a                	sll	a1,a1,0x2
    void  *mem = kbelfx_realloc(dyn->builtins, cap);
42010d52:	14f47963          	bgeu	s0,a5,42010ea4 <check_deps.isra.0+0x40c>
42010d56:	4c48                	lw	a0,28(s0)
42010d58:	f1bf90ef          	jal	4200ac72 <kbelfx_realloc>
    if (!mem)
42010d5c:	cd15                	beqz	a0,42010d98 <check_deps.isra.0+0x300>
    dyn->builtins[dyn->builtins_len++] = lib;
42010d5e:	4c1c                	lw	a5,24(s0)
    dyn->builtins                      = mem;
42010d60:	cc48                	sw	a0,28(s0)
    dyn->builtins[dyn->builtins_len++] = lib;
42010d62:	00178713          	add	a4,a5,1
42010d66:	cc18                	sw	a4,24(s0)
42010d68:	078a                	sll	a5,a5,0x2
42010d6a:	00f50733          	add	a4,a0,a5
42010d6e:	0207d263          	bgez	a5,42010d92 <check_deps.isra.0+0x2fa>
42010d72:	02e56263          	bltu	a0,a4,42010d96 <check_deps.isra.0+0x2fe>
42010d76:	12070363          	beqz	a4,42010e9c <check_deps.isra.0+0x404>
42010d7a:	00377793          	and	a5,a4,3
42010d7e:	10079f63          	bnez	a5,42010e9c <check_deps.isra.0+0x404>
42010d82:	038a2a83          	lw	s5,56(s4)
42010d86:	01372023          	sw	s3,0(a4)
    return true;
42010d8a:	b359                	j	42010b10 <check_deps.isra.0+0x78>
            return &kbelfx_builtin_libs[i];
42010d8c:	fbbcfce3          	bgeu	s9,s11,42010d44 <check_deps.isra.0+0x2ac>
42010d90:	9002                	ebreak
    dyn->builtins[dyn->builtins_len++] = lib;
42010d92:	fea772e3          	bgeu	a4,a0,42010d76 <check_deps.isra.0+0x2de>
42010d96:	9002                	ebreak
                        KBELF_ERROR(abort, "Out of memory")
42010d98:	4201b437          	lui	s0,0x4201b
42010d9c:	02f00593          	li	a1,47
42010da0:	25440513          	add	a0,s0,596 # 4201b254 <hextab+0x4588>
42010da4:	e85f90ef          	jal	4200ac28 <kbelfq_strrchr>
42010da8:	c539                	beqz	a0,42010df6 <check_deps.isra.0+0x35e>
42010daa:	57fd                	li	a5,-1
42010dac:	00150613          	add	a2,a0,1
42010db0:	04f56563          	bltu	a0,a5,42010dfa <check_deps.isra.0+0x362>
42010db4:	9002                	ebreak
    dyn->libs_inst[dyn->libs_len] = inst;
42010db6:	f4a7f6e3          	bgeu	a5,a0,42010d02 <check_deps.isra.0+0x26a>
42010dba:	9002                	ebreak
    dyn->libs_file[dyn->libs_len] = file;
42010dbc:	f337f6e3          	bgeu	a5,s3,42010ce8 <check_deps.isra.0+0x250>
42010dc0:	9002                	ebreak
    if (inst_mem)
42010dc2:	c111                	beqz	a0,42010dc6 <check_deps.isra.0+0x32e>
        dyn->libs_inst = inst_mem;
42010dc4:	c848                	sw	a0,20(s0)
                        KBELF_ERROR(abort, "Out of memory")
42010dc6:	4201b437          	lui	s0,0x4201b
42010dca:	02f00593          	li	a1,47
42010dce:	25440513          	add	a0,s0,596 # 4201b254 <hextab+0x4588>
42010dd2:	e57f90ef          	jal	4200ac28 <kbelfq_strrchr>
42010dd6:	c531                	beqz	a0,42010e22 <check_deps.isra.0+0x38a>
42010dd8:	577d                	li	a4,-1
42010dda:	00150613          	add	a2,a0,1
42010dde:	0ae57163          	bgeu	a0,a4,42010e80 <check_deps.isra.0+0x3e8>
42010de2:	4201b5b7          	lui	a1,0x4201b
42010de6:	0b400693          	li	a3,180
42010dea:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42010dee:	4505                	li	a0,1
42010df0:	caaf20ef          	jal	4200329a <logkf>
42010df4:	a821                	j	42010e0c <check_deps.isra.0+0x374>
                        KBELF_ERROR(abort, "Out of memory")
42010df6:	25440613          	add	a2,s0,596
42010dfa:	4201b5b7          	lui	a1,0x4201b
42010dfe:	0ad00693          	li	a3,173
42010e02:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42010e06:	4505                	li	a0,1
42010e08:	c92f20ef          	jal	4200329a <logkf>
    return false;
42010e0c:	4426                	lw	s0,72(sp)
42010e0e:	4496                	lw	s1,68(sp)
42010e10:	59f2                	lw	s3,60(sp)
42010e12:	5b42                	lw	s6,48(sp)
42010e14:	5bb2                	lw	s7,44(sp)
42010e16:	5c22                	lw	s8,40(sp)
42010e18:	5c92                	lw	s9,36(sp)
42010e1a:	5d02                	lw	s10,32(sp)
42010e1c:	4df2                	lw	s11,28(sp)
42010e1e:	4501                	li	a0,0
42010e20:	b329                	j	42010b2a <check_deps.isra.0+0x92>
                        KBELF_ERROR(abort, "Out of memory")
42010e22:	25440613          	add	a2,s0,596
42010e26:	bf75                	j	42010de2 <check_deps.isra.0+0x34a>
        if (kbelfq_streq(path_to_filename(dyn->builtins[i]->path), needed))
42010e28:	9002                	ebreak
42010e2a:	9002                	ebreak
42010e2c:	9002                	ebreak
        kbelf_dynentry dt = inst->dynamic[i];
42010e2e:	9002                	ebreak
                        KBELF_ERROR(abort, "Unable to find " KBELF_FMT_CSTR "", needed)
42010e30:	4201b437          	lui	s0,0x4201b
42010e34:	02f00593          	li	a1,47
42010e38:	25440513          	add	a0,s0,596 # 4201b254 <hextab+0x4588>
42010e3c:	dedf90ef          	jal	4200ac28 <kbelfq_strrchr>
42010e40:	cd05                	beqz	a0,42010e78 <check_deps.isra.0+0x3e0>
42010e42:	577d                	li	a4,-1
42010e44:	00150613          	add	a2,a0,1
42010e48:	02e57b63          	bgeu	a0,a4,42010e7e <check_deps.isra.0+0x3e6>
42010e4c:	4201b5b7          	lui	a1,0x4201b
42010e50:	876a                	mv	a4,s10
42010e52:	0b200693          	li	a3,178
42010e56:	2bc58593          	add	a1,a1,700 # 4201b2bc <hextab+0x45f0>
42010e5a:	4505                	li	a0,1
42010e5c:	c3ef20ef          	jal	4200329a <logkf>
42010e60:	b775                	j	42010e0c <check_deps.isra.0+0x374>
        kbelf_dynentry dt = inst->dynamic[i];
42010e62:	9002                	ebreak
        path = c0 + 1;
42010e64:	9002                	ebreak
        if (kbelfq_streq(path_to_filename(needed), path_to_filename(kbelfx_builtin_libs[i].path)))
42010e66:	9002                	ebreak
        if (kbelfq_streq(dyn->libs_file[i]->name, needed))
42010e68:	9002                	ebreak
42010e6a:	9002                	ebreak
42010e6c:	9002                	ebreak
        path = c0 + 1;
42010e6e:	9002                	ebreak
    for (size_t i = 0; i < dyn->builtins_len; i++) {
42010e70:	9002                	ebreak
        path = c0 + 1;
42010e72:	9002                	ebreak
            char const *needed = inst->dynstr + dt.value;
42010e74:	9002                	ebreak
    for (size_t i = 0; i < dyn->builtins_len; i++) {
42010e76:	9002                	ebreak
                        KBELF_ERROR(abort, "Unable to find " KBELF_FMT_CSTR "", needed)
42010e78:	25440613          	add	a2,s0,596
42010e7c:	bfc1                	j	42010e4c <check_deps.isra.0+0x3b4>
42010e7e:	9002                	ebreak
                        KBELF_ERROR(abort, "Out of memory")
42010e80:	9002                	ebreak
42010e82:	c4a2                	sw	s0,72(sp)
42010e84:	c2a6                	sw	s1,68(sp)
42010e86:	c0ca                	sw	s2,64(sp)
42010e88:	de4e                	sw	s3,60(sp)
42010e8a:	da56                	sw	s5,52(sp)
42010e8c:	d85a                	sw	s6,48(sp)
42010e8e:	d65e                	sw	s7,44(sp)
42010e90:	d462                	sw	s8,40(sp)
42010e92:	d266                	sw	s9,36(sp)
42010e94:	d06a                	sw	s10,32(sp)
42010e96:	ce6e                	sw	s11,28(sp)
    for (size_t i = 0; i < inst->dynamic_len; i++) {
42010e98:	9002                	ebreak
42010e9a:	9002                	ebreak
    dyn->builtins[dyn->builtins_len++] = lib;
42010e9c:	9002                	ebreak
    dyn->libs_inst[dyn->libs_len] = inst;
42010e9e:	9002                	ebreak
    dyn->libs_file[dyn->libs_len] = file;
42010ea0:	9002                	ebreak
        path = c0 + 1;
42010ea2:	9002                	ebreak
    void  *mem = kbelfx_realloc(dyn->builtins, cap);
42010ea4:	9002                	ebreak
42010ea6:	c4a2                	sw	s0,72(sp)
42010ea8:	c2a6                	sw	s1,68(sp)
42010eaa:	c0ca                	sw	s2,64(sp)
42010eac:	de4e                	sw	s3,60(sp)
42010eae:	da56                	sw	s5,52(sp)
42010eb0:	d85a                	sw	s6,48(sp)
42010eb2:	d65e                	sw	s7,44(sp)
42010eb4:	d462                	sw	s8,40(sp)
42010eb6:	d266                	sw	s9,36(sp)
42010eb8:	d06a                	sw	s10,32(sp)
42010eba:	ce6e                	sw	s11,28(sp)
    for (size_t i = 0; i < inst->dynamic_len; i++) {
42010ebc:	9002                	ebreak

42010ebe <sort_init_order_recursive>:
    }
}

// Sort the initialisation order.
static void sort_init_order_recursive(kbelf_dyn dyn, size_t *arr, size_t len, size_t *tmp) {
    if (len == 1) {
42010ebe:	4785                	li	a5,1
42010ec0:	2cf60f63          	beq	a2,a5,4201119e <sort_init_order_recursive+0x2e0>
static void sort_init_order_recursive(kbelf_dyn dyn, size_t *arr, size_t len, size_t *tmp) {
42010ec4:	711d                	add	sp,sp,-96
42010ec6:	c8ca                	sw	s2,80(sp)
42010ec8:	de5e                	sw	s7,60(sp)
42010eca:	d86a                	sw	s10,48(sp)
42010ecc:	ce86                	sw	ra,92(sp)
        // Base case: 1 element.
        return;
    } else if (len == 2) {
42010ece:	4789                	li	a5,2
42010ed0:	8d32                	mv	s10,a2
42010ed2:	8baa                	mv	s7,a0
42010ed4:	892e                	mv	s2,a1
42010ed6:	1cf60e63          	beq	a2,a5,420110b2 <sort_init_order_recursive+0x1f4>
42010eda:	dc62                	sw	s8,56(sp)
        }
        return;
    }

    // Determine midpoint.
    size_t midpoint = len / 2;
42010edc:	00165c13          	srl	s8,a2,0x1

    // Sort left.
    sort_init_order_recursive(dyn, arr, midpoint, tmp);
42010ee0:	8662                	mv	a2,s8
42010ee2:	c4d2                	sw	s4,72(sp)
42010ee4:	8a36                	mv	s4,a3
42010ee6:	3fe1                	jal	42010ebe <sort_init_order_recursive>

    // Sort right.
    sort_init_order_recursive(dyn, arr + midpoint, len - midpoint, tmp);
42010ee8:	002c1793          	sll	a5,s8,0x2
42010eec:	00f905b3          	add	a1,s2,a5
42010ef0:	1a07d763          	bgez	a5,4201109e <sort_init_order_recursive+0x1e0>
42010ef4:	1ab96763          	bltu	s2,a1,420110a2 <sort_init_order_recursive+0x1e4>
42010ef8:	418d0c33          	sub	s8,s10,s8
42010efc:	86d2                	mv	a3,s4
42010efe:	8662                	mv	a2,s8
42010f00:	855e                	mv	a0,s7
42010f02:	3f75                	jal	42010ebe <sort_init_order_recursive>

    // Merge.
    for (size_t i = 0, l = 0, r = 0; i < len; i++) {
42010f04:	060d0c63          	beqz	s10,42010f7c <sort_init_order_recursive+0xbe>
    kbelf_inst la = dyn->libs_inst[a];
42010f08:	003bf793          	and	a5,s7,3
42010f0c:	caa6                	sw	s1,84(sp)
42010f0e:	c6ce                	sw	s3,76(sp)
42010f10:	da66                	sw	s9,52(sp)
42010f12:	d66e                	sw	s11,44(sp)
42010f14:	cca2                	sw	s0,88(sp)
42010f16:	c2d6                	sw	s5,68(sp)
42010f18:	c0da                	sw	s6,64(sp)
42010f1a:	84d2                	mv	s1,s4
    for (size_t i = 0, l = 0, r = 0; i < len; i++) {
42010f1c:	4c81                	li	s9,0
42010f1e:	4d81                	li	s11,0
42010f20:	4981                	li	s3,0
    kbelf_inst la = dyn->libs_inst[a];
42010f22:	ce3e                	sw	a5,28(sp)
        if (r < len - midpoint && comparator(dyn, arr[l], arr[r]) < 0) {
42010f24:	002d9a93          	sll	s5,s11,0x2
42010f28:	01590433          	add	s0,s2,s5
42010f2c:	00299b13          	sll	s6,s3,0x2
42010f30:	078ce963          	bltu	s9,s8,42010fa2 <sort_init_order_recursive+0xe4>
            // Take from the right.
            tmp[i] = arr[r++];
        } else {
            // Take from the left.
            tmp[i] = arr[l++];
42010f34:	0d85                	add	s11,s11,1
42010f36:	060ac363          	bltz	s5,42010f9c <sort_init_order_recursive+0xde>
42010f3a:	07246363          	bltu	s0,s2,42010fa0 <sort_init_order_recursive+0xe2>
42010f3e:	016a06b3          	add	a3,s4,s6
42010f42:	040b4a63          	bltz	s6,42010f96 <sort_init_order_recursive+0xd8>
42010f46:	0546ea63          	bltu	a3,s4,42010f9a <sort_init_order_recursive+0xdc>
42010f4a:	24040c63          	beqz	s0,420111a2 <sort_init_order_recursive+0x2e4>
42010f4e:	00347693          	and	a3,s0,3
42010f52:	24069863          	bnez	a3,420111a2 <sort_init_order_recursive+0x2e4>
42010f56:	4014                	lw	a3,0(s0)
42010f58:	24048463          	beqz	s1,420111a0 <sort_init_order_recursive+0x2e2>
42010f5c:	0034f613          	and	a2,s1,3
42010f60:	24061063          	bnez	a2,420111a0 <sort_init_order_recursive+0x2e2>
            tmp[i] = arr[r++];
42010f64:	c094                	sw	a3,0(s1)
    for (size_t i = 0, l = 0, r = 0; i < len; i++) {
42010f66:	0985                	add	s3,s3,1
42010f68:	0491                	add	s1,s1,4
42010f6a:	fb3d1de3          	bne	s10,s3,42010f24 <sort_init_order_recursive+0x66>
42010f6e:	4466                	lw	s0,88(sp)
42010f70:	44d6                	lw	s1,84(sp)
42010f72:	49b6                	lw	s3,76(sp)
42010f74:	4a96                	lw	s5,68(sp)
42010f76:	4b06                	lw	s6,64(sp)
42010f78:	5cd2                	lw	s9,52(sp)
42010f7a:	5db2                	lw	s11,44(sp)
        }
    }
    kbelfq_memcpy(arr, tmp, sizeof(size_t) * len);
42010f7c:	5c62                	lw	s8,56(sp)
}
42010f7e:	40f6                	lw	ra,92(sp)
42010f80:	5bf2                	lw	s7,60(sp)
    kbelfq_memcpy(arr, tmp, sizeof(size_t) * len);
42010f82:	002d1613          	sll	a2,s10,0x2
42010f86:	85d2                	mv	a1,s4
}
42010f88:	5d42                	lw	s10,48(sp)
    kbelfq_memcpy(arr, tmp, sizeof(size_t) * len);
42010f8a:	4a26                	lw	s4,72(sp)
42010f8c:	854a                	mv	a0,s2
}
42010f8e:	4946                	lw	s2,80(sp)
42010f90:	6125                	add	sp,sp,96
    kbelfq_memcpy(arr, tmp, sizeof(size_t) * len);
42010f92:	cd1f906f          	j	4200ac62 <kbelfq_memcpy>
            tmp[i] = arr[l++];
42010f96:	fada7ae3          	bgeu	s4,a3,42010f4a <sort_init_order_recursive+0x8c>
42010f9a:	9002                	ebreak
42010f9c:	fa8971e3          	bgeu	s2,s0,42010f3e <sort_init_order_recursive+0x80>
42010fa0:	9002                	ebreak
        if (r < len - midpoint && comparator(dyn, arr[l], arr[r]) < 0) {
42010fa2:	0a0acf63          	bltz	s5,42011060 <sort_init_order_recursive+0x1a2>
42010fa6:	0b246f63          	bltu	s0,s2,42011064 <sort_init_order_recursive+0x1a6>
42010faa:	20040163          	beqz	s0,420111ac <sort_init_order_recursive+0x2ee>
42010fae:	00347693          	and	a3,s0,3
42010fb2:	1e069d63          	bnez	a3,420111ac <sort_init_order_recursive+0x2ee>
42010fb6:	002c9313          	sll	t1,s9,0x2
42010fba:	400c                	lw	a1,0(s0)
42010fbc:	00690833          	add	a6,s2,t1
42010fc0:	08034d63          	bltz	t1,4201105a <sort_init_order_recursive+0x19c>
42010fc4:	09286d63          	bltu	a6,s2,4201105e <sort_init_order_recursive+0x1a0>
42010fc8:	1c080e63          	beqz	a6,420111a4 <sort_init_order_recursive+0x2e6>
42010fcc:	00387693          	and	a3,a6,3
42010fd0:	1c069a63          	bnez	a3,420111a4 <sort_init_order_recursive+0x2e6>
42010fd4:	00082503          	lw	a0,0(a6)
    kbelf_inst la = dyn->libs_inst[a];
42010fd8:	1c0b8863          	beqz	s7,420111a8 <sort_init_order_recursive+0x2ea>
42010fdc:	47f2                	lw	a5,28(sp)
42010fde:	1c079563          	bnez	a5,420111a8 <sort_init_order_recursive+0x2ea>
42010fe2:	57b1                	li	a5,-20
42010fe4:	1cfbf163          	bgeu	s7,a5,420111a6 <sort_init_order_recursive+0x2e8>
42010fe8:	014ba683          	lw	a3,20(s7)
42010fec:	058a                	sll	a1,a1,0x2
42010fee:	00b68633          	add	a2,a3,a1
42010ff2:	0605ca63          	bltz	a1,42011066 <sort_init_order_recursive+0x1a8>
42010ff6:	06d66a63          	bltu	a2,a3,4201106a <sort_init_order_recursive+0x1ac>
42010ffa:	1a060863          	beqz	a2,420111aa <sort_init_order_recursive+0x2ec>
42010ffe:	00367593          	and	a1,a2,3
42011002:	1a059463          	bnez	a1,420111aa <sort_init_order_recursive+0x2ec>
    kbelf_inst lb = dyn->libs_inst[b];
42011006:	050a                	sll	a0,a0,0x2
    kbelf_inst la = dyn->libs_inst[a];
42011008:	420c                	lw	a1,0(a2)
    kbelf_inst lb = dyn->libs_inst[b];
4201100a:	00a68633          	add	a2,a3,a0
4201100e:	04054363          	bltz	a0,42011054 <sort_init_order_recursive+0x196>
42011012:	04d66363          	bltu	a2,a3,42011058 <sort_init_order_recursive+0x19a>
42011016:	18060c63          	beqz	a2,420111ae <sort_init_order_recursive+0x2f0>
4201101a:	00367693          	and	a3,a2,3
4201101e:	18069863          	bnez	a3,420111ae <sort_init_order_recursive+0x2f0>
42011022:	421c                	lw	a5,0(a2)
    return depends_on_recursive(dyn, a, b, dyn->libs_len + 1);
42011024:	00cba683          	lw	a3,12(s7)
42011028:	855e                	mv	a0,s7
4201102a:	863e                	mv	a2,a5
4201102c:	0685                	add	a3,a3,1 # 60009001 <__stop_free_lpsram+0x10005001>
4201102e:	c842                	sw	a6,16(sp)
42011030:	c61a                	sw	t1,12(sp)
42011032:	cc2e                	sw	a1,24(sp)
42011034:	ca3e                	sw	a5,20(sp)
42011036:	fd2ff0ef          	jal	42010808 <depends_on_recursive>
    if (depends_on(dyn, la, lb)) {
4201103a:	4332                	lw	t1,12(sp)
4201103c:	4842                	lw	a6,16(sp)
4201103e:	e51d                	bnez	a0,4201106c <sort_init_order_recursive+0x1ae>
    return depends_on_recursive(dyn, a, b, dyn->libs_len + 1);
42011040:	45e2                	lw	a1,24(sp)
42011042:	00cba683          	lw	a3,12(s7)
42011046:	855e                	mv	a0,s7
42011048:	862e                	mv	a2,a1
4201104a:	45d2                	lw	a1,20(sp)
4201104c:	0685                	add	a3,a3,1
4201104e:	fbaff0ef          	jal	42010808 <depends_on_recursive>
42011052:	b5cd                	j	42010f34 <sort_init_order_recursive+0x76>
    kbelf_inst lb = dyn->libs_inst[b];
42011054:	fcc6f1e3          	bgeu	a3,a2,42011016 <sort_init_order_recursive+0x158>
42011058:	9002                	ebreak
        if (r < len - midpoint && comparator(dyn, arr[l], arr[r]) < 0) {
4201105a:	f70977e3          	bgeu	s2,a6,42010fc8 <sort_init_order_recursive+0x10a>
4201105e:	9002                	ebreak
42011060:	f48975e3          	bgeu	s2,s0,42010faa <sort_init_order_recursive+0xec>
42011064:	9002                	ebreak
    kbelf_inst la = dyn->libs_inst[a];
42011066:	f8c6fae3          	bgeu	a3,a2,42010ffa <sort_init_order_recursive+0x13c>
4201106a:	9002                	ebreak
            tmp[i] = arr[r++];
4201106c:	0c85                	add	s9,s9,1
4201106e:	02035563          	bgez	t1,42011098 <sort_init_order_recursive+0x1da>
42011072:	03096563          	bltu	s2,a6,4201109c <sort_init_order_recursive+0x1de>
42011076:	016a06b3          	add	a3,s4,s6
4201107a:	000b5c63          	bgez	s6,42011092 <sort_init_order_recursive+0x1d4>
4201107e:	00da6c63          	bltu	s4,a3,42011096 <sort_init_order_recursive+0x1d8>
42011082:	00082683          	lw	a3,0(a6)
42011086:	c489                	beqz	s1,42011090 <sort_init_order_recursive+0x1d2>
42011088:	0034f613          	and	a2,s1,3
4201108c:	ec060ce3          	beqz	a2,42010f64 <sort_init_order_recursive+0xa6>
42011090:	9002                	ebreak
42011092:	ff46f8e3          	bgeu	a3,s4,42011082 <sort_init_order_recursive+0x1c4>
42011096:	9002                	ebreak
42011098:	fd287fe3          	bgeu	a6,s2,42011076 <sort_init_order_recursive+0x1b8>
4201109c:	9002                	ebreak
    sort_init_order_recursive(dyn, arr + midpoint, len - midpoint, tmp);
4201109e:	e525fde3          	bgeu	a1,s2,42010ef8 <sort_init_order_recursive+0x3a>
420110a2:	cca2                	sw	s0,88(sp)
420110a4:	caa6                	sw	s1,84(sp)
420110a6:	c6ce                	sw	s3,76(sp)
420110a8:	c2d6                	sw	s5,68(sp)
420110aa:	c0da                	sw	s6,64(sp)
420110ac:	da66                	sw	s9,52(sp)
420110ae:	d66e                	sw	s11,44(sp)
420110b0:	9002                	ebreak
        if (comparator(dyn, arr[0], arr[1]) < 0) {
420110b2:	16058963          	beqz	a1,42011224 <sort_init_order_recursive+0x366>
420110b6:	0035f793          	and	a5,a1,3
420110ba:	16079563          	bnez	a5,42011224 <sort_init_order_recursive+0x366>
420110be:	57f1                	li	a5,-4
420110c0:	4190                	lw	a2,0(a1)
420110c2:	14f5f763          	bgeu	a1,a5,42011210 <sort_init_order_recursive+0x352>
420110c6:	00458793          	add	a5,a1,4
420110ca:	10078f63          	beqz	a5,420111e8 <sort_init_order_recursive+0x32a>
420110ce:	8b8d                	and	a5,a5,3
420110d0:	10079c63          	bnez	a5,420111e8 <sort_init_order_recursive+0x32a>
420110d4:	41d4                	lw	a3,4(a1)
    kbelf_inst la = dyn->libs_inst[a];
420110d6:	0e050f63          	beqz	a0,420111d4 <sort_init_order_recursive+0x316>
420110da:	00357793          	and	a5,a0,3
420110de:	ebfd                	bnez	a5,420111d4 <sort_init_order_recursive+0x316>
420110e0:	57b1                	li	a5,-20
420110e2:	0cf57f63          	bgeu	a0,a5,420111c0 <sort_init_order_recursive+0x302>
420110e6:	495c                	lw	a5,20(a0)
420110e8:	060a                	sll	a2,a2,0x2
420110ea:	00c78733          	add	a4,a5,a2
420110ee:	06064263          	bltz	a2,42011152 <sort_init_order_recursive+0x294>
420110f2:	06f76263          	bltu	a4,a5,42011156 <sort_init_order_recursive+0x298>
420110f6:	10070363          	beqz	a4,420111fc <sort_init_order_recursive+0x33e>
420110fa:	00377613          	and	a2,a4,3
420110fe:	0e061f63          	bnez	a2,420111fc <sort_init_order_recursive+0x33e>
42011102:	caa6                	sw	s1,84(sp)
    kbelf_inst lb = dyn->libs_inst[b];
42011104:	068a                	sll	a3,a3,0x2
    kbelf_inst la = dyn->libs_inst[a];
42011106:	4304                	lw	s1,0(a4)
    kbelf_inst lb = dyn->libs_inst[b];
42011108:	00d78733          	add	a4,a5,a3
4201110c:	0406cf63          	bltz	a3,4201116a <sort_init_order_recursive+0x2ac>
42011110:	04f76f63          	bltu	a4,a5,4201116e <sort_init_order_recursive+0x2b0>
42011114:	cca2                	sw	s0,88(sp)
42011116:	cf49                	beqz	a4,420111b0 <sort_init_order_recursive+0x2f2>
42011118:	00377793          	and	a5,a4,3
4201111c:	ebd1                	bnez	a5,420111b0 <sort_init_order_recursive+0x2f2>
4201111e:	4300                	lw	s0,0(a4)
    return depends_on_recursive(dyn, a, b, dyn->libs_len + 1);
42011120:	00cba683          	lw	a3,12(s7)
42011124:	85a6                	mv	a1,s1
42011126:	8622                	mv	a2,s0
42011128:	0685                	add	a3,a3,1
4201112a:	855e                	mv	a0,s7
4201112c:	edcff0ef          	jal	42010808 <depends_on_recursive>
    if (depends_on(dyn, la, lb)) {
42011130:	c921                	beqz	a0,42011180 <sort_init_order_recursive+0x2c2>
            size_t tmp = arr[0];
42011132:	00092703          	lw	a4,0(s2)
            arr[0]     = arr[1];
42011136:	00492783          	lw	a5,4(s2)
4201113a:	4466                	lw	s0,88(sp)
}
4201113c:	40f6                	lw	ra,92(sp)
            arr[1]     = tmp;
4201113e:	00e92223          	sw	a4,4(s2)
            arr[0]     = arr[1];
42011142:	00f92023          	sw	a5,0(s2)
            arr[1]     = tmp;
42011146:	44d6                	lw	s1,84(sp)
}
42011148:	4946                	lw	s2,80(sp)
4201114a:	5bf2                	lw	s7,60(sp)
4201114c:	5d42                	lw	s10,48(sp)
4201114e:	6125                	add	sp,sp,96
42011150:	8082                	ret
    kbelf_inst la = dyn->libs_inst[a];
42011152:	fae7f2e3          	bgeu	a5,a4,420110f6 <sort_init_order_recursive+0x238>
42011156:	cca2                	sw	s0,88(sp)
42011158:	caa6                	sw	s1,84(sp)
4201115a:	c6ce                	sw	s3,76(sp)
4201115c:	c4d2                	sw	s4,72(sp)
4201115e:	c2d6                	sw	s5,68(sp)
42011160:	c0da                	sw	s6,64(sp)
42011162:	dc62                	sw	s8,56(sp)
42011164:	da66                	sw	s9,52(sp)
42011166:	d66e                	sw	s11,44(sp)
42011168:	9002                	ebreak
    kbelf_inst lb = dyn->libs_inst[b];
4201116a:	fae7f5e3          	bgeu	a5,a4,42011114 <sort_init_order_recursive+0x256>
4201116e:	cca2                	sw	s0,88(sp)
42011170:	c6ce                	sw	s3,76(sp)
42011172:	c4d2                	sw	s4,72(sp)
42011174:	c2d6                	sw	s5,68(sp)
42011176:	c0da                	sw	s6,64(sp)
42011178:	dc62                	sw	s8,56(sp)
4201117a:	da66                	sw	s9,52(sp)
4201117c:	d66e                	sw	s11,44(sp)
4201117e:	9002                	ebreak
    return depends_on_recursive(dyn, a, b, dyn->libs_len + 1);
42011180:	00cba683          	lw	a3,12(s7)
42011184:	85a2                	mv	a1,s0
42011186:	4466                	lw	s0,88(sp)
}
42011188:	40f6                	lw	ra,92(sp)
4201118a:	4946                	lw	s2,80(sp)
4201118c:	5d42                	lw	s10,48(sp)
    return depends_on_recursive(dyn, a, b, dyn->libs_len + 1);
4201118e:	8626                	mv	a2,s1
42011190:	855e                	mv	a0,s7
42011192:	44d6                	lw	s1,84(sp)
}
42011194:	5bf2                	lw	s7,60(sp)
    return depends_on_recursive(dyn, a, b, dyn->libs_len + 1);
42011196:	0685                	add	a3,a3,1
}
42011198:	6125                	add	sp,sp,96
    return depends_on_recursive(dyn, a, b, dyn->libs_len + 1);
4201119a:	e6eff06f          	j	42010808 <depends_on_recursive>
4201119e:	8082                	ret
            tmp[i] = arr[l++];
420111a0:	9002                	ebreak
420111a2:	9002                	ebreak
        if (r < len - midpoint && comparator(dyn, arr[l], arr[r]) < 0) {
420111a4:	9002                	ebreak
    kbelf_inst la = dyn->libs_inst[a];
420111a6:	9002                	ebreak
420111a8:	9002                	ebreak
420111aa:	9002                	ebreak
        if (r < len - midpoint && comparator(dyn, arr[l], arr[r]) < 0) {
420111ac:	9002                	ebreak
    kbelf_inst lb = dyn->libs_inst[b];
420111ae:	9002                	ebreak
420111b0:	c6ce                	sw	s3,76(sp)
420111b2:	c4d2                	sw	s4,72(sp)
420111b4:	c2d6                	sw	s5,68(sp)
420111b6:	c0da                	sw	s6,64(sp)
420111b8:	dc62                	sw	s8,56(sp)
420111ba:	da66                	sw	s9,52(sp)
420111bc:	d66e                	sw	s11,44(sp)
420111be:	9002                	ebreak
420111c0:	cca2                	sw	s0,88(sp)
420111c2:	caa6                	sw	s1,84(sp)
420111c4:	c6ce                	sw	s3,76(sp)
420111c6:	c4d2                	sw	s4,72(sp)
420111c8:	c2d6                	sw	s5,68(sp)
420111ca:	c0da                	sw	s6,64(sp)
420111cc:	dc62                	sw	s8,56(sp)
420111ce:	da66                	sw	s9,52(sp)
420111d0:	d66e                	sw	s11,44(sp)
    kbelf_inst la = dyn->libs_inst[a];
420111d2:	9002                	ebreak
420111d4:	cca2                	sw	s0,88(sp)
420111d6:	caa6                	sw	s1,84(sp)
420111d8:	c6ce                	sw	s3,76(sp)
420111da:	c4d2                	sw	s4,72(sp)
420111dc:	c2d6                	sw	s5,68(sp)
420111de:	c0da                	sw	s6,64(sp)
420111e0:	dc62                	sw	s8,56(sp)
420111e2:	da66                	sw	s9,52(sp)
420111e4:	d66e                	sw	s11,44(sp)
420111e6:	9002                	ebreak
420111e8:	cca2                	sw	s0,88(sp)
420111ea:	caa6                	sw	s1,84(sp)
420111ec:	c6ce                	sw	s3,76(sp)
420111ee:	c4d2                	sw	s4,72(sp)
420111f0:	c2d6                	sw	s5,68(sp)
420111f2:	c0da                	sw	s6,64(sp)
420111f4:	dc62                	sw	s8,56(sp)
420111f6:	da66                	sw	s9,52(sp)
420111f8:	d66e                	sw	s11,44(sp)
        if (comparator(dyn, arr[0], arr[1]) < 0) {
420111fa:	9002                	ebreak
420111fc:	cca2                	sw	s0,88(sp)
420111fe:	caa6                	sw	s1,84(sp)
42011200:	c6ce                	sw	s3,76(sp)
42011202:	c4d2                	sw	s4,72(sp)
42011204:	c2d6                	sw	s5,68(sp)
42011206:	c0da                	sw	s6,64(sp)
42011208:	dc62                	sw	s8,56(sp)
4201120a:	da66                	sw	s9,52(sp)
4201120c:	d66e                	sw	s11,44(sp)
    kbelf_inst la = dyn->libs_inst[a];
4201120e:	9002                	ebreak
42011210:	cca2                	sw	s0,88(sp)
42011212:	caa6                	sw	s1,84(sp)
42011214:	c6ce                	sw	s3,76(sp)
42011216:	c4d2                	sw	s4,72(sp)
42011218:	c2d6                	sw	s5,68(sp)
4201121a:	c0da                	sw	s6,64(sp)
4201121c:	dc62                	sw	s8,56(sp)
4201121e:	da66                	sw	s9,52(sp)
42011220:	d66e                	sw	s11,44(sp)
        if (comparator(dyn, arr[0], arr[1]) < 0) {
42011222:	9002                	ebreak
42011224:	cca2                	sw	s0,88(sp)
42011226:	caa6                	sw	s1,84(sp)
42011228:	c6ce                	sw	s3,76(sp)
4201122a:	c4d2                	sw	s4,72(sp)
4201122c:	c2d6                	sw	s5,68(sp)
4201122e:	c0da                	sw	s6,64(sp)
42011230:	dc62                	sw	s8,56(sp)
42011232:	da66                	sw	s9,52(sp)
42011234:	d66e                	sw	s11,44(sp)
42011236:	9002                	ebreak

42011238 <kbelf_dyn_create>:
kbelf_dyn kbelf_dyn_create(int pid) {
42011238:	1141                	add	sp,sp,-16
4201123a:	c226                	sw	s1,4(sp)
4201123c:	84aa                	mv	s1,a0
    kbelf_dyn dyn = kbelfx_malloc(sizeof(struct struct_kbelf_dyn));
4201123e:	03400513          	li	a0,52
kbelf_dyn kbelf_dyn_create(int pid) {
42011242:	c422                	sw	s0,8(sp)
42011244:	c606                	sw	ra,12(sp)
    kbelf_dyn dyn = kbelfx_malloc(sizeof(struct struct_kbelf_dyn));
42011246:	a29f90ef          	jal	4200ac6e <kbelfx_malloc>
4201124a:	842a                	mv	s0,a0
    if (!dyn)
4201124c:	c11d                	beqz	a0,42011272 <kbelf_dyn_create+0x3a>
    kbelfq_memset(dyn, 0, sizeof(struct struct_kbelf_dyn));
4201124e:	03400613          	li	a2,52
42011252:	4581                	li	a1,0
42011254:	a13f90ef          	jal	4200ac66 <kbelfq_memset>
    dyn->pid = pid;
42011258:	00347793          	and	a5,s0,3
4201125c:	ebb9                	bnez	a5,420112b2 <kbelf_dyn_create+0x7a>
4201125e:	57e1                	li	a5,-8
42011260:	04f47963          	bgeu	s0,a5,420112b2 <kbelf_dyn_create+0x7a>
42011264:	c404                	sw	s1,8(s0)
}
42011266:	40b2                	lw	ra,12(sp)
42011268:	8522                	mv	a0,s0
4201126a:	4422                	lw	s0,8(sp)
4201126c:	4492                	lw	s1,4(sp)
4201126e:	0141                	add	sp,sp,16
42011270:	8082                	ret
        KBELF_ERROR(abort, "Out of memory")
42011272:	4201b4b7          	lui	s1,0x4201b
42011276:	02f00593          	li	a1,47
4201127a:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
4201127e:	9abf90ef          	jal	4200ac28 <kbelfq_strrchr>
42011282:	c50d                	beqz	a0,420112ac <kbelf_dyn_create+0x74>
42011284:	57fd                	li	a5,-1
42011286:	00150613          	add	a2,a0,1
4201128a:	02f57463          	bgeu	a0,a5,420112b2 <kbelf_dyn_create+0x7a>
4201128e:	4201b5b7          	lui	a1,0x4201b
42011292:	4505                	li	a0,1
42011294:	02200693          	li	a3,34
42011298:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
4201129c:	ffff10ef          	jal	4200329a <logkf>
}
420112a0:	40b2                	lw	ra,12(sp)
420112a2:	8522                	mv	a0,s0
420112a4:	4422                	lw	s0,8(sp)
420112a6:	4492                	lw	s1,4(sp)
420112a8:	0141                	add	sp,sp,16
420112aa:	8082                	ret
        KBELF_ERROR(abort, "Out of memory")
420112ac:	25448613          	add	a2,s1,596
420112b0:	bff9                	j	4201128e <kbelf_dyn_create+0x56>
    dyn->pid = pid;
420112b2:	9002                	ebreak

420112b4 <kbelf_dyn_destroy>:
    if (!dyn)
420112b4:	c971                	beqz	a0,42011388 <kbelf_dyn_destroy+0xd4>
void kbelf_dyn_destroy(kbelf_dyn dyn) {
420112b6:	1101                	add	sp,sp,-32
420112b8:	cc22                	sw	s0,24(sp)
420112ba:	ce06                	sw	ra,28(sp)
    if (dyn->exec_file)
420112bc:	00357793          	and	a5,a0,3
420112c0:	842a                	mv	s0,a0
420112c2:	0e079763          	bnez	a5,420113b0 <kbelf_dyn_destroy+0xfc>
420112c6:	4108                	lw	a0,0(a0)
420112c8:	c119                	beqz	a0,420112ce <kbelf_dyn_destroy+0x1a>
        kbelf_file_close(dyn->exec_file);
420112ca:	30b000ef          	jal	42011dd4 <kbelf_file_close>
    if (dyn->exec_inst)
420112ce:	57f1                	li	a5,-4
420112d0:	0cf47163          	bgeu	s0,a5,42011392 <kbelf_dyn_destroy+0xde>
420112d4:	4048                	lw	a0,4(s0)
420112d6:	c119                	beqz	a0,420112dc <kbelf_dyn_destroy+0x28>
        kbelf_inst_destroy(dyn->exec_inst);
420112d8:	0ac010ef          	jal	42012384 <kbelf_inst_destroy>
    for (size_t i = 0; i < dyn->libs_len; i++) {
420112dc:	57d1                	li	a5,-12
420112de:	0af47f63          	bgeu	s0,a5,4201139c <kbelf_dyn_destroy+0xe8>
420112e2:	445c                	lw	a5,12(s0)
420112e4:	c3bd                	beqz	a5,4201134a <kbelf_dyn_destroy+0x96>
420112e6:	c84a                	sw	s2,16(sp)
420112e8:	c64e                	sw	s3,12(sp)
420112ea:	c452                	sw	s4,8(sp)
420112ec:	ca26                	sw	s1,20(sp)
420112ee:	4901                	li	s2,0
        kbelf_file_close(dyn->libs_file[i]);
420112f0:	5a41                	li	s4,-16
        kbelf_inst_destroy(dyn->libs_inst[i]);
420112f2:	59b1                	li	s3,-20
        kbelf_file_close(dyn->libs_file[i]);
420112f4:	09447d63          	bgeu	s0,s4,4201138e <kbelf_dyn_destroy+0xda>
420112f8:	4818                	lw	a4,16(s0)
420112fa:	00291493          	sll	s1,s2,0x2
420112fe:	009707b3          	add	a5,a4,s1
42011302:	0604c563          	bltz	s1,4201136c <kbelf_dyn_destroy+0xb8>
42011306:	06e7e563          	bltu	a5,a4,42011370 <kbelf_dyn_destroy+0xbc>
4201130a:	c3c9                	beqz	a5,4201138c <kbelf_dyn_destroy+0xd8>
4201130c:	0037f713          	and	a4,a5,3
42011310:	ef35                	bnez	a4,4201138c <kbelf_dyn_destroy+0xd8>
42011312:	4388                	lw	a0,0(a5)
42011314:	2c1000ef          	jal	42011dd4 <kbelf_file_close>
        kbelf_inst_destroy(dyn->libs_inst[i]);
42011318:	07347c63          	bgeu	s0,s3,42011390 <kbelf_dyn_destroy+0xdc>
4201131c:	4858                	lw	a4,20(s0)
4201131e:	009707b3          	add	a5,a4,s1
42011322:	0404c263          	bltz	s1,42011366 <kbelf_dyn_destroy+0xb2>
42011326:	04e7e263          	bltu	a5,a4,4201136a <kbelf_dyn_destroy+0xb6>
4201132a:	c3a5                	beqz	a5,4201138a <kbelf_dyn_destroy+0xd6>
4201132c:	0037f713          	and	a4,a5,3
42011330:	ef29                	bnez	a4,4201138a <kbelf_dyn_destroy+0xd6>
42011332:	4388                	lw	a0,0(a5)
    for (size_t i = 0; i < dyn->libs_len; i++) {
42011334:	0905                	add	s2,s2,1
        kbelf_inst_destroy(dyn->libs_inst[i]);
42011336:	04e010ef          	jal	42012384 <kbelf_inst_destroy>
    for (size_t i = 0; i < dyn->libs_len; i++) {
4201133a:	445c                	lw	a5,12(s0)
4201133c:	faf96ce3          	bltu	s2,a5,420112f4 <kbelf_dyn_destroy+0x40>
    if (dyn->libs_len) {
42011340:	eb8d                	bnez	a5,42011372 <kbelf_dyn_destroy+0xbe>
42011342:	44d2                	lw	s1,20(sp)
42011344:	4942                	lw	s2,16(sp)
42011346:	49b2                	lw	s3,12(sp)
42011348:	4a22                	lw	s4,8(sp)
    if (dyn->init_order)
4201134a:	fd000793          	li	a5,-48
4201134e:	04f47c63          	bgeu	s0,a5,420113a6 <kbelf_dyn_destroy+0xf2>
42011352:	5808                	lw	a0,48(s0)
42011354:	c119                	beqz	a0,4201135a <kbelf_dyn_destroy+0xa6>
        kbelfx_free(dyn->init_order);
42011356:	921f90ef          	jal	4200ac76 <kbelfx_free>
    kbelfx_free(dyn);
4201135a:	8522                	mv	a0,s0
}
4201135c:	4462                	lw	s0,24(sp)
4201135e:	40f2                	lw	ra,28(sp)
42011360:	6105                	add	sp,sp,32
    kbelfx_free(dyn);
42011362:	915f906f          	j	4200ac76 <kbelfx_free>
        kbelf_inst_destroy(dyn->libs_inst[i]);
42011366:	fcf772e3          	bgeu	a4,a5,4201132a <kbelf_dyn_destroy+0x76>
4201136a:	9002                	ebreak
        kbelf_file_close(dyn->libs_file[i]);
4201136c:	f8f77fe3          	bgeu	a4,a5,4201130a <kbelf_dyn_destroy+0x56>
42011370:	9002                	ebreak
        kbelfx_free(dyn->libs_file);
42011372:	4808                	lw	a0,16(s0)
42011374:	903f90ef          	jal	4200ac76 <kbelfx_free>
        kbelfx_free(dyn->libs_inst);
42011378:	4848                	lw	a0,20(s0)
4201137a:	8fdf90ef          	jal	4200ac76 <kbelfx_free>
4201137e:	44d2                	lw	s1,20(sp)
42011380:	4942                	lw	s2,16(sp)
42011382:	49b2                	lw	s3,12(sp)
42011384:	4a22                	lw	s4,8(sp)
42011386:	b7d1                	j	4201134a <kbelf_dyn_destroy+0x96>
42011388:	8082                	ret
        kbelf_inst_destroy(dyn->libs_inst[i]);
4201138a:	9002                	ebreak
        kbelf_file_close(dyn->libs_file[i]);
4201138c:	9002                	ebreak
4201138e:	9002                	ebreak
        kbelf_inst_destroy(dyn->libs_inst[i]);
42011390:	9002                	ebreak
42011392:	ca26                	sw	s1,20(sp)
42011394:	c84a                	sw	s2,16(sp)
42011396:	c64e                	sw	s3,12(sp)
42011398:	c452                	sw	s4,8(sp)
    if (dyn->exec_inst)
4201139a:	9002                	ebreak
4201139c:	ca26                	sw	s1,20(sp)
4201139e:	c84a                	sw	s2,16(sp)
420113a0:	c64e                	sw	s3,12(sp)
420113a2:	c452                	sw	s4,8(sp)
    for (size_t i = 0; i < dyn->libs_len; i++) {
420113a4:	9002                	ebreak
420113a6:	ca26                	sw	s1,20(sp)
420113a8:	c84a                	sw	s2,16(sp)
420113aa:	c64e                	sw	s3,12(sp)
420113ac:	c452                	sw	s4,8(sp)
    if (dyn->init_order)
420113ae:	9002                	ebreak
420113b0:	ca26                	sw	s1,20(sp)
420113b2:	c84a                	sw	s2,16(sp)
420113b4:	c64e                	sw	s3,12(sp)
420113b6:	c452                	sw	s4,8(sp)
    if (dyn->exec_file)
420113b8:	9002                	ebreak

420113ba <kbelf_dyn_unload>:
    if (!dyn)
420113ba:	c119                	beqz	a0,420113c0 <kbelf_dyn_unload+0x6>
420113bc:	e28ff06f          	j	420109e4 <kbelf_dyn_unload.part.0>
}
420113c0:	8082                	ret

420113c2 <kbelf_dyn_set_exec>:
bool kbelf_dyn_set_exec(kbelf_dyn dyn, char const *path, void *fd) {
420113c2:	1141                	add	sp,sp,-16
420113c4:	c422                	sw	s0,8(sp)
420113c6:	c606                	sw	ra,12(sp)
420113c8:	842a                	mv	s0,a0
    if (!dyn)
420113ca:	c511                	beqz	a0,420113d6 <kbelf_dyn_set_exec+0x14>
    if (dyn->exec_file)
420113cc:	00357793          	and	a5,a0,3
420113d0:	e39d                	bnez	a5,420113f6 <kbelf_dyn_set_exec+0x34>
420113d2:	411c                	lw	a5,0(a0)
420113d4:	c791                	beqz	a5,420113e0 <kbelf_dyn_set_exec+0x1e>
}
420113d6:	40b2                	lw	ra,12(sp)
420113d8:	4422                	lw	s0,8(sp)
        return false;
420113da:	4501                	li	a0,0
}
420113dc:	0141                	add	sp,sp,16
420113de:	8082                	ret
    dyn->exec_file = kbelf_file_open(path, fd);
420113e0:	852e                	mv	a0,a1
420113e2:	85b2                	mv	a1,a2
420113e4:	233000ef          	jal	42011e16 <kbelf_file_open>
420113e8:	c008                	sw	a0,0(s0)
}
420113ea:	40b2                	lw	ra,12(sp)
420113ec:	4422                	lw	s0,8(sp)
    return dyn->exec_file;
420113ee:	00a03533          	snez	a0,a0
}
420113f2:	0141                	add	sp,sp,16
420113f4:	8082                	ret
    if (dyn->exec_file)
420113f6:	9002                	ebreak

420113f8 <kbelf_dyn_load>:
}


// Interpret the files and create a process image.
// Returns success status.
bool kbelf_dyn_load(kbelf_dyn dyn) {
420113f8:	7179                	add	sp,sp,-48
420113fa:	d606                	sw	ra,44(sp)
420113fc:	d226                	sw	s1,36(sp)
    kbelf_reloc reloc = NULL;
    if (!dyn)
420113fe:	30050b63          	beqz	a0,42011714 <kbelf_dyn_load+0x31c>
42011402:	d422                	sw	s0,40(sp)
42011404:	d04a                	sw	s2,32(sp)
        return false;
    if (!dyn->exec_file)
42011406:	00357793          	and	a5,a0,3
4201140a:	842a                	mv	s0,a0
4201140c:	62079963          	bnez	a5,42011a3e <kbelf_dyn_load+0x646>
42011410:	4108                	lw	a0,0(a0)
42011412:	2c050063          	beqz	a0,420116d2 <kbelf_dyn_load+0x2da>
        KBELF_ERROR(abort, "No executable file")

    // Load the executable.
    dyn->exec_inst = kbelf_inst_load(dyn->exec_file, dyn->pid);
42011416:	57e1                	li	a5,-8
42011418:	62f47363          	bgeu	s0,a5,42011a3e <kbelf_dyn_load+0x646>
4201141c:	440c                	lw	a1,8(s0)
4201141e:	598010ef          	jal	420129b6 <kbelf_inst_load>
42011422:	c048                	sw	a0,4(s0)
42011424:	85aa                	mv	a1,a0
    if (!dyn->exec_inst)
42011426:	3c050663          	beqz	a0,420117f2 <kbelf_dyn_load+0x3fa>
        KBELF_ERROR(abort, "Unable to load " KBELF_FMT_CSTR, dyn->exec_file->path)

    // Load libraries for the executable.
    if (!check_deps(dyn, dyn->exec_file, dyn->exec_inst))
4201142a:	8522                	mv	a0,s0
4201142c:	e6cff0ef          	jal	42010a98 <check_deps.isra.0>
42011430:	42050c63          	beqz	a0,42011868 <kbelf_dyn_load+0x470>
        KBELF_ERROR(abort, "Unable to satisfy library requirements")

    // Check dependencies for the libraries.
    for (size_t i = 0; i < dyn->libs_len; i++) {
42011434:	57d1                	li	a5,-12
42011436:	ce4e                	sw	s3,28(sp)
42011438:	cc52                	sw	s4,24(sp)
4201143a:	ca56                	sw	s5,20(sp)
4201143c:	2ef47463          	bgeu	s0,a5,42011724 <kbelf_dyn_load+0x32c>
42011440:	445c                	lw	a5,12(s0)
42011442:	4a01                	li	s4,0
        if (!dyn->libs_inst[i]) {
42011444:	5ab1                	li	s5,-20
    for (size_t i = 0; i < dyn->libs_len; i++) {
42011446:	10078663          	beqz	a5,42011552 <kbelf_dyn_load+0x15a>
        if (!dyn->libs_inst[i]) {
4201144a:	2d547d63          	bgeu	s0,s5,42011724 <kbelf_dyn_load+0x32c>
4201144e:	4844                	lw	s1,20(s0)
42011450:	002a1913          	sll	s2,s4,0x2
42011454:	012489b3          	add	s3,s1,s2
42011458:	2c094463          	bltz	s2,42011720 <kbelf_dyn_load+0x328>
4201145c:	2c99e463          	bltu	s3,s1,42011724 <kbelf_dyn_load+0x32c>
42011460:	2c098263          	beqz	s3,42011724 <kbelf_dyn_load+0x32c>
42011464:	0039f793          	and	a5,s3,3
42011468:	2a079e63          	bnez	a5,42011724 <kbelf_dyn_load+0x32c>
4201146c:	0009a783          	lw	a5,0(s3)
42011470:	2c078563          	beqz	a5,4201173a <kbelf_dyn_load+0x342>
            dyn->libs_inst[i] = kbelf_inst_load(dyn->libs_file[i], dyn->pid);
            if (!dyn->libs_inst[i])
                KBELF_ERROR(abort, "Unable to load " KBELF_FMT_CSTR, dyn->libs_file[i]->path)
        }
        if (!check_deps(dyn, dyn->libs_file[i], dyn->libs_inst[i]))
42011474:	4818                	lw	a4,16(s0)
42011476:	012707b3          	add	a5,a4,s2
4201147a:	2a094d63          	bltz	s2,42011734 <kbelf_dyn_load+0x33c>
4201147e:	2ae7e363          	bltu	a5,a4,42011724 <kbelf_dyn_load+0x32c>
42011482:	2a078163          	beqz	a5,42011724 <kbelf_dyn_load+0x32c>
42011486:	8b8d                	and	a5,a5,3
42011488:	28079e63          	bnez	a5,42011724 <kbelf_dyn_load+0x32c>
4201148c:	012487b3          	add	a5,s1,s2
42011490:	28094f63          	bltz	s2,4201172e <kbelf_dyn_load+0x336>
42011494:	2897e863          	bltu	a5,s1,42011724 <kbelf_dyn_load+0x32c>
42011498:	28078663          	beqz	a5,42011724 <kbelf_dyn_load+0x32c>
4201149c:	0037f713          	and	a4,a5,3
420114a0:	28071263          	bnez	a4,42011724 <kbelf_dyn_load+0x32c>
420114a4:	438c                	lw	a1,0(a5)
420114a6:	8522                	mv	a0,s0
420114a8:	df0ff0ef          	jal	42010a98 <check_deps.isra.0>
420114ac:	3e050663          	beqz	a0,42011898 <kbelf_dyn_load+0x4a0>
    for (size_t i = 0; i < dyn->libs_len; i++) {
420114b0:	00c42983          	lw	s3,12(s0)
420114b4:	0a05                	add	s4,s4,1
420114b6:	f93a6ae3          	bltu	s4,s3,4201144a <kbelf_dyn_load+0x52>
            KBELF_ERROR(abort, "Unable to satisfy library requirements")
    }

    // Count the number of libs with init and/or fini functions.
    for (size_t i = 0; i < dyn->libs_len; i++) {
420114ba:	08098c63          	beqz	s3,42011552 <kbelf_dyn_load+0x15a>
420114be:	4844                	lw	s1,20(s0)
420114c0:	c85a                	sw	s6,16(sp)
420114c2:	c462                	sw	s8,8(sp)
420114c4:	c65e                	sw	s7,12(sp)
420114c6:	c266                	sw	s9,4(sp)
420114c8:	4b01                	li	s6,0
        dyn->init_order_len += has_init_funcs(dyn->libs_inst[i]);
420114ca:	fd400c13          	li	s8,-44
420114ce:	002b1a13          	sll	s4,s6,0x2
420114d2:	01448933          	add	s2,s1,s4
420114d6:	360a4a63          	bltz	s4,4201184a <kbelf_dyn_load+0x452>
420114da:	36996463          	bltu	s2,s1,42011842 <kbelf_dyn_load+0x44a>
420114de:	36090263          	beqz	s2,42011842 <kbelf_dyn_load+0x44a>
420114e2:	00397793          	and	a5,s2,3
420114e6:	34079e63          	bnez	a5,42011842 <kbelf_dyn_load+0x44a>
420114ea:	00092a83          	lw	s5,0(s2)
    return kbelf_inst_preinit_len(inst) || kbelf_inst_init_len(inst) || kbelf_inst_fini_len(inst);
420114ee:	4c85                	li	s9,1
420114f0:	8556                	mv	a0,s5
420114f2:	739010ef          	jal	4201342a <kbelf_inst_preinit_len>
420114f6:	e911                	bnez	a0,4201150a <kbelf_dyn_load+0x112>
420114f8:	8556                	mv	a0,s5
420114fa:	7af010ef          	jal	420134a8 <kbelf_inst_init_len>
420114fe:	e511                	bnez	a0,4201150a <kbelf_dyn_load+0x112>
42011500:	8556                	mv	a0,s5
42011502:	042020ef          	jal	42013544 <kbelf_inst_fini_len>
42011506:	00a03cb3          	snez	s9,a0
        dyn->init_order_len += has_init_funcs(dyn->libs_inst[i]);
4201150a:	33847c63          	bgeu	s0,s8,42011842 <kbelf_dyn_load+0x44a>
4201150e:	545c                	lw	a5,44(s0)
        dyn->init_len       += kbelf_inst_init_len(dyn->libs_inst[i]);
42011510:	02442b83          	lw	s7,36(s0)
        dyn->init_order_len += has_init_funcs(dyn->libs_inst[i]);
42011514:	97e6                	add	a5,a5,s9
42011516:	d45c                	sw	a5,44(s0)
        dyn->init_len       += kbelf_inst_init_len(dyn->libs_inst[i]);
42011518:	320a4663          	bltz	s4,42011844 <kbelf_dyn_load+0x44c>
4201151c:	32996363          	bltu	s2,s1,42011842 <kbelf_dyn_load+0x44a>
42011520:	8556                	mv	a0,s5
42011522:	787010ef          	jal	420134a8 <kbelf_inst_init_len>
42011526:	9baa                	add	s7,s7,a0
42011528:	03742223          	sw	s7,36(s0)
        dyn->fini_len       += kbelf_inst_fini_len(dyn->libs_inst[i]);
4201152c:	02842b83          	lw	s7,40(s0)
42011530:	300a4763          	bltz	s4,4201183e <kbelf_dyn_load+0x446>
42011534:	30996763          	bltu	s2,s1,42011842 <kbelf_dyn_load+0x44a>
42011538:	8556                	mv	a0,s5
4201153a:	00a020ef          	jal	42013544 <kbelf_inst_fini_len>
4201153e:	9baa                	add	s7,s7,a0
42011540:	03742423          	sw	s7,40(s0)
    for (size_t i = 0; i < dyn->libs_len; i++) {
42011544:	0b05                	add	s6,s6,1
42011546:	f96994e3          	bne	s3,s6,420114ce <kbelf_dyn_load+0xd6>
4201154a:	4b42                	lw	s6,16(sp)
4201154c:	4bb2                	lw	s7,12(sp)
4201154e:	4c22                	lw	s8,8(sp)
42011550:	4c92                	lw	s9,4(sp)
    }

    // Allocate memory.
    dyn->init_order = kbelfx_malloc(sizeof(size_t) * dyn->init_order_len);
42011552:	fd400793          	li	a5,-44
42011556:	1cf47763          	bgeu	s0,a5,42011724 <kbelf_dyn_load+0x32c>
4201155a:	5448                	lw	a0,44(s0)
4201155c:	050a                	sll	a0,a0,0x2
4201155e:	f10f90ef          	jal	4200ac6e <kbelfx_malloc>
42011562:	fd000793          	li	a5,-48
42011566:	89aa                	mv	s3,a0
42011568:	1af47e63          	bgeu	s0,a5,42011724 <kbelf_dyn_load+0x32c>
4201156c:	d808                	sw	a0,48(s0)
    if (!dyn->init_order)
4201156e:	40050263          	beqz	a0,42011972 <kbelf_dyn_load+0x57a>
42011572:	c85a                	sw	s6,16(sp)
        KBELF_ERROR(abort, "Out of memory")

    // Compute initialisation order.
    for (size_t i = 0, li = 0; i < dyn->libs_len; i++) {
42011574:	00c42b03          	lw	s6,12(s0)
42011578:	060b0763          	beqz	s6,420115e6 <kbelf_dyn_load+0x1ee>
4201157c:	4844                	lw	s1,20(s0)
4201157e:	4a81                	li	s5,0
42011580:	4901                	li	s2,0
        if (has_init_funcs(dyn->libs_inst[i])) {
42011582:	00291713          	sll	a4,s2,0x2
42011586:	00e487b3          	add	a5,s1,a4
4201158a:	2c074363          	bltz	a4,42011850 <kbelf_dyn_load+0x458>
4201158e:	2c97e363          	bltu	a5,s1,42011854 <kbelf_dyn_load+0x45c>
42011592:	2c078163          	beqz	a5,42011854 <kbelf_dyn_load+0x45c>
42011596:	0037f713          	and	a4,a5,3
4201159a:	2a071d63          	bnez	a4,42011854 <kbelf_dyn_load+0x45c>
4201159e:	0007aa03          	lw	s4,0(a5)
    return kbelf_inst_preinit_len(inst) || kbelf_inst_init_len(inst) || kbelf_inst_fini_len(inst);
420115a2:	8552                	mv	a0,s4
420115a4:	687010ef          	jal	4201342a <kbelf_inst_preinit_len>
420115a8:	e909                	bnez	a0,420115ba <kbelf_dyn_load+0x1c2>
420115aa:	8552                	mv	a0,s4
420115ac:	6fd010ef          	jal	420134a8 <kbelf_inst_init_len>
420115b0:	e509                	bnez	a0,420115ba <kbelf_dyn_load+0x1c2>
420115b2:	8552                	mv	a0,s4
420115b4:	791010ef          	jal	42013544 <kbelf_inst_fini_len>
420115b8:	c505                	beqz	a0,420115e0 <kbelf_dyn_load+0x1e8>
            dyn->init_order[li] = i;
420115ba:	002a9713          	sll	a4,s5,0x2
420115be:	00e987b3          	add	a5,s3,a4
420115c2:	28074d63          	bltz	a4,4201185c <kbelf_dyn_load+0x464>
420115c6:	2937e763          	bltu	a5,s3,42011854 <kbelf_dyn_load+0x45c>
420115ca:	28078563          	beqz	a5,42011854 <kbelf_dyn_load+0x45c>
420115ce:	0037f713          	and	a4,a5,3
420115d2:	28071163          	bnez	a4,42011854 <kbelf_dyn_load+0x45c>
420115d6:	0127a023          	sw	s2,0(a5)
            li++;
420115da:	00c42b03          	lw	s6,12(s0)
420115de:	0a85                	add	s5,s5,1
    for (size_t i = 0, li = 0; i < dyn->libs_len; i++) {
420115e0:	0905                	add	s2,s2,1
420115e2:	fb6960e3          	bltu	s2,s6,42011582 <kbelf_dyn_load+0x18a>
    if (dyn->init_order_len) {
420115e6:	5448                	lw	a0,44(s0)
420115e8:	30051563          	bnez	a0,420118f2 <kbelf_dyn_load+0x4fa>
    }
    if (!sort_init_order(dyn))
        KBELF_ERROR(abort, "Out of memory");

    // Perform relocation.
    reloc = kbelf_reloc_create();
420115ec:	7f7010ef          	jal	420135e2 <kbelf_reloc_create>
    for (size_t i = 0; i < dyn->builtins_len; i++) {
420115f0:	4c1c                	lw	a5,24(s0)
    reloc = kbelf_reloc_create();
420115f2:	892a                	mv	s2,a0
    for (size_t i = 0; i < dyn->builtins_len; i++) {
420115f4:	4481                	li	s1,0
420115f6:	cb95                	beqz	a5,4201162a <kbelf_dyn_load+0x232>
        if (!kbelf_reloc_add_builtin(reloc, dyn->builtins[i]))
420115f8:	4c58                	lw	a4,28(s0)
420115fa:	00249693          	sll	a3,s1,0x2
420115fe:	00d707b3          	add	a5,a4,a3
42011602:	2606c063          	bltz	a3,42011862 <kbelf_dyn_load+0x46a>
42011606:	24e7e763          	bltu	a5,a4,42011854 <kbelf_dyn_load+0x45c>
4201160a:	24078563          	beqz	a5,42011854 <kbelf_dyn_load+0x45c>
4201160e:	0037f713          	and	a4,a5,3
42011612:	24071163          	bnez	a4,42011854 <kbelf_dyn_load+0x45c>
42011616:	438c                	lw	a1,0(a5)
42011618:	854a                	mv	a0,s2
4201161a:	726020ef          	jal	42013d40 <kbelf_reloc_add_builtin>
4201161e:	32050563          	beqz	a0,42011948 <kbelf_dyn_load+0x550>
    for (size_t i = 0; i < dyn->builtins_len; i++) {
42011622:	4c1c                	lw	a5,24(s0)
42011624:	0485                	add	s1,s1,1
42011626:	fcf4e9e3          	bltu	s1,a5,420115f8 <kbelf_dyn_load+0x200>
            KBELF_ERROR(abort, "Out of memory")
    }
    if (!kbelf_reloc_add(reloc, dyn->exec_file, dyn->exec_inst))
4201162a:	4050                	lw	a2,4(s0)
4201162c:	400c                	lw	a1,0(s0)
4201162e:	854a                	mv	a0,s2
42011630:	632020ef          	jal	42013c62 <kbelf_reloc_add>
42011634:	36050a63          	beqz	a0,420119a8 <kbelf_dyn_load+0x5b0>
        KBELF_ERROR(abort, "Out of memory")
    for (size_t i = 0; i < dyn->libs_len; i++) {
42011638:	445c                	lw	a5,12(s0)
4201163a:	4481                	li	s1,0
4201163c:	cba1                	beqz	a5,4201168c <kbelf_dyn_load+0x294>
        if (!kbelf_reloc_add(reloc, dyn->libs_file[i], dyn->libs_inst[i]))
4201163e:	4814                	lw	a3,16(s0)
42011640:	00249713          	sll	a4,s1,0x2
42011644:	00e687b3          	add	a5,a3,a4
42011648:	28074963          	bltz	a4,420118da <kbelf_dyn_load+0x4e2>
4201164c:	20d7e463          	bltu	a5,a3,42011854 <kbelf_dyn_load+0x45c>
42011650:	20078263          	beqz	a5,42011854 <kbelf_dyn_load+0x45c>
42011654:	0037f693          	and	a3,a5,3
42011658:	1e069e63          	bnez	a3,42011854 <kbelf_dyn_load+0x45c>
4201165c:	4854                	lw	a3,20(s0)
4201165e:	438c                	lw	a1,0(a5)
42011660:	00e687b3          	add	a5,a3,a4
42011664:	26074863          	bltz	a4,420118d4 <kbelf_dyn_load+0x4dc>
42011668:	1ed7e663          	bltu	a5,a3,42011854 <kbelf_dyn_load+0x45c>
4201166c:	1e078463          	beqz	a5,42011854 <kbelf_dyn_load+0x45c>
42011670:	0037f713          	and	a4,a5,3
42011674:	1e071063          	bnez	a4,42011854 <kbelf_dyn_load+0x45c>
42011678:	4390                	lw	a2,0(a5)
4201167a:	854a                	mv	a0,s2
4201167c:	5e6020ef          	jal	42013c62 <kbelf_reloc_add>
42011680:	34050563          	beqz	a0,420119ca <kbelf_dyn_load+0x5d2>
    for (size_t i = 0; i < dyn->libs_len; i++) {
42011684:	445c                	lw	a5,12(s0)
42011686:	0485                	add	s1,s1,1
42011688:	faf4ebe3          	bltu	s1,a5,4201163e <kbelf_dyn_load+0x246>
            KBELF_ERROR(abort, "Out of memory")
    }
    if (!kbelf_reloc_perform(reloc))
4201168c:	854a                	mv	a0,s2
4201168e:	7b7010ef          	jal	42013644 <kbelf_reloc_perform>
42011692:	84aa                	mv	s1,a0
42011694:	36051263          	bnez	a0,420119f8 <kbelf_dyn_load+0x600>
        KBELF_ERROR(abort, "Relocation failed")
42011698:	4201b4b7          	lui	s1,0x4201b
4201169c:	02f00593          	li	a1,47
420116a0:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
420116a4:	d84f90ef          	jal	4200ac28 <kbelfq_strrchr>
420116a8:	38050863          	beqz	a0,42011a38 <kbelf_dyn_load+0x640>
420116ac:	577d                	li	a4,-1
420116ae:	00150613          	add	a2,a0,1
420116b2:	1ae57163          	bgeu	a0,a4,42011854 <kbelf_dyn_load+0x45c>
420116b6:	4201b5b7          	lui	a1,0x4201b
420116ba:	16000693          	li	a3,352
420116be:	37058593          	add	a1,a1,880 # 4201b370 <hextab+0x46a4>
            KBELF_ERROR(abort, "Out of memory")
420116c2:	4505                	li	a0,1
420116c4:	bd7f10ef          	jal	4200329a <logkf>
420116c8:	49f2                	lw	s3,28(sp)
420116ca:	4a62                	lw	s4,24(sp)
420116cc:	4ad2                	lw	s5,20(sp)
420116ce:	4b42                	lw	s6,16(sp)
420116d0:	a815                	j	42011704 <kbelf_dyn_load+0x30c>
        KBELF_ERROR(abort, "No executable file")
420116d2:	4201b4b7          	lui	s1,0x4201b
420116d6:	02f00593          	li	a1,47
420116da:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
420116de:	d4af90ef          	jal	4200ac28 <kbelfq_strrchr>
420116e2:	14050b63          	beqz	a0,42011838 <kbelf_dyn_load+0x440>
420116e6:	57fd                	li	a5,-1
420116e8:	00150613          	add	a2,a0,1
420116ec:	34f57963          	bgeu	a0,a5,42011a3e <kbelf_dyn_load+0x646>
420116f0:	4201b5b7          	lui	a1,0x4201b
420116f4:	12700693          	li	a3,295
420116f8:	2e458593          	add	a1,a1,740 # 4201b2e4 <hextab+0x4618>
420116fc:	4505                	li	a0,1
420116fe:	b9df10ef          	jal	4200329a <logkf>
    kbelf_reloc reloc = NULL;
42011702:	4901                	li	s2,0
    dyn->entrypoint = dyn->exec_inst->entry;
    return true;

// Error.
abort:
    kbelf_reloc_destroy(reloc);
42011704:	854a                	mv	a0,s2
42011706:	6ff010ef          	jal	42013604 <kbelf_reloc_destroy>
    if (!dyn)
4201170a:	8522                	mv	a0,s0
4201170c:	ad8ff0ef          	jal	420109e4 <kbelf_dyn_unload.part.0>
    kbelf_dyn_unload(dyn);
    return false;
42011710:	5422                	lw	s0,40(sp)
42011712:	5902                	lw	s2,32(sp)
        return false;
42011714:	4481                	li	s1,0
}
42011716:	50b2                	lw	ra,44(sp)
42011718:	8526                	mv	a0,s1
4201171a:	5492                	lw	s1,36(sp)
4201171c:	6145                	add	sp,sp,48
4201171e:	8082                	ret
        if (!dyn->libs_inst[i]) {
42011720:	d534f0e3          	bgeu	s1,s3,42011460 <kbelf_dyn_load+0x68>
42011724:	c85a                	sw	s6,16(sp)
42011726:	c65e                	sw	s7,12(sp)
42011728:	c462                	sw	s8,8(sp)
4201172a:	c266                	sw	s9,4(sp)
        KBELF_ERROR(abort, "Out of memory")
4201172c:	9002                	ebreak
        if (!check_deps(dyn, dyn->libs_file[i], dyn->libs_inst[i]))
4201172e:	d6f4f5e3          	bgeu	s1,a5,42011498 <kbelf_dyn_load+0xa0>
42011732:	bfcd                	j	42011724 <kbelf_dyn_load+0x32c>
42011734:	d4f777e3          	bgeu	a4,a5,42011482 <kbelf_dyn_load+0x8a>
42011738:	b7f5                	j	42011724 <kbelf_dyn_load+0x32c>
            dyn->libs_inst[i] = kbelf_inst_load(dyn->libs_file[i], dyn->pid);
4201173a:	4818                	lw	a4,16(s0)
4201173c:	012707b3          	add	a5,a4,s2
42011740:	0a094663          	bltz	s2,420117ec <kbelf_dyn_load+0x3f4>
42011744:	fee7e0e3          	bltu	a5,a4,42011724 <kbelf_dyn_load+0x32c>
42011748:	dff1                	beqz	a5,42011724 <kbelf_dyn_load+0x32c>
4201174a:	0037f713          	and	a4,a5,3
4201174e:	fb79                	bnez	a4,42011724 <kbelf_dyn_load+0x32c>
42011750:	4388                	lw	a0,0(a5)
42011752:	440c                	lw	a1,8(s0)
42011754:	08094963          	bltz	s2,420117e6 <kbelf_dyn_load+0x3ee>
42011758:	fc99e6e3          	bltu	s3,s1,42011724 <kbelf_dyn_load+0x32c>
4201175c:	25a010ef          	jal	420129b6 <kbelf_inst_load>
            if (!dyn->libs_inst[i])
42011760:	4844                	lw	s1,20(s0)
            dyn->libs_inst[i] = kbelf_inst_load(dyn->libs_file[i], dyn->pid);
42011762:	00a9a023          	sw	a0,0(s3)
            if (!dyn->libs_inst[i])
42011766:	012487b3          	add	a5,s1,s2
4201176a:	06094b63          	bltz	s2,420117e0 <kbelf_dyn_load+0x3e8>
4201176e:	fa97ebe3          	bltu	a5,s1,42011724 <kbelf_dyn_load+0x32c>
42011772:	dbcd                	beqz	a5,42011724 <kbelf_dyn_load+0x32c>
42011774:	0037f713          	and	a4,a5,3
42011778:	f755                	bnez	a4,42011724 <kbelf_dyn_load+0x32c>
4201177a:	439c                	lw	a5,0(a5)
4201177c:	ce079ce3          	bnez	a5,42011474 <kbelf_dyn_load+0x7c>
                KBELF_ERROR(abort, "Unable to load " KBELF_FMT_CSTR, dyn->libs_file[i]->path)
42011780:	4201b4b7          	lui	s1,0x4201b
42011784:	02f00593          	li	a1,47
42011788:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
4201178c:	c9cf90ef          	jal	4200ac28 <kbelfq_strrchr>
42011790:	20050963          	beqz	a0,420119a2 <kbelf_dyn_load+0x5aa>
42011794:	57fd                	li	a5,-1
42011796:	00150613          	add	a2,a0,1
4201179a:	f8f575e3          	bgeu	a0,a5,42011724 <kbelf_dyn_load+0x32c>
4201179e:	4818                	lw	a4,16(s0)
420117a0:	012707b3          	add	a5,a4,s2
420117a4:	14094163          	bltz	s2,420118e6 <kbelf_dyn_load+0x4ee>
420117a8:	f6e7eee3          	bltu	a5,a4,42011724 <kbelf_dyn_load+0x32c>
420117ac:	dfa5                	beqz	a5,42011724 <kbelf_dyn_load+0x32c>
420117ae:	0037f713          	and	a4,a5,3
420117b2:	fb2d                	bnez	a4,42011724 <kbelf_dyn_load+0x32c>
420117b4:	439c                	lw	a5,0(a5)
420117b6:	d7bd                	beqz	a5,42011724 <kbelf_dyn_load+0x32c>
420117b8:	0037f713          	and	a4,a5,3
420117bc:	f725                	bnez	a4,42011724 <kbelf_dyn_load+0x32c>
420117be:	5771                	li	a4,-4
420117c0:	f6e7f2e3          	bgeu	a5,a4,42011724 <kbelf_dyn_load+0x32c>
420117c4:	43d8                	lw	a4,4(a5)
420117c6:	4201b5b7          	lui	a1,0x4201b
420117ca:	13700693          	li	a3,311
420117ce:	30c58593          	add	a1,a1,780 # 4201b30c <hextab+0x4640>
420117d2:	4505                	li	a0,1
420117d4:	ac7f10ef          	jal	4200329a <logkf>
420117d8:	49f2                	lw	s3,28(sp)
420117da:	4a62                	lw	s4,24(sp)
420117dc:	4ad2                	lw	s5,20(sp)
420117de:	b715                	j	42011702 <kbelf_dyn_load+0x30a>
            if (!dyn->libs_inst[i])
420117e0:	f8f4f9e3          	bgeu	s1,a5,42011772 <kbelf_dyn_load+0x37a>
420117e4:	b781                	j	42011724 <kbelf_dyn_load+0x32c>
            dyn->libs_inst[i] = kbelf_inst_load(dyn->libs_file[i], dyn->pid);
420117e6:	f734fbe3          	bgeu	s1,s3,4201175c <kbelf_dyn_load+0x364>
420117ea:	bf2d                	j	42011724 <kbelf_dyn_load+0x32c>
420117ec:	f4f77ee3          	bgeu	a4,a5,42011748 <kbelf_dyn_load+0x350>
420117f0:	bf15                	j	42011724 <kbelf_dyn_load+0x32c>
        KBELF_ERROR(abort, "Unable to load " KBELF_FMT_CSTR, dyn->exec_file->path)
420117f2:	4201b4b7          	lui	s1,0x4201b
420117f6:	02f00593          	li	a1,47
420117fa:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
420117fe:	c2af90ef          	jal	4200ac28 <kbelfq_strrchr>
42011802:	c571                	beqz	a0,420118ce <kbelf_dyn_load+0x4d6>
42011804:	57fd                	li	a5,-1
42011806:	00150613          	add	a2,a0,1
4201180a:	22f57a63          	bgeu	a0,a5,42011a3e <kbelf_dyn_load+0x646>
4201180e:	401c                	lw	a5,0(s0)
42011810:	22078763          	beqz	a5,42011a3e <kbelf_dyn_load+0x646>
42011814:	0037f713          	and	a4,a5,3
42011818:	22071363          	bnez	a4,42011a3e <kbelf_dyn_load+0x646>
4201181c:	5771                	li	a4,-4
4201181e:	22e7f063          	bgeu	a5,a4,42011a3e <kbelf_dyn_load+0x646>
42011822:	43d8                	lw	a4,4(a5)
42011824:	4201b5b7          	lui	a1,0x4201b
42011828:	12c00693          	li	a3,300
4201182c:	30c58593          	add	a1,a1,780 # 4201b30c <hextab+0x4640>
42011830:	4505                	li	a0,1
42011832:	a69f10ef          	jal	4200329a <logkf>
42011836:	b5f1                	j	42011702 <kbelf_dyn_load+0x30a>
        KBELF_ERROR(abort, "No executable file")
42011838:	25448613          	add	a2,s1,596
4201183c:	bd55                	j	420116f0 <kbelf_dyn_load+0x2f8>
        dyn->fini_len       += kbelf_inst_fini_len(dyn->libs_inst[i]);
4201183e:	cf24fde3          	bgeu	s1,s2,42011538 <kbelf_dyn_load+0x140>
    dyn->entrypoint = dyn->exec_inst->entry;
42011842:	9002                	ebreak
        dyn->init_len       += kbelf_inst_init_len(dyn->libs_inst[i]);
42011844:	cd24fee3          	bgeu	s1,s2,42011520 <kbelf_dyn_load+0x128>
    dyn->entrypoint = dyn->exec_inst->entry;
42011848:	9002                	ebreak
        dyn->init_order_len += has_init_funcs(dyn->libs_inst[i]);
4201184a:	c924fae3          	bgeu	s1,s2,420114de <kbelf_dyn_load+0xe6>
    dyn->entrypoint = dyn->exec_inst->entry;
4201184e:	9002                	ebreak
        if (has_init_funcs(dyn->libs_inst[i])) {
42011850:	d4f4f1e3          	bgeu	s1,a5,42011592 <kbelf_dyn_load+0x19a>
42011854:	c65e                	sw	s7,12(sp)
42011856:	c462                	sw	s8,8(sp)
42011858:	c266                	sw	s9,4(sp)
    dyn->entrypoint = dyn->exec_inst->entry;
4201185a:	9002                	ebreak
            dyn->init_order[li] = i;
4201185c:	d6f9f7e3          	bgeu	s3,a5,420115ca <kbelf_dyn_load+0x1d2>
42011860:	bfd5                	j	42011854 <kbelf_dyn_load+0x45c>
        if (!kbelf_reloc_add_builtin(reloc, dyn->builtins[i]))
42011862:	daf774e3          	bgeu	a4,a5,4201160a <kbelf_dyn_load+0x212>
42011866:	b7fd                	j	42011854 <kbelf_dyn_load+0x45c>
        KBELF_ERROR(abort, "Unable to satisfy library requirements")
42011868:	4201b4b7          	lui	s1,0x4201b
4201186c:	02f00593          	li	a1,47
42011870:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
42011874:	bb4f90ef          	jal	4200ac28 <kbelfq_strrchr>
42011878:	c525                	beqz	a0,420118e0 <kbelf_dyn_load+0x4e8>
4201187a:	57fd                	li	a5,-1
4201187c:	00150613          	add	a2,a0,1
42011880:	1af57f63          	bgeu	a0,a5,42011a3e <kbelf_dyn_load+0x646>
42011884:	4201b5b7          	lui	a1,0x4201b
42011888:	13000693          	li	a3,304
4201188c:	33458593          	add	a1,a1,820 # 4201b334 <hextab+0x4668>
42011890:	4505                	li	a0,1
42011892:	a09f10ef          	jal	4200329a <logkf>
42011896:	b5b5                	j	42011702 <kbelf_dyn_load+0x30a>
            KBELF_ERROR(abort, "Unable to satisfy library requirements")
42011898:	4201b4b7          	lui	s1,0x4201b
4201189c:	02f00593          	li	a1,47
420118a0:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
420118a4:	b84f90ef          	jal	4200ac28 <kbelfq_strrchr>
420118a8:	c131                	beqz	a0,420118ec <kbelf_dyn_load+0x4f4>
420118aa:	57fd                	li	a5,-1
420118ac:	00150613          	add	a2,a0,1
420118b0:	e6f57ae3          	bgeu	a0,a5,42011724 <kbelf_dyn_load+0x32c>
420118b4:	4201b5b7          	lui	a1,0x4201b
420118b8:	13a00693          	li	a3,314
420118bc:	33458593          	add	a1,a1,820 # 4201b334 <hextab+0x4668>
        KBELF_ERROR(abort, "Out of memory")
420118c0:	4505                	li	a0,1
420118c2:	9d9f10ef          	jal	4200329a <logkf>
420118c6:	49f2                	lw	s3,28(sp)
420118c8:	4a62                	lw	s4,24(sp)
420118ca:	4ad2                	lw	s5,20(sp)
420118cc:	bd1d                	j	42011702 <kbelf_dyn_load+0x30a>
        KBELF_ERROR(abort, "Unable to load " KBELF_FMT_CSTR, dyn->exec_file->path)
420118ce:	25448613          	add	a2,s1,596
420118d2:	bf35                	j	4201180e <kbelf_dyn_load+0x416>
        if (!kbelf_reloc_add(reloc, dyn->libs_file[i], dyn->libs_inst[i]))
420118d4:	d8f6fce3          	bgeu	a3,a5,4201166c <kbelf_dyn_load+0x274>
420118d8:	bfb5                	j	42011854 <kbelf_dyn_load+0x45c>
420118da:	d6f6fbe3          	bgeu	a3,a5,42011650 <kbelf_dyn_load+0x258>
420118de:	bf9d                	j	42011854 <kbelf_dyn_load+0x45c>
        KBELF_ERROR(abort, "Unable to satisfy library requirements")
420118e0:	25448613          	add	a2,s1,596
420118e4:	b745                	j	42011884 <kbelf_dyn_load+0x48c>
                KBELF_ERROR(abort, "Unable to load " KBELF_FMT_CSTR, dyn->libs_file[i]->path)
420118e6:	ecf773e3          	bgeu	a4,a5,420117ac <kbelf_dyn_load+0x3b4>
420118ea:	bd2d                	j	42011724 <kbelf_dyn_load+0x32c>
            KBELF_ERROR(abort, "Unable to satisfy library requirements")
420118ec:	25448613          	add	a2,s1,596
420118f0:	b7d1                	j	420118b4 <kbelf_dyn_load+0x4bc>
        size_t *tmp = kbelfx_malloc(sizeof(size_t) * dyn->init_order_len);
420118f2:	050a                	sll	a0,a0,0x2
420118f4:	b7af90ef          	jal	4200ac6e <kbelfx_malloc>
420118f8:	84aa                	mv	s1,a0
        if (!tmp)
420118fa:	c919                	beqz	a0,42011910 <kbelf_dyn_load+0x518>
        sort_init_order_recursive(dyn, dyn->init_order, dyn->init_order_len, tmp);
420118fc:	5450                	lw	a2,44(s0)
420118fe:	580c                	lw	a1,48(s0)
42011900:	86aa                	mv	a3,a0
42011902:	8522                	mv	a0,s0
42011904:	dbaff0ef          	jal	42010ebe <sort_init_order_recursive>
        kbelfx_free(tmp);
42011908:	8526                	mv	a0,s1
4201190a:	b6cf90ef          	jal	4200ac76 <kbelfx_free>
4201190e:	b9f9                	j	420115ec <kbelf_dyn_load+0x1f4>
        KBELF_ERROR(abort, "Out of memory");
42011910:	4201b4b7          	lui	s1,0x4201b
42011914:	02f00593          	li	a1,47
42011918:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
4201191c:	b0cf90ef          	jal	4200ac28 <kbelfq_strrchr>
42011920:	cd35                	beqz	a0,4201199c <kbelf_dyn_load+0x5a4>
42011922:	57fd                	li	a5,-1
42011924:	00150613          	add	a2,a0,1
42011928:	f2f576e3          	bgeu	a0,a5,42011854 <kbelf_dyn_load+0x45c>
4201192c:	4201b5b7          	lui	a1,0x4201b
42011930:	15100693          	li	a3,337
42011934:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42011938:	4505                	li	a0,1
4201193a:	961f10ef          	jal	4200329a <logkf>
4201193e:	49f2                	lw	s3,28(sp)
42011940:	4a62                	lw	s4,24(sp)
42011942:	4ad2                	lw	s5,20(sp)
42011944:	4b42                	lw	s6,16(sp)
42011946:	bb75                	j	42011702 <kbelf_dyn_load+0x30a>
            KBELF_ERROR(abort, "Out of memory")
42011948:	4201b4b7          	lui	s1,0x4201b
4201194c:	02f00593          	li	a1,47
42011950:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
42011954:	ad4f90ef          	jal	4200ac28 <kbelfq_strrchr>
42011958:	c951                	beqz	a0,420119ec <kbelf_dyn_load+0x5f4>
4201195a:	57fd                	li	a5,-1
4201195c:	00150613          	add	a2,a0,1
42011960:	eef57ae3          	bgeu	a0,a5,42011854 <kbelf_dyn_load+0x45c>
42011964:	15700693          	li	a3,343
            KBELF_ERROR(abort, "Out of memory")
42011968:	4201b5b7          	lui	a1,0x4201b
4201196c:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42011970:	bb89                	j	420116c2 <kbelf_dyn_load+0x2ca>
        KBELF_ERROR(abort, "Out of memory")
42011972:	4201b4b7          	lui	s1,0x4201b
42011976:	02f00593          	li	a1,47
4201197a:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
4201197e:	aaaf90ef          	jal	4200ac28 <kbelfq_strrchr>
42011982:	c925                	beqz	a0,420119f2 <kbelf_dyn_load+0x5fa>
42011984:	57fd                	li	a5,-1
42011986:	00150613          	add	a2,a0,1
4201198a:	d8f57de3          	bgeu	a0,a5,42011724 <kbelf_dyn_load+0x32c>
4201198e:	4201b5b7          	lui	a1,0x4201b
42011992:	14700693          	li	a3,327
42011996:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
4201199a:	b71d                	j	420118c0 <kbelf_dyn_load+0x4c8>
        KBELF_ERROR(abort, "Out of memory");
4201199c:	25448613          	add	a2,s1,596
420119a0:	b771                	j	4201192c <kbelf_dyn_load+0x534>
                KBELF_ERROR(abort, "Unable to load " KBELF_FMT_CSTR, dyn->libs_file[i]->path)
420119a2:	25448613          	add	a2,s1,596
420119a6:	bbe5                	j	4201179e <kbelf_dyn_load+0x3a6>
        KBELF_ERROR(abort, "Out of memory")
420119a8:	4201b4b7          	lui	s1,0x4201b
420119ac:	02f00593          	li	a1,47
420119b0:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
420119b4:	a74f90ef          	jal	4200ac28 <kbelfq_strrchr>
420119b8:	c535                	beqz	a0,42011a24 <kbelf_dyn_load+0x62c>
420119ba:	57fd                	li	a5,-1
420119bc:	00150613          	add	a2,a0,1
420119c0:	e8f57ae3          	bgeu	a0,a5,42011854 <kbelf_dyn_load+0x45c>
420119c4:	15a00693          	li	a3,346
420119c8:	b745                	j	42011968 <kbelf_dyn_load+0x570>
            KBELF_ERROR(abort, "Out of memory")
420119ca:	4201b4b7          	lui	s1,0x4201b
420119ce:	02f00593          	li	a1,47
420119d2:	25448513          	add	a0,s1,596 # 4201b254 <hextab+0x4588>
420119d6:	a52f90ef          	jal	4200ac28 <kbelfq_strrchr>
420119da:	c931                	beqz	a0,42011a2e <kbelf_dyn_load+0x636>
420119dc:	57fd                	li	a5,-1
420119de:	00150613          	add	a2,a0,1
420119e2:	e6f579e3          	bgeu	a0,a5,42011854 <kbelf_dyn_load+0x45c>
420119e6:	15d00693          	li	a3,349
420119ea:	bfbd                	j	42011968 <kbelf_dyn_load+0x570>
            KBELF_ERROR(abort, "Out of memory")
420119ec:	25448613          	add	a2,s1,596
420119f0:	bf95                	j	42011964 <kbelf_dyn_load+0x56c>
        KBELF_ERROR(abort, "Out of memory")
420119f2:	25448613          	add	a2,s1,596
420119f6:	bf61                	j	4201198e <kbelf_dyn_load+0x596>
    kbelf_reloc_destroy(reloc);
420119f8:	854a                	mv	a0,s2
420119fa:	40b010ef          	jal	42013604 <kbelf_reloc_destroy>
    dyn->entrypoint = dyn->exec_inst->entry;
420119fe:	405c                	lw	a5,4(s0)
42011a00:	e4078ae3          	beqz	a5,42011854 <kbelf_dyn_load+0x45c>
42011a04:	0037f713          	and	a4,a5,3
42011a08:	e40716e3          	bnez	a4,42011854 <kbelf_dyn_load+0x45c>
42011a0c:	5731                	li	a4,-20
42011a0e:	e4e7f3e3          	bgeu	a5,a4,42011854 <kbelf_dyn_load+0x45c>
42011a12:	4bdc                	lw	a5,20(a5)
    return true;
42011a14:	5902                	lw	s2,32(sp)
42011a16:	49f2                	lw	s3,28(sp)
    dyn->entrypoint = dyn->exec_inst->entry;
42011a18:	d01c                	sw	a5,32(s0)
    return true;
42011a1a:	4a62                	lw	s4,24(sp)
42011a1c:	5422                	lw	s0,40(sp)
42011a1e:	4ad2                	lw	s5,20(sp)
42011a20:	4b42                	lw	s6,16(sp)
42011a22:	b9d5                	j	42011716 <kbelf_dyn_load+0x31e>
        KBELF_ERROR(abort, "Out of memory")
42011a24:	25448613          	add	a2,s1,596
42011a28:	15a00693          	li	a3,346
42011a2c:	bf35                	j	42011968 <kbelf_dyn_load+0x570>
            KBELF_ERROR(abort, "Out of memory")
42011a2e:	25448613          	add	a2,s1,596
42011a32:	15d00693          	li	a3,349
42011a36:	bf0d                	j	42011968 <kbelf_dyn_load+0x570>
        KBELF_ERROR(abort, "Relocation failed")
42011a38:	25448613          	add	a2,s1,596
42011a3c:	b9ad                	j	420116b6 <kbelf_dyn_load+0x2be>
42011a3e:	ce4e                	sw	s3,28(sp)
42011a40:	cc52                	sw	s4,24(sp)
42011a42:	ca56                	sw	s5,20(sp)
42011a44:	b1c5                	j	42011724 <kbelf_dyn_load+0x32c>

42011a46 <kbelf_dyn_preinit_len>:



// Get the number of pre-initialisation functions for the process.
size_t kbelf_dyn_preinit_len(kbelf_dyn dyn) {
    return dyn && dyn->exec_inst ? kbelf_inst_preinit_len(dyn->exec_inst) : 0;
42011a46:	c919                	beqz	a0,42011a5c <kbelf_dyn_preinit_len+0x16>
42011a48:	00357793          	and	a5,a0,3
42011a4c:	eb91                	bnez	a5,42011a60 <kbelf_dyn_preinit_len+0x1a>
42011a4e:	57f1                	li	a5,-4
42011a50:	00f57863          	bgeu	a0,a5,42011a60 <kbelf_dyn_preinit_len+0x1a>
42011a54:	4148                	lw	a0,4(a0)
42011a56:	c119                	beqz	a0,42011a5c <kbelf_dyn_preinit_len+0x16>
42011a58:	1d30106f          	j	4201342a <kbelf_inst_preinit_len>
}
42011a5c:	4501                	li	a0,0
42011a5e:	8082                	ret
    return dyn && dyn->exec_inst ? kbelf_inst_preinit_len(dyn->exec_inst) : 0;
42011a60:	9002                	ebreak

42011a62 <kbelf_dyn_preinit_get>:

// Get the virtual address of an initialisation function by index.
// Functions are sorted; the first index is the first in the running order.
kbelf_addr kbelf_dyn_preinit_get(kbelf_dyn dyn, size_t i) {
    return dyn && dyn->exec_inst ? kbelf_inst_preinit_get(dyn->exec_inst, i) : 0;
42011a62:	c919                	beqz	a0,42011a78 <kbelf_dyn_preinit_get+0x16>
42011a64:	00357793          	and	a5,a0,3
42011a68:	eb91                	bnez	a5,42011a7c <kbelf_dyn_preinit_get+0x1a>
42011a6a:	57f1                	li	a5,-4
42011a6c:	00f57863          	bgeu	a0,a5,42011a7c <kbelf_dyn_preinit_get+0x1a>
42011a70:	4148                	lw	a0,4(a0)
42011a72:	c119                	beqz	a0,42011a78 <kbelf_dyn_preinit_get+0x16>
42011a74:	1cf0106f          	j	42013442 <kbelf_inst_preinit_get>
}
42011a78:	4501                	li	a0,0
42011a7a:	8082                	ret
    return dyn && dyn->exec_inst ? kbelf_inst_preinit_get(dyn->exec_inst, i) : 0;
42011a7c:	9002                	ebreak

42011a7e <kbelf_dyn_init_len>:

// Get the number of initialisation functions for the process.
size_t kbelf_dyn_init_len(kbelf_dyn dyn) {
    return dyn ? dyn->init_len : 0;
42011a7e:	c911                	beqz	a0,42011a92 <kbelf_dyn_init_len+0x14>
42011a80:	00357793          	and	a5,a0,3
42011a84:	eb89                	bnez	a5,42011a96 <kbelf_dyn_init_len+0x18>
42011a86:	fdc00793          	li	a5,-36
42011a8a:	00f57663          	bgeu	a0,a5,42011a96 <kbelf_dyn_init_len+0x18>
42011a8e:	5148                	lw	a0,36(a0)
42011a90:	8082                	ret
42011a92:	4501                	li	a0,0
}
42011a94:	8082                	ret
    return dyn ? dyn->init_len : 0;
42011a96:	9002                	ebreak

42011a98 <kbelf_dyn_init_get>:

// Get the virtual address of an initialisation function by index.
// Functions are sorted; the first index is the first in the running order.
kbelf_addr kbelf_dyn_init_get(kbelf_dyn dyn, size_t i) {
    if (!dyn || i >= dyn->init_len)
42011a98:	12050a63          	beqz	a0,42011bcc <kbelf_dyn_init_get+0x134>
kbelf_addr kbelf_dyn_init_get(kbelf_dyn dyn, size_t i) {
42011a9c:	7139                	add	sp,sp,-64
42011a9e:	d452                	sw	s4,40(sp)
42011aa0:	de06                	sw	ra,60(sp)
42011aa2:	d64e                	sw	s3,44(sp)
    if (!dyn || i >= dyn->init_len)
42011aa4:	00357793          	and	a5,a0,3
42011aa8:	8a2a                	mv	s4,a0
42011aaa:	14079463          	bnez	a5,42011bf2 <kbelf_dyn_init_get+0x15a>
42011aae:	fdc00793          	li	a5,-36
42011ab2:	12f57563          	bgeu	a0,a5,42011bdc <kbelf_dyn_init_get+0x144>
42011ab6:	515c                	lw	a5,36(a0)
42011ab8:	89ae                	mv	s3,a1
42011aba:	0af5f463          	bgeu	a1,a5,42011b62 <kbelf_dyn_init_get+0xca>
42011abe:	dc22                	sw	s0,56(sp)
        return 0;

    // Executable first.
    size_t len = kbelf_inst_init_len(dyn->exec_inst);
42011ac0:	4140                	lw	s0,4(a0)
42011ac2:	8522                	mv	a0,s0
42011ac4:	1e5010ef          	jal	420134a8 <kbelf_inst_init_len>
    if (i < len) {
42011ac8:	0aa9e963          	bltu	s3,a0,42011b7a <kbelf_dyn_init_get+0xe2>
42011acc:	ce5e                	sw	s7,28(sp)
        return kbelf_inst_init_get(dyn->exec_inst, i);
    }
    i -= len;

    // Libraries second.
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011ace:	fd400793          	li	a5,-44
    i -= len;
42011ad2:	40a989b3          	sub	s3,s3,a0
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011ad6:	12fa7963          	bgeu	s4,a5,42011c08 <kbelf_dyn_init_get+0x170>
42011ada:	02ca2b83          	lw	s7,44(s4)
42011ade:	0e0b8963          	beqz	s7,42011bd0 <kbelf_dyn_init_get+0x138>
42011ae2:	c66e                	sw	s11,12(sp)
42011ae4:	014a2d83          	lw	s11,20(s4)
42011ae8:	d256                	sw	s5,36(sp)
42011aea:	cc62                	sw	s8,24(sp)
42011aec:	da26                	sw	s1,52(sp)
42011aee:	d84a                	sw	s2,48(sp)
42011af0:	d05a                	sw	s6,32(sp)
42011af2:	ca66                	sw	s9,20(sp)
42011af4:	c86a                	sw	s10,16(sp)
42011af6:	4a81                	li	s5,0
        len = kbelf_inst_init_len(dyn->libs_inst[dyn->init_order[x]]);
42011af8:	fd000c13          	li	s8,-48
42011afc:	0d8a7f63          	bgeu	s4,s8,42011bda <kbelf_dyn_init_get+0x142>
42011b00:	030a2b03          	lw	s6,48(s4)
42011b04:	002a9d13          	sll	s10,s5,0x2
42011b08:	01ab04b3          	add	s1,s6,s10
42011b0c:	060d4463          	bltz	s10,42011b74 <kbelf_dyn_init_get+0xdc>
42011b10:	0764e463          	bltu	s1,s6,42011b78 <kbelf_dyn_init_get+0xe0>
42011b14:	c0f1                	beqz	s1,42011bd8 <kbelf_dyn_init_get+0x140>
42011b16:	0034f793          	and	a5,s1,3
42011b1a:	efdd                	bnez	a5,42011bd8 <kbelf_dyn_init_get+0x140>
42011b1c:	0004a903          	lw	s2,0(s1)
42011b20:	090a                	sll	s2,s2,0x2
42011b22:	012d8433          	add	s0,s11,s2
42011b26:	04094463          	bltz	s2,42011b6e <kbelf_dyn_init_get+0xd6>
42011b2a:	05b46463          	bltu	s0,s11,42011b72 <kbelf_dyn_init_get+0xda>
42011b2e:	c445                	beqz	s0,42011bd6 <kbelf_dyn_init_get+0x13e>
42011b30:	00347793          	and	a5,s0,3
42011b34:	e3cd                	bnez	a5,42011bd6 <kbelf_dyn_init_get+0x13e>
42011b36:	00042c83          	lw	s9,0(s0)
42011b3a:	8566                	mv	a0,s9
42011b3c:	16d010ef          	jal	420134a8 <kbelf_inst_init_len>
        if (i < len)
42011b40:	04a9e663          	bltu	s3,a0,42011b8c <kbelf_dyn_init_get+0xf4>
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011b44:	0a85                	add	s5,s5,1
            return kbelf_inst_init_get(dyn->libs_inst[dyn->init_order[x]], i);
        i -= len;
42011b46:	40a989b3          	sub	s3,s3,a0
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011b4a:	fb5b99e3          	bne	s7,s5,42011afc <kbelf_dyn_init_get+0x64>
42011b4e:	5462                	lw	s0,56(sp)
42011b50:	54d2                	lw	s1,52(sp)
42011b52:	5942                	lw	s2,48(sp)
42011b54:	5a92                	lw	s5,36(sp)
42011b56:	5b02                	lw	s6,32(sp)
42011b58:	4bf2                	lw	s7,28(sp)
42011b5a:	4c62                	lw	s8,24(sp)
42011b5c:	4cd2                	lw	s9,20(sp)
42011b5e:	4d42                	lw	s10,16(sp)
42011b60:	4db2                	lw	s11,12(sp)
    }

    return 0;
}
42011b62:	50f2                	lw	ra,60(sp)
42011b64:	59b2                	lw	s3,44(sp)
42011b66:	5a22                	lw	s4,40(sp)
42011b68:	4501                	li	a0,0
42011b6a:	6121                	add	sp,sp,64
42011b6c:	8082                	ret
        len = kbelf_inst_init_len(dyn->libs_inst[dyn->init_order[x]]);
42011b6e:	fc8df0e3          	bgeu	s11,s0,42011b2e <kbelf_dyn_init_get+0x96>
42011b72:	9002                	ebreak
42011b74:	fa9b70e3          	bgeu	s6,s1,42011b14 <kbelf_dyn_init_get+0x7c>
42011b78:	9002                	ebreak
        return kbelf_inst_init_get(dyn->exec_inst, i);
42011b7a:	8522                	mv	a0,s0
42011b7c:	5462                	lw	s0,56(sp)
}
42011b7e:	50f2                	lw	ra,60(sp)
42011b80:	5a22                	lw	s4,40(sp)
        return kbelf_inst_init_get(dyn->exec_inst, i);
42011b82:	85ce                	mv	a1,s3
}
42011b84:	59b2                	lw	s3,44(sp)
42011b86:	6121                	add	sp,sp,64
            return kbelf_inst_init_get(dyn->libs_inst[dyn->init_order[x]], i);
42011b88:	1430106f          	j	420134ca <kbelf_inst_init_get>
42011b8c:	020d4a63          	bltz	s10,42011bc0 <kbelf_dyn_init_get+0x128>
42011b90:	0364ea63          	bltu	s1,s6,42011bc4 <kbelf_dyn_init_get+0x12c>
42011b94:	02094963          	bltz	s2,42011bc6 <kbelf_dyn_init_get+0x12e>
42011b98:	03b46963          	bltu	s0,s11,42011bca <kbelf_dyn_init_get+0x132>
42011b9c:	5462                	lw	s0,56(sp)
42011b9e:	54d2                	lw	s1,52(sp)
42011ba0:	5942                	lw	s2,48(sp)
42011ba2:	5a92                	lw	s5,36(sp)
42011ba4:	5b02                	lw	s6,32(sp)
42011ba6:	4bf2                	lw	s7,28(sp)
42011ba8:	4c62                	lw	s8,24(sp)
42011baa:	4d42                	lw	s10,16(sp)
42011bac:	4db2                	lw	s11,12(sp)
}
42011bae:	50f2                	lw	ra,60(sp)
42011bb0:	5a22                	lw	s4,40(sp)
            return kbelf_inst_init_get(dyn->libs_inst[dyn->init_order[x]], i);
42011bb2:	85ce                	mv	a1,s3
42011bb4:	8566                	mv	a0,s9
}
42011bb6:	59b2                	lw	s3,44(sp)
            return kbelf_inst_init_get(dyn->libs_inst[dyn->init_order[x]], i);
42011bb8:	4cd2                	lw	s9,20(sp)
}
42011bba:	6121                	add	sp,sp,64
            return kbelf_inst_init_get(dyn->libs_inst[dyn->init_order[x]], i);
42011bbc:	10f0106f          	j	420134ca <kbelf_inst_init_get>
42011bc0:	fc9b7ae3          	bgeu	s6,s1,42011b94 <kbelf_dyn_init_get+0xfc>
42011bc4:	9002                	ebreak
42011bc6:	fc8dfbe3          	bgeu	s11,s0,42011b9c <kbelf_dyn_init_get+0x104>
42011bca:	9002                	ebreak
}
42011bcc:	4501                	li	a0,0
42011bce:	8082                	ret
42011bd0:	5462                	lw	s0,56(sp)
42011bd2:	4bf2                	lw	s7,28(sp)
42011bd4:	b779                	j	42011b62 <kbelf_dyn_init_get+0xca>
        len = kbelf_inst_init_len(dyn->libs_inst[dyn->init_order[x]]);
42011bd6:	9002                	ebreak
42011bd8:	9002                	ebreak
42011bda:	9002                	ebreak
42011bdc:	dc22                	sw	s0,56(sp)
42011bde:	da26                	sw	s1,52(sp)
42011be0:	d84a                	sw	s2,48(sp)
42011be2:	d256                	sw	s5,36(sp)
42011be4:	d05a                	sw	s6,32(sp)
42011be6:	ce5e                	sw	s7,28(sp)
42011be8:	cc62                	sw	s8,24(sp)
42011bea:	ca66                	sw	s9,20(sp)
42011bec:	c86a                	sw	s10,16(sp)
42011bee:	c66e                	sw	s11,12(sp)
    if (!dyn || i >= dyn->init_len)
42011bf0:	9002                	ebreak
42011bf2:	dc22                	sw	s0,56(sp)
42011bf4:	da26                	sw	s1,52(sp)
42011bf6:	d84a                	sw	s2,48(sp)
42011bf8:	d256                	sw	s5,36(sp)
42011bfa:	d05a                	sw	s6,32(sp)
42011bfc:	ce5e                	sw	s7,28(sp)
42011bfe:	cc62                	sw	s8,24(sp)
42011c00:	ca66                	sw	s9,20(sp)
42011c02:	c86a                	sw	s10,16(sp)
42011c04:	c66e                	sw	s11,12(sp)
42011c06:	9002                	ebreak
42011c08:	da26                	sw	s1,52(sp)
42011c0a:	d84a                	sw	s2,48(sp)
42011c0c:	d256                	sw	s5,36(sp)
42011c0e:	d05a                	sw	s6,32(sp)
42011c10:	cc62                	sw	s8,24(sp)
42011c12:	ca66                	sw	s9,20(sp)
42011c14:	c86a                	sw	s10,16(sp)
42011c16:	c66e                	sw	s11,12(sp)
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011c18:	9002                	ebreak

42011c1a <kbelf_dyn_fini_len>:

// Get the number of finalisation functions for the process.
size_t kbelf_dyn_fini_len(kbelf_dyn dyn) {
    return dyn ? dyn->fini_len : 0;
42011c1a:	c911                	beqz	a0,42011c2e <kbelf_dyn_fini_len+0x14>
42011c1c:	00357793          	and	a5,a0,3
42011c20:	eb89                	bnez	a5,42011c32 <kbelf_dyn_fini_len+0x18>
42011c22:	fd800793          	li	a5,-40
42011c26:	00f57663          	bgeu	a0,a5,42011c32 <kbelf_dyn_fini_len+0x18>
42011c2a:	5508                	lw	a0,40(a0)
42011c2c:	8082                	ret
42011c2e:	4501                	li	a0,0
}
42011c30:	8082                	ret
    return dyn ? dyn->fini_len : 0;
42011c32:	9002                	ebreak

42011c34 <kbelf_dyn_fini_get>:

// Get the virtual address of an finalisation function by index.
// Functions are sorted; the first index is the first in the running order.
kbelf_addr kbelf_dyn_fini_get(kbelf_dyn dyn, size_t i) {
    if (!dyn || i >= dyn->fini_len)
42011c34:	12050d63          	beqz	a0,42011d6e <kbelf_dyn_fini_get+0x13a>
kbelf_addr kbelf_dyn_fini_get(kbelf_dyn dyn, size_t i) {
42011c38:	7139                	add	sp,sp,-64
42011c3a:	d452                	sw	s4,40(sp)
42011c3c:	de06                	sw	ra,60(sp)
42011c3e:	d64e                	sw	s3,44(sp)
    if (!dyn || i >= dyn->fini_len)
42011c40:	00357793          	and	a5,a0,3
42011c44:	8a2a                	mv	s4,a0
42011c46:	14079763          	bnez	a5,42011d94 <kbelf_dyn_fini_get+0x160>
42011c4a:	fd800793          	li	a5,-40
42011c4e:	12f57863          	bgeu	a0,a5,42011d7e <kbelf_dyn_fini_get+0x14a>
42011c52:	02852983          	lw	s3,40(a0)
42011c56:	0b35f763          	bgeu	a1,s3,42011d04 <kbelf_dyn_fini_get+0xd0>
42011c5a:	dc22                	sw	s0,56(sp)

    // Finaliser order is to opposite of initialiser order.
    i = dyn->fini_len - i - 1;

    // Executable first.
    size_t len = kbelf_inst_fini_len(dyn->exec_inst);
42011c5c:	4140                	lw	s0,4(a0)
42011c5e:	40b989b3          	sub	s3,s3,a1
    i = dyn->fini_len - i - 1;
42011c62:	19fd                	add	s3,s3,-1
    size_t len = kbelf_inst_fini_len(dyn->exec_inst);
42011c64:	8522                	mv	a0,s0
42011c66:	0df010ef          	jal	42013544 <kbelf_inst_fini_len>
    if (i < len) {
42011c6a:	0aa9e963          	bltu	s3,a0,42011d1c <kbelf_dyn_fini_get+0xe8>
42011c6e:	ce5e                	sw	s7,28(sp)
        return kbelf_inst_fini_get(dyn->exec_inst, i);
    }
    i -= len;

    // Libraries second.
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011c70:	fd400793          	li	a5,-44
    i -= len;
42011c74:	40a989b3          	sub	s3,s3,a0
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011c78:	12fa7963          	bgeu	s4,a5,42011daa <kbelf_dyn_fini_get+0x176>
42011c7c:	02ca2b83          	lw	s7,44(s4)
42011c80:	0e0b8963          	beqz	s7,42011d72 <kbelf_dyn_fini_get+0x13e>
42011c84:	c66e                	sw	s11,12(sp)
42011c86:	014a2d83          	lw	s11,20(s4)
42011c8a:	d256                	sw	s5,36(sp)
42011c8c:	cc62                	sw	s8,24(sp)
42011c8e:	da26                	sw	s1,52(sp)
42011c90:	d84a                	sw	s2,48(sp)
42011c92:	d05a                	sw	s6,32(sp)
42011c94:	ca66                	sw	s9,20(sp)
42011c96:	c86a                	sw	s10,16(sp)
42011c98:	4a81                	li	s5,0
        len = kbelf_inst_fini_len(dyn->libs_inst[dyn->init_order[x]]);
42011c9a:	fd000c13          	li	s8,-48
42011c9e:	0d8a7f63          	bgeu	s4,s8,42011d7c <kbelf_dyn_fini_get+0x148>
42011ca2:	030a2b03          	lw	s6,48(s4)
42011ca6:	002a9d13          	sll	s10,s5,0x2
42011caa:	01ab04b3          	add	s1,s6,s10
42011cae:	060d4463          	bltz	s10,42011d16 <kbelf_dyn_fini_get+0xe2>
42011cb2:	0764e463          	bltu	s1,s6,42011d1a <kbelf_dyn_fini_get+0xe6>
42011cb6:	c0f1                	beqz	s1,42011d7a <kbelf_dyn_fini_get+0x146>
42011cb8:	0034f793          	and	a5,s1,3
42011cbc:	efdd                	bnez	a5,42011d7a <kbelf_dyn_fini_get+0x146>
42011cbe:	0004a903          	lw	s2,0(s1)
42011cc2:	090a                	sll	s2,s2,0x2
42011cc4:	012d8433          	add	s0,s11,s2
42011cc8:	04094463          	bltz	s2,42011d10 <kbelf_dyn_fini_get+0xdc>
42011ccc:	05b46463          	bltu	s0,s11,42011d14 <kbelf_dyn_fini_get+0xe0>
42011cd0:	c445                	beqz	s0,42011d78 <kbelf_dyn_fini_get+0x144>
42011cd2:	00347793          	and	a5,s0,3
42011cd6:	e3cd                	bnez	a5,42011d78 <kbelf_dyn_fini_get+0x144>
42011cd8:	00042c83          	lw	s9,0(s0)
42011cdc:	8566                	mv	a0,s9
42011cde:	067010ef          	jal	42013544 <kbelf_inst_fini_len>
        if (i < len)
42011ce2:	04a9e663          	bltu	s3,a0,42011d2e <kbelf_dyn_fini_get+0xfa>
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011ce6:	0a85                	add	s5,s5,1
            return kbelf_inst_fini_get(dyn->libs_inst[dyn->init_order[x]], i);
        i -= len;
42011ce8:	40a989b3          	sub	s3,s3,a0
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011cec:	fb5b99e3          	bne	s7,s5,42011c9e <kbelf_dyn_fini_get+0x6a>
42011cf0:	5462                	lw	s0,56(sp)
42011cf2:	54d2                	lw	s1,52(sp)
42011cf4:	5942                	lw	s2,48(sp)
42011cf6:	5a92                	lw	s5,36(sp)
42011cf8:	5b02                	lw	s6,32(sp)
42011cfa:	4bf2                	lw	s7,28(sp)
42011cfc:	4c62                	lw	s8,24(sp)
42011cfe:	4cd2                	lw	s9,20(sp)
42011d00:	4d42                	lw	s10,16(sp)
42011d02:	4db2                	lw	s11,12(sp)
    }

    return 0;
}
42011d04:	50f2                	lw	ra,60(sp)
42011d06:	59b2                	lw	s3,44(sp)
42011d08:	5a22                	lw	s4,40(sp)
42011d0a:	4501                	li	a0,0
42011d0c:	6121                	add	sp,sp,64
42011d0e:	8082                	ret
        len = kbelf_inst_fini_len(dyn->libs_inst[dyn->init_order[x]]);
42011d10:	fc8df0e3          	bgeu	s11,s0,42011cd0 <kbelf_dyn_fini_get+0x9c>
42011d14:	9002                	ebreak
42011d16:	fa9b70e3          	bgeu	s6,s1,42011cb6 <kbelf_dyn_fini_get+0x82>
42011d1a:	9002                	ebreak
        return kbelf_inst_fini_get(dyn->exec_inst, i);
42011d1c:	8522                	mv	a0,s0
42011d1e:	5462                	lw	s0,56(sp)
}
42011d20:	50f2                	lw	ra,60(sp)
42011d22:	5a22                	lw	s4,40(sp)
        return kbelf_inst_fini_get(dyn->exec_inst, i);
42011d24:	85ce                	mv	a1,s3
}
42011d26:	59b2                	lw	s3,44(sp)
42011d28:	6121                	add	sp,sp,64
            return kbelf_inst_fini_get(dyn->libs_inst[dyn->init_order[x]], i);
42011d2a:	03d0106f          	j	42013566 <kbelf_inst_fini_get>
42011d2e:	020d4a63          	bltz	s10,42011d62 <kbelf_dyn_fini_get+0x12e>
42011d32:	0364ea63          	bltu	s1,s6,42011d66 <kbelf_dyn_fini_get+0x132>
42011d36:	02094963          	bltz	s2,42011d68 <kbelf_dyn_fini_get+0x134>
42011d3a:	03b46963          	bltu	s0,s11,42011d6c <kbelf_dyn_fini_get+0x138>
42011d3e:	5462                	lw	s0,56(sp)
42011d40:	54d2                	lw	s1,52(sp)
42011d42:	5942                	lw	s2,48(sp)
42011d44:	5a92                	lw	s5,36(sp)
42011d46:	5b02                	lw	s6,32(sp)
42011d48:	4bf2                	lw	s7,28(sp)
42011d4a:	4c62                	lw	s8,24(sp)
42011d4c:	4d42                	lw	s10,16(sp)
42011d4e:	4db2                	lw	s11,12(sp)
}
42011d50:	50f2                	lw	ra,60(sp)
42011d52:	5a22                	lw	s4,40(sp)
            return kbelf_inst_fini_get(dyn->libs_inst[dyn->init_order[x]], i);
42011d54:	85ce                	mv	a1,s3
42011d56:	8566                	mv	a0,s9
}
42011d58:	59b2                	lw	s3,44(sp)
            return kbelf_inst_fini_get(dyn->libs_inst[dyn->init_order[x]], i);
42011d5a:	4cd2                	lw	s9,20(sp)
}
42011d5c:	6121                	add	sp,sp,64
            return kbelf_inst_fini_get(dyn->libs_inst[dyn->init_order[x]], i);
42011d5e:	0090106f          	j	42013566 <kbelf_inst_fini_get>
42011d62:	fc9b7ae3          	bgeu	s6,s1,42011d36 <kbelf_dyn_fini_get+0x102>
42011d66:	9002                	ebreak
42011d68:	fc8dfbe3          	bgeu	s11,s0,42011d3e <kbelf_dyn_fini_get+0x10a>
42011d6c:	9002                	ebreak
}
42011d6e:	4501                	li	a0,0
42011d70:	8082                	ret
42011d72:	5462                	lw	s0,56(sp)
42011d74:	4bf2                	lw	s7,28(sp)
42011d76:	b779                	j	42011d04 <kbelf_dyn_fini_get+0xd0>
        len = kbelf_inst_fini_len(dyn->libs_inst[dyn->init_order[x]]);
42011d78:	9002                	ebreak
42011d7a:	9002                	ebreak
42011d7c:	9002                	ebreak
42011d7e:	dc22                	sw	s0,56(sp)
42011d80:	da26                	sw	s1,52(sp)
42011d82:	d84a                	sw	s2,48(sp)
42011d84:	d256                	sw	s5,36(sp)
42011d86:	d05a                	sw	s6,32(sp)
42011d88:	ce5e                	sw	s7,28(sp)
42011d8a:	cc62                	sw	s8,24(sp)
42011d8c:	ca66                	sw	s9,20(sp)
42011d8e:	c86a                	sw	s10,16(sp)
42011d90:	c66e                	sw	s11,12(sp)
    if (!dyn || i >= dyn->fini_len)
42011d92:	9002                	ebreak
42011d94:	dc22                	sw	s0,56(sp)
42011d96:	da26                	sw	s1,52(sp)
42011d98:	d84a                	sw	s2,48(sp)
42011d9a:	d256                	sw	s5,36(sp)
42011d9c:	d05a                	sw	s6,32(sp)
42011d9e:	ce5e                	sw	s7,28(sp)
42011da0:	cc62                	sw	s8,24(sp)
42011da2:	ca66                	sw	s9,20(sp)
42011da4:	c86a                	sw	s10,16(sp)
42011da6:	c66e                	sw	s11,12(sp)
42011da8:	9002                	ebreak
42011daa:	da26                	sw	s1,52(sp)
42011dac:	d84a                	sw	s2,48(sp)
42011dae:	d256                	sw	s5,36(sp)
42011db0:	d05a                	sw	s6,32(sp)
42011db2:	cc62                	sw	s8,24(sp)
42011db4:	ca66                	sw	s9,20(sp)
42011db6:	c86a                	sw	s10,16(sp)
42011db8:	c66e                	sw	s11,12(sp)
    for (size_t x = 0; x < dyn->init_order_len; x++) {
42011dba:	9002                	ebreak

42011dbc <kbelf_dyn_entrypoint>:

// Get the entrypoint address of the process.
kbelf_addr kbelf_dyn_entrypoint(kbelf_dyn dyn) {
    return dyn ? dyn->entrypoint : 0;
42011dbc:	c909                	beqz	a0,42011dce <kbelf_dyn_entrypoint+0x12>
42011dbe:	00357793          	and	a5,a0,3
42011dc2:	eb81                	bnez	a5,42011dd2 <kbelf_dyn_entrypoint+0x16>
42011dc4:	5781                	li	a5,-32
42011dc6:	00f57663          	bgeu	a0,a5,42011dd2 <kbelf_dyn_entrypoint+0x16>
42011dca:	5108                	lw	a0,32(a0)
42011dcc:	8082                	ret
42011dce:	4501                	li	a0,0
}
42011dd0:	8082                	ret
    return dyn ? dyn->entrypoint : 0;
42011dd2:	9002                	ebreak

42011dd4 <kbelf_file_close>:
}

// Clean up a `kbelf_file` context.
// Calls `kbelfx_close` on the `fd` originally provided to `kbelf_file_open`.
void kbelf_file_close(kbelf_file file) {
    if (!file)
42011dd4:	cd15                	beqz	a0,42011e10 <kbelf_file_close+0x3c>
void kbelf_file_close(kbelf_file file) {
42011dd6:	1141                	add	sp,sp,-16
42011dd8:	c422                	sw	s0,8(sp)
42011dda:	c606                	sw	ra,12(sp)
        return;
    if (file->strtab)
42011ddc:	00357793          	and	a5,a0,3
42011de0:	842a                	mv	s0,a0
42011de2:	eb85                	bnez	a5,42011e12 <kbelf_file_close+0x3e>
42011de4:	fbc00793          	li	a5,-68
42011de8:	02f57663          	bgeu	a0,a5,42011e14 <kbelf_file_close+0x40>
42011dec:	4168                	lw	a0,68(a0)
42011dee:	c119                	beqz	a0,42011df4 <kbelf_file_close+0x20>
        kbelfx_free(file->strtab);
42011df0:	e87f80ef          	jal	4200ac76 <kbelfx_free>
    if (file->path)
42011df4:	4048                	lw	a0,4(s0)
42011df6:	c119                	beqz	a0,42011dfc <kbelf_file_close+0x28>
        kbelfx_free(file->path);
42011df8:	e7ff80ef          	jal	4200ac76 <kbelfx_free>
    if (file->fd)
42011dfc:	4008                	lw	a0,0(s0)
42011dfe:	c119                	beqz	a0,42011e04 <kbelf_file_close+0x30>
        kbelfx_close(file->fd);
42011e00:	922f90ef          	jal	4200af22 <kbelfx_close>
    kbelfx_free(file);
42011e04:	8522                	mv	a0,s0
}
42011e06:	4422                	lw	s0,8(sp)
42011e08:	40b2                	lw	ra,12(sp)
42011e0a:	0141                	add	sp,sp,16
    kbelfx_free(file);
42011e0c:	e6bf806f          	j	4200ac76 <kbelfx_free>
42011e10:	8082                	ret
    if (file->strtab)
42011e12:	9002                	ebreak
42011e14:	9002                	ebreak

42011e16 <kbelf_file_open>:
kbelf_file kbelf_file_open(char const *path, void *fd) {
42011e16:	1141                	add	sp,sp,-16
42011e18:	c04a                	sw	s2,0(sp)
42011e1a:	892a                	mv	s2,a0
    kbelf_file file = kbelfx_malloc(sizeof(struct struct_kbelf_file));
42011e1c:	05000513          	li	a0,80
kbelf_file kbelf_file_open(char const *path, void *fd) {
42011e20:	c422                	sw	s0,8(sp)
42011e22:	c226                	sw	s1,4(sp)
42011e24:	c606                	sw	ra,12(sp)
42011e26:	84ae                	mv	s1,a1
    kbelf_file file = kbelfx_malloc(sizeof(struct struct_kbelf_file));
42011e28:	e47f80ef          	jal	4200ac6e <kbelfx_malloc>
42011e2c:	842a                	mv	s0,a0
    if (!file)
42011e2e:	1e050f63          	beqz	a0,4201202c <kbelf_file_open+0x216>
    kbelfq_memset(file, 0, sizeof(struct struct_kbelf_file));
42011e32:	05000613          	li	a2,80
42011e36:	4581                	li	a1,0
42011e38:	e2ff80ef          	jal	4200ac66 <kbelfq_memset>
    if (!fd) {
42011e3c:	12048763          	beqz	s1,42011f6a <kbelf_file_open+0x154>
    file->fd = fd;
42011e40:	30040d63          	beqz	s0,4201215a <kbelf_file_open+0x344>
42011e44:	00347793          	and	a5,s0,3
42011e48:	30079963          	bnez	a5,4201215a <kbelf_file_open+0x344>
42011e4c:	c004                	sw	s1,0(s0)
    size_t path_len = kbelfq_strlen(path);
42011e4e:	854a                	mv	a0,s2
42011e50:	dcdf80ef          	jal	4200ac1c <kbelfq_strlen>
    file->path      = kbelfx_malloc(path_len + 1);
42011e54:	0505                	add	a0,a0,1
42011e56:	e19f80ef          	jal	4200ac6e <kbelfx_malloc>
42011e5a:	5771                	li	a4,-4
42011e5c:	2ee47f63          	bgeu	s0,a4,4201215a <kbelf_file_open+0x344>
42011e60:	c048                	sw	a0,4(s0)
    if (!file->path)
42011e62:	1e050e63          	beqz	a0,4201205e <kbelf_file_open+0x248>
    kbelfq_strcpy(file->path, path);
42011e66:	85ca                	mv	a1,s2
42011e68:	db9f80ef          	jal	4200ac20 <kbelfq_strcpy>
    char const *c0 = kbelfq_strrchr(file->path, '/');
42011e6c:	4044                	lw	s1,4(s0)
42011e6e:	02f00593          	li	a1,47
42011e72:	8526                	mv	a0,s1
42011e74:	db5f80ef          	jal	4200ac28 <kbelfq_strrchr>
    file->name = c0 ? c0 + 1 : file->path;
42011e78:	c511                	beqz	a0,42011e84 <kbelf_file_open+0x6e>
42011e7a:	57fd                	li	a5,-1
42011e7c:	00150493          	add	s1,a0,1
42011e80:	2cf57d63          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
42011e84:	57e1                	li	a5,-8
42011e86:	2cf47a63          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011e8a:	c404                	sw	s1,8(s0)
    int len = kbelfx_read(file->fd, &file->header, sizeof(file->header));
42011e8c:	57d1                	li	a5,-12
42011e8e:	4008                	lw	a0,0(s0)
42011e90:	2cf47563          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011e94:	00c40913          	add	s2,s0,12
42011e98:	03400613          	li	a2,52
42011e9c:	85ca                	mv	a1,s2
42011e9e:	8c0f90ef          	jal	4200af5e <kbelfx_read>
    if (len != sizeof(file->header))
42011ea2:	03400793          	li	a5,52
    int len = kbelfx_read(file->fd, &file->header, sizeof(file->header));
42011ea6:	84aa                	mv	s1,a0
    if (len != sizeof(file->header))
42011ea8:	10f51163          	bne	a0,a5,42011faa <kbelf_file_open+0x194>
    if (!kbelfq_memeq(file->header.magic, kbelf_magic, 4))
42011eac:	4201c5b7          	lui	a1,0x4201c
42011eb0:	4611                	li	a2,4
42011eb2:	9d058593          	add	a1,a1,-1584 # 4201b9d0 <kbelf_magic>
42011eb6:	854a                	mv	a0,s2
42011eb8:	db3f80ef          	jal	4200ac6a <kbelfq_memeq>
42011ebc:	20050263          	beqz	a0,420120c0 <kbelf_file_open+0x2aa>
    if (file->header.word_size != KBELF_CLASS)
42011ec0:	57c1                	li	a5,-16
42011ec2:	28f47c63          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011ec6:	01044783          	lbu	a5,16(s0)
42011eca:	4705                	li	a4,1
42011ecc:	1ce79263          	bne	a5,a4,42012090 <kbelf_file_open+0x27a>
    if (file->header.endianness != KBELF_ENDIANNESS)
42011ed0:	573d                	li	a4,-17
42011ed2:	28e47463          	bgeu	s0,a4,4201215a <kbelf_file_open+0x344>
42011ed6:	01144703          	lbu	a4,17(s0)
42011eda:	20f71c63          	bne	a4,a5,420120f2 <kbelf_file_open+0x2dc>
    if (file->header.version != 1)
42011ede:	57b9                	li	a5,-18
42011ee0:	26f47d63          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011ee4:	01244783          	lbu	a5,18(s0)
42011ee8:	10e79963          	bne	a5,a4,42011ffa <kbelf_file_open+0x1e4>
    if (file->header.type != ET_DYN && file->header.type != ET_EXEC)
42011eec:	5791                	li	a5,-28
42011eee:	26f47663          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011ef2:	01c45783          	lhu	a5,28(s0)
42011ef6:	4705                	li	a4,1
42011ef8:	17f9                	add	a5,a5,-2
42011efa:	07c2                	sll	a5,a5,0x10
42011efc:	83c1                	srl	a5,a5,0x10
42011efe:	26f76863          	bltu	a4,a5,4201216e <kbelf_file_open+0x358>
    if (file->header.machine != kbelf_machine_type)
42011f02:	5789                	li	a5,-30
42011f04:	24f47b63          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011f08:	4201c7b7          	lui	a5,0x4201c
42011f0c:	01e45683          	lhu	a3,30(s0)
42011f10:	9d47d783          	lhu	a5,-1580(a5) # 4201b9d4 <kbelf_machine_type>
42011f14:	28f69663          	bne	a3,a5,420121a0 <kbelf_file_open+0x38a>
    if (file->header.version2 != 1)
42011f18:	5781                	li	a5,-32
42011f1a:	24f47063          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011f1e:	501c                	lw	a5,32(s0)
42011f20:	2ae79e63          	bne	a5,a4,420121dc <kbelf_file_open+0x3c6>
    if (file->header.size != sizeof(file->header))
42011f24:	fcc00793          	li	a5,-52
42011f28:	22f47963          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011f2c:	03445703          	lhu	a4,52(s0)
42011f30:	03400793          	li	a5,52
42011f34:	1ef71a63          	bne	a4,a5,42012128 <kbelf_file_open+0x312>
    if (file->header.ph_ent_size != sizeof(kbelf_progheader))
42011f38:	fca00793          	li	a5,-54
42011f3c:	20f47f63          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011f40:	03645703          	lhu	a4,54(s0)
42011f44:	02000793          	li	a5,32
42011f48:	2ef71a63          	bne	a4,a5,4201223c <kbelf_file_open+0x426>
    if (file->header.sh_ent_size != sizeof(kbelf_sectheader))
42011f4c:	fc600793          	li	a5,-58
42011f50:	20f47563          	bgeu	s0,a5,4201215a <kbelf_file_open+0x344>
42011f54:	03a45703          	lhu	a4,58(s0)
42011f58:	02800793          	li	a5,40
42011f5c:	2af71863          	bne	a4,a5,4201220c <kbelf_file_open+0x3f6>
    if (!kbelfp_file_verify(file))
42011f60:	8522                	mv	a0,s0
42011f62:	65b010ef          	jal	42013dbc <kbelfp_file_verify>
42011f66:	e141                	bnez	a0,42011fe6 <kbelf_file_open+0x1d0>
42011f68:	a89d                	j	42011fde <kbelf_file_open+0x1c8>
        fd = kbelfx_open(path);
42011f6a:	854a                	mv	a0,s2
42011f6c:	f89f80ef          	jal	4200aef4 <kbelfx_open>
42011f70:	84aa                	mv	s1,a0
        if (!fd)
42011f72:	ec0517e3          	bnez	a0,42011e40 <kbelf_file_open+0x2a>
            KBELF_ERROR(abort, "File not found: " KBELF_FMT_CSTR, path)
42011f76:	4201b4b7          	lui	s1,0x4201b
42011f7a:	02f00593          	li	a1,47
42011f7e:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
42011f82:	ca7f80ef          	jal	4200ac28 <kbelfq_strrchr>
42011f86:	2e050c63          	beqz	a0,4201227e <kbelf_file_open+0x468>
42011f8a:	57fd                	li	a5,-1
42011f8c:	00150613          	add	a2,a0,1
42011f90:	1cf57563          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
42011f94:	4201b5b7          	lui	a1,0x4201b
42011f98:	874a                	mv	a4,s2
42011f9a:	02d00693          	li	a3,45
42011f9e:	3e058593          	add	a1,a1,992 # 4201b3e0 <hextab+0x4714>
42011fa2:	4505                	li	a0,1
42011fa4:	af6f10ef          	jal	4200329a <logkf>
42011fa8:	a81d                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(
42011faa:	4201b937          	lui	s2,0x4201b
42011fae:	02f00593          	li	a1,47
42011fb2:	39890513          	add	a0,s2,920 # 4201b398 <hextab+0x46cc>
42011fb6:	c73f80ef          	jal	4200ac28 <kbelfq_strrchr>
42011fba:	cd0d                	beqz	a0,42011ff4 <kbelf_file_open+0x1de>
42011fbc:	57fd                	li	a5,-1
42011fbe:	00150613          	add	a2,a0,1
42011fc2:	18f57c63          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
42011fc6:	4201b5b7          	lui	a1,0x4201b
42011fca:	87a6                	mv	a5,s1
42011fcc:	03400713          	li	a4,52
42011fd0:	04600693          	li	a3,70
42011fd4:	40c58593          	add	a1,a1,1036 # 4201b40c <hextab+0x4740>
42011fd8:	4505                	li	a0,1
42011fda:	ac0f10ef          	jal	4200329a <logkf>
    kbelf_file_close(file);
42011fde:	8522                	mv	a0,s0
42011fe0:	df5ff0ef          	jal	42011dd4 <kbelf_file_close>
    return NULL;
42011fe4:	4401                	li	s0,0
}
42011fe6:	40b2                	lw	ra,12(sp)
42011fe8:	8522                	mv	a0,s0
42011fea:	4422                	lw	s0,8(sp)
42011fec:	4492                	lw	s1,4(sp)
42011fee:	4902                	lw	s2,0(sp)
42011ff0:	0141                	add	sp,sp,16
42011ff2:	8082                	ret
        KBELF_ERROR(
42011ff4:	39890613          	add	a2,s2,920
42011ff8:	b7f9                	j	42011fc6 <kbelf_file_open+0x1b0>
        KBELF_ERROR(abort, "Invalid or unsupported version")
42011ffa:	4201b4b7          	lui	s1,0x4201b
42011ffe:	02f00593          	li	a1,47
42012002:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
42012006:	c23f80ef          	jal	4200ac28 <kbelfq_strrchr>
4201200a:	10050c63          	beqz	a0,42012122 <kbelf_file_open+0x30c>
4201200e:	57fd                	li	a5,-1
42012010:	00150613          	add	a2,a0,1
42012014:	14f57363          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
42012018:	4201b5b7          	lui	a1,0x4201b
4201201c:	05600693          	li	a3,86
42012020:	4e058593          	add	a1,a1,1248 # 4201b4e0 <hextab+0x4814>
42012024:	4505                	li	a0,1
42012026:	a74f10ef          	jal	4200329a <logkf>
4201202a:	bf55                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Out of memory")
4201202c:	4201b4b7          	lui	s1,0x4201b
42012030:	02f00593          	li	a1,47
42012034:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
42012038:	bf1f80ef          	jal	4200ac28 <kbelfq_strrchr>
4201203c:	12050063          	beqz	a0,4201215c <kbelf_file_open+0x346>
42012040:	57fd                	li	a5,-1
42012042:	00150613          	add	a2,a0,1
42012046:	10f57a63          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
4201204a:	4201b5b7          	lui	a1,0x4201b
4201204e:	02600693          	li	a3,38
42012052:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42012056:	4505                	li	a0,1
42012058:	a42f10ef          	jal	4200329a <logkf>
4201205c:	b749                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Out of memory")
4201205e:	4201b4b7          	lui	s1,0x4201b
42012062:	02f00593          	li	a1,47
42012066:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
4201206a:	bbff80ef          	jal	4200ac28 <kbelfq_strrchr>
4201206e:	0e050a63          	beqz	a0,42012162 <kbelf_file_open+0x34c>
42012072:	57fd                	li	a5,-1
42012074:	00150613          	add	a2,a0,1
42012078:	0ef57163          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
4201207c:	4201b5b7          	lui	a1,0x4201b
42012080:	03600693          	li	a3,54
42012084:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42012088:	4505                	li	a0,1
4201208a:	a10f10ef          	jal	4200329a <logkf>
4201208e:	bf81                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Invalid or unsupported class")
42012090:	4201b4b7          	lui	s1,0x4201b
42012094:	02f00593          	li	a1,47
42012098:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
4201209c:	b8df80ef          	jal	4200ac28 <kbelfq_strrchr>
420120a0:	c561                	beqz	a0,42012168 <kbelf_file_open+0x352>
420120a2:	57fd                	li	a5,-1
420120a4:	00150613          	add	a2,a0,1
420120a8:	0af57963          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
420120ac:	4201b5b7          	lui	a1,0x4201b
420120b0:	05200693          	li	a3,82
420120b4:	47858593          	add	a1,a1,1144 # 4201b478 <hextab+0x47ac>
420120b8:	4505                	li	a0,1
420120ba:	9e0f10ef          	jal	4200329a <logkf>
420120be:	b705                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Invalid magic")
420120c0:	4201b4b7          	lui	s1,0x4201b
420120c4:	02f00593          	li	a1,47
420120c8:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
420120cc:	b5df80ef          	jal	4200ac28 <kbelfq_strrchr>
420120d0:	10050063          	beqz	a0,420121d0 <kbelf_file_open+0x3ba>
420120d4:	57fd                	li	a5,-1
420120d6:	00150613          	add	a2,a0,1
420120da:	08f57063          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
420120de:	4201b5b7          	lui	a1,0x4201b
420120e2:	05000693          	li	a3,80
420120e6:	45458593          	add	a1,a1,1108 # 4201b454 <hextab+0x4788>
420120ea:	4505                	li	a0,1
420120ec:	9aef10ef          	jal	4200329a <logkf>
420120f0:	b5fd                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Invalid or unsupported endianness")
420120f2:	4201b4b7          	lui	s1,0x4201b
420120f6:	02f00593          	li	a1,47
420120fa:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
420120fe:	b2bf80ef          	jal	4200ac28 <kbelfq_strrchr>
42012102:	c971                	beqz	a0,420121d6 <kbelf_file_open+0x3c0>
42012104:	57fd                	li	a5,-1
42012106:	00150613          	add	a2,a0,1
4201210a:	04f57863          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
4201210e:	4201b5b7          	lui	a1,0x4201b
42012112:	05400693          	li	a3,84
42012116:	4a858593          	add	a1,a1,1192 # 4201b4a8 <hextab+0x47dc>
4201211a:	4505                	li	a0,1
4201211c:	97ef10ef          	jal	4200329a <logkf>
42012120:	bd7d                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Invalid or unsupported version")
42012122:	39848613          	add	a2,s1,920
42012126:	bdcd                	j	42012018 <kbelf_file_open+0x202>
        KBELF_ERROR(abort, "Invalid header size")
42012128:	4201b4b7          	lui	s1,0x4201b
4201212c:	02f00593          	li	a1,47
42012130:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
42012134:	af5f80ef          	jal	4200ac28 <kbelfq_strrchr>
42012138:	14050663          	beqz	a0,42012284 <kbelf_file_open+0x46e>
4201213c:	57fd                	li	a5,-1
4201213e:	00150613          	add	a2,a0,1
42012142:	00f57c63          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
42012146:	4201b5b7          	lui	a1,0x4201b
4201214a:	06000693          	li	a3,96
4201214e:	59458593          	add	a1,a1,1428 # 4201b594 <hextab+0x48c8>
42012152:	4505                	li	a0,1
42012154:	946f10ef          	jal	4200329a <logkf>
42012158:	b559                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Invalid section header entry size")
4201215a:	9002                	ebreak
        KBELF_ERROR(abort, "Out of memory")
4201215c:	39848613          	add	a2,s1,920
42012160:	b5ed                	j	4201204a <kbelf_file_open+0x234>
        KBELF_ERROR(abort, "Out of memory")
42012162:	39848613          	add	a2,s1,920
42012166:	bf19                	j	4201207c <kbelf_file_open+0x266>
        KBELF_ERROR(abort, "Invalid or unsupported class")
42012168:	39848613          	add	a2,s1,920
4201216c:	b781                	j	420120ac <kbelf_file_open+0x296>
        KBELF_ERROR(abort, "Unsupported type")
4201216e:	4201b4b7          	lui	s1,0x4201b
42012172:	02f00593          	li	a1,47
42012176:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
4201217a:	aaff80ef          	jal	4200ac28 <kbelfq_strrchr>
4201217e:	0e050763          	beqz	a0,4201226c <kbelf_file_open+0x456>
42012182:	57fd                	li	a5,-1
42012184:	00150613          	add	a2,a0,1
42012188:	fcf579e3          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
4201218c:	4201b5b7          	lui	a1,0x4201b
42012190:	05900693          	li	a3,89
42012194:	51458593          	add	a1,a1,1300 # 4201b514 <hextab+0x4848>
42012198:	4505                	li	a0,1
4201219a:	900f10ef          	jal	4200329a <logkf>
4201219e:	b581                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Unsupported machine")
420121a0:	4201b4b7          	lui	s1,0x4201b
420121a4:	02f00593          	li	a1,47
420121a8:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
420121ac:	a7df80ef          	jal	4200ac28 <kbelfq_strrchr>
420121b0:	c169                	beqz	a0,42012272 <kbelf_file_open+0x45c>
420121b2:	57fd                	li	a5,-1
420121b4:	00150613          	add	a2,a0,1
420121b8:	faf571e3          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
420121bc:	4201b5b7          	lui	a1,0x4201b
420121c0:	05b00693          	li	a3,91
420121c4:	53858593          	add	a1,a1,1336 # 4201b538 <hextab+0x486c>
420121c8:	4505                	li	a0,1
420121ca:	8d0f10ef          	jal	4200329a <logkf>
420121ce:	bd01                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Invalid magic")
420121d0:	39848613          	add	a2,s1,920
420121d4:	b729                	j	420120de <kbelf_file_open+0x2c8>
        KBELF_ERROR(abort, "Invalid or unsupported endianness")
420121d6:	39848613          	add	a2,s1,920
420121da:	bf15                	j	4201210e <kbelf_file_open+0x2f8>
        KBELF_ERROR(abort, "Invalid or unsupported version2")
420121dc:	4201b4b7          	lui	s1,0x4201b
420121e0:	02f00593          	li	a1,47
420121e4:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
420121e8:	a41f80ef          	jal	4200ac28 <kbelfq_strrchr>
420121ec:	c551                	beqz	a0,42012278 <kbelf_file_open+0x462>
420121ee:	57fd                	li	a5,-1
420121f0:	00150613          	add	a2,a0,1
420121f4:	f6f573e3          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
420121f8:	4201b5b7          	lui	a1,0x4201b
420121fc:	05d00693          	li	a3,93
42012200:	56058593          	add	a1,a1,1376 # 4201b560 <hextab+0x4894>
42012204:	4505                	li	a0,1
42012206:	894f10ef          	jal	4200329a <logkf>
4201220a:	bbd1                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Invalid section header entry size")
4201220c:	4201b4b7          	lui	s1,0x4201b
42012210:	02f00593          	li	a1,47
42012214:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
42012218:	a11f80ef          	jal	4200ac28 <kbelfq_strrchr>
4201221c:	c53d                	beqz	a0,4201228a <kbelf_file_open+0x474>
4201221e:	57fd                	li	a5,-1
42012220:	00150613          	add	a2,a0,1
42012224:	f2f57be3          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
42012228:	4201b5b7          	lui	a1,0x4201b
4201222c:	06400693          	li	a3,100
42012230:	5f458593          	add	a1,a1,1524 # 4201b5f4 <hextab+0x4928>
42012234:	4505                	li	a0,1
42012236:	864f10ef          	jal	4200329a <logkf>
4201223a:	b355                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Invalid program header entry size")
4201223c:	4201b4b7          	lui	s1,0x4201b
42012240:	02f00593          	li	a1,47
42012244:	39848513          	add	a0,s1,920 # 4201b398 <hextab+0x46cc>
42012248:	9e1f80ef          	jal	4200ac28 <kbelfq_strrchr>
4201224c:	c131                	beqz	a0,42012290 <kbelf_file_open+0x47a>
4201224e:	57fd                	li	a5,-1
42012250:	00150613          	add	a2,a0,1
42012254:	f0f573e3          	bgeu	a0,a5,4201215a <kbelf_file_open+0x344>
42012258:	4201b5b7          	lui	a1,0x4201b
4201225c:	06200693          	li	a3,98
42012260:	5bc58593          	add	a1,a1,1468 # 4201b5bc <hextab+0x48f0>
42012264:	4505                	li	a0,1
42012266:	834f10ef          	jal	4200329a <logkf>
4201226a:	bb95                	j	42011fde <kbelf_file_open+0x1c8>
        KBELF_ERROR(abort, "Unsupported type")
4201226c:	39848613          	add	a2,s1,920
42012270:	bf31                	j	4201218c <kbelf_file_open+0x376>
        KBELF_ERROR(abort, "Unsupported machine")
42012272:	39848613          	add	a2,s1,920
42012276:	b799                	j	420121bc <kbelf_file_open+0x3a6>
        KBELF_ERROR(abort, "Invalid or unsupported version2")
42012278:	39848613          	add	a2,s1,920
4201227c:	bfb5                	j	420121f8 <kbelf_file_open+0x3e2>
            KBELF_ERROR(abort, "File not found: " KBELF_FMT_CSTR, path)
4201227e:	39848613          	add	a2,s1,920
42012282:	bb09                	j	42011f94 <kbelf_file_open+0x17e>
        KBELF_ERROR(abort, "Invalid header size")
42012284:	39848613          	add	a2,s1,920
42012288:	bd7d                	j	42012146 <kbelf_file_open+0x330>
        KBELF_ERROR(abort, "Invalid section header entry size")
4201228a:	39848613          	add	a2,s1,920
4201228e:	bf69                	j	42012228 <kbelf_file_open+0x412>
        KBELF_ERROR(abort, "Invalid program header entry size")
42012290:	39848613          	add	a2,s1,920
42012294:	b7d1                	j	42012258 <kbelf_file_open+0x442>

42012296 <kbelf_file_prog_len>:


// Returns the number of program headers in an ELF file.
// Returns 0 when there are no program headers.
size_t kbelf_file_prog_len(kbelf_file file) {
    return file ? file->header.ph_ent_num : 0;
42012296:	c919                	beqz	a0,420122ac <kbelf_file_prog_len+0x16>
42012298:	00357793          	and	a5,a0,3
4201229c:	eb91                	bnez	a5,420122b0 <kbelf_file_prog_len+0x1a>
4201229e:	fc800793          	li	a5,-56
420122a2:	00f57763          	bgeu	a0,a5,420122b0 <kbelf_file_prog_len+0x1a>
420122a6:	03855503          	lhu	a0,56(a0)
420122aa:	8082                	ret
420122ac:	4501                	li	a0,0
}
420122ae:	8082                	ret
    return file ? file->header.ph_ent_num : 0;
420122b0:	9002                	ebreak

420122b2 <kbelf_file_prog_get>:

// Returns a copy of a program header in an ELF file using a pointer.
// Returns success status.
bool kbelf_file_prog_get(kbelf_file file, kbelf_progheader *prog, size_t index) {
    if (!file)
420122b2:	c53d                	beqz	a0,42012320 <kbelf_file_prog_get+0x6e>
bool kbelf_file_prog_get(kbelf_file file, kbelf_progheader *prog, size_t index) {
420122b4:	1141                	add	sp,sp,-16
420122b6:	c422                	sw	s0,8(sp)
420122b8:	c606                	sw	ra,12(sp)
        return false;
    if (index > file->header.ph_ent_num)
420122ba:	00357793          	and	a5,a0,3
420122be:	842a                	mv	s0,a0
420122c0:	e7a5                	bnez	a5,42012328 <kbelf_file_prog_get+0x76>
420122c2:	fc800793          	li	a5,-56
420122c6:	04f57f63          	bgeu	a0,a5,42012324 <kbelf_file_prog_get+0x72>
420122ca:	03855783          	lhu	a5,56(a0)
420122ce:	00c7f763          	bgeu	a5,a2,420122dc <kbelf_file_prog_get+0x2a>
        return false;
    res = kbelfx_read(file->fd, prog, sizeof(kbelf_progheader));
    if (res < (int)sizeof(kbelf_progheader))
        return false;
    return true;
}
420122d2:	40b2                	lw	ra,12(sp)
420122d4:	4422                	lw	s0,8(sp)
        return false;
420122d6:	4501                	li	a0,0
}
420122d8:	0141                	add	sp,sp,16
420122da:	8082                	ret
    int res = kbelfx_seek(file->fd, (long)file->header.ph_offset + (long)sizeof(kbelf_progheader) * (long)index);
420122dc:	551c                	lw	a5,40(a0)
420122de:	0616                	sll	a2,a2,0x5
420122e0:	c226                	sw	s1,4(sp)
420122e2:	84ae                	mv	s1,a1
420122e4:	00c785b3          	add	a1,a5,a2
420122e8:	00062713          	slti	a4,a2,0
420122ec:	00f5a7b3          	slt	a5,a1,a5
420122f0:	4108                	lw	a0,0(a0)
420122f2:	02f71d63          	bne	a4,a5,4201232c <kbelf_file_prog_get+0x7a>
420122f6:	c7ff80ef          	jal	4200af74 <kbelfx_seek>
    if (res < 0)
420122fa:	02054163          	bltz	a0,4201231c <kbelf_file_prog_get+0x6a>
    res = kbelfx_read(file->fd, prog, sizeof(kbelf_progheader));
420122fe:	4008                	lw	a0,0(s0)
42012300:	85a6                	mv	a1,s1
42012302:	02000613          	li	a2,32
42012306:	c59f80ef          	jal	4200af5e <kbelfx_read>
}
4201230a:	40b2                	lw	ra,12(sp)
4201230c:	4422                	lw	s0,8(sp)
    if (res < (int)sizeof(kbelf_progheader))
4201230e:	02052513          	slti	a0,a0,32
42012312:	4492                	lw	s1,4(sp)
42012314:	00154513          	xor	a0,a0,1
}
42012318:	0141                	add	sp,sp,16
4201231a:	8082                	ret
4201231c:	4492                	lw	s1,4(sp)
4201231e:	bf55                	j	420122d2 <kbelf_file_prog_get+0x20>
        return false;
42012320:	4501                	li	a0,0
}
42012322:	8082                	ret
42012324:	c226                	sw	s1,4(sp)
    if (index > file->header.ph_ent_num)
42012326:	9002                	ebreak
42012328:	c226                	sw	s1,4(sp)
4201232a:	9002                	ebreak
    int res = kbelfx_seek(file->fd, (long)file->header.ph_offset + (long)sizeof(kbelf_progheader) * (long)index);
4201232c:	9002                	ebreak

4201232e <kbelf_inst_unload>:
    return NULL;
}

// Unloads an instance created with `kbelf_load` and clean up the handle.
void kbelf_inst_unload(kbelf_inst inst) {
    if (!inst)
4201232e:	c539                	beqz	a0,4201237c <kbelf_inst_unload+0x4e>
void kbelf_inst_unload(kbelf_inst inst) {
42012330:	1141                	add	sp,sp,-16
42012332:	c422                	sw	s0,8(sp)
42012334:	c606                	sw	ra,12(sp)
        return;
    if (inst->path)
42012336:	00357793          	and	a5,a0,3
4201233a:	842a                	mv	s0,a0
4201233c:	e3a9                	bnez	a5,4201237e <kbelf_inst_unload+0x50>
4201233e:	4108                	lw	a0,0(a0)
42012340:	c119                	beqz	a0,42012346 <kbelf_inst_unload+0x18>
        kbelfx_free(inst->path);
42012342:	935f80ef          	jal	4200ac76 <kbelfx_free>
    if (inst->segments_len) {
42012346:	57d1                	li	a5,-12
42012348:	02f47c63          	bgeu	s0,a5,42012380 <kbelf_inst_unload+0x52>
4201234c:	444c                	lw	a1,12(s0)
4201234e:	e599                	bnez	a1,4201235c <kbelf_inst_unload+0x2e>
        kbelfx_seg_free(inst, inst->segments_len, inst->segments);
        kbelfx_free(inst->segments);
    }
    kbelfx_free(inst);
42012350:	8522                	mv	a0,s0
}
42012352:	4422                	lw	s0,8(sp)
42012354:	40b2                	lw	ra,12(sp)
42012356:	0141                	add	sp,sp,16
    kbelfx_free(inst);
42012358:	91ff806f          	j	4200ac76 <kbelfx_free>
        kbelfx_seg_free(inst, inst->segments_len, inst->segments);
4201235c:	57c1                	li	a5,-16
4201235e:	02f47263          	bgeu	s0,a5,42012382 <kbelf_inst_unload+0x54>
42012362:	4810                	lw	a2,16(s0)
42012364:	8522                	mv	a0,s0
42012366:	b57f80ef          	jal	4200aebc <kbelfx_seg_free>
        kbelfx_free(inst->segments);
4201236a:	4808                	lw	a0,16(s0)
4201236c:	90bf80ef          	jal	4200ac76 <kbelfx_free>
    kbelfx_free(inst);
42012370:	8522                	mv	a0,s0
}
42012372:	4422                	lw	s0,8(sp)
42012374:	40b2                	lw	ra,12(sp)
42012376:	0141                	add	sp,sp,16
    kbelfx_free(inst);
42012378:	8fff806f          	j	4200ac76 <kbelfx_free>
4201237c:	8082                	ret
    if (inst->path)
4201237e:	9002                	ebreak
    if (inst->segments_len) {
42012380:	9002                	ebreak
        kbelfx_seg_free(inst, inst->segments_len, inst->segments);
42012382:	9002                	ebreak

42012384 <kbelf_inst_destroy>:

// Clean up the instance handle but not the loaded segments.
void kbelf_inst_destroy(kbelf_inst inst) {
    if (!inst)
42012384:	c139                	beqz	a0,420123ca <kbelf_inst_destroy+0x46>
void kbelf_inst_destroy(kbelf_inst inst) {
42012386:	1141                	add	sp,sp,-16
42012388:	c422                	sw	s0,8(sp)
4201238a:	c606                	sw	ra,12(sp)
        return;
    if (inst->path)
4201238c:	00357793          	and	a5,a0,3
42012390:	842a                	mv	s0,a0
42012392:	ef8d                	bnez	a5,420123cc <kbelf_inst_destroy+0x48>
42012394:	4108                	lw	a0,0(a0)
42012396:	c119                	beqz	a0,4201239c <kbelf_inst_destroy+0x18>
        kbelfx_free(inst->path);
42012398:	8dff80ef          	jal	4200ac76 <kbelfx_free>
    if (inst->segments_len) {
4201239c:	57d1                	li	a5,-12
4201239e:	02f47863          	bgeu	s0,a5,420123ce <kbelf_inst_destroy+0x4a>
420123a2:	445c                	lw	a5,12(s0)
420123a4:	e799                	bnez	a5,420123b2 <kbelf_inst_destroy+0x2e>
        kbelfx_free(inst->segments);
    }
    kbelfx_free(inst);
420123a6:	8522                	mv	a0,s0
}
420123a8:	4422                	lw	s0,8(sp)
420123aa:	40b2                	lw	ra,12(sp)
420123ac:	0141                	add	sp,sp,16
    kbelfx_free(inst);
420123ae:	8c9f806f          	j	4200ac76 <kbelfx_free>
        kbelfx_free(inst->segments);
420123b2:	57c1                	li	a5,-16
420123b4:	00f47e63          	bgeu	s0,a5,420123d0 <kbelf_inst_destroy+0x4c>
420123b8:	4808                	lw	a0,16(s0)
420123ba:	8bdf80ef          	jal	4200ac76 <kbelfx_free>
    kbelfx_free(inst);
420123be:	8522                	mv	a0,s0
}
420123c0:	4422                	lw	s0,8(sp)
420123c2:	40b2                	lw	ra,12(sp)
420123c4:	0141                	add	sp,sp,16
    kbelfx_free(inst);
420123c6:	8b1f806f          	j	4200ac76 <kbelfx_free>
420123ca:	8082                	ret
    if (inst->path)
420123cc:	9002                	ebreak
    if (inst->segments_len) {
420123ce:	9002                	ebreak
        kbelfx_free(inst->segments);
420123d0:	9002                	ebreak

420123d2 <kbelf_inst_getpid>:


// Get the PID number passed when the `kbelf_inst` was created.
int kbelf_inst_getpid(kbelf_inst inst) {
    return inst->pid;
420123d2:	c909                	beqz	a0,420123e4 <kbelf_inst_getpid+0x12>
420123d4:	00357793          	and	a5,a0,3
420123d8:	e791                	bnez	a5,420123e4 <kbelf_inst_getpid+0x12>
420123da:	57e1                	li	a5,-8
420123dc:	00f57463          	bgeu	a0,a5,420123e4 <kbelf_inst_getpid+0x12>
}
420123e0:	4508                	lw	a0,8(a0)
420123e2:	8082                	ret
    return inst->pid;
420123e4:	9002                	ebreak

420123e6 <kbelf_inst_getoff>:

// Translate a virtual address to an offset in the file.
long kbelf_inst_getoff(kbelf_inst inst, kbelf_addr vaddr) {
    if (!inst)
420123e6:	c925                	beqz	a0,42012456 <kbelf_inst_getoff+0x70>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
420123e8:	00357793          	and	a5,a0,3
420123ec:	ebad                	bnez	a5,4201245e <kbelf_inst_getoff+0x78>
420123ee:	57d1                	li	a5,-12
420123f0:	06f57763          	bgeu	a0,a5,4201245e <kbelf_inst_getoff+0x78>
420123f4:	00c52303          	lw	t1,12(a0)
420123f8:	04030f63          	beqz	t1,42012456 <kbelf_inst_getoff+0x70>
420123fc:	4681                	li	a3,0
420123fe:	4601                	li	a2,0
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
42012400:	5ec1                	li	t4,-16
42012402:	5e31                	li	t3,-20
42012404:	5f21                	li	t5,-24
42012406:	05d57c63          	bgeu	a0,t4,4201245e <kbelf_inst_getoff+0x78>
4201240a:	4918                	lw	a4,16(a0)
4201240c:	00d707b3          	add	a5,a4,a3
42012410:	0406c563          	bltz	a3,4201245a <kbelf_inst_getoff+0x74>
42012414:	04e7e563          	bltu	a5,a4,4201245e <kbelf_inst_getoff+0x78>
42012418:	c3b9                	beqz	a5,4201245e <kbelf_inst_getoff+0x78>
4201241a:	0037f813          	and	a6,a5,3
4201241e:	04081063          	bnez	a6,4201245e <kbelf_inst_getoff+0x78>
42012422:	03c7fe63          	bgeu	a5,t3,4201245e <kbelf_inst_getoff+0x78>
42012426:	0147a803          	lw	a6,20(a5)
4201242a:	0305e163          	bltu	a1,a6,4201244c <kbelf_inst_getoff+0x66>
4201242e:	0206cc63          	bltz	a3,42012466 <kbelf_inst_getoff+0x80>
42012432:	02e7e663          	bltu	a5,a4,4201245e <kbelf_inst_getoff+0x78>
42012436:	0206c563          	bltz	a3,42012460 <kbelf_inst_getoff+0x7a>
4201243a:	02e7e263          	bltu	a5,a4,4201245e <kbelf_inst_getoff+0x78>
4201243e:	03e7f063          	bgeu	a5,t5,4201245e <kbelf_inst_getoff+0x78>
42012442:	0187a883          	lw	a7,24(a5)
42012446:	98c2                	add	a7,a7,a6
42012448:	0315e263          	bltu	a1,a7,4201246c <kbelf_inst_getoff+0x86>
    for (size_t i = 0; i < inst->segments_len; i++) {
4201244c:	0605                	add	a2,a2,1
4201244e:	02868693          	add	a3,a3,40
42012452:	fa661ae3          	bne	a2,t1,42012406 <kbelf_inst_getoff+0x20>
        return 0;
42012456:	4501                	li	a0,0
            return (long)vaddr - (long)inst->segments[i].vaddr_req + (long)inst->segments[i].file_off;
        }
    }
    return 0;
}
42012458:	8082                	ret
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
4201245a:	faf77fe3          	bgeu	a4,a5,42012418 <kbelf_inst_getoff+0x32>
            return (long)vaddr - (long)inst->segments[i].vaddr_req + (long)inst->segments[i].file_off;
4201245e:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
42012460:	fcf77fe3          	bgeu	a4,a5,4201243e <kbelf_inst_getoff+0x58>
            return (long)vaddr - (long)inst->segments[i].vaddr_req + (long)inst->segments[i].file_off;
42012464:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
42012466:	fcf778e3          	bgeu	a4,a5,42012436 <kbelf_inst_getoff+0x50>
            return (long)vaddr - (long)inst->segments[i].vaddr_req + (long)inst->segments[i].file_off;
4201246a:	9002                	ebreak
4201246c:	0406d063          	bgez	a3,420124ac <kbelf_inst_getoff+0xc6>
42012470:	fef767e3          	bltu	a4,a5,4201245e <kbelf_inst_getoff+0x78>
42012474:	41058633          	sub	a2,a1,a6
42012478:	00c5a5b3          	slt	a1,a1,a2
4201247c:	00082813          	slti	a6,a6,0
42012480:	fcb81fe3          	bne	a6,a1,4201245e <kbelf_inst_getoff+0x78>
42012484:	0206d163          	bgez	a3,420124a6 <kbelf_inst_getoff+0xc0>
42012488:	fcf76be3          	bltu	a4,a5,4201245e <kbelf_inst_getoff+0x78>
4201248c:	5711                	li	a4,-28
4201248e:	fce7f8e3          	bgeu	a5,a4,4201245e <kbelf_inst_getoff+0x78>
42012492:	4fdc                	lw	a5,28(a5)
42012494:	00f60533          	add	a0,a2,a5
42012498:	00c52633          	slt	a2,a0,a2
4201249c:	0007a793          	slti	a5,a5,0
420124a0:	fac79fe3          	bne	a5,a2,4201245e <kbelf_inst_getoff+0x78>
}
420124a4:	8082                	ret
            return (long)vaddr - (long)inst->segments[i].vaddr_req + (long)inst->segments[i].file_off;
420124a6:	fee7f3e3          	bgeu	a5,a4,4201248c <kbelf_inst_getoff+0xa6>
420124aa:	9002                	ebreak
420124ac:	fce7f4e3          	bgeu	a5,a4,42012474 <kbelf_inst_getoff+0x8e>
420124b0:	9002                	ebreak

420124b2 <kbelf_inst_getladdr>:

// Translate a virtual address to a load address in a loaded instance.
// Typically used by an ELF loader/interpreter.
kbelf_laddr kbelf_inst_getladdr(kbelf_inst inst, kbelf_addr vaddr) {
    if (!inst)
420124b2:	c925                	beqz	a0,42012522 <kbelf_inst_getladdr+0x70>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
420124b4:	00357793          	and	a5,a0,3
420124b8:	ebad                	bnez	a5,4201252a <kbelf_inst_getladdr+0x78>
420124ba:	57d1                	li	a5,-12
420124bc:	06f57763          	bgeu	a0,a5,4201252a <kbelf_inst_getladdr+0x78>
420124c0:	00c52303          	lw	t1,12(a0)
420124c4:	04030f63          	beqz	t1,42012522 <kbelf_inst_getladdr+0x70>
420124c8:	4681                	li	a3,0
420124ca:	4601                	li	a2,0
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
420124cc:	5ec1                	li	t4,-16
420124ce:	5e31                	li	t3,-20
420124d0:	5f21                	li	t5,-24
420124d2:	05d57c63          	bgeu	a0,t4,4201252a <kbelf_inst_getladdr+0x78>
420124d6:	4918                	lw	a4,16(a0)
420124d8:	00d707b3          	add	a5,a4,a3
420124dc:	0406c563          	bltz	a3,42012526 <kbelf_inst_getladdr+0x74>
420124e0:	04e7e563          	bltu	a5,a4,4201252a <kbelf_inst_getladdr+0x78>
420124e4:	c3b9                	beqz	a5,4201252a <kbelf_inst_getladdr+0x78>
420124e6:	0037f813          	and	a6,a5,3
420124ea:	04081063          	bnez	a6,4201252a <kbelf_inst_getladdr+0x78>
420124ee:	03c7fe63          	bgeu	a5,t3,4201252a <kbelf_inst_getladdr+0x78>
420124f2:	0147a803          	lw	a6,20(a5)
420124f6:	0305e163          	bltu	a1,a6,42012518 <kbelf_inst_getladdr+0x66>
420124fa:	0206cc63          	bltz	a3,42012532 <kbelf_inst_getladdr+0x80>
420124fe:	02e7e663          	bltu	a5,a4,4201252a <kbelf_inst_getladdr+0x78>
42012502:	0206c563          	bltz	a3,4201252c <kbelf_inst_getladdr+0x7a>
42012506:	02e7e263          	bltu	a5,a4,4201252a <kbelf_inst_getladdr+0x78>
4201250a:	03e7f063          	bgeu	a5,t5,4201252a <kbelf_inst_getladdr+0x78>
4201250e:	0187a883          	lw	a7,24(a5)
42012512:	98c2                	add	a7,a7,a6
42012514:	0315e263          	bltu	a1,a7,42012538 <kbelf_inst_getladdr+0x86>
    for (size_t i = 0; i < inst->segments_len; i++) {
42012518:	0605                	add	a2,a2,1
4201251a:	02868693          	add	a3,a3,40
4201251e:	fa661ae3          	bne	a2,t1,420124d2 <kbelf_inst_getladdr+0x20>
        return 0;
42012522:	4501                	li	a0,0
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].vaddr_req + inst->segments[i].laddr;
        }
    }
    return 0;
}
42012524:	8082                	ret
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
42012526:	faf77fe3          	bgeu	a4,a5,420124e4 <kbelf_inst_getladdr+0x32>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].vaddr_req + inst->segments[i].laddr;
4201252a:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
4201252c:	fcf77fe3          	bgeu	a4,a5,4201250a <kbelf_inst_getladdr+0x58>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].vaddr_req + inst->segments[i].laddr;
42012530:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
42012532:	fcf778e3          	bgeu	a4,a5,42012502 <kbelf_inst_getladdr+0x50>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].vaddr_req + inst->segments[i].laddr;
42012536:	9002                	ebreak
42012538:	0206d463          	bgez	a3,42012560 <kbelf_inst_getladdr+0xae>
4201253c:	fef767e3          	bltu	a4,a5,4201252a <kbelf_inst_getladdr+0x78>
42012540:	0006d963          	bgez	a3,42012552 <kbelf_inst_getladdr+0xa0>
42012544:	fef763e3          	bltu	a4,a5,4201252a <kbelf_inst_getladdr+0x78>
42012548:	479c                	lw	a5,8(a5)
4201254a:	95be                	add	a1,a1,a5
4201254c:	41058533          	sub	a0,a1,a6
42012550:	8082                	ret
42012552:	fce7ece3          	bltu	a5,a4,4201252a <kbelf_inst_getladdr+0x78>
42012556:	479c                	lw	a5,8(a5)
42012558:	95be                	add	a1,a1,a5
4201255a:	41058533          	sub	a0,a1,a6
4201255e:	8082                	ret
42012560:	fce7e5e3          	bltu	a5,a4,4201252a <kbelf_inst_getladdr+0x78>
42012564:	fe06c0e3          	bltz	a3,42012544 <kbelf_inst_getladdr+0x92>
42012568:	b7ed                	j	42012552 <kbelf_inst_getladdr+0xa0>

4201256a <kbelf_inst_getpaddr>:

// Translate a virtual address to a physical address in a loaded instance.
kbelf_addr kbelf_inst_getpaddr(kbelf_inst inst, kbelf_addr vaddr) {
    if (!inst)
4201256a:	c925                	beqz	a0,420125da <kbelf_inst_getpaddr+0x70>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
4201256c:	00357793          	and	a5,a0,3
42012570:	ebad                	bnez	a5,420125e2 <kbelf_inst_getpaddr+0x78>
42012572:	57d1                	li	a5,-12
42012574:	06f57763          	bgeu	a0,a5,420125e2 <kbelf_inst_getpaddr+0x78>
42012578:	00c52303          	lw	t1,12(a0)
4201257c:	04030f63          	beqz	t1,420125da <kbelf_inst_getpaddr+0x70>
42012580:	4681                	li	a3,0
42012582:	4601                	li	a2,0
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
42012584:	5ec1                	li	t4,-16
42012586:	5e31                	li	t3,-20
42012588:	5f21                	li	t5,-24
4201258a:	05d57c63          	bgeu	a0,t4,420125e2 <kbelf_inst_getpaddr+0x78>
4201258e:	4918                	lw	a4,16(a0)
42012590:	00d707b3          	add	a5,a4,a3
42012594:	0406c563          	bltz	a3,420125de <kbelf_inst_getpaddr+0x74>
42012598:	04e7e563          	bltu	a5,a4,420125e2 <kbelf_inst_getpaddr+0x78>
4201259c:	c3b9                	beqz	a5,420125e2 <kbelf_inst_getpaddr+0x78>
4201259e:	0037f813          	and	a6,a5,3
420125a2:	04081063          	bnez	a6,420125e2 <kbelf_inst_getpaddr+0x78>
420125a6:	03c7fe63          	bgeu	a5,t3,420125e2 <kbelf_inst_getpaddr+0x78>
420125aa:	0147a803          	lw	a6,20(a5)
420125ae:	0305e163          	bltu	a1,a6,420125d0 <kbelf_inst_getpaddr+0x66>
420125b2:	0206cc63          	bltz	a3,420125ea <kbelf_inst_getpaddr+0x80>
420125b6:	02e7e663          	bltu	a5,a4,420125e2 <kbelf_inst_getpaddr+0x78>
420125ba:	0206c563          	bltz	a3,420125e4 <kbelf_inst_getpaddr+0x7a>
420125be:	02e7e263          	bltu	a5,a4,420125e2 <kbelf_inst_getpaddr+0x78>
420125c2:	03e7f063          	bgeu	a5,t5,420125e2 <kbelf_inst_getpaddr+0x78>
420125c6:	0187a883          	lw	a7,24(a5)
420125ca:	98c2                	add	a7,a7,a6
420125cc:	0315e263          	bltu	a1,a7,420125f0 <kbelf_inst_getpaddr+0x86>
    for (size_t i = 0; i < inst->segments_len; i++) {
420125d0:	0605                	add	a2,a2,1
420125d2:	02868693          	add	a3,a3,40
420125d6:	fa661ae3          	bne	a2,t1,4201258a <kbelf_inst_getpaddr+0x20>
        return 0;
420125da:	4501                	li	a0,0
            return vaddr - inst->segments[i].vaddr_req + inst->segments[i].paddr;
        }
    }
    return 0;
}
420125dc:	8082                	ret
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
420125de:	faf77fe3          	bgeu	a4,a5,4201259c <kbelf_inst_getpaddr+0x32>
            return vaddr - inst->segments[i].vaddr_req + inst->segments[i].paddr;
420125e2:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
420125e4:	fcf77fe3          	bgeu	a4,a5,420125c2 <kbelf_inst_getpaddr+0x58>
            return vaddr - inst->segments[i].vaddr_req + inst->segments[i].paddr;
420125e8:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
420125ea:	fcf778e3          	bgeu	a4,a5,420125ba <kbelf_inst_getpaddr+0x50>
            return vaddr - inst->segments[i].vaddr_req + inst->segments[i].paddr;
420125ee:	9002                	ebreak
420125f0:	0206d463          	bgez	a3,42012618 <kbelf_inst_getpaddr+0xae>
420125f4:	fef767e3          	bltu	a4,a5,420125e2 <kbelf_inst_getpaddr+0x78>
420125f8:	0006d963          	bgez	a3,4201260a <kbelf_inst_getpaddr+0xa0>
420125fc:	fef763e3          	bltu	a4,a5,420125e2 <kbelf_inst_getpaddr+0x78>
42012600:	47dc                	lw	a5,12(a5)
42012602:	95be                	add	a1,a1,a5
42012604:	41058533          	sub	a0,a1,a6
42012608:	8082                	ret
4201260a:	fce7ece3          	bltu	a5,a4,420125e2 <kbelf_inst_getpaddr+0x78>
4201260e:	47dc                	lw	a5,12(a5)
42012610:	95be                	add	a1,a1,a5
42012612:	41058533          	sub	a0,a1,a6
42012616:	8082                	ret
42012618:	fce7e5e3          	bltu	a5,a4,420125e2 <kbelf_inst_getpaddr+0x78>
4201261c:	fe06c0e3          	bltz	a3,420125fc <kbelf_inst_getpaddr+0x92>
42012620:	b7ed                	j	4201260a <kbelf_inst_getpaddr+0xa0>

42012622 <kbelf_inst_getvaddr>:

// Translate a virtual address to a virtual address in a loaded instance.
kbelf_addr kbelf_inst_getvaddr(kbelf_inst inst, kbelf_addr vaddr) {
    if (!inst)
42012622:	c925                	beqz	a0,42012692 <kbelf_inst_getvaddr+0x70>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
42012624:	00357793          	and	a5,a0,3
42012628:	ebad                	bnez	a5,4201269a <kbelf_inst_getvaddr+0x78>
4201262a:	57d1                	li	a5,-12
4201262c:	06f57763          	bgeu	a0,a5,4201269a <kbelf_inst_getvaddr+0x78>
42012630:	00c52303          	lw	t1,12(a0)
42012634:	04030f63          	beqz	t1,42012692 <kbelf_inst_getvaddr+0x70>
42012638:	4681                	li	a3,0
4201263a:	4601                	li	a2,0
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
4201263c:	5ec1                	li	t4,-16
4201263e:	5e31                	li	t3,-20
42012640:	5f21                	li	t5,-24
42012642:	05d57c63          	bgeu	a0,t4,4201269a <kbelf_inst_getvaddr+0x78>
42012646:	4918                	lw	a4,16(a0)
42012648:	00d707b3          	add	a5,a4,a3
4201264c:	0406c563          	bltz	a3,42012696 <kbelf_inst_getvaddr+0x74>
42012650:	04e7e563          	bltu	a5,a4,4201269a <kbelf_inst_getvaddr+0x78>
42012654:	c3b9                	beqz	a5,4201269a <kbelf_inst_getvaddr+0x78>
42012656:	0037f813          	and	a6,a5,3
4201265a:	04081063          	bnez	a6,4201269a <kbelf_inst_getvaddr+0x78>
4201265e:	03c7fe63          	bgeu	a5,t3,4201269a <kbelf_inst_getvaddr+0x78>
42012662:	0147a803          	lw	a6,20(a5)
42012666:	0305e163          	bltu	a1,a6,42012688 <kbelf_inst_getvaddr+0x66>
4201266a:	0206cc63          	bltz	a3,420126a2 <kbelf_inst_getvaddr+0x80>
4201266e:	02e7e663          	bltu	a5,a4,4201269a <kbelf_inst_getvaddr+0x78>
42012672:	0206c563          	bltz	a3,4201269c <kbelf_inst_getvaddr+0x7a>
42012676:	02e7e263          	bltu	a5,a4,4201269a <kbelf_inst_getvaddr+0x78>
4201267a:	03e7f063          	bgeu	a5,t5,4201269a <kbelf_inst_getvaddr+0x78>
4201267e:	0187a883          	lw	a7,24(a5)
42012682:	98c2                	add	a7,a7,a6
42012684:	0315e263          	bltu	a1,a7,420126a8 <kbelf_inst_getvaddr+0x86>
    for (size_t i = 0; i < inst->segments_len; i++) {
42012688:	0605                	add	a2,a2,1
4201268a:	02868693          	add	a3,a3,40
4201268e:	fa661ae3          	bne	a2,t1,42012642 <kbelf_inst_getvaddr+0x20>
        return 0;
42012692:	4501                	li	a0,0
            return vaddr - inst->segments[i].vaddr_req + inst->segments[i].vaddr_real;
        }
    }
    return 0;
}
42012694:	8082                	ret
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
42012696:	faf77fe3          	bgeu	a4,a5,42012654 <kbelf_inst_getvaddr+0x32>
            return vaddr - inst->segments[i].vaddr_req + inst->segments[i].vaddr_real;
4201269a:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
4201269c:	fcf77fe3          	bgeu	a4,a5,4201267a <kbelf_inst_getvaddr+0x58>
            return vaddr - inst->segments[i].vaddr_req + inst->segments[i].vaddr_real;
420126a0:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_req && vaddr < inst->segments[i].vaddr_req + inst->segments[i].size) {
420126a2:	fcf778e3          	bgeu	a4,a5,42012672 <kbelf_inst_getvaddr+0x50>
            return vaddr - inst->segments[i].vaddr_req + inst->segments[i].vaddr_real;
420126a6:	9002                	ebreak
420126a8:	0206d463          	bgez	a3,420126d0 <kbelf_inst_getvaddr+0xae>
420126ac:	fef767e3          	bltu	a4,a5,4201269a <kbelf_inst_getvaddr+0x78>
420126b0:	0006d963          	bgez	a3,420126c2 <kbelf_inst_getvaddr+0xa0>
420126b4:	fef763e3          	bltu	a4,a5,4201269a <kbelf_inst_getvaddr+0x78>
420126b8:	4b9c                	lw	a5,16(a5)
420126ba:	95be                	add	a1,a1,a5
420126bc:	41058533          	sub	a0,a1,a6
420126c0:	8082                	ret
420126c2:	fce7ece3          	bltu	a5,a4,4201269a <kbelf_inst_getvaddr+0x78>
420126c6:	4b9c                	lw	a5,16(a5)
420126c8:	95be                	add	a1,a1,a5
420126ca:	41058533          	sub	a0,a1,a6
420126ce:	8082                	ret
420126d0:	fce7e5e3          	bltu	a5,a4,4201269a <kbelf_inst_getvaddr+0x78>
420126d4:	fe06c0e3          	bltz	a3,420126b4 <kbelf_inst_getvaddr+0x92>
420126d8:	b7ed                	j	420126c2 <kbelf_inst_getvaddr+0xa0>

420126da <kbelf_inst_vaddr_to_paddr>:

// Translate a virtual address in a loaded instance to a physical address in a loaded instance.
kbelf_addr kbelf_inst_vaddr_to_paddr(kbelf_inst inst, kbelf_addr vaddr) {
    if (!inst)
420126da:	c53d                	beqz	a0,42012748 <kbelf_inst_vaddr_to_paddr+0x6e>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
420126dc:	00357793          	and	a5,a0,3
420126e0:	eba5                	bnez	a5,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
420126e2:	57d1                	li	a5,-12
420126e4:	06f57663          	bgeu	a0,a5,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
420126e8:	00c52e03          	lw	t3,12(a0)
420126ec:	040e0e63          	beqz	t3,42012748 <kbelf_inst_vaddr_to_paddr+0x6e>
420126f0:	4681                	li	a3,0
420126f2:	4601                	li	a2,0
        if (vaddr >= inst->segments[i].vaddr_real && vaddr < inst->segments[i].vaddr_real + inst->segments[i].size) {
420126f4:	58c1                	li	a7,-16
420126f6:	5ea1                	li	t4,-24
420126f8:	05157c63          	bgeu	a0,a7,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
420126fc:	4918                	lw	a4,16(a0)
420126fe:	00d707b3          	add	a5,a4,a3
42012702:	0406c563          	bltz	a3,4201274c <kbelf_inst_vaddr_to_paddr+0x72>
42012706:	04e7e563          	bltu	a5,a4,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
4201270a:	c3b9                	beqz	a5,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
4201270c:	0037f813          	and	a6,a5,3
42012710:	04081063          	bnez	a6,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
42012714:	0317fe63          	bgeu	a5,a7,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
42012718:	0107a803          	lw	a6,16(a5)
4201271c:	0305e163          	bltu	a1,a6,4201273e <kbelf_inst_vaddr_to_paddr+0x64>
42012720:	0206cc63          	bltz	a3,42012758 <kbelf_inst_vaddr_to_paddr+0x7e>
42012724:	02e7e663          	bltu	a5,a4,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
42012728:	0206c563          	bltz	a3,42012752 <kbelf_inst_vaddr_to_paddr+0x78>
4201272c:	02e7e263          	bltu	a5,a4,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
42012730:	03d7f063          	bgeu	a5,t4,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
42012734:	0187a303          	lw	t1,24(a5)
42012738:	9342                	add	t1,t1,a6
4201273a:	0265e263          	bltu	a1,t1,4201275e <kbelf_inst_vaddr_to_paddr+0x84>
    for (size_t i = 0; i < inst->segments_len; i++) {
4201273e:	0605                	add	a2,a2,1
42012740:	02868693          	add	a3,a3,40
42012744:	fbc61ae3          	bne	a2,t3,420126f8 <kbelf_inst_vaddr_to_paddr+0x1e>
        return 0;
42012748:	4501                	li	a0,0
            return vaddr - inst->segments[i].vaddr_real + inst->segments[i].paddr;
        }
    }
    return 0;
}
4201274a:	8082                	ret
        if (vaddr >= inst->segments[i].vaddr_real && vaddr < inst->segments[i].vaddr_real + inst->segments[i].size) {
4201274c:	faf77fe3          	bgeu	a4,a5,4201270a <kbelf_inst_vaddr_to_paddr+0x30>
            return vaddr - inst->segments[i].vaddr_real + inst->segments[i].paddr;
42012750:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_real && vaddr < inst->segments[i].vaddr_real + inst->segments[i].size) {
42012752:	fcf77fe3          	bgeu	a4,a5,42012730 <kbelf_inst_vaddr_to_paddr+0x56>
            return vaddr - inst->segments[i].vaddr_real + inst->segments[i].paddr;
42012756:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_real && vaddr < inst->segments[i].vaddr_real + inst->segments[i].size) {
42012758:	fcf778e3          	bgeu	a4,a5,42012728 <kbelf_inst_vaddr_to_paddr+0x4e>
            return vaddr - inst->segments[i].vaddr_real + inst->segments[i].paddr;
4201275c:	9002                	ebreak
4201275e:	0206d463          	bgez	a3,42012786 <kbelf_inst_vaddr_to_paddr+0xac>
42012762:	fef767e3          	bltu	a4,a5,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
42012766:	0006d963          	bgez	a3,42012778 <kbelf_inst_vaddr_to_paddr+0x9e>
4201276a:	fef763e3          	bltu	a4,a5,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
4201276e:	47dc                	lw	a5,12(a5)
42012770:	95be                	add	a1,a1,a5
42012772:	41058533          	sub	a0,a1,a6
42012776:	8082                	ret
42012778:	fce7ece3          	bltu	a5,a4,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
4201277c:	47dc                	lw	a5,12(a5)
4201277e:	95be                	add	a1,a1,a5
42012780:	41058533          	sub	a0,a1,a6
42012784:	8082                	ret
42012786:	fce7e5e3          	bltu	a5,a4,42012750 <kbelf_inst_vaddr_to_paddr+0x76>
4201278a:	fe06c0e3          	bltz	a3,4201276a <kbelf_inst_vaddr_to_paddr+0x90>
4201278e:	b7ed                	j	42012778 <kbelf_inst_vaddr_to_paddr+0x9e>

42012790 <kbelf_inst_vaddr_to_laddr>:

// Translate a virtual address in a loaded instance to a load address in a loaded instance.
kbelf_laddr kbelf_inst_vaddr_to_laddr(kbelf_inst inst, kbelf_addr vaddr) {
    if (!inst)
42012790:	c53d                	beqz	a0,420127fe <kbelf_inst_vaddr_to_laddr+0x6e>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
42012792:	00357793          	and	a5,a0,3
42012796:	eba5                	bnez	a5,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
42012798:	57d1                	li	a5,-12
4201279a:	06f57663          	bgeu	a0,a5,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
4201279e:	00c52e03          	lw	t3,12(a0)
420127a2:	040e0e63          	beqz	t3,420127fe <kbelf_inst_vaddr_to_laddr+0x6e>
420127a6:	4681                	li	a3,0
420127a8:	4601                	li	a2,0
        if (vaddr >= inst->segments[i].vaddr_real && vaddr < inst->segments[i].vaddr_real + inst->segments[i].size) {
420127aa:	58c1                	li	a7,-16
420127ac:	5ea1                	li	t4,-24
420127ae:	05157c63          	bgeu	a0,a7,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
420127b2:	4918                	lw	a4,16(a0)
420127b4:	00d707b3          	add	a5,a4,a3
420127b8:	0406c563          	bltz	a3,42012802 <kbelf_inst_vaddr_to_laddr+0x72>
420127bc:	04e7e563          	bltu	a5,a4,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
420127c0:	c3b9                	beqz	a5,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
420127c2:	0037f813          	and	a6,a5,3
420127c6:	04081063          	bnez	a6,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
420127ca:	0317fe63          	bgeu	a5,a7,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
420127ce:	0107a803          	lw	a6,16(a5)
420127d2:	0305e163          	bltu	a1,a6,420127f4 <kbelf_inst_vaddr_to_laddr+0x64>
420127d6:	0206cc63          	bltz	a3,4201280e <kbelf_inst_vaddr_to_laddr+0x7e>
420127da:	02e7e663          	bltu	a5,a4,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
420127de:	0206c563          	bltz	a3,42012808 <kbelf_inst_vaddr_to_laddr+0x78>
420127e2:	02e7e263          	bltu	a5,a4,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
420127e6:	03d7f063          	bgeu	a5,t4,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
420127ea:	0187a303          	lw	t1,24(a5)
420127ee:	9342                	add	t1,t1,a6
420127f0:	0265e263          	bltu	a1,t1,42012814 <kbelf_inst_vaddr_to_laddr+0x84>
    for (size_t i = 0; i < inst->segments_len; i++) {
420127f4:	0605                	add	a2,a2,1
420127f6:	02868693          	add	a3,a3,40
420127fa:	fbc61ae3          	bne	a2,t3,420127ae <kbelf_inst_vaddr_to_laddr+0x1e>
        return 0;
420127fe:	4501                	li	a0,0
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].vaddr_real + inst->segments[i].laddr;
        }
    }
    return 0;
}
42012800:	8082                	ret
        if (vaddr >= inst->segments[i].vaddr_real && vaddr < inst->segments[i].vaddr_real + inst->segments[i].size) {
42012802:	faf77fe3          	bgeu	a4,a5,420127c0 <kbelf_inst_vaddr_to_laddr+0x30>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].vaddr_real + inst->segments[i].laddr;
42012806:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_real && vaddr < inst->segments[i].vaddr_real + inst->segments[i].size) {
42012808:	fcf77fe3          	bgeu	a4,a5,420127e6 <kbelf_inst_vaddr_to_laddr+0x56>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].vaddr_real + inst->segments[i].laddr;
4201280c:	9002                	ebreak
        if (vaddr >= inst->segments[i].vaddr_real && vaddr < inst->segments[i].vaddr_real + inst->segments[i].size) {
4201280e:	fcf778e3          	bgeu	a4,a5,420127de <kbelf_inst_vaddr_to_laddr+0x4e>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].vaddr_real + inst->segments[i].laddr;
42012812:	9002                	ebreak
42012814:	0206d463          	bgez	a3,4201283c <kbelf_inst_vaddr_to_laddr+0xac>
42012818:	fef767e3          	bltu	a4,a5,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
4201281c:	0006d963          	bgez	a3,4201282e <kbelf_inst_vaddr_to_laddr+0x9e>
42012820:	fef763e3          	bltu	a4,a5,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
42012824:	479c                	lw	a5,8(a5)
42012826:	95be                	add	a1,a1,a5
42012828:	41058533          	sub	a0,a1,a6
4201282c:	8082                	ret
4201282e:	fce7ece3          	bltu	a5,a4,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
42012832:	479c                	lw	a5,8(a5)
42012834:	95be                	add	a1,a1,a5
42012836:	41058533          	sub	a0,a1,a6
4201283a:	8082                	ret
4201283c:	fce7e5e3          	bltu	a5,a4,42012806 <kbelf_inst_vaddr_to_laddr+0x76>
42012840:	fe06c0e3          	bltz	a3,42012820 <kbelf_inst_vaddr_to_laddr+0x90>
42012844:	b7ed                	j	4201282e <kbelf_inst_vaddr_to_laddr+0x9e>

42012846 <kbelf_inst_paddr_to_vaddr>:

// Translate a physical address in a loaded instance to a virtual address in a loaded instance.
kbelf_addr kbelf_inst_paddr_to_vaddr(kbelf_inst inst, kbelf_addr vaddr) {
    if (!inst)
42012846:	c925                	beqz	a0,420128b6 <kbelf_inst_paddr_to_vaddr+0x70>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
42012848:	00357793          	and	a5,a0,3
4201284c:	ebad                	bnez	a5,420128be <kbelf_inst_paddr_to_vaddr+0x78>
4201284e:	57d1                	li	a5,-12
42012850:	06f57763          	bgeu	a0,a5,420128be <kbelf_inst_paddr_to_vaddr+0x78>
42012854:	00c52303          	lw	t1,12(a0)
42012858:	04030f63          	beqz	t1,420128b6 <kbelf_inst_paddr_to_vaddr+0x70>
4201285c:	4681                	li	a3,0
4201285e:	4601                	li	a2,0
        if (vaddr >= inst->segments[i].paddr && vaddr < inst->segments[i].paddr + inst->segments[i].size) {
42012860:	5ec1                	li	t4,-16
42012862:	5e51                	li	t3,-12
42012864:	5f21                	li	t5,-24
42012866:	05d57c63          	bgeu	a0,t4,420128be <kbelf_inst_paddr_to_vaddr+0x78>
4201286a:	4918                	lw	a4,16(a0)
4201286c:	00d707b3          	add	a5,a4,a3
42012870:	0406c563          	bltz	a3,420128ba <kbelf_inst_paddr_to_vaddr+0x74>
42012874:	04e7e563          	bltu	a5,a4,420128be <kbelf_inst_paddr_to_vaddr+0x78>
42012878:	c3b9                	beqz	a5,420128be <kbelf_inst_paddr_to_vaddr+0x78>
4201287a:	0037f813          	and	a6,a5,3
4201287e:	04081063          	bnez	a6,420128be <kbelf_inst_paddr_to_vaddr+0x78>
42012882:	03c7fe63          	bgeu	a5,t3,420128be <kbelf_inst_paddr_to_vaddr+0x78>
42012886:	00c7a803          	lw	a6,12(a5)
4201288a:	0305e163          	bltu	a1,a6,420128ac <kbelf_inst_paddr_to_vaddr+0x66>
4201288e:	0206cc63          	bltz	a3,420128c6 <kbelf_inst_paddr_to_vaddr+0x80>
42012892:	02e7e663          	bltu	a5,a4,420128be <kbelf_inst_paddr_to_vaddr+0x78>
42012896:	0206c563          	bltz	a3,420128c0 <kbelf_inst_paddr_to_vaddr+0x7a>
4201289a:	02e7e263          	bltu	a5,a4,420128be <kbelf_inst_paddr_to_vaddr+0x78>
4201289e:	03e7f063          	bgeu	a5,t5,420128be <kbelf_inst_paddr_to_vaddr+0x78>
420128a2:	0187a883          	lw	a7,24(a5)
420128a6:	98c2                	add	a7,a7,a6
420128a8:	0315e263          	bltu	a1,a7,420128cc <kbelf_inst_paddr_to_vaddr+0x86>
    for (size_t i = 0; i < inst->segments_len; i++) {
420128ac:	0605                	add	a2,a2,1
420128ae:	02868693          	add	a3,a3,40
420128b2:	fa661ae3          	bne	a2,t1,42012866 <kbelf_inst_paddr_to_vaddr+0x20>
        return 0;
420128b6:	4501                	li	a0,0
            return vaddr - inst->segments[i].paddr + inst->segments[i].vaddr_real;
        }
    }
    return 0;
}
420128b8:	8082                	ret
        if (vaddr >= inst->segments[i].paddr && vaddr < inst->segments[i].paddr + inst->segments[i].size) {
420128ba:	faf77fe3          	bgeu	a4,a5,42012878 <kbelf_inst_paddr_to_vaddr+0x32>
            return vaddr - inst->segments[i].paddr + inst->segments[i].vaddr_real;
420128be:	9002                	ebreak
        if (vaddr >= inst->segments[i].paddr && vaddr < inst->segments[i].paddr + inst->segments[i].size) {
420128c0:	fcf77fe3          	bgeu	a4,a5,4201289e <kbelf_inst_paddr_to_vaddr+0x58>
            return vaddr - inst->segments[i].paddr + inst->segments[i].vaddr_real;
420128c4:	9002                	ebreak
        if (vaddr >= inst->segments[i].paddr && vaddr < inst->segments[i].paddr + inst->segments[i].size) {
420128c6:	fcf778e3          	bgeu	a4,a5,42012896 <kbelf_inst_paddr_to_vaddr+0x50>
            return vaddr - inst->segments[i].paddr + inst->segments[i].vaddr_real;
420128ca:	9002                	ebreak
420128cc:	0206d463          	bgez	a3,420128f4 <kbelf_inst_paddr_to_vaddr+0xae>
420128d0:	fef767e3          	bltu	a4,a5,420128be <kbelf_inst_paddr_to_vaddr+0x78>
420128d4:	0006d963          	bgez	a3,420128e6 <kbelf_inst_paddr_to_vaddr+0xa0>
420128d8:	fef763e3          	bltu	a4,a5,420128be <kbelf_inst_paddr_to_vaddr+0x78>
420128dc:	4b9c                	lw	a5,16(a5)
420128de:	95be                	add	a1,a1,a5
420128e0:	41058533          	sub	a0,a1,a6
420128e4:	8082                	ret
420128e6:	fce7ece3          	bltu	a5,a4,420128be <kbelf_inst_paddr_to_vaddr+0x78>
420128ea:	4b9c                	lw	a5,16(a5)
420128ec:	95be                	add	a1,a1,a5
420128ee:	41058533          	sub	a0,a1,a6
420128f2:	8082                	ret
420128f4:	fce7e5e3          	bltu	a5,a4,420128be <kbelf_inst_paddr_to_vaddr+0x78>
420128f8:	fe06c0e3          	bltz	a3,420128d8 <kbelf_inst_paddr_to_vaddr+0x92>
420128fc:	b7ed                	j	420128e6 <kbelf_inst_paddr_to_vaddr+0xa0>

420128fe <kbelf_inst_paddr_to_laddr>:

// Translate a physical address in a loaded instance to a load address in a loaded instance.
kbelf_laddr kbelf_inst_paddr_to_laddr(kbelf_inst inst, kbelf_addr vaddr) {
    if (!inst)
420128fe:	c925                	beqz	a0,4201296e <kbelf_inst_paddr_to_laddr+0x70>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
42012900:	00357793          	and	a5,a0,3
42012904:	ebad                	bnez	a5,42012976 <kbelf_inst_paddr_to_laddr+0x78>
42012906:	57d1                	li	a5,-12
42012908:	06f57763          	bgeu	a0,a5,42012976 <kbelf_inst_paddr_to_laddr+0x78>
4201290c:	00c52303          	lw	t1,12(a0)
42012910:	04030f63          	beqz	t1,4201296e <kbelf_inst_paddr_to_laddr+0x70>
42012914:	4681                	li	a3,0
42012916:	4601                	li	a2,0
        if (vaddr >= inst->segments[i].paddr && vaddr < inst->segments[i].paddr + inst->segments[i].size) {
42012918:	5ec1                	li	t4,-16
4201291a:	5e51                	li	t3,-12
4201291c:	5f21                	li	t5,-24
4201291e:	05d57c63          	bgeu	a0,t4,42012976 <kbelf_inst_paddr_to_laddr+0x78>
42012922:	4918                	lw	a4,16(a0)
42012924:	00d707b3          	add	a5,a4,a3
42012928:	0406c563          	bltz	a3,42012972 <kbelf_inst_paddr_to_laddr+0x74>
4201292c:	04e7e563          	bltu	a5,a4,42012976 <kbelf_inst_paddr_to_laddr+0x78>
42012930:	c3b9                	beqz	a5,42012976 <kbelf_inst_paddr_to_laddr+0x78>
42012932:	0037f813          	and	a6,a5,3
42012936:	04081063          	bnez	a6,42012976 <kbelf_inst_paddr_to_laddr+0x78>
4201293a:	03c7fe63          	bgeu	a5,t3,42012976 <kbelf_inst_paddr_to_laddr+0x78>
4201293e:	00c7a803          	lw	a6,12(a5)
42012942:	0305e163          	bltu	a1,a6,42012964 <kbelf_inst_paddr_to_laddr+0x66>
42012946:	0206cc63          	bltz	a3,4201297e <kbelf_inst_paddr_to_laddr+0x80>
4201294a:	02e7e663          	bltu	a5,a4,42012976 <kbelf_inst_paddr_to_laddr+0x78>
4201294e:	0206c563          	bltz	a3,42012978 <kbelf_inst_paddr_to_laddr+0x7a>
42012952:	02e7e263          	bltu	a5,a4,42012976 <kbelf_inst_paddr_to_laddr+0x78>
42012956:	03e7f063          	bgeu	a5,t5,42012976 <kbelf_inst_paddr_to_laddr+0x78>
4201295a:	0187a883          	lw	a7,24(a5)
4201295e:	98c2                	add	a7,a7,a6
42012960:	0315e263          	bltu	a1,a7,42012984 <kbelf_inst_paddr_to_laddr+0x86>
    for (size_t i = 0; i < inst->segments_len; i++) {
42012964:	0605                	add	a2,a2,1
42012966:	02868693          	add	a3,a3,40
4201296a:	fa661ae3          	bne	a2,t1,4201291e <kbelf_inst_paddr_to_laddr+0x20>
        return 0;
4201296e:	4501                	li	a0,0
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].paddr + inst->segments[i].laddr;
        }
    }
    return 0;
}
42012970:	8082                	ret
        if (vaddr >= inst->segments[i].paddr && vaddr < inst->segments[i].paddr + inst->segments[i].size) {
42012972:	faf77fe3          	bgeu	a4,a5,42012930 <kbelf_inst_paddr_to_laddr+0x32>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].paddr + inst->segments[i].laddr;
42012976:	9002                	ebreak
        if (vaddr >= inst->segments[i].paddr && vaddr < inst->segments[i].paddr + inst->segments[i].size) {
42012978:	fcf77fe3          	bgeu	a4,a5,42012956 <kbelf_inst_paddr_to_laddr+0x58>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].paddr + inst->segments[i].laddr;
4201297c:	9002                	ebreak
        if (vaddr >= inst->segments[i].paddr && vaddr < inst->segments[i].paddr + inst->segments[i].size) {
4201297e:	fcf778e3          	bgeu	a4,a5,4201294e <kbelf_inst_paddr_to_laddr+0x50>
            return (kbelf_laddr)vaddr - (kbelf_laddr)inst->segments[i].paddr + inst->segments[i].laddr;
42012982:	9002                	ebreak
42012984:	0206d463          	bgez	a3,420129ac <kbelf_inst_paddr_to_laddr+0xae>
42012988:	fef767e3          	bltu	a4,a5,42012976 <kbelf_inst_paddr_to_laddr+0x78>
4201298c:	0006d963          	bgez	a3,4201299e <kbelf_inst_paddr_to_laddr+0xa0>
42012990:	fef763e3          	bltu	a4,a5,42012976 <kbelf_inst_paddr_to_laddr+0x78>
42012994:	479c                	lw	a5,8(a5)
42012996:	95be                	add	a1,a1,a5
42012998:	41058533          	sub	a0,a1,a6
4201299c:	8082                	ret
4201299e:	fce7ece3          	bltu	a5,a4,42012976 <kbelf_inst_paddr_to_laddr+0x78>
420129a2:	479c                	lw	a5,8(a5)
420129a4:	95be                	add	a1,a1,a5
420129a6:	41058533          	sub	a0,a1,a6
420129aa:	8082                	ret
420129ac:	fce7e5e3          	bltu	a5,a4,42012976 <kbelf_inst_paddr_to_laddr+0x78>
420129b0:	fe06c0e3          	bltz	a3,42012990 <kbelf_inst_paddr_to_laddr+0x92>
420129b4:	b7ed                	j	4201299e <kbelf_inst_paddr_to_laddr+0xa0>

420129b6 <kbelf_inst_load>:
kbelf_inst kbelf_inst_load(kbelf_file file, int pid) {
420129b6:	711d                	add	sp,sp,-96
420129b8:	cca2                	sw	s0,88(sp)
420129ba:	842a                	mv	s0,a0
    kbelf_inst inst = kbelfx_malloc(sizeof(struct struct_kbelf_inst));
420129bc:	05000513          	li	a0,80
kbelf_inst kbelf_inst_load(kbelf_file file, int pid) {
420129c0:	caa6                	sw	s1,84(sp)
420129c2:	c6ce                	sw	s3,76(sp)
420129c4:	ce86                	sw	ra,92(sp)
420129c6:	89ae                	mv	s3,a1
    kbelf_inst inst = kbelfx_malloc(sizeof(struct struct_kbelf_inst));
420129c8:	aa6f80ef          	jal	4200ac6e <kbelfx_malloc>
420129cc:	84aa                	mv	s1,a0
    if (!inst)
420129ce:	26050863          	beqz	a0,42012c3e <kbelf_inst_load+0x288>
    kbelfq_memset(inst, 0, sizeof(struct struct_kbelf_inst));
420129d2:	05000613          	li	a2,80
420129d6:	4581                	li	a1,0
420129d8:	c8ca                	sw	s2,80(sp)
420129da:	c4d2                	sw	s4,72(sp)
420129dc:	a8af80ef          	jal	4200ac66 <kbelfq_memset>
    inst->pid = pid;
420129e0:	0034f793          	and	a5,s1,3
420129e4:	0e079b63          	bnez	a5,42012ada <kbelf_inst_load+0x124>
420129e8:	5a61                	li	s4,-8
420129ea:	0f44f863          	bgeu	s1,s4,42012ada <kbelf_inst_load+0x124>
420129ee:	0134a423          	sw	s3,8(s1)
    size_t path_len = kbelfq_strlen(file->path);
420129f2:	0e040463          	beqz	s0,42012ada <kbelf_inst_load+0x124>
420129f6:	00347793          	and	a5,s0,3
420129fa:	e3e5                	bnez	a5,42012ada <kbelf_inst_load+0x124>
420129fc:	57f1                	li	a5,-4
420129fe:	0cf47e63          	bgeu	s0,a5,42012ada <kbelf_inst_load+0x124>
42012a02:	4048                	lw	a0,4(s0)
42012a04:	a18f80ef          	jal	4200ac1c <kbelfq_strlen>
    inst->path      = kbelfx_malloc(path_len + 1);
42012a08:	00150913          	add	s2,a0,1
42012a0c:	854a                	mv	a0,s2
42012a0e:	a60f80ef          	jal	4200ac6e <kbelfx_malloc>
42012a12:	c088                	sw	a0,0(s1)
    if (!inst->path)
42012a14:	24050e63          	beqz	a0,42012c70 <kbelf_inst_load+0x2ba>
    kbelfq_memcpy(inst->path, file->path, path_len + 1);
42012a18:	404c                	lw	a1,4(s0)
42012a1a:	864a                	mv	a2,s2
42012a1c:	a46f80ef          	jal	4200ac62 <kbelfq_memcpy>
    inst->name = file->name - file->path + inst->path;
42012a20:	4094                	lw	a3,0(s1)
42012a22:	0b447c63          	bgeu	s0,s4,42012ada <kbelf_inst_load+0x124>
42012a26:	4058                	lw	a4,4(s0)
42012a28:	441c                	lw	a5,8(s0)
42012a2a:	8f99                	sub	a5,a5,a4
42012a2c:	00f68733          	add	a4,a3,a5
42012a30:	0a07d363          	bgez	a5,42012ad6 <kbelf_inst_load+0x120>
42012a34:	0ae6e363          	bltu	a3,a4,42012ada <kbelf_inst_load+0x124>
42012a38:	c0d8                	sw	a4,4(s1)
    if (!file->header.ph_ent_num)
42012a3a:	fc800793          	li	a5,-56
42012a3e:	08f47e63          	bgeu	s0,a5,42012ada <kbelf_inst_load+0x124>
42012a42:	03845783          	lhu	a5,56(s0)
42012a46:	26078063          	beqz	a5,42012ca6 <kbelf_inst_load+0x2f0>
42012a4a:	c2d6                	sw	s5,68(sp)
    for (size_t i = 0; i < file->header.ph_ent_num; i++) {
42012a4c:	4a01                	li	s4,0
    size_t loadable_len = 0;
42012a4e:	4901                	li	s2,0
    return prog->type == PT_LOAD && prog->mem_size;
42012a50:	4a85                	li	s5,1
42012a52:	a829                	j	42012a6c <kbelf_inst_load+0xb6>
42012a54:	4782                	lw	a5,0(sp)
42012a56:	01579663          	bne	a5,s5,42012a62 <kbelf_inst_load+0xac>
42012a5a:	47d2                	lw	a5,20(sp)
42012a5c:	00f037b3          	snez	a5,a5
        loadable_len += kbelf_prog_loadable(&prog);
42012a60:	993e                	add	s2,s2,a5
    for (size_t i = 0; i < file->header.ph_ent_num; i++) {
42012a62:	03845783          	lhu	a5,56(s0)
42012a66:	0a05                	add	s4,s4,1
42012a68:	06fa7c63          	bgeu	s4,a5,42012ae0 <kbelf_inst_load+0x12a>
        if (!kbelf_file_prog_get(file, &prog, i))
42012a6c:	8652                	mv	a2,s4
42012a6e:	858a                	mv	a1,sp
42012a70:	8522                	mv	a0,s0
        kbelf_progheader prog = {.type = PT_UNUSED, .mem_size = 0};
42012a72:	c002                	sw	zero,0(sp)
42012a74:	c202                	sw	zero,4(sp)
42012a76:	c402                	sw	zero,8(sp)
42012a78:	c602                	sw	zero,12(sp)
42012a7a:	c802                	sw	zero,16(sp)
42012a7c:	ca02                	sw	zero,20(sp)
42012a7e:	cc02                	sw	zero,24(sp)
42012a80:	ce02                	sw	zero,28(sp)
        if (!kbelf_file_prog_get(file, &prog, i))
42012a82:	831ff0ef          	jal	420122b2 <kbelf_file_prog_get>
42012a86:	f579                	bnez	a0,42012a54 <kbelf_inst_load+0x9e>
            KBELF_ERROR(abort, "Unable to read program header " KBELF_FMT_SIZE, i)
42012a88:	4201b437          	lui	s0,0x4201b
42012a8c:	02f00593          	li	a1,47
42012a90:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012a94:	994f80ef          	jal	4200ac28 <kbelfq_strrchr>
42012a98:	36050c63          	beqz	a0,42012e10 <kbelf_inst_load+0x45a>
42012a9c:	57fd                	li	a5,-1
42012a9e:	00150613          	add	a2,a0,1
42012aa2:	7ef57a63          	bgeu	a0,a5,42013296 <kbelf_inst_load+0x8e0>
42012aa6:	4201b5b7          	lui	a1,0x4201b
42012aaa:	8752                	mv	a4,s4
42012aac:	03c00693          	li	a3,60
42012ab0:	69c58593          	add	a1,a1,1692 # 4201b69c <hextab+0x49d0>
42012ab4:	4505                	li	a0,1
42012ab6:	fe4f00ef          	jal	4200329a <logkf>
42012aba:	4946                	lw	s2,80(sp)
42012abc:	4a26                	lw	s4,72(sp)
42012abe:	4a96                	lw	s5,68(sp)
    kbelf_inst_unload(inst);
42012ac0:	8526                	mv	a0,s1
42012ac2:	86dff0ef          	jal	4201232e <kbelf_inst_unload>
    return NULL;
42012ac6:	4481                	li	s1,0
}
42012ac8:	40f6                	lw	ra,92(sp)
42012aca:	4466                	lw	s0,88(sp)
42012acc:	49b6                	lw	s3,76(sp)
42012ace:	8526                	mv	a0,s1
42012ad0:	44d6                	lw	s1,84(sp)
42012ad2:	6125                	add	sp,sp,96
42012ad4:	8082                	ret
    inst->name = file->name - file->path + inst->path;
42012ad6:	f6d771e3          	bgeu	a4,a3,42012a38 <kbelf_inst_load+0x82>
42012ada:	c2d6                	sw	s5,68(sp)
42012adc:	c0da                	sw	s6,64(sp)
42012ade:	abdd                	j	420130d4 <kbelf_inst_load+0x71e>
    inst->segments_len = loadable_len;
42012ae0:	57d1                	li	a5,-12
42012ae2:	7af4fa63          	bgeu	s1,a5,42013296 <kbelf_inst_load+0x8e0>
    inst->segments     = kbelfx_malloc(loadable_len * sizeof(kbelf_segment));
42012ae6:	00291a13          	sll	s4,s2,0x2
42012aea:	9a4a                	add	s4,s4,s2
42012aec:	0a0e                	sll	s4,s4,0x3
    inst->segments_len = loadable_len;
42012aee:	0124a623          	sw	s2,12(s1)
    inst->segments     = kbelfx_malloc(loadable_len * sizeof(kbelf_segment));
42012af2:	8552                	mv	a0,s4
42012af4:	97af80ef          	jal	4200ac6e <kbelfx_malloc>
42012af8:	5741                	li	a4,-16
42012afa:	78e4fe63          	bgeu	s1,a4,42013296 <kbelf_inst_load+0x8e0>
42012afe:	c888                	sw	a0,16(s1)
    if (!inst->segments)
42012b00:	34050663          	beqz	a0,42012e4c <kbelf_inst_load+0x496>
    kbelfq_memset(inst->segments, 0, loadable_len * sizeof(kbelf_segment));
42012b04:	8652                	mv	a2,s4
42012b06:	4581                	li	a1,0
42012b08:	c0da                	sw	s6,64(sp)
42012b0a:	95cf80ef          	jal	4200ac66 <kbelfq_memset>
    for (size_t i = 0, li = 0; li < loadable_len; i++) {
42012b0e:	62090163          	beqz	s2,42013130 <kbelf_inst_load+0x77a>
42012b12:	de5e                	sw	s7,60(sp)
42012b14:	dc62                	sw	s8,56(sp)
42012b16:	da66                	sw	s9,52(sp)
42012b18:	d86a                	sw	s10,48(sp)
42012b1a:	d66e                	sw	s11,44(sp)
42012b1c:	4a81                	li	s5,0
42012b1e:	4d81                	li	s11,0
    return prog->type == PT_LOAD && prog->mem_size;
42012b20:	4a05                	li	s4,1
        inst->segments[li].pid       = pid;
42012b22:	5d71                	li	s10,-4
        inst->segments[li].vaddr_req = prog.vaddr;
42012b24:	5cb1                	li	s9,-20
        inst->segments[li].size      = prog.mem_size;
42012b26:	5c21                	li	s8,-24
        inst->segments[li].r         = prog.flags & PF_R;
42012b28:	fdc00b93          	li	s7,-36
        inst->segments[li].w         = prog.flags & PF_W;
42012b2c:	fdb00b13          	li	s6,-37
42012b30:	a021                	j	42012b38 <kbelf_inst_load+0x182>
    for (size_t i = 0, li = 0; li < loadable_len; i++) {
42012b32:	0a85                	add	s5,s5,1
42012b34:	1f2df863          	bgeu	s11,s2,42012d24 <kbelf_inst_load+0x36e>
        if (!kbelf_file_prog_get(file, &prog, i))
42012b38:	8656                	mv	a2,s5
42012b3a:	858a                	mv	a1,sp
42012b3c:	8522                	mv	a0,s0
        kbelf_progheader prog = {.type = PT_UNUSED, .mem_size = 0};
42012b3e:	c002                	sw	zero,0(sp)
42012b40:	c202                	sw	zero,4(sp)
42012b42:	c402                	sw	zero,8(sp)
42012b44:	c602                	sw	zero,12(sp)
42012b46:	c802                	sw	zero,16(sp)
42012b48:	ca02                	sw	zero,20(sp)
42012b4a:	cc02                	sw	zero,24(sp)
42012b4c:	ce02                	sw	zero,28(sp)
        if (!kbelf_file_prog_get(file, &prog, i))
42012b4e:	f64ff0ef          	jal	420122b2 <kbelf_file_prog_get>
42012b52:	18050563          	beqz	a0,42012cdc <kbelf_inst_load+0x326>
    return prog->type == PT_LOAD && prog->mem_size;
42012b56:	4782                	lw	a5,0(sp)
42012b58:	fd479de3          	bne	a5,s4,42012b32 <kbelf_inst_load+0x17c>
42012b5c:	4752                	lw	a4,20(sp)
42012b5e:	db71                	beqz	a4,42012b32 <kbelf_inst_load+0x17c>
        if (prog.mem_size < prog.file_size)
42012b60:	4842                	lw	a6,16(sp)
42012b62:	2b076a63          	bltu	a4,a6,42012e16 <kbelf_inst_load+0x460>
        inst->segments[li].pid       = pid;
42012b66:	4894                	lw	a3,16(s1)
42012b68:	002d9593          	sll	a1,s11,0x2
42012b6c:	95ee                	add	a1,a1,s11
42012b6e:	058e                	sll	a1,a1,0x3
42012b70:	00b687b3          	add	a5,a3,a1
42012b74:	0c05c263          	bltz	a1,42012c38 <kbelf_inst_load+0x282>
42012b78:	08d7ed63          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012b7c:	cbd9                	beqz	a5,42012c12 <kbelf_inst_load+0x25c>
42012b7e:	0037f513          	and	a0,a5,3
42012b82:	e941                	bnez	a0,42012c12 <kbelf_inst_load+0x25c>
42012b84:	09a7f763          	bgeu	a5,s10,42012c12 <kbelf_inst_load+0x25c>
42012b88:	0137a223          	sw	s3,4(a5)
        inst->segments[li].vaddr_req = prog.vaddr;
42012b8c:	0a05c363          	bltz	a1,42012c32 <kbelf_inst_load+0x27c>
42012b90:	08d7e163          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012b94:	4522                	lw	a0,8(sp)
42012b96:	0797fe63          	bgeu	a5,s9,42012c12 <kbelf_inst_load+0x25c>
42012b9a:	cbc8                	sw	a0,20(a5)
        inst->segments[li].size      = prog.mem_size;
42012b9c:	0605c963          	bltz	a1,42012c0e <kbelf_inst_load+0x258>
42012ba0:	06d7e963          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012ba4:	0787f763          	bgeu	a5,s8,42012c12 <kbelf_inst_load+0x25c>
        inst->segments[li].r         = prog.flags & PF_R;
42012ba8:	4562                	lw	a0,24(sp)
        inst->segments[li].size      = prog.mem_size;
42012baa:	cf98                	sw	a4,24(a5)
        inst->segments[li].r         = prog.flags & PF_R;
42012bac:	00457713          	and	a4,a0,4
42012bb0:	0605ce63          	bltz	a1,42012c2c <kbelf_inst_load+0x276>
42012bb4:	04d7ef63          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012bb8:	00e03733          	snez	a4,a4
42012bbc:	0577fb63          	bgeu	a5,s7,42012c12 <kbelf_inst_load+0x25c>
42012bc0:	02e78223          	sb	a4,36(a5)
        inst->segments[li].w         = prog.flags & PF_W;
42012bc4:	00257713          	and	a4,a0,2
42012bc8:	0405cf63          	bltz	a1,42012c26 <kbelf_inst_load+0x270>
42012bcc:	04d7e363          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012bd0:	00e03733          	snez	a4,a4
42012bd4:	0367ff63          	bgeu	a5,s6,42012c12 <kbelf_inst_load+0x25c>
42012bd8:	02e782a3          	sb	a4,37(a5)
        inst->segments[li].x         = prog.flags & PF_X;
42012bdc:	0405c263          	bltz	a1,42012c20 <kbelf_inst_load+0x26a>
42012be0:	02d7e963          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012be4:	fda00713          	li	a4,-38
42012be8:	8905                	and	a0,a0,1
42012bea:	02e7f463          	bgeu	a5,a4,42012c12 <kbelf_inst_load+0x25c>
42012bee:	02a78323          	sb	a0,38(a5)
        inst->segments[li].file_off  = (long)prog.offset;
42012bf2:	4712                	lw	a4,4(sp)
42012bf4:	0205c363          	bltz	a1,42012c1a <kbelf_inst_load+0x264>
42012bf8:	00d7ed63          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012bfc:	cfd8                	sw	a4,28(a5)
        inst->segments[li].file_size = (long)prog.file_size;
42012bfe:	0005cb63          	bltz	a1,42012c14 <kbelf_inst_load+0x25e>
42012c02:	00d7e863          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012c06:	0307a023          	sw	a6,32(a5)
        li++;
42012c0a:	0d85                	add	s11,s11,1
42012c0c:	b71d                	j	42012b32 <kbelf_inst_load+0x17c>
        inst->segments[li].size      = prog.mem_size;
42012c0e:	f8f6fbe3          	bgeu	a3,a5,42012ba4 <kbelf_inst_load+0x1ee>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012c12:	9002                	ebreak
        inst->segments[li].file_size = (long)prog.file_size;
42012c14:	fef6f9e3          	bgeu	a3,a5,42012c06 <kbelf_inst_load+0x250>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012c18:	9002                	ebreak
        inst->segments[li].file_off  = (long)prog.offset;
42012c1a:	fef6f1e3          	bgeu	a3,a5,42012bfc <kbelf_inst_load+0x246>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012c1e:	9002                	ebreak
        inst->segments[li].x         = prog.flags & PF_X;
42012c20:	fcf6f2e3          	bgeu	a3,a5,42012be4 <kbelf_inst_load+0x22e>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012c24:	9002                	ebreak
        inst->segments[li].w         = prog.flags & PF_W;
42012c26:	faf6f5e3          	bgeu	a3,a5,42012bd0 <kbelf_inst_load+0x21a>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012c2a:	9002                	ebreak
        inst->segments[li].r         = prog.flags & PF_R;
42012c2c:	f8f6f6e3          	bgeu	a3,a5,42012bb8 <kbelf_inst_load+0x202>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012c30:	9002                	ebreak
        inst->segments[li].vaddr_req = prog.vaddr;
42012c32:	f6f6f1e3          	bgeu	a3,a5,42012b94 <kbelf_inst_load+0x1de>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012c36:	9002                	ebreak
        inst->segments[li].pid       = pid;
42012c38:	f4f6f2e3          	bgeu	a3,a5,42012b7c <kbelf_inst_load+0x1c6>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012c3c:	9002                	ebreak
        KBELF_ERROR(abort, "Out of memory")
42012c3e:	4201b437          	lui	s0,0x4201b
42012c42:	02f00593          	li	a1,47
42012c46:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012c4a:	fdff70ef          	jal	4200ac28 <kbelfq_strrchr>
42012c4e:	22050b63          	beqz	a0,42012e84 <kbelf_inst_load+0x4ce>
42012c52:	57fd                	li	a5,-1
42012c54:	00150613          	add	a2,a0,1
42012c58:	64f57163          	bgeu	a0,a5,4201329a <kbelf_inst_load+0x8e4>
42012c5c:	4201b5b7          	lui	a1,0x4201b
42012c60:	02900693          	li	a3,41
42012c64:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42012c68:	4505                	li	a0,1
42012c6a:	e30f00ef          	jal	4200329a <logkf>
42012c6e:	bd89                	j	42012ac0 <kbelf_inst_load+0x10a>
        KBELF_ERROR(abort, "Out of memory")
42012c70:	4201b437          	lui	s0,0x4201b
42012c74:	02f00593          	li	a1,47
42012c78:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012c7c:	fadf70ef          	jal	4200ac28 <kbelfq_strrchr>
42012c80:	20050563          	beqz	a0,42012e8a <kbelf_inst_load+0x4d4>
42012c84:	57fd                	li	a5,-1
42012c86:	00150613          	add	a2,a0,1
42012c8a:	e4f578e3          	bgeu	a0,a5,42012ada <kbelf_inst_load+0x124>
42012c8e:	4201b5b7          	lui	a1,0x4201b
42012c92:	03100693          	li	a3,49
42012c96:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42012c9a:	4505                	li	a0,1
42012c9c:	dfef00ef          	jal	4200329a <logkf>
42012ca0:	4946                	lw	s2,80(sp)
42012ca2:	4a26                	lw	s4,72(sp)
42012ca4:	bd31                	j	42012ac0 <kbelf_inst_load+0x10a>
        KBELF_ERROR(abort, "No loadable segments")
42012ca6:	4201b437          	lui	s0,0x4201b
42012caa:	02f00593          	li	a1,47
42012cae:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012cb2:	f77f70ef          	jal	4200ac28 <kbelfq_strrchr>
42012cb6:	1c050d63          	beqz	a0,42012e90 <kbelf_inst_load+0x4da>
42012cba:	57fd                	li	a5,-1
42012cbc:	00150613          	add	a2,a0,1
42012cc0:	e0f57de3          	bgeu	a0,a5,42012ada <kbelf_inst_load+0x124>
42012cc4:	4201b5b7          	lui	a1,0x4201b
42012cc8:	03700693          	li	a3,55
42012ccc:	67458593          	add	a1,a1,1652 # 4201b674 <hextab+0x49a8>
42012cd0:	4505                	li	a0,1
42012cd2:	dc8f00ef          	jal	4200329a <logkf>
42012cd6:	4946                	lw	s2,80(sp)
42012cd8:	4a26                	lw	s4,72(sp)
42012cda:	b3dd                	j	42012ac0 <kbelf_inst_load+0x10a>
            KBELF_ERROR(abort, "Unable to read program header " KBELF_FMT_SIZE, i)
42012cdc:	4201b437          	lui	s0,0x4201b
42012ce0:	02f00593          	li	a1,47
42012ce4:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012ce8:	f41f70ef          	jal	4200ac28 <kbelfq_strrchr>
42012cec:	26050763          	beqz	a0,42012f5a <kbelf_inst_load+0x5a4>
42012cf0:	57fd                	li	a5,-1
42012cf2:	00150413          	add	s0,a0,1
42012cf6:	f0f57ee3          	bgeu	a0,a5,42012c12 <kbelf_inst_load+0x25c>
42012cfa:	4201b5b7          	lui	a1,0x4201b
42012cfe:	8756                	mv	a4,s5
42012d00:	04b00693          	li	a3,75
42012d04:	8622                	mv	a2,s0
42012d06:	69c58593          	add	a1,a1,1692 # 4201b69c <hextab+0x49d0>
42012d0a:	4505                	li	a0,1
42012d0c:	d8ef00ef          	jal	4200329a <logkf>
            KBELF_ERROR(abort, "Invalid program header size")
42012d10:	4946                	lw	s2,80(sp)
42012d12:	4a26                	lw	s4,72(sp)
42012d14:	4a96                	lw	s5,68(sp)
42012d16:	4b06                	lw	s6,64(sp)
42012d18:	5bf2                	lw	s7,60(sp)
42012d1a:	5c62                	lw	s8,56(sp)
42012d1c:	5cd2                	lw	s9,52(sp)
42012d1e:	5d42                	lw	s10,48(sp)
42012d20:	5db2                	lw	s11,44(sp)
42012d22:	bb79                	j	42012ac0 <kbelf_inst_load+0x10a>
    if (!kbelfx_seg_alloc(inst, inst->segments_len, inst->segments))
42012d24:	4890                	lw	a2,16(s1)
42012d26:	44cc                	lw	a1,12(s1)
42012d28:	8526                	mv	a0,s1
    for (size_t i = 0, li = 0; li < loadable_len; i++) {
42012d2a:	4981                	li	s3,0
    if (!kbelfx_seg_alloc(inst, inst->segments_len, inst->segments))
42012d2c:	f4ff70ef          	jal	4200ac7a <kbelfx_seg_alloc>
    for (size_t i = 0, li = 0; li < loadable_len; i++) {
42012d30:	4a01                	li	s4,0
    return prog->type == PT_LOAD && prog->mem_size;
42012d32:	4b85                	li	s7,1
            kbelf_laddr laddr = kbelf_inst_paddr_to_laddr(inst, inst->segments[li].paddr + prog.file_size);
42012d34:	5c51                	li	s8,-12
    if (!kbelfx_seg_alloc(inst, inst->segments_len, inst->segments))
42012d36:	e509                	bnez	a0,42012d40 <kbelf_inst_load+0x38a>
42012d38:	a67d                	j	420130e6 <kbelf_inst_load+0x730>
    for (size_t i = 0, li = 0; li < loadable_len; i++) {
42012d3a:	0a05                	add	s4,s4,1
42012d3c:	1929f763          	bgeu	s3,s2,42012eca <kbelf_inst_load+0x514>
        if (!kbelf_file_prog_get(file, &prog, i))
42012d40:	8652                	mv	a2,s4
42012d42:	858a                	mv	a1,sp
42012d44:	8522                	mv	a0,s0
        kbelf_progheader prog = {.type = PT_UNUSED, .mem_size = 0};
42012d46:	c002                	sw	zero,0(sp)
42012d48:	c202                	sw	zero,4(sp)
42012d4a:	c402                	sw	zero,8(sp)
42012d4c:	c602                	sw	zero,12(sp)
42012d4e:	c802                	sw	zero,16(sp)
42012d50:	ca02                	sw	zero,20(sp)
42012d52:	cc02                	sw	zero,24(sp)
42012d54:	ce02                	sw	zero,28(sp)
        if (!kbelf_file_prog_get(file, &prog, i))
42012d56:	d5cff0ef          	jal	420122b2 <kbelf_file_prog_get>
42012d5a:	12050e63          	beqz	a0,42012e96 <kbelf_inst_load+0x4e0>
    return prog->type == PT_LOAD && prog->mem_size;
42012d5e:	4782                	lw	a5,0(sp)
42012d60:	fd779de3          	bne	a5,s7,42012d3a <kbelf_inst_load+0x384>
42012d64:	4cd2                	lw	s9,20(sp)
42012d66:	fc0c8ae3          	beqz	s9,42012d3a <kbelf_inst_load+0x384>
        if (prog.file_size) {
42012d6a:	4ac2                	lw	s5,16(sp)
42012d6c:	00299b13          	sll	s6,s3,0x2
42012d70:	020a9f63          	bnez	s5,42012dae <kbelf_inst_load+0x3f8>
            kbelf_laddr laddr = kbelf_inst_paddr_to_laddr(inst, inst->segments[li].paddr + prog.file_size);
42012d74:	4898                	lw	a4,16(s1)
42012d76:	9b4e                	add	s6,s6,s3
42012d78:	0b0e                	sll	s6,s6,0x3
42012d7a:	016707b3          	add	a5,a4,s6
42012d7e:	080b4363          	bltz	s6,42012e04 <kbelf_inst_load+0x44e>
42012d82:	e8e7e8e3          	bltu	a5,a4,42012c12 <kbelf_inst_load+0x25c>
42012d86:	e80786e3          	beqz	a5,42012c12 <kbelf_inst_load+0x25c>
42012d8a:	0037f713          	and	a4,a5,3
42012d8e:	e80712e3          	bnez	a4,42012c12 <kbelf_inst_load+0x25c>
42012d92:	e987f0e3          	bgeu	a5,s8,42012c12 <kbelf_inst_load+0x25c>
42012d96:	47cc                	lw	a1,12(a5)
42012d98:	8526                	mv	a0,s1
        li++;
42012d9a:	0985                	add	s3,s3,1
            kbelf_laddr laddr = kbelf_inst_paddr_to_laddr(inst, inst->segments[li].paddr + prog.file_size);
42012d9c:	95d6                	add	a1,a1,s5
42012d9e:	b61ff0ef          	jal	420128fe <kbelf_inst_paddr_to_laddr>
            kbelfq_memset((void *)laddr, 0, prog.mem_size - prog.file_size);
42012da2:	415c8633          	sub	a2,s9,s5
42012da6:	4581                	li	a1,0
42012da8:	ebff70ef          	jal	4200ac66 <kbelfq_memset>
        li++;
42012dac:	b779                	j	42012d3a <kbelf_inst_load+0x384>
            int res = kbelfx_seek(file->fd, (long)prog.offset);
42012dae:	4592                	lw	a1,4(sp)
42012db0:	4008                	lw	a0,0(s0)
42012db2:	9c2f80ef          	jal	4200af74 <kbelfx_seek>
            if (res < 0)
42012db6:	3a054963          	bltz	a0,42013168 <kbelf_inst_load+0x7b2>
            kbelf_laddr laddr = kbelf_inst_paddr_to_laddr(inst, inst->segments[li].paddr);
42012dba:	4894                	lw	a3,16(s1)
42012dbc:	00299b13          	sll	s6,s3,0x2
42012dc0:	013b0733          	add	a4,s6,s3
42012dc4:	070e                	sll	a4,a4,0x3
42012dc6:	00e687b3          	add	a5,a3,a4
42012dca:	04074063          	bltz	a4,42012e0a <kbelf_inst_load+0x454>
42012dce:	e4d7e2e3          	bltu	a5,a3,42012c12 <kbelf_inst_load+0x25c>
42012dd2:	e40780e3          	beqz	a5,42012c12 <kbelf_inst_load+0x25c>
42012dd6:	0037f713          	and	a4,a5,3
42012dda:	e2071ce3          	bnez	a4,42012c12 <kbelf_inst_load+0x25c>
42012dde:	e387fae3          	bgeu	a5,s8,42012c12 <kbelf_inst_load+0x25c>
42012de2:	47cc                	lw	a1,12(a5)
42012de4:	8526                	mv	a0,s1
42012de6:	b19ff0ef          	jal	420128fe <kbelf_inst_paddr_to_laddr>
42012dea:	85aa                	mv	a1,a0
            res               = kbelfx_read(file->fd, (void *)laddr, (long)prog.file_size);
42012dec:	4642                	lw	a2,16(sp)
42012dee:	4008                	lw	a0,0(s0)
42012df0:	96ef80ef          	jal	4200af5e <kbelfx_read>
            if (res < (int)prog.file_size)
42012df4:	4ac2                	lw	s5,16(sp)
42012df6:	35554463          	blt	a0,s5,4201313e <kbelf_inst_load+0x788>
        if (prog.file_size < prog.mem_size) {
42012dfa:	4cd2                	lw	s9,20(sp)
42012dfc:	f79aece3          	bltu	s5,s9,42012d74 <kbelf_inst_load+0x3be>
        li++;
42012e00:	0985                	add	s3,s3,1
42012e02:	bf25                	j	42012d3a <kbelf_inst_load+0x384>
            kbelf_laddr laddr = kbelf_inst_paddr_to_laddr(inst, inst->segments[li].paddr + prog.file_size);
42012e04:	f8f771e3          	bgeu	a4,a5,42012d86 <kbelf_inst_load+0x3d0>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012e08:	9002                	ebreak
            kbelf_laddr laddr = kbelf_inst_paddr_to_laddr(inst, inst->segments[li].paddr);
42012e0a:	fcf6f4e3          	bgeu	a3,a5,42012dd2 <kbelf_inst_load+0x41c>
        KBELF_ERROR(abort, "Invalid dynamic section")
42012e0e:	9002                	ebreak
            KBELF_ERROR(abort, "Unable to read program header " KBELF_FMT_SIZE, i)
42012e10:	62c40613          	add	a2,s0,1580
42012e14:	b949                	j	42012aa6 <kbelf_inst_load+0xf0>
            KBELF_ERROR(abort, "Invalid program header size")
42012e16:	4201b437          	lui	s0,0x4201b
42012e1a:	02f00593          	li	a1,47
42012e1e:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012e22:	e07f70ef          	jal	4200ac28 <kbelfq_strrchr>
42012e26:	c105                	beqz	a0,42012e46 <kbelf_inst_load+0x490>
42012e28:	57fd                	li	a5,-1
42012e2a:	00150613          	add	a2,a0,1
42012e2e:	def572e3          	bgeu	a0,a5,42012c12 <kbelf_inst_load+0x25c>
42012e32:	4201b5b7          	lui	a1,0x4201b
42012e36:	04f00693          	li	a3,79
42012e3a:	6d858593          	add	a1,a1,1752 # 4201b6d8 <hextab+0x4a0c>
42012e3e:	4505                	li	a0,1
42012e40:	c5af00ef          	jal	4200329a <logkf>
42012e44:	b5f1                	j	42012d10 <kbelf_inst_load+0x35a>
42012e46:	62c40613          	add	a2,s0,1580
42012e4a:	b7e5                	j	42012e32 <kbelf_inst_load+0x47c>
        KBELF_ERROR(abort, "Out of memory");
42012e4c:	4201b437          	lui	s0,0x4201b
42012e50:	02f00593          	li	a1,47
42012e54:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012e58:	dd1f70ef          	jal	4200ac28 <kbelfq_strrchr>
42012e5c:	28050263          	beqz	a0,420130e0 <kbelf_inst_load+0x72a>
42012e60:	57fd                	li	a5,-1
42012e62:	00150613          	add	a2,a0,1
42012e66:	42f57863          	bgeu	a0,a5,42013296 <kbelf_inst_load+0x8e0>
42012e6a:	4201b5b7          	lui	a1,0x4201b
42012e6e:	04400693          	li	a3,68
42012e72:	29858593          	add	a1,a1,664 # 4201b298 <hextab+0x45cc>
42012e76:	4505                	li	a0,1
42012e78:	c22f00ef          	jal	4200329a <logkf>
42012e7c:	4946                	lw	s2,80(sp)
42012e7e:	4a26                	lw	s4,72(sp)
42012e80:	4a96                	lw	s5,68(sp)
42012e82:	b93d                	j	42012ac0 <kbelf_inst_load+0x10a>
        KBELF_ERROR(abort, "Out of memory")
42012e84:	62c40613          	add	a2,s0,1580
42012e88:	bbd1                	j	42012c5c <kbelf_inst_load+0x2a6>
        KBELF_ERROR(abort, "Out of memory")
42012e8a:	62c40613          	add	a2,s0,1580
42012e8e:	b501                	j	42012c8e <kbelf_inst_load+0x2d8>
        KBELF_ERROR(abort, "No loadable segments")
42012e90:	62c40613          	add	a2,s0,1580
42012e94:	bd05                	j	42012cc4 <kbelf_inst_load+0x30e>
            KBELF_ERROR(abort, "Unable to read program header " KBELF_FMT_SIZE, i)
42012e96:	4201b437          	lui	s0,0x4201b
42012e9a:	02f00593          	li	a1,47
42012e9e:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012ea2:	d87f70ef          	jal	4200ac28 <kbelfq_strrchr>
42012ea6:	28050263          	beqz	a0,4201312a <kbelf_inst_load+0x774>
42012eaa:	57fd                	li	a5,-1
42012eac:	00150613          	add	a2,a0,1
42012eb0:	d6f571e3          	bgeu	a0,a5,42012c12 <kbelf_inst_load+0x25c>
42012eb4:	4201b5b7          	lui	a1,0x4201b
42012eb8:	8752                	mv	a4,s4
42012eba:	06600693          	li	a3,102
42012ebe:	69c58593          	add	a1,a1,1692 # 4201b69c <hextab+0x49d0>
42012ec2:	4505                	li	a0,1
42012ec4:	bd6f00ef          	jal	4200329a <logkf>
42012ec8:	b5a1                	j	42012d10 <kbelf_inst_load+0x35a>
42012eca:	5bf2                	lw	s7,60(sp)
42012ecc:	5c62                	lw	s8,56(sp)
42012ece:	5cd2                	lw	s9,52(sp)
42012ed0:	5d42                	lw	s10,48(sp)
42012ed2:	5db2                	lw	s11,44(sp)
    if (file->header.entry) {
42012ed4:	504c                	lw	a1,36(s0)
42012ed6:	c981                	beqz	a1,42012ee6 <kbelf_inst_load+0x530>
        inst->entry = kbelf_inst_getvaddr(inst, file->header.entry);
42012ed8:	8526                	mv	a0,s1
42012eda:	f48ff0ef          	jal	42012622 <kbelf_inst_getvaddr>
42012ede:	57b1                	li	a5,-20
42012ee0:	1ef4fa63          	bgeu	s1,a5,420130d4 <kbelf_inst_load+0x71e>
42012ee4:	c8c8                	sw	a0,20(s1)
    for (size_t i = 0; i < file->header.ph_ent_num; i++) {
42012ee6:	03845783          	lhu	a5,56(s0)
42012eea:	4901                	li	s2,0
        if (prog.type == PT_DYNAMIC) {
42012eec:	4989                	li	s3,2
    for (size_t i = 0; i < file->header.ph_ent_num; i++) {
42012eee:	eb91                	bnez	a5,42012f02 <kbelf_inst_load+0x54c>
42012ef0:	a061                	j	42012f78 <kbelf_inst_load+0x5c2>
        if (prog.type == PT_DYNAMIC) {
42012ef2:	4782                	lw	a5,0(sp)
42012ef4:	07378663          	beq	a5,s3,42012f60 <kbelf_inst_load+0x5aa>
    for (size_t i = 0; i < file->header.ph_ent_num; i++) {
42012ef8:	03845783          	lhu	a5,56(s0)
42012efc:	0905                	add	s2,s2,1
42012efe:	06f97d63          	bgeu	s2,a5,42012f78 <kbelf_inst_load+0x5c2>
        if (!kbelf_file_prog_get(file, &prog, i))
42012f02:	864a                	mv	a2,s2
42012f04:	858a                	mv	a1,sp
42012f06:	8522                	mv	a0,s0
        kbelf_progheader prog = {.type = PT_UNUSED, .mem_size = 0};
42012f08:	c002                	sw	zero,0(sp)
42012f0a:	c202                	sw	zero,4(sp)
42012f0c:	c402                	sw	zero,8(sp)
42012f0e:	c602                	sw	zero,12(sp)
42012f10:	c802                	sw	zero,16(sp)
42012f12:	ca02                	sw	zero,20(sp)
42012f14:	cc02                	sw	zero,24(sp)
42012f16:	ce02                	sw	zero,28(sp)
        if (!kbelf_file_prog_get(file, &prog, i))
42012f18:	b9aff0ef          	jal	420122b2 <kbelf_file_prog_get>
42012f1c:	f979                	bnez	a0,42012ef2 <kbelf_inst_load+0x53c>
            KBELF_ERROR(abort, "Unable to read program header " KBELF_FMT_SIZE, i)
42012f1e:	4201b437          	lui	s0,0x4201b
42012f22:	02f00593          	li	a1,47
42012f26:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42012f2a:	cfff70ef          	jal	4200ac28 <kbelfq_strrchr>
42012f2e:	2e050263          	beqz	a0,42013212 <kbelf_inst_load+0x85c>
42012f32:	57fd                	li	a5,-1
42012f34:	00150613          	add	a2,a0,1
42012f38:	18f57e63          	bgeu	a0,a5,420130d4 <kbelf_inst_load+0x71e>
42012f3c:	4201b5b7          	lui	a1,0x4201b
42012f40:	874a                	mv	a4,s2
42012f42:	08600693          	li	a3,134
42012f46:	69c58593          	add	a1,a1,1692 # 4201b69c <hextab+0x49d0>
42012f4a:	4505                	li	a0,1
42012f4c:	b4ef00ef          	jal	4200329a <logkf>
42012f50:	4946                	lw	s2,80(sp)
42012f52:	4a26                	lw	s4,72(sp)
42012f54:	4a96                	lw	s5,68(sp)
42012f56:	4b06                	lw	s6,64(sp)
42012f58:	b6a5                	j	42012ac0 <kbelf_inst_load+0x10a>
            KBELF_ERROR(abort, "Unable to read program header " KBELF_FMT_SIZE, i)
42012f5a:	62c40413          	add	s0,s0,1580
42012f5e:	bb71                	j	42012cfa <kbelf_inst_load+0x344>
            inst->dynamic     = (void *)kbelf_inst_getladdr(inst, prog.vaddr);
42012f60:	45a2                	lw	a1,8(sp)
42012f62:	8526                	mv	a0,s1
42012f64:	d4eff0ef          	jal	420124b2 <kbelf_inst_getladdr>
42012f68:	fc400793          	li	a5,-60
42012f6c:	16f4f463          	bgeu	s1,a5,420130d4 <kbelf_inst_load+0x71e>
            inst->dynamic_len = prog.mem_size / sizeof(kbelf_dynentry);
42012f70:	47d2                	lw	a5,20(sp)
            inst->dynamic     = (void *)kbelf_inst_getladdr(inst, prog.vaddr);
42012f72:	dcc8                	sw	a0,60(s1)
            inst->dynamic_len = prog.mem_size / sizeof(kbelf_dynentry);
42012f74:	838d                	srl	a5,a5,0x3
42012f76:	dc9c                	sw	a5,56(s1)
    if (!inst->dynamic && inst->dynamic_len)
42012f78:	fc400793          	li	a5,-60
42012f7c:	14f4fc63          	bgeu	s1,a5,420130d4 <kbelf_inst_load+0x71e>
42012f80:	03c4a983          	lw	s3,60(s1)
42012f84:	0384aa83          	lw	s5,56(s1)
42012f88:	20098863          	beqz	s3,42013198 <kbelf_inst_load+0x7e2>
    for (size_t i = 0; i < inst->dynamic_len; i++) {
42012f8c:	844e                	mv	s0,s3
42012f8e:	4901                	li	s2,0
42012f90:	040a8a63          	beqz	s5,42012fe4 <kbelf_inst_load+0x62e>
42012f94:	42017a37          	lui	s4,0x42017
42012f98:	02100b13          	li	s6,33
42012f9c:	ce0a0a13          	add	s4,s4,-800 # 42016ce0 <hextab+0x14>
        kbelf_dynentry dt = inst->dynamic[i];
42012fa0:	00391793          	sll	a5,s2,0x3
42012fa4:	00f98733          	add	a4,s3,a5
42012fa8:	1207c463          	bltz	a5,420130d0 <kbelf_inst_load+0x71a>
42012fac:	13376463          	bltu	a4,s3,420130d4 <kbelf_inst_load+0x71e>
42012fb0:	12040263          	beqz	s0,420130d4 <kbelf_inst_load+0x71e>
42012fb4:	00347793          	and	a5,s0,3
42012fb8:	10079e63          	bnez	a5,420130d4 <kbelf_inst_load+0x71e>
42012fbc:	401c                	lw	a5,0(s0)
42012fbe:	404c                	lw	a1,4(s0)
        if (dt.tag == DT_NULL) {
42012fc0:	00fb6e63          	bltu	s6,a5,42012fdc <kbelf_inst_load+0x626>
42012fc4:	078a                	sll	a5,a5,0x2
42012fc6:	97d2                	add	a5,a5,s4
42012fc8:	439c                	lw	a5,0(a5)
42012fca:	8782                	jr	a5
            inst->dynsym = (void *)kbelf_inst_getladdr(inst, dt.value);
42012fcc:	8526                	mv	a0,s1
42012fce:	ce4ff0ef          	jal	420124b2 <kbelf_inst_getladdr>
42012fd2:	fb400793          	li	a5,-76
42012fd6:	0ef4ff63          	bgeu	s1,a5,420130d4 <kbelf_inst_load+0x71e>
42012fda:	c4e8                	sw	a0,76(s1)
    for (size_t i = 0; i < inst->dynamic_len; i++) {
42012fdc:	0905                	add	s2,s2,1
42012fde:	0421                	add	s0,s0,8
42012fe0:	fd5910e3          	bne	s2,s5,42012fa0 <kbelf_inst_load+0x5ea>
    if (!!inst->dynsym ^ !!inst->dynsym_len)
42012fe4:	fb400793          	li	a5,-76
42012fe8:	0ef4f663          	bgeu	s1,a5,420130d4 <kbelf_inst_load+0x71e>
42012fec:	44f8                	lw	a4,76(s1)
42012fee:	44bc                	lw	a5,72(s1)
42012ff0:	00e03733          	snez	a4,a4
42012ff4:	00f037b3          	snez	a5,a5
42012ff8:	1af71363          	bne	a4,a5,4201319e <kbelf_inst_load+0x7e8>
    if (!!inst->dynstr ^ !!inst->dynstr_len)
42012ffc:	40f8                	lw	a4,68(s1)
42012ffe:	40bc                	lw	a5,64(s1)
42013000:	00e03733          	snez	a4,a4
42013004:	00f037b3          	snez	a5,a5
42013008:	1cf71063          	bne	a4,a5,420131c8 <kbelf_inst_load+0x812>
    if (!!inst->init_array ^ !!inst->init_array_len)
4201300c:	54d8                	lw	a4,44(s1)
4201300e:	549c                	lw	a5,40(s1)
42013010:	00e03733          	snez	a4,a4
42013014:	00f037b3          	snez	a5,a5
42013018:	1cf71c63          	bne	a4,a5,420131f0 <kbelf_inst_load+0x83a>
    if (!!inst->fini_array ^ !!inst->fini_array_len)
4201301c:	58d8                	lw	a4,52(s1)
4201301e:	589c                	lw	a5,48(s1)
42013020:	00e03733          	snez	a4,a4
42013024:	00f037b3          	snez	a5,a5
42013028:	1ef71e63          	bne	a4,a5,42013224 <kbelf_inst_load+0x86e>
    if (!!inst->preinit_array ^ !!inst->preinit_array_len)
4201302c:	50d8                	lw	a4,36(s1)
4201302e:	509c                	lw	a5,32(s1)
42013030:	00e03733          	snez	a4,a4
42013034:	00f037b3          	snez	a5,a5
42013038:	20f71f63          	bne	a4,a5,42013256 <kbelf_inst_load+0x8a0>
4201303c:	4946                	lw	s2,80(sp)
4201303e:	4a26                	lw	s4,72(sp)
42013040:	4a96                	lw	s5,68(sp)
42013042:	4b06                	lw	s6,64(sp)
42013044:	b451                	j	42012ac8 <kbelf_inst_load+0x112>
            inst->preinit_array_len = dt.value / sizeof(kbelf_addr);
42013046:	8189                	srl	a1,a1,0x2
42013048:	d08c                	sw	a1,32(s1)
4201304a:	bf49                	j	42012fdc <kbelf_inst_load+0x626>
            inst->init_array = kbelf_inst_getvaddr(inst, dt.value);
4201304c:	8526                	mv	a0,s1
4201304e:	dd4ff0ef          	jal	42012622 <kbelf_inst_getvaddr>
42013052:	d4c8                	sw	a0,44(s1)
42013054:	b761                	j	42012fdc <kbelf_inst_load+0x626>
            inst->fini_func = kbelf_inst_getvaddr(inst, dt.value);
42013056:	8526                	mv	a0,s1
42013058:	dcaff0ef          	jal	42012622 <kbelf_inst_getvaddr>
4201305c:	ccc8                	sw	a0,28(s1)
4201305e:	bfbd                	j	42012fdc <kbelf_inst_load+0x626>
            inst->init_func = kbelf_inst_getvaddr(inst, dt.value);
42013060:	8526                	mv	a0,s1
42013062:	dc0ff0ef          	jal	42012622 <kbelf_inst_getvaddr>
42013066:	cc88                	sw	a0,24(s1)
42013068:	bf95                	j	42012fdc <kbelf_inst_load+0x626>
            inst->dynstr_len = dt.value;
4201306a:	fc000793          	li	a5,-64
4201306e:	06f4f363          	bgeu	s1,a5,420130d4 <kbelf_inst_load+0x71e>
42013072:	c0ac                	sw	a1,64(s1)
42013074:	b7a5                	j	42012fdc <kbelf_inst_load+0x626>
            inst->dynstr = (void *)kbelf_inst_getladdr(inst, dt.value);
42013076:	8526                	mv	a0,s1
42013078:	c3aff0ef          	jal	420124b2 <kbelf_inst_getladdr>
4201307c:	fbc00793          	li	a5,-68
42013080:	04f4fa63          	bgeu	s1,a5,420130d4 <kbelf_inst_load+0x71e>
42013084:	c0e8                	sw	a0,68(s1)
42013086:	bf99                	j	42012fdc <kbelf_inst_load+0x626>
            kbelf_addr *addr = (void *)kbelf_inst_getladdr(inst, dt.value);
42013088:	8526                	mv	a0,s1
4201308a:	c28ff0ef          	jal	420124b2 <kbelf_inst_getladdr>
            if (addr != NULL)
4201308e:	d539                	beqz	a0,42012fdc <kbelf_inst_load+0x626>
                inst->dynsym_len = addr[1];
42013090:	00357793          	and	a5,a0,3
42013094:	e3a1                	bnez	a5,420130d4 <kbelf_inst_load+0x71e>
42013096:	57f1                	li	a5,-4
42013098:	02f57e63          	bgeu	a0,a5,420130d4 <kbelf_inst_load+0x71e>
4201309c:	fb800713          	li	a4,-72
420130a0:	415c                	lw	a5,4(a0)
420130a2:	02e4f963          	bgeu	s1,a4,420130d4 <kbelf_inst_load+0x71e>
420130a6:	c4bc                	sw	a5,72(s1)
420130a8:	bf15                	j	42012fdc <kbelf_inst_load+0x626>
            inst->dynamic_len = i;
420130aa:	0324ac23          	sw	s2,56(s1)
            break;
420130ae:	bf1d                	j	42012fe4 <kbelf_inst_load+0x62e>
            inst->preinit_array = kbelf_inst_getvaddr(inst, dt.value);
420130b0:	8526                	mv	a0,s1
420130b2:	d70ff0ef          	jal	42012622 <kbelf_inst_getvaddr>
420130b6:	d0c8                	sw	a0,36(s1)
420130b8:	b715                	j	42012fdc <kbelf_inst_load+0x626>
            inst->fini_array_len = dt.value / sizeof(kbelf_addr);
420130ba:	8189                	srl	a1,a1,0x2
420130bc:	d88c                	sw	a1,48(s1)
420130be:	bf39                	j	42012fdc <kbelf_inst_load+0x626>
            inst->init_array_len = dt.value / sizeof(kbelf_addr);
420130c0:	8189                	srl	a1,a1,0x2
420130c2:	d48c                	sw	a1,40(s1)
420130c4:	bf21                	j	42012fdc <kbelf_inst_load+0x626>
            inst->fini_array = kbelf_inst_getvaddr(inst, dt.value);
420130c6:	8526                	mv	a0,s1
420130c8:	d5aff0ef          	jal	42012622 <kbelf_inst_getvaddr>
420130cc:	d8c8                	sw	a0,52(s1)
420130ce:	b739                	j	42012fdc <kbelf_inst_load+0x626>
        kbelf_dynentry dt = inst->dynamic[i];
420130d0:	eee9f0e3          	bgeu	s3,a4,42012fb0 <kbelf_inst_load+0x5fa>
420130d4:	de5e                	sw	s7,60(sp)
420130d6:	dc62                	sw	s8,56(sp)
420130d8:	da66                	sw	s9,52(sp)
420130da:	d86a                	sw	s10,48(sp)
420130dc:	d66e                	sw	s11,44(sp)
        KBELF_ERROR(abort, "Invalid dynamic section")
420130de:	9002                	ebreak
        KBELF_ERROR(abort, "Out of memory");
420130e0:	62c40613          	add	a2,s0,1580
420130e4:	b359                	j	42012e6a <kbelf_inst_load+0x4b4>
420130e6:	5bf2                	lw	s7,60(sp)
420130e8:	5c62                	lw	s8,56(sp)
420130ea:	5cd2                	lw	s9,52(sp)
420130ec:	5d42                	lw	s10,48(sp)
420130ee:	5db2                	lw	s11,44(sp)
        KBELF_ERROR(abort, "Out of virtual memory")
420130f0:	4201b437          	lui	s0,0x4201b
420130f4:	02f00593          	li	a1,47
420130f8:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
420130fc:	b2df70ef          	jal	4200ac28 <kbelfq_strrchr>
42013100:	0e050563          	beqz	a0,420131ea <kbelf_inst_load+0x834>
42013104:	57fd                	li	a5,-1
42013106:	00150613          	add	a2,a0,1
4201310a:	fcf575e3          	bgeu	a0,a5,420130d4 <kbelf_inst_load+0x71e>
4201310e:	4201b5b7          	lui	a1,0x4201b
42013112:	06000693          	li	a3,96
42013116:	70858593          	add	a1,a1,1800 # 4201b708 <hextab+0x4a3c>
        KBELF_ERROR(abort, "Invalid dynamic section")
4201311a:	4505                	li	a0,1
4201311c:	97ef00ef          	jal	4200329a <logkf>
42013120:	4946                	lw	s2,80(sp)
42013122:	4a26                	lw	s4,72(sp)
42013124:	4a96                	lw	s5,68(sp)
42013126:	4b06                	lw	s6,64(sp)
42013128:	ba61                	j	42012ac0 <kbelf_inst_load+0x10a>
            KBELF_ERROR(abort, "Unable to read program header " KBELF_FMT_SIZE, i)
4201312a:	62c40613          	add	a2,s0,1580
4201312e:	b359                	j	42012eb4 <kbelf_inst_load+0x4fe>
    if (!kbelfx_seg_alloc(inst, inst->segments_len, inst->segments))
42013130:	4890                	lw	a2,16(s1)
42013132:	44cc                	lw	a1,12(s1)
42013134:	8526                	mv	a0,s1
42013136:	b45f70ef          	jal	4200ac7a <kbelfx_seg_alloc>
4201313a:	d95d                	beqz	a0,420130f0 <kbelf_inst_load+0x73a>
4201313c:	bb61                	j	42012ed4 <kbelf_inst_load+0x51e>
                KBELF_ERROR(abort, "I/O error");
4201313e:	4201b437          	lui	s0,0x4201b
42013142:	02f00593          	li	a1,47
42013146:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
4201314a:	adff70ef          	jal	4200ac28 <kbelfq_strrchr>
4201314e:	c569                	beqz	a0,42013218 <kbelf_inst_load+0x862>
42013150:	577d                	li	a4,-1
42013152:	00150613          	add	a2,a0,1
42013156:	aae57ee3          	bgeu	a0,a4,42012c12 <kbelf_inst_load+0x25c>
4201315a:	4201b5b7          	lui	a1,0x4201b
4201315e:	07200693          	li	a3,114
42013162:	73458593          	add	a1,a1,1844 # 4201b734 <hextab+0x4a68>
42013166:	b9e1                	j	42012e3e <kbelf_inst_load+0x488>
                KBELF_ERROR(abort, "I/O error");
42013168:	4201b437          	lui	s0,0x4201b
4201316c:	02f00593          	li	a1,47
42013170:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42013174:	ab5f70ef          	jal	4200ac28 <kbelfq_strrchr>
42013178:	c15d                	beqz	a0,4201321e <kbelf_inst_load+0x868>
4201317a:	577d                	li	a4,-1
4201317c:	00150613          	add	a2,a0,1
42013180:	a8e579e3          	bgeu	a0,a4,42012c12 <kbelf_inst_load+0x25c>
42013184:	4201b5b7          	lui	a1,0x4201b
42013188:	06e00693          	li	a3,110
4201318c:	73458593          	add	a1,a1,1844 # 4201b734 <hextab+0x4a68>
42013190:	4505                	li	a0,1
42013192:	908f00ef          	jal	4200329a <logkf>
42013196:	bead                	j	42012d10 <kbelf_inst_load+0x35a>
    if (!inst->dynamic && inst->dynamic_len)
42013198:	e40a86e3          	beqz	s5,42012fe4 <kbelf_inst_load+0x62e>
4201319c:	bf25                	j	420130d4 <kbelf_inst_load+0x71e>
        KBELF_ERROR(abort, "Invalid dynamic section")
4201319e:	4201b437          	lui	s0,0x4201b
420131a2:	02f00593          	li	a1,47
420131a6:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
420131aa:	a7ff70ef          	jal	4200ac28 <kbelfq_strrchr>
420131ae:	cd41                	beqz	a0,42013246 <kbelf_inst_load+0x890>
420131b0:	577d                	li	a4,-1
420131b2:	00150613          	add	a2,a0,1
420131b6:	f0e57fe3          	bgeu	a0,a4,420130d4 <kbelf_inst_load+0x71e>
420131ba:	0b500693          	li	a3,181
        KBELF_ERROR(abort, "Invalid dynamic section")
420131be:	4201b5b7          	lui	a1,0x4201b
420131c2:	75458593          	add	a1,a1,1876 # 4201b754 <hextab+0x4a88>
420131c6:	bf91                	j	4201311a <kbelf_inst_load+0x764>
        KBELF_ERROR(abort, "Invalid dynamic section")
420131c8:	4201b437          	lui	s0,0x4201b
420131cc:	02f00593          	li	a1,47
420131d0:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
420131d4:	a55f70ef          	jal	4200ac28 <kbelfq_strrchr>
420131d8:	c935                	beqz	a0,4201324c <kbelf_inst_load+0x896>
420131da:	577d                	li	a4,-1
420131dc:	00150613          	add	a2,a0,1
420131e0:	eee57ae3          	bgeu	a0,a4,420130d4 <kbelf_inst_load+0x71e>
420131e4:	0b700693          	li	a3,183
420131e8:	bfd9                	j	420131be <kbelf_inst_load+0x808>
        KBELF_ERROR(abort, "Out of virtual memory")
420131ea:	62c40613          	add	a2,s0,1580
420131ee:	b705                	j	4201310e <kbelf_inst_load+0x758>
        KBELF_ERROR(abort, "Invalid dynamic section")
420131f0:	4201b437          	lui	s0,0x4201b
420131f4:	02f00593          	li	a1,47
420131f8:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
420131fc:	a2df70ef          	jal	4200ac28 <kbelfq_strrchr>
42013200:	cd25                	beqz	a0,42013278 <kbelf_inst_load+0x8c2>
42013202:	577d                	li	a4,-1
42013204:	00150613          	add	a2,a0,1
42013208:	ece576e3          	bgeu	a0,a4,420130d4 <kbelf_inst_load+0x71e>
4201320c:	0b900693          	li	a3,185
42013210:	b77d                	j	420131be <kbelf_inst_load+0x808>
            KBELF_ERROR(abort, "Unable to read program header " KBELF_FMT_SIZE, i)
42013212:	62c40613          	add	a2,s0,1580
42013216:	b31d                	j	42012f3c <kbelf_inst_load+0x586>
                KBELF_ERROR(abort, "I/O error");
42013218:	62c40613          	add	a2,s0,1580
4201321c:	bf3d                	j	4201315a <kbelf_inst_load+0x7a4>
                KBELF_ERROR(abort, "I/O error");
4201321e:	62c40613          	add	a2,s0,1580
42013222:	b78d                	j	42013184 <kbelf_inst_load+0x7ce>
        KBELF_ERROR(abort, "Invalid dynamic section")
42013224:	4201b437          	lui	s0,0x4201b
42013228:	02f00593          	li	a1,47
4201322c:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42013230:	9f9f70ef          	jal	4200ac28 <kbelfq_strrchr>
42013234:	cd21                	beqz	a0,4201328c <kbelf_inst_load+0x8d6>
42013236:	577d                	li	a4,-1
42013238:	00150613          	add	a2,a0,1
4201323c:	e8e57ce3          	bgeu	a0,a4,420130d4 <kbelf_inst_load+0x71e>
42013240:	0bb00693          	li	a3,187
42013244:	bfad                	j	420131be <kbelf_inst_load+0x808>
        KBELF_ERROR(abort, "Invalid dynamic section")
42013246:	62c40613          	add	a2,s0,1580
4201324a:	bf85                	j	420131ba <kbelf_inst_load+0x804>
        KBELF_ERROR(abort, "Invalid dynamic section")
4201324c:	62c40613          	add	a2,s0,1580
42013250:	0b700693          	li	a3,183
42013254:	b7ad                	j	420131be <kbelf_inst_load+0x808>
        KBELF_ERROR(abort, "Invalid dynamic section")
42013256:	4201b437          	lui	s0,0x4201b
4201325a:	02f00593          	li	a1,47
4201325e:	62c40513          	add	a0,s0,1580 # 4201b62c <hextab+0x4960>
42013262:	9c7f70ef          	jal	4200ac28 <kbelfq_strrchr>
42013266:	cd11                	beqz	a0,42013282 <kbelf_inst_load+0x8cc>
42013268:	577d                	li	a4,-1
4201326a:	00150613          	add	a2,a0,1
4201326e:	e6e573e3          	bgeu	a0,a4,420130d4 <kbelf_inst_load+0x71e>
42013272:	0bd00693          	li	a3,189
42013276:	b7a1                	j	420131be <kbelf_inst_load+0x808>
        KBELF_ERROR(abort, "Invalid dynamic section")
42013278:	62c40613          	add	a2,s0,1580
4201327c:	0b900693          	li	a3,185
42013280:	bf3d                	j	420131be <kbelf_inst_load+0x808>
        KBELF_ERROR(abort, "Invalid dynamic section")
42013282:	62c40613          	add	a2,s0,1580
42013286:	0bd00693          	li	a3,189
4201328a:	bf15                	j	420131be <kbelf_inst_load+0x808>
        KBELF_ERROR(abort, "Invalid dynamic section")
4201328c:	62c40613          	add	a2,s0,1580
42013290:	0bb00693          	li	a3,187
42013294:	b72d                	j	420131be <kbelf_inst_load+0x808>
42013296:	c0da                	sw	s6,64(sp)
42013298:	bd35                	j	420130d4 <kbelf_inst_load+0x71e>
4201329a:	c8ca                	sw	s2,80(sp)
4201329c:	c4d2                	sw	s4,72(sp)
4201329e:	83dff06f          	j	42012ada <kbelf_inst_load+0x124>

420132a2 <kbelf_inst_laddr_to_vaddr>:

// Translate a load address in a loaded instance to a virtual address in a loaded instance.
kbelf_addr kbelf_inst_laddr_to_vaddr(kbelf_inst inst, kbelf_laddr laddr) {
    if (!inst)
420132a2:	c925                	beqz	a0,42013312 <kbelf_inst_laddr_to_vaddr+0x70>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
420132a4:	00357793          	and	a5,a0,3
420132a8:	ebad                	bnez	a5,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132aa:	57d1                	li	a5,-12
420132ac:	06f57763          	bgeu	a0,a5,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132b0:	00c52303          	lw	t1,12(a0)
420132b4:	04030f63          	beqz	t1,42013312 <kbelf_inst_laddr_to_vaddr+0x70>
420132b8:	4681                	li	a3,0
420132ba:	4601                	li	a2,0
        if (laddr >= inst->segments[i].laddr && laddr < inst->segments[i].laddr + inst->segments[i].size) {
420132bc:	5ec1                	li	t4,-16
420132be:	5e61                	li	t3,-8
420132c0:	5f21                	li	t5,-24
420132c2:	05d57c63          	bgeu	a0,t4,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132c6:	4918                	lw	a4,16(a0)
420132c8:	00d707b3          	add	a5,a4,a3
420132cc:	0406c563          	bltz	a3,42013316 <kbelf_inst_laddr_to_vaddr+0x74>
420132d0:	04e7e563          	bltu	a5,a4,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132d4:	c3b9                	beqz	a5,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132d6:	0037f813          	and	a6,a5,3
420132da:	04081063          	bnez	a6,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132de:	03c7fe63          	bgeu	a5,t3,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132e2:	0087a803          	lw	a6,8(a5)
420132e6:	0305e163          	bltu	a1,a6,42013308 <kbelf_inst_laddr_to_vaddr+0x66>
420132ea:	0206cc63          	bltz	a3,42013322 <kbelf_inst_laddr_to_vaddr+0x80>
420132ee:	02e7e663          	bltu	a5,a4,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132f2:	0206c563          	bltz	a3,4201331c <kbelf_inst_laddr_to_vaddr+0x7a>
420132f6:	02e7e263          	bltu	a5,a4,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132fa:	03e7f063          	bgeu	a5,t5,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
420132fe:	0187a883          	lw	a7,24(a5)
42013302:	98c2                	add	a7,a7,a6
42013304:	0315e263          	bltu	a1,a7,42013328 <kbelf_inst_laddr_to_vaddr+0x86>
    for (size_t i = 0; i < inst->segments_len; i++) {
42013308:	0605                	add	a2,a2,1
4201330a:	02868693          	add	a3,a3,40
4201330e:	fa661ae3          	bne	a2,t1,420132c2 <kbelf_inst_laddr_to_vaddr+0x20>
        return 0;
42013312:	4501                	li	a0,0
            return (kbelf_addr)laddr - (kbelf_addr)inst->segments[i].laddr + inst->segments[i].vaddr_real;
        }
    }
    return 0;
}
42013314:	8082                	ret
        if (laddr >= inst->segments[i].laddr && laddr < inst->segments[i].laddr + inst->segments[i].size) {
42013316:	faf77fe3          	bgeu	a4,a5,420132d4 <kbelf_inst_laddr_to_vaddr+0x32>
            return (kbelf_addr)laddr - (kbelf_addr)inst->segments[i].laddr + inst->segments[i].vaddr_real;
4201331a:	9002                	ebreak
        if (laddr >= inst->segments[i].laddr && laddr < inst->segments[i].laddr + inst->segments[i].size) {
4201331c:	fcf77fe3          	bgeu	a4,a5,420132fa <kbelf_inst_laddr_to_vaddr+0x58>
            return (kbelf_addr)laddr - (kbelf_addr)inst->segments[i].laddr + inst->segments[i].vaddr_real;
42013320:	9002                	ebreak
        if (laddr >= inst->segments[i].laddr && laddr < inst->segments[i].laddr + inst->segments[i].size) {
42013322:	fcf778e3          	bgeu	a4,a5,420132f2 <kbelf_inst_laddr_to_vaddr+0x50>
            return (kbelf_addr)laddr - (kbelf_addr)inst->segments[i].laddr + inst->segments[i].vaddr_real;
42013326:	9002                	ebreak
42013328:	0206d463          	bgez	a3,42013350 <kbelf_inst_laddr_to_vaddr+0xae>
4201332c:	fef767e3          	bltu	a4,a5,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
42013330:	0006d963          	bgez	a3,42013342 <kbelf_inst_laddr_to_vaddr+0xa0>
42013334:	fef763e3          	bltu	a4,a5,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
42013338:	4b9c                	lw	a5,16(a5)
4201333a:	95be                	add	a1,a1,a5
4201333c:	41058533          	sub	a0,a1,a6
42013340:	8082                	ret
42013342:	fce7ece3          	bltu	a5,a4,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
42013346:	4b9c                	lw	a5,16(a5)
42013348:	95be                	add	a1,a1,a5
4201334a:	41058533          	sub	a0,a1,a6
4201334e:	8082                	ret
42013350:	fce7e5e3          	bltu	a5,a4,4201331a <kbelf_inst_laddr_to_vaddr+0x78>
42013354:	fe06c0e3          	bltz	a3,42013334 <kbelf_inst_laddr_to_vaddr+0x92>
42013358:	b7ed                	j	42013342 <kbelf_inst_laddr_to_vaddr+0xa0>

4201335a <kbelf_inst_laddr_to_paddr>:

// Translate a load address in a loaded instance to a physical address in a loaded instance.
kbelf_addr kbelf_inst_laddr_to_paddr(kbelf_inst inst, kbelf_laddr laddr) {
    if (!inst)
4201335a:	c925                	beqz	a0,420133ca <kbelf_inst_laddr_to_paddr+0x70>
        return 0;
    for (size_t i = 0; i < inst->segments_len; i++) {
4201335c:	00357793          	and	a5,a0,3
42013360:	ebad                	bnez	a5,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
42013362:	57d1                	li	a5,-12
42013364:	06f57763          	bgeu	a0,a5,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
42013368:	00c52303          	lw	t1,12(a0)
4201336c:	04030f63          	beqz	t1,420133ca <kbelf_inst_laddr_to_paddr+0x70>
42013370:	4681                	li	a3,0
42013372:	4601                	li	a2,0
        if (laddr >= inst->segments[i].laddr && laddr < inst->segments[i].laddr + inst->segments[i].size) {
42013374:	5ec1                	li	t4,-16
42013376:	5e61                	li	t3,-8
42013378:	5f21                	li	t5,-24
4201337a:	05d57c63          	bgeu	a0,t4,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
4201337e:	4918                	lw	a4,16(a0)
42013380:	00d707b3          	add	a5,a4,a3
42013384:	0406c563          	bltz	a3,420133ce <kbelf_inst_laddr_to_paddr+0x74>
42013388:	04e7e563          	bltu	a5,a4,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
4201338c:	c3b9                	beqz	a5,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
4201338e:	0037f813          	and	a6,a5,3
42013392:	04081063          	bnez	a6,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
42013396:	03c7fe63          	bgeu	a5,t3,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
4201339a:	0087a803          	lw	a6,8(a5)
4201339e:	0305e163          	bltu	a1,a6,420133c0 <kbelf_inst_laddr_to_paddr+0x66>
420133a2:	0206cc63          	bltz	a3,420133da <kbelf_inst_laddr_to_paddr+0x80>
420133a6:	02e7e663          	bltu	a5,a4,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
420133aa:	0206c563          	bltz	a3,420133d4 <kbelf_inst_laddr_to_paddr+0x7a>
420133ae:	02e7e263          	bltu	a5,a4,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
420133b2:	03e7f063          	bgeu	a5,t5,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
420133b6:	0187a883          	lw	a7,24(a5)
420133ba:	98c2                	add	a7,a7,a6
420133bc:	0315e263          	bltu	a1,a7,420133e0 <kbelf_inst_laddr_to_paddr+0x86>
    for (size_t i = 0; i < inst->segments_len; i++) {
420133c0:	0605                	add	a2,a2,1
420133c2:	02868693          	add	a3,a3,40
420133c6:	fa661ae3          	bne	a2,t1,4201337a <kbelf_inst_laddr_to_paddr+0x20>
        return 0;
420133ca:	4501                	li	a0,0
            return (kbelf_addr)laddr - (kbelf_addr)inst->segments[i].laddr + inst->segments[i].paddr;
        }
    }
    return 0;
}
420133cc:	8082                	ret
        if (laddr >= inst->segments[i].laddr && laddr < inst->segments[i].laddr + inst->segments[i].size) {
420133ce:	faf77fe3          	bgeu	a4,a5,4201338c <kbelf_inst_laddr_to_paddr+0x32>
            return (kbelf_addr)laddr - (kbelf_addr)inst->segments[i].laddr + inst->segments[i].paddr;
420133d2:	9002                	ebreak
        if (laddr >= inst->segments[i].laddr && laddr < inst->segments[i].laddr + inst->segments[i].size) {
420133d4:	fcf77fe3          	bgeu	a4,a5,420133b2 <kbelf_inst_laddr_to_paddr+0x58>
            return (kbelf_addr)laddr - (kbelf_addr)inst->segments[i].laddr + inst->segments[i].paddr;
420133d8:	9002                	ebreak
        if (laddr >= inst->segments[i].laddr && laddr < inst->segments[i].laddr + inst->segments[i].size) {
420133da:	fcf778e3          	bgeu	a4,a5,420133aa <kbelf_inst_laddr_to_paddr+0x50>
            return (kbelf_addr)laddr - (kbelf_addr)inst->segments[i].laddr + inst->segments[i].paddr;
420133de:	9002                	ebreak
420133e0:	0206d463          	bgez	a3,42013408 <kbelf_inst_laddr_to_paddr+0xae>
420133e4:	fef767e3          	bltu	a4,a5,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
420133e8:	0006d963          	bgez	a3,420133fa <kbelf_inst_laddr_to_paddr+0xa0>
420133ec:	fef763e3          	bltu	a4,a5,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
420133f0:	47dc                	lw	a5,12(a5)
420133f2:	95be                	add	a1,a1,a5
420133f4:	41058533          	sub	a0,a1,a6
420133f8:	8082                	ret
420133fa:	fce7ece3          	bltu	a5,a4,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
420133fe:	47dc                	lw	a5,12(a5)
42013400:	95be                	add	a1,a1,a5
42013402:	41058533          	sub	a0,a1,a6
42013406:	8082                	ret
42013408:	fce7e5e3          	bltu	a5,a4,420133d2 <kbelf_inst_laddr_to_paddr+0x78>
4201340c:	fe06c0e3          	bltz	a3,420133ec <kbelf_inst_laddr_to_paddr+0x92>
42013410:	b7ed                	j	420133fa <kbelf_inst_laddr_to_paddr+0xa0>

42013412 <kbelf_inst_entrypoint>:


// Get the entrypoint address of a loaded instance.
kbelf_addr kbelf_inst_entrypoint(kbelf_inst inst) {
    return inst ? inst->entry : 0;
42013412:	c909                	beqz	a0,42013424 <kbelf_inst_entrypoint+0x12>
42013414:	00357793          	and	a5,a0,3
42013418:	eb81                	bnez	a5,42013428 <kbelf_inst_entrypoint+0x16>
4201341a:	57b1                	li	a5,-20
4201341c:	00f57663          	bgeu	a0,a5,42013428 <kbelf_inst_entrypoint+0x16>
42013420:	4948                	lw	a0,20(a0)
42013422:	8082                	ret
42013424:	4501                	li	a0,0
}
42013426:	8082                	ret
    return inst ? inst->entry : 0;
42013428:	9002                	ebreak

4201342a <kbelf_inst_preinit_len>:

// Get the number of pre-initialisation functions.
size_t kbelf_inst_preinit_len(kbelf_inst inst) {
    return inst ? inst->preinit_array_len : 0;
4201342a:	c909                	beqz	a0,4201343c <kbelf_inst_preinit_len+0x12>
4201342c:	00357793          	and	a5,a0,3
42013430:	eb81                	bnez	a5,42013440 <kbelf_inst_preinit_len+0x16>
42013432:	5781                	li	a5,-32
42013434:	00f57663          	bgeu	a0,a5,42013440 <kbelf_inst_preinit_len+0x16>
42013438:	5108                	lw	a0,32(a0)
4201343a:	8082                	ret
4201343c:	4501                	li	a0,0
}
4201343e:	8082                	ret
    return inst ? inst->preinit_array_len : 0;
42013440:	9002                	ebreak

42013442 <kbelf_inst_preinit_get>:

// Get virtual pre-initialisation function address of a loaded instance.
kbelf_addr kbelf_inst_preinit_get(kbelf_inst inst, size_t index) {
    if (!inst)
42013442:	cd31                	beqz	a0,4201349e <kbelf_inst_preinit_get+0x5c>
kbelf_addr kbelf_inst_preinit_get(kbelf_inst inst, size_t index) {
42013444:	1141                	add	sp,sp,-16
42013446:	c422                	sw	s0,8(sp)
42013448:	c606                	sw	ra,12(sp)
4201344a:	c226                	sw	s1,4(sp)
        return 0;
    kbelf_addr *arr = (void *)kbelf_inst_vaddr_to_laddr(inst, inst->preinit_array);
4201344c:	00357793          	and	a5,a0,3
42013450:	842a                	mv	s0,a0
42013452:	eba9                	bnez	a5,420134a4 <kbelf_inst_preinit_get+0x62>
42013454:	fdc00793          	li	a5,-36
42013458:	04f57563          	bgeu	a0,a5,420134a2 <kbelf_inst_preinit_get+0x60>
4201345c:	84ae                	mv	s1,a1
4201345e:	514c                	lw	a1,36(a0)
42013460:	b30ff0ef          	jal	42012790 <kbelf_inst_vaddr_to_laddr>
    return index < inst->preinit_array_len ? arr[index] : 0;
42013464:	501c                	lw	a5,32(s0)
42013466:	02f4f363          	bgeu	s1,a5,4201348c <kbelf_inst_preinit_get+0x4a>
4201346a:	048a                	sll	s1,s1,0x2
4201346c:	009507b3          	add	a5,a0,s1
42013470:	0204c463          	bltz	s1,42013498 <kbelf_inst_preinit_get+0x56>
42013474:	02a7e463          	bltu	a5,a0,4201349c <kbelf_inst_preinit_get+0x5a>
42013478:	c79d                	beqz	a5,420134a6 <kbelf_inst_preinit_get+0x64>
4201347a:	0037f713          	and	a4,a5,3
4201347e:	e705                	bnez	a4,420134a6 <kbelf_inst_preinit_get+0x64>
}
42013480:	40b2                	lw	ra,12(sp)
42013482:	4422                	lw	s0,8(sp)
    return index < inst->preinit_array_len ? arr[index] : 0;
42013484:	4388                	lw	a0,0(a5)
}
42013486:	4492                	lw	s1,4(sp)
42013488:	0141                	add	sp,sp,16
4201348a:	8082                	ret
4201348c:	40b2                	lw	ra,12(sp)
4201348e:	4422                	lw	s0,8(sp)
42013490:	4492                	lw	s1,4(sp)
        return 0;
42013492:	4501                	li	a0,0
}
42013494:	0141                	add	sp,sp,16
42013496:	8082                	ret
    return index < inst->preinit_array_len ? arr[index] : 0;
42013498:	fef570e3          	bgeu	a0,a5,42013478 <kbelf_inst_preinit_get+0x36>
4201349c:	9002                	ebreak
        return 0;
4201349e:	4501                	li	a0,0
}
420134a0:	8082                	ret
    kbelf_addr *arr = (void *)kbelf_inst_vaddr_to_laddr(inst, inst->preinit_array);
420134a2:	9002                	ebreak
420134a4:	9002                	ebreak
    return index < inst->preinit_array_len ? arr[index] : 0;
420134a6:	9002                	ebreak

420134a8 <kbelf_inst_init_len>:

// Get the number of initialisation functions.
size_t kbelf_inst_init_len(kbelf_inst inst) {
    return inst ? inst->init_array_len + !!inst->init_func : 0;
420134a8:	cd11                	beqz	a0,420134c4 <kbelf_inst_init_len+0x1c>
420134aa:	00357793          	and	a5,a0,3
420134ae:	ef89                	bnez	a5,420134c8 <kbelf_inst_init_len+0x20>
420134b0:	fd800793          	li	a5,-40
420134b4:	00f57a63          	bgeu	a0,a5,420134c8 <kbelf_inst_init_len+0x20>
420134b8:	4d1c                	lw	a5,24(a0)
420134ba:	5518                	lw	a4,40(a0)
420134bc:	00f03533          	snez	a0,a5
420134c0:	953a                	add	a0,a0,a4
420134c2:	8082                	ret
420134c4:	4501                	li	a0,0
}
420134c6:	8082                	ret
    return inst ? inst->init_array_len + !!inst->init_func : 0;
420134c8:	9002                	ebreak

420134ca <kbelf_inst_init_get>:

// Get virtual initialisation function address of a loaded instance.
kbelf_addr kbelf_inst_init_get(kbelf_inst inst, size_t index) {
    if (!inst)
420134ca:	c53d                	beqz	a0,42013538 <kbelf_inst_init_get+0x6e>
kbelf_addr kbelf_inst_init_get(kbelf_inst inst, size_t index) {
420134cc:	1141                	add	sp,sp,-16
420134ce:	c422                	sw	s0,8(sp)
420134d0:	c606                	sw	ra,12(sp)
420134d2:	c226                	sw	s1,4(sp)
        return 0;
    if (inst->init_func) {
420134d4:	00357793          	and	a5,a0,3
420134d8:	842a                	mv	s0,a0
420134da:	e3ad                	bnez	a5,4201353c <kbelf_inst_init_get+0x72>
420134dc:	57a1                	li	a5,-24
420134de:	06f57063          	bgeu	a0,a5,4201353e <kbelf_inst_init_get+0x74>
420134e2:	4d08                	lw	a0,24(a0)
420134e4:	84ae                	mv	s1,a1
420134e6:	c501                	beqz	a0,420134ee <kbelf_inst_init_get+0x24>
        if (index == 0)
420134e8:	cd99                	beqz	a1,42013506 <kbelf_inst_init_get+0x3c>
            return inst->init_func;
        index--;
420134ea:	fff58493          	add	s1,a1,-1
    }
    kbelf_addr *arr = (void *)kbelf_inst_vaddr_to_laddr(inst, inst->init_array);
420134ee:	fd400793          	li	a5,-44
420134f2:	04f47763          	bgeu	s0,a5,42013540 <kbelf_inst_init_get+0x76>
420134f6:	544c                	lw	a1,44(s0)
420134f8:	8522                	mv	a0,s0
420134fa:	a96ff0ef          	jal	42012790 <kbelf_inst_vaddr_to_laddr>
    return index < inst->init_array_len ? arr[index] : 0;
420134fe:	541c                	lw	a5,40(s0)
42013500:	00f4e863          	bltu	s1,a5,42013510 <kbelf_inst_init_get+0x46>
        return 0;
42013504:	4501                	li	a0,0
}
42013506:	40b2                	lw	ra,12(sp)
42013508:	4422                	lw	s0,8(sp)
4201350a:	4492                	lw	s1,4(sp)
4201350c:	0141                	add	sp,sp,16
4201350e:	8082                	ret
    return index < inst->init_array_len ? arr[index] : 0;
42013510:	048a                	sll	s1,s1,0x2
42013512:	009507b3          	add	a5,a0,s1
42013516:	0004de63          	bgez	s1,42013532 <kbelf_inst_init_get+0x68>
4201351a:	00f56e63          	bltu	a0,a5,42013536 <kbelf_inst_init_get+0x6c>
4201351e:	c395                	beqz	a5,42013542 <kbelf_inst_init_get+0x78>
42013520:	0037f713          	and	a4,a5,3
42013524:	ef19                	bnez	a4,42013542 <kbelf_inst_init_get+0x78>
}
42013526:	40b2                	lw	ra,12(sp)
42013528:	4422                	lw	s0,8(sp)
    return index < inst->init_array_len ? arr[index] : 0;
4201352a:	4388                	lw	a0,0(a5)
}
4201352c:	4492                	lw	s1,4(sp)
4201352e:	0141                	add	sp,sp,16
42013530:	8082                	ret
    return index < inst->init_array_len ? arr[index] : 0;
42013532:	fea7f6e3          	bgeu	a5,a0,4201351e <kbelf_inst_init_get+0x54>
42013536:	9002                	ebreak
        return 0;
42013538:	4501                	li	a0,0
}
4201353a:	8082                	ret
    if (inst->init_func) {
4201353c:	9002                	ebreak
4201353e:	9002                	ebreak
    kbelf_addr *arr = (void *)kbelf_inst_vaddr_to_laddr(inst, inst->init_array);
42013540:	9002                	ebreak
    return index < inst->init_array_len ? arr[index] : 0;
42013542:	9002                	ebreak

42013544 <kbelf_inst_fini_len>:

// Get the number of finalisation functions.
size_t kbelf_inst_fini_len(kbelf_inst inst) {
    return inst ? inst->fini_array_len + !!inst->init_func : 0;
42013544:	cd11                	beqz	a0,42013560 <kbelf_inst_fini_len+0x1c>
42013546:	00357793          	and	a5,a0,3
4201354a:	ef89                	bnez	a5,42013564 <kbelf_inst_fini_len+0x20>
4201354c:	fd000793          	li	a5,-48
42013550:	00f57a63          	bgeu	a0,a5,42013564 <kbelf_inst_fini_len+0x20>
42013554:	4d1c                	lw	a5,24(a0)
42013556:	5918                	lw	a4,48(a0)
42013558:	00f03533          	snez	a0,a5
4201355c:	953a                	add	a0,a0,a4
4201355e:	8082                	ret
42013560:	4501                	li	a0,0
}
42013562:	8082                	ret
    return inst ? inst->fini_array_len + !!inst->init_func : 0;
42013564:	9002                	ebreak

42013566 <kbelf_inst_fini_get>:

// Get virtual finalisation function address of a loaded instance.
kbelf_addr kbelf_inst_fini_get(kbelf_inst inst, size_t index) {
    if (!inst)
42013566:	c925                	beqz	a0,420135d6 <kbelf_inst_fini_get+0x70>
kbelf_addr kbelf_inst_fini_get(kbelf_inst inst, size_t index) {
42013568:	1141                	add	sp,sp,-16
4201356a:	c422                	sw	s0,8(sp)
4201356c:	c606                	sw	ra,12(sp)
4201356e:	c226                	sw	s1,4(sp)
        return 0;
    if (inst->fini_func) {
42013570:	00357793          	and	a5,a0,3
42013574:	842a                	mv	s0,a0
42013576:	e3bd                	bnez	a5,420135dc <kbelf_inst_fini_get+0x76>
42013578:	5791                	li	a5,-28
4201357a:	06f57063          	bgeu	a0,a5,420135da <kbelf_inst_fini_get+0x74>
4201357e:	4d48                	lw	a0,28(a0)
42013580:	84ae                	mv	s1,a1
42013582:	c501                	beqz	a0,4201358a <kbelf_inst_fini_get+0x24>
        if (index == 0)
42013584:	c1a9                	beqz	a1,420135c6 <kbelf_inst_fini_get+0x60>
            return inst->fini_func;
        index--;
42013586:	fff58493          	add	s1,a1,-1
    }
    kbelf_addr *arr = (void *)kbelf_inst_vaddr_to_laddr(inst, inst->fini_array);
4201358a:	fcc00793          	li	a5,-52
4201358e:	04f47863          	bgeu	s0,a5,420135de <kbelf_inst_fini_get+0x78>
42013592:	584c                	lw	a1,52(s0)
42013594:	8522                	mv	a0,s0
42013596:	9faff0ef          	jal	42012790 <kbelf_inst_vaddr_to_laddr>
    if (arr == NULL)
4201359a:	c50d                	beqz	a0,420135c4 <kbelf_inst_fini_get+0x5e>
        return 0;
    return index < inst->fini_array_len ? arr[index] : 0;
4201359c:	581c                	lw	a5,48(s0)
4201359e:	02f4f363          	bgeu	s1,a5,420135c4 <kbelf_inst_fini_get+0x5e>
420135a2:	048a                	sll	s1,s1,0x2
420135a4:	009507b3          	add	a5,a0,s1
420135a8:	0204d463          	bgez	s1,420135d0 <kbelf_inst_fini_get+0x6a>
420135ac:	02f56463          	bltu	a0,a5,420135d4 <kbelf_inst_fini_get+0x6e>
420135b0:	cb85                	beqz	a5,420135e0 <kbelf_inst_fini_get+0x7a>
420135b2:	0037f713          	and	a4,a5,3
420135b6:	e70d                	bnez	a4,420135e0 <kbelf_inst_fini_get+0x7a>
}
420135b8:	40b2                	lw	ra,12(sp)
420135ba:	4422                	lw	s0,8(sp)
    return index < inst->fini_array_len ? arr[index] : 0;
420135bc:	4388                	lw	a0,0(a5)
}
420135be:	4492                	lw	s1,4(sp)
420135c0:	0141                	add	sp,sp,16
420135c2:	8082                	ret
        return 0;
420135c4:	4501                	li	a0,0
}
420135c6:	40b2                	lw	ra,12(sp)
420135c8:	4422                	lw	s0,8(sp)
420135ca:	4492                	lw	s1,4(sp)
420135cc:	0141                	add	sp,sp,16
420135ce:	8082                	ret
    return index < inst->fini_array_len ? arr[index] : 0;
420135d0:	fea7f0e3          	bgeu	a5,a0,420135b0 <kbelf_inst_fini_get+0x4a>
420135d4:	9002                	ebreak
        return 0;
420135d6:	4501                	li	a0,0
}
420135d8:	8082                	ret
    if (inst->fini_func) {
420135da:	9002                	ebreak
420135dc:	9002                	ebreak
    kbelf_addr *arr = (void *)kbelf_inst_vaddr_to_laddr(inst, inst->fini_array);
420135de:	9002                	ebreak
    return index < inst->fini_array_len ? arr[index] : 0;
420135e0:	9002                	ebreak

420135e2 <kbelf_reloc_create>:
#define KBELF_REVEAL_PRIVATE
#include <kbelf.h>
#include <kbelf/port.h>

// Create an empty relocation context.
kbelf_reloc kbelf_reloc_create() {
420135e2:	1141                	add	sp,sp,-16
    kbelf_reloc reloc = kbelfx_malloc(sizeof(struct struct_kbelf_reloc));
420135e4:	4551                	li	a0,20
kbelf_reloc kbelf_reloc_create() {
420135e6:	c422                	sw	s0,8(sp)
420135e8:	c606                	sw	ra,12(sp)
    kbelf_reloc reloc = kbelfx_malloc(sizeof(struct struct_kbelf_reloc));
420135ea:	e84f70ef          	jal	4200ac6e <kbelfx_malloc>
420135ee:	842a                	mv	s0,a0
    if (!reloc)
420135f0:	c509                	beqz	a0,420135fa <kbelf_reloc_create+0x18>
        return NULL;
    kbelfq_memset(reloc, 0, sizeof(struct struct_kbelf_reloc));
420135f2:	4651                	li	a2,20
420135f4:	4581                	li	a1,0
420135f6:	e70f70ef          	jal	4200ac66 <kbelfq_memset>
    return reloc;
}
420135fa:	40b2                	lw	ra,12(sp)
420135fc:	8522                	mv	a0,s0
420135fe:	4422                	lw	s0,8(sp)
42013600:	0141                	add	sp,sp,16
42013602:	8082                	ret

42013604 <kbelf_reloc_destroy>:

// Clean up a `kbelf_reloc` context.
void kbelf_reloc_destroy(kbelf_reloc reloc) {
    if (!reloc)
42013604:	cd05                	beqz	a0,4201363c <kbelf_reloc_destroy+0x38>
void kbelf_reloc_destroy(kbelf_reloc reloc) {
42013606:	1141                	add	sp,sp,-16
42013608:	c422                	sw	s0,8(sp)
4201360a:	c606                	sw	ra,12(sp)
        return;
    if (reloc->libs_file)
4201360c:	00357793          	and	a5,a0,3
42013610:	842a                	mv	s0,a0
42013612:	e79d                	bnez	a5,42013640 <kbelf_reloc_destroy+0x3c>
42013614:	57f1                	li	a5,-4
42013616:	02f57463          	bgeu	a0,a5,4201363e <kbelf_reloc_destroy+0x3a>
4201361a:	4148                	lw	a0,4(a0)
4201361c:	c119                	beqz	a0,42013622 <kbelf_reloc_destroy+0x1e>
        kbelfx_free(reloc->libs_file);
4201361e:	e58f70ef          	jal	4200ac76 <kbelfx_free>
    if (reloc->libs_inst)
42013622:	57e1                	li	a5,-8
42013624:	00f47f63          	bgeu	s0,a5,42013642 <kbelf_reloc_destroy+0x3e>
42013628:	4408                	lw	a0,8(s0)
4201362a:	c119                	beqz	a0,42013630 <kbelf_reloc_destroy+0x2c>
        kbelfx_free(reloc->libs_inst);
4201362c:	e4af70ef          	jal	4200ac76 <kbelfx_free>
    kbelfx_free(reloc);
42013630:	8522                	mv	a0,s0
}
42013632:	4422                	lw	s0,8(sp)
42013634:	40b2                	lw	ra,12(sp)
42013636:	0141                	add	sp,sp,16
    kbelfx_free(reloc);
42013638:	e3ef706f          	j	4200ac76 <kbelfx_free>
4201363c:	8082                	ret
    if (reloc->libs_file)
4201363e:	9002                	ebreak
42013640:	9002                	ebreak
    if (reloc->libs_inst)
42013642:	9002                	ebreak

42013644 <kbelf_reloc_perform>:
}

// Perform the relocation.
// Returns success status.
bool kbelf_reloc_perform(kbelf_reloc reloc) {
    if (!reloc)
42013644:	60050463          	beqz	a0,42013c4c <kbelf_reloc_perform+0x608>
        return false;
    // Iterate objects.
    for (size_t x = 0; x < reloc->libs_len; x++) {
42013648:	00357793          	and	a5,a0,3
4201364c:	882a                	mv	a6,a0
4201364e:	5e079e63          	bnez	a5,42013c4a <kbelf_reloc_perform+0x606>
bool kbelf_reloc_perform(kbelf_reloc reloc) {
42013652:	7135                	add	sp,sp,-160
42013654:	c356                	sw	s5,132(sp)
    for (size_t x = 0; x < reloc->libs_len; x++) {
42013656:	00052a83          	lw	s5,0(a0)
bool kbelf_reloc_perform(kbelf_reloc reloc) {
4201365a:	cf06                	sw	ra,156(sp)
    for (size_t x = 0; x < reloc->libs_len; x++) {
4201365c:	4601                	li	a2,0
4201365e:	1a0a8e63          	beqz	s5,4201381a <kbelf_reloc_perform+0x1d6>
42013662:	420177b7          	lui	a5,0x42017
42013666:	dae6                	sw	s9,116(sp)
42013668:	d8ea                	sw	s10,112(sp)
4201366a:	cd22                	sw	s0,152(sp)
4201366c:	cb26                	sw	s1,148(sp)
4201366e:	c94a                	sw	s2,144(sp)
42013670:	c74e                	sw	s3,140(sp)
42013672:	c552                	sw	s4,136(sp)
42013674:	c15a                	sw	s6,128(sp)
42013676:	dede                	sw	s7,124(sp)
42013678:	dce2                	sw	s8,120(sp)
4201367a:	d6ee                	sw	s11,108(sp)
4201367c:	4d31                	li	s10,12
4201367e:	d6878c93          	add	s9,a5,-664 # 42016d68 <hextab+0x9c>
42013682:	85b2                	mv	a1,a2
42013684:	cc56                	sw	s5,24(sp)
        kbelf_inst inst = reloc->libs_inst[x];
42013686:	57e1                	li	a5,-8
42013688:	58f87d63          	bgeu	a6,a5,42013c22 <kbelf_reloc_perform+0x5de>
4201368c:	00882683          	lw	a3,8(a6)
42013690:	00259713          	sll	a4,a1,0x2
42013694:	00e687b3          	add	a5,a3,a4
42013698:	1e074463          	bltz	a4,42013880 <kbelf_reloc_perform+0x23c>
4201369c:	1ed7e463          	bltu	a5,a3,42013884 <kbelf_reloc_perform+0x240>
420136a0:	58078a63          	beqz	a5,42013c34 <kbelf_reloc_perform+0x5f0>
420136a4:	0037f693          	and	a3,a5,3
420136a8:	58069663          	bnez	a3,42013c34 <kbelf_reloc_perform+0x5f0>
        kbelf_file file = reloc->libs_file[x];
420136ac:	00482683          	lw	a3,4(a6)
        kbelf_inst inst = reloc->libs_inst[x];
420136b0:	4380                	lw	s0,0(a5)
        kbelf_file file = reloc->libs_file[x];
420136b2:	00e687b3          	add	a5,a3,a4
420136b6:	1c074263          	bltz	a4,4201387a <kbelf_reloc_perform+0x236>
420136ba:	1cd7e263          	bltu	a5,a3,4201387e <kbelf_reloc_perform+0x23a>
420136be:	56078a63          	beqz	a5,42013c32 <kbelf_reloc_perform+0x5ee>
420136c2:	0037f713          	and	a4,a5,3
420136c6:	56071663          	bnez	a4,42013c32 <kbelf_reloc_perform+0x5ee>
420136ca:	439c                	lw	a5,0(a5)
420136cc:	ca3e                	sw	a5,20(sp)
        size_t rel_sz = 0, rela_sz = 0;
        size_t rel_ent = 0, rela_ent = 0;
        void  *rel = NULL, *rela = NULL;

        // Search for REL and RELA tables.
        for (size_t y = 0; y < inst->dynamic_len; y++) {
420136ce:	56040163          	beqz	s0,42013c30 <kbelf_reloc_perform+0x5ec>
420136d2:	00347793          	and	a5,s0,3
420136d6:	54079d63          	bnez	a5,42013c30 <kbelf_reloc_perform+0x5ec>
420136da:	fc800793          	li	a5,-56
420136de:	54f47863          	bgeu	s0,a5,42013c2e <kbelf_reloc_perform+0x5ea>
420136e2:	03842c03          	lw	s8,56(s0)
420136e6:	100c0b63          	beqz	s8,420137fc <kbelf_reloc_perform+0x1b8>
420136ea:	4b01                	li	s6,0
            kbelf_dynentry dyn = inst->dynamic[y];
420136ec:	84a2                	mv	s1,s0
420136ee:	8be2                	mv	s7,s8
        void  *rel = NULL, *rela = NULL;
420136f0:	c602                	sw	zero,12(sp)
        size_t rel_ent = 0, rela_ent = 0;
420136f2:	4981                	li	s3,0
420136f4:	4a01                	li	s4,0
        size_t rel_sz = 0, rela_sz = 0;
420136f6:	4a81                	li	s5,0
420136f8:	4901                	li	s2,0
            kbelf_dynentry dyn = inst->dynamic[y];
420136fa:	fc400d93          	li	s11,-60
420136fe:	c82e                	sw	a1,16(sp)
42013700:	8c42                	mv	s8,a6
42013702:	845a                	mv	s0,s6
42013704:	51b4f763          	bgeu	s1,s11,42013c12 <kbelf_reloc_perform+0x5ce>
42013708:	5cdc                	lw	a5,60(s1)
4201370a:	00341693          	sll	a3,s0,0x3
4201370e:	00d78733          	add	a4,a5,a3
42013712:	1406c563          	bltz	a3,4201385c <kbelf_reloc_perform+0x218>
42013716:	14f76563          	bltu	a4,a5,42013860 <kbelf_reloc_perform+0x21c>
4201371a:	4e070d63          	beqz	a4,42013c14 <kbelf_reloc_perform+0x5d0>
4201371e:	00377793          	and	a5,a4,3
42013722:	4e079963          	bnez	a5,42013c14 <kbelf_reloc_perform+0x5d0>
42013726:	431c                	lw	a5,0(a4)
42013728:	434c                	lw	a1,4(a4)
            if (dyn.tag == DT_REL) {
4201372a:	17e5                	add	a5,a5,-7
4201372c:	00fd6a63          	bltu	s10,a5,42013740 <kbelf_reloc_perform+0xfc>
42013730:	078a                	sll	a5,a5,0x2
42013732:	97e6                	add	a5,a5,s9
42013734:	439c                	lw	a5,0(a5)
42013736:	8782                	jr	a5
                rel = (void *)kbelf_inst_getladdr(inst, dyn.value);
42013738:	8526                	mv	a0,s1
4201373a:	d79fe0ef          	jal	420124b2 <kbelf_inst_getladdr>
4201373e:	c62a                	sw	a0,12(sp)
        for (size_t y = 0; y < inst->dynamic_len; y++) {
42013740:	0405                	add	s0,s0,1
42013742:	fd7411e3          	bne	s0,s7,42013704 <kbelf_reloc_perform+0xc0>
                rela_ent = dyn.value;
            }
        }

        // Apply the REL.
        if (rel_sz && rel_ent && rel) {
42013746:	8426                	mv	s0,s1
42013748:	45c2                	lw	a1,16(sp)
4201374a:	84da                	mv	s1,s6
4201374c:	8862                	mv	a6,s8
4201374e:	00090763          	beqz	s2,4201375c <kbelf_reloc_perform+0x118>
42013752:	000a0563          	beqz	s4,4201375c <kbelf_reloc_perform+0x118>
42013756:	47b2                	lw	a5,12(sp)
42013758:	44079a63          	bnez	a5,42013bac <kbelf_reloc_perform+0x568>
            if (!rel_perform(reloc, file, inst, rel_sz / sizeof(kbelf_relentry), rel))
                return false;
        }

        // Apply the RELA.
        if (rela_sz && rela_ent && rela) {
4201375c:	0a0a8063          	beqz	s5,420137fc <kbelf_reloc_perform+0x1b8>
42013760:	08098e63          	beqz	s3,420137fc <kbelf_reloc_perform+0x1b8>
42013764:	ccc1                	beqz	s1,420137fc <kbelf_reloc_perform+0x1b8>
            if (rela_ent != sizeof(kbelf_relaentry))
42013766:	47a99e63          	bne	s3,s10,42013be2 <kbelf_reloc_perform+0x59e>
    for (size_t i = 0; i < relatab_len; i++) {
4201376a:	47ad                	li	a5,11
                KBELF_ERROR(abort, "Invalid RELA entry size")
            if (!rela_perform(reloc, file, inst, rela_sz / sizeof(kbelf_relaentry), rela))
4201376c:	03aadb33          	divu	s6,s5,s10
    for (size_t i = 0; i < relatab_len; i++) {
42013770:	0957f663          	bgeu	a5,s5,420137fc <kbelf_reloc_perform+0x1b8>
        kbelf_builtin_lib const *lib = reloc->builtins[x];
42013774:	4ad2                	lw	s5,20(sp)
    for (size_t i = 0; i < relatab_len; i++) {
42013776:	4981                	li	s3,0
42013778:	8926                	mv	s2,s1
4201377a:	4d81                	li	s11,0
        kbelf_addrdiff addend = relatab[i].addend;
4201377c:	5c61                	li	s8,-8
        kbelf_builtin_lib const *lib = reloc->builtins[x];
4201377e:	8bce                	mv	s7,s3
42013780:	d82e                	sw	a1,48(sp)
42013782:	c642                	sw	a6,12(sp)
        kbelf_laddr    laddr  = kbelf_inst_getladdr(inst, relatab[i].offset);
42013784:	017489b3          	add	s3,s1,s7
42013788:	0e0bc063          	bltz	s7,42013868 <kbelf_reloc_perform+0x224>
4201378c:	0e99e063          	bltu	s3,s1,4201386c <kbelf_reloc_perform+0x228>
42013790:	48090b63          	beqz	s2,42013c26 <kbelf_reloc_perform+0x5e2>
42013794:	00397793          	and	a5,s2,3
42013798:	48079763          	bnez	a5,42013c26 <kbelf_reloc_perform+0x5e2>
4201379c:	00092583          	lw	a1,0(s2)
420137a0:	8522                	mv	a0,s0
420137a2:	d11fe0ef          	jal	420124b2 <kbelf_inst_getladdr>
420137a6:	87aa                	mv	a5,a0
        size_t         sym    = KBELF_R_SYM(relatab[i].info);
420137a8:	0c0bc663          	bltz	s7,42013874 <kbelf_reloc_perform+0x230>
420137ac:	0c99e663          	bltu	s3,s1,42013878 <kbelf_reloc_perform+0x234>
420137b0:	5771                	li	a4,-4
420137b2:	46e97963          	bgeu	s2,a4,42013c24 <kbelf_reloc_perform+0x5e0>
420137b6:	00492603          	lw	a2,4(s2)
420137ba:	00865693          	srl	a3,a2,0x8
        uint_fast8_t   type   = KBELF_R_TYPE(relatab[i].info);
420137be:	0a0bc863          	bltz	s7,4201386e <kbelf_reloc_perform+0x22a>
420137c2:	0a99e863          	bltu	s3,s1,42013872 <kbelf_reloc_perform+0x22e>
        kbelf_addrdiff addend = relatab[i].addend;
420137c6:	080bce63          	bltz	s7,42013862 <kbelf_reloc_perform+0x21e>
420137ca:	0899ee63          	bltu	s3,s1,42013866 <kbelf_reloc_perform+0x222>
420137ce:	45897f63          	bgeu	s2,s8,42013c2c <kbelf_reloc_perform+0x5e8>
420137d2:	00892703          	lw	a4,8(s2)
        if (sym == 0) {
420137d6:	eac5                	bnez	a3,42013886 <kbelf_reloc_perform+0x242>
        if (!kbelfp_reloc_apply(file, inst, type, symval, addend, (uint8_t *)laddr))
420137d8:	0ff67a13          	zext.b	s4,a2
420137dc:	8652                	mv	a2,s4
420137de:	85a2                	mv	a1,s0
420137e0:	8556                	mv	a0,s5
420137e2:	25dd                	jal	42013ec8 <kbelfp_reloc_apply>
420137e4:	18050e63          	beqz	a0,42013980 <kbelf_reloc_perform+0x33c>
    for (size_t i = 0; i < relatab_len; i++) {
420137e8:	0d85                	add	s11,s11,1
420137ea:	0bb1                	add	s7,s7,12
420137ec:	0931                	add	s2,s2,12
420137ee:	f96debe3          	bltu	s11,s6,42013784 <kbelf_reloc_perform+0x140>
420137f2:	4832                	lw	a6,12(sp)
420137f4:	55c2                	lw	a1,48(sp)
420137f6:	00082783          	lw	a5,0(a6)
420137fa:	cc3e                	sw	a5,24(sp)
    for (size_t x = 0; x < reloc->libs_len; x++) {
420137fc:	47e2                	lw	a5,24(sp)
420137fe:	0585                	add	a1,a1,1
42013800:	e8f5e3e3          	bltu	a1,a5,42013686 <kbelf_reloc_perform+0x42>
42013804:	446a                	lw	s0,152(sp)
42013806:	44da                	lw	s1,148(sp)
42013808:	494a                	lw	s2,144(sp)
4201380a:	49ba                	lw	s3,140(sp)
4201380c:	4a2a                	lw	s4,136(sp)
4201380e:	4b0a                	lw	s6,128(sp)
42013810:	5bf6                	lw	s7,124(sp)
42013812:	5c66                	lw	s8,120(sp)
42013814:	5cd6                	lw	s9,116(sp)
42013816:	5d46                	lw	s10,112(sp)
42013818:	5db6                	lw	s11,108(sp)

    return true;

abort:
    return false;
}
4201381a:	40fa                	lw	ra,156(sp)
4201381c:	4a9a                	lw	s5,132(sp)
    return true;
4201381e:	4505                	li	a0,1
}
42013820:	610d                	add	sp,sp,160
42013822:	8082                	ret
        for (size_t y = 0; y < inst->dynamic_len; y++) {
42013824:	0405                	add	s0,s0,1
            kbelf_dynentry dyn = inst->dynamic[y];
42013826:	8a2e                	mv	s4,a1
        for (size_t y = 0; y < inst->dynamic_len; y++) {
42013828:	ed741ee3          	bne	s0,s7,42013704 <kbelf_reloc_perform+0xc0>
4201382c:	bf29                	j	42013746 <kbelf_reloc_perform+0x102>
4201382e:	0405                	add	s0,s0,1
                rela_ent = dyn.value;
42013830:	89ae                	mv	s3,a1
        for (size_t y = 0; y < inst->dynamic_len; y++) {
42013832:	ed7419e3          	bne	s0,s7,42013704 <kbelf_reloc_perform+0xc0>
42013836:	bf01                	j	42013746 <kbelf_reloc_perform+0x102>
42013838:	0405                	add	s0,s0,1
            kbelf_dynentry dyn = inst->dynamic[y];
4201383a:	8aae                	mv	s5,a1
        for (size_t y = 0; y < inst->dynamic_len; y++) {
4201383c:	ed7414e3          	bne	s0,s7,42013704 <kbelf_reloc_perform+0xc0>
42013840:	b719                	j	42013746 <kbelf_reloc_perform+0x102>
                rela = (void *)kbelf_inst_getladdr(inst, dyn.value);
42013842:	8526                	mv	a0,s1
42013844:	c6ffe0ef          	jal	420124b2 <kbelf_inst_getladdr>
        for (size_t y = 0; y < inst->dynamic_len; y++) {
42013848:	0405                	add	s0,s0,1
                rela = (void *)kbelf_inst_getladdr(inst, dyn.value);
4201384a:	8b2a                	mv	s6,a0
        for (size_t y = 0; y < inst->dynamic_len; y++) {
4201384c:	eb741ce3          	bne	s0,s7,42013704 <kbelf_reloc_perform+0xc0>
42013850:	bddd                	j	42013746 <kbelf_reloc_perform+0x102>
42013852:	0405                	add	s0,s0,1
            kbelf_dynentry dyn = inst->dynamic[y];
42013854:	892e                	mv	s2,a1
        for (size_t y = 0; y < inst->dynamic_len; y++) {
42013856:	eb7417e3          	bne	s0,s7,42013704 <kbelf_reloc_perform+0xc0>
4201385a:	b5f5                	j	42013746 <kbelf_reloc_perform+0x102>
            kbelf_dynentry dyn = inst->dynamic[y];
4201385c:	eae7ffe3          	bgeu	a5,a4,4201371a <kbelf_reloc_perform+0xd6>
42013860:	9002                	ebreak
        kbelf_addrdiff addend = relatab[i].addend;
42013862:	f734f6e3          	bgeu	s1,s3,420137ce <kbelf_reloc_perform+0x18a>
42013866:	9002                	ebreak
        kbelf_laddr    laddr  = kbelf_inst_getladdr(inst, relatab[i].offset);
42013868:	f334f4e3          	bgeu	s1,s3,42013790 <kbelf_reloc_perform+0x14c>
4201386c:	9002                	ebreak
        uint_fast8_t   type   = KBELF_R_TYPE(relatab[i].info);
4201386e:	f534fce3          	bgeu	s1,s3,420137c6 <kbelf_reloc_perform+0x182>
42013872:	9002                	ebreak
        size_t         sym    = KBELF_R_SYM(relatab[i].info);
42013874:	f334fee3          	bgeu	s1,s3,420137b0 <kbelf_reloc_perform+0x16c>
42013878:	9002                	ebreak
        kbelf_file file = reloc->libs_file[x];
4201387a:	e4f6f2e3          	bgeu	a3,a5,420136be <kbelf_reloc_perform+0x7a>
4201387e:	9002                	ebreak
        kbelf_inst inst = reloc->libs_inst[x];
42013880:	e2f6f0e3          	bgeu	a3,a5,420136a0 <kbelf_reloc_perform+0x5c>
42013884:	9002                	ebreak
            char const *symname = inst->dynstr + inst->dynsym[sym].name_index;
42013886:	fbc00593          	li	a1,-68
4201388a:	3cb47963          	bgeu	s0,a1,42013c5c <kbelf_reloc_perform+0x618>
4201388e:	fb400513          	li	a0,-76
42013892:	406c                	lw	a1,68(s0)
42013894:	3ca47363          	bgeu	s0,a0,42013c5a <kbelf_reloc_perform+0x616>
42013898:	4468                	lw	a0,76(s0)
4201389a:	0692                	sll	a3,a3,0x4
4201389c:	96aa                	add	a3,a3,a0
4201389e:	3aa6ed63          	bltu	a3,a0,42013c58 <kbelf_reloc_perform+0x614>
420138a2:	3a068a63          	beqz	a3,42013c56 <kbelf_reloc_perform+0x612>
420138a6:	0036f513          	and	a0,a3,3
420138aa:	3a051663          	bnez	a0,42013c56 <kbelf_reloc_perform+0x612>
420138ae:	4294                	lw	a3,0(a3)
420138b0:	00d58f33          	add	t5,a1,a3
420138b4:	1206c663          	bltz	a3,420139e0 <kbelf_reloc_perform+0x39c>
420138b8:	12bf6663          	bltu	t5,a1,420139e4 <kbelf_reloc_perform+0x3a0>
    for (size_t x = 0; x < reloc->builtins_len; x++) {
420138bc:	46b2                	lw	a3,12(sp)
420138be:	55d1                	li	a1,-12
420138c0:	38b6fa63          	bgeu	a3,a1,42013c54 <kbelf_reloc_perform+0x610>
420138c4:	46b2                	lw	a3,12(sp)
420138c6:	4881                	li	a7,0
420138c8:	00c6a303          	lw	t1,12(a3)
420138cc:	12030d63          	beqz	t1,42013a06 <kbelf_reloc_perform+0x3c2>
420138d0:	c87a                	sw	t5,16(sp)
420138d2:	ca4a                	sw	s2,20(sp)
420138d4:	cc26                	sw	s1,24(sp)
420138d6:	ce22                	sw	s0,28(sp)
420138d8:	d41a                	sw	t1,40(sp)
420138da:	89be                	mv	s3,a5
420138dc:	8a32                	mv	s4,a2
420138de:	d03a                	sw	a4,32(sp)
420138e0:	8f46                	mv	t5,a7
        kbelf_builtin_lib const *lib = reloc->builtins[x];
420138e2:	47b2                	lw	a5,12(sp)
420138e4:	5741                	li	a4,-16
420138e6:	34e7ff63          	bgeu	a5,a4,42013c44 <kbelf_reloc_perform+0x600>
420138ea:	47b2                	lw	a5,12(sp)
420138ec:	002f1613          	sll	a2,t5,0x2
420138f0:	4b94                	lw	a3,16(a5)
420138f2:	00c687b3          	add	a5,a3,a2
420138f6:	0e064263          	bltz	a2,420139da <kbelf_reloc_perform+0x396>
420138fa:	0ed7e263          	bltu	a5,a3,420139de <kbelf_reloc_perform+0x39a>
420138fe:	34078263          	beqz	a5,42013c42 <kbelf_reloc_perform+0x5fe>
42013902:	0037f693          	and	a3,a5,3
42013906:	32069e63          	bnez	a3,42013c42 <kbelf_reloc_perform+0x5fe>
4201390a:	0007a903          	lw	s2,0(a5)
        for (size_t y = 0; y < lib->symbols_len; y++) {
4201390e:	32090963          	beqz	s2,42013c40 <kbelf_reloc_perform+0x5fc>
42013912:	00397793          	and	a5,s2,3
42013916:	32079563          	bnez	a5,42013c40 <kbelf_reloc_perform+0x5fc>
4201391a:	57f1                	li	a5,-4
4201391c:	32f97163          	bgeu	s2,a5,42013c3e <kbelf_reloc_perform+0x5fa>
42013920:	00492e03          	lw	t3,4(s2)
42013924:	0c0e0663          	beqz	t3,420139f0 <kbelf_reloc_perform+0x3ac>
42013928:	4481                	li	s1,0
4201392a:	87ca                	mv	a5,s2
4201392c:	d272                	sw	t3,36(sp)
4201392e:	8926                	mv	s2,s1
42013930:	d67a                	sw	t5,44(sp)
42013932:	84be                	mv	s1,a5
            kbelf_builtin_sym sym = lib->symbols[y];
42013934:	3184f463          	bgeu	s1,s8,42013c3c <kbelf_reloc_perform+0x5f8>
42013938:	4498                	lw	a4,8(s1)
4201393a:	00491693          	sll	a3,s2,0x4
4201393e:	00d707b3          	add	a5,a4,a3
42013942:	0806c963          	bltz	a3,420139d4 <kbelf_reloc_perform+0x390>
42013946:	08e7e963          	bltu	a5,a4,420139d8 <kbelf_reloc_perform+0x394>
4201394a:	2e078863          	beqz	a5,42013c3a <kbelf_reloc_perform+0x5f6>
4201394e:	0037f713          	and	a4,a5,3
42013952:	2e071463          	bnez	a4,42013c3a <kbelf_reloc_perform+0x5f6>
            if (!kbelfq_streq(sym.name, sym_name))
42013956:	4388                	lw	a0,0(a5)
42013958:	45c2                	lw	a1,16(sp)
            kbelf_builtin_sym sym = lib->symbols[y];
4201395a:	4780                	lw	s0,8(a5)
            if (!kbelfq_streq(sym.name, sym_name))
4201395c:	b02f70ef          	jal	4200ac5e <kbelfq_streq>
42013960:	c159                	beqz	a0,420139e6 <kbelf_reloc_perform+0x3a2>
42013962:	86a2                	mv	a3,s0
42013964:	4472                	lw	s0,28(sp)
42013966:	8652                	mv	a2,s4
42013968:	5702                	lw	a4,32(sp)
        if (!kbelfp_reloc_apply(file, inst, type, symval, addend, (uint8_t *)laddr))
4201396a:	0ff67a13          	zext.b	s4,a2
4201396e:	87ce                	mv	a5,s3
42013970:	8652                	mv	a2,s4
42013972:	85a2                	mv	a1,s0
42013974:	8556                	mv	a0,s5
42013976:	4952                	lw	s2,20(sp)
42013978:	44e2                	lw	s1,24(sp)
4201397a:	23b9                	jal	42013ec8 <kbelfp_reloc_apply>
4201397c:	e60516e3          	bnez	a0,420137e8 <kbelf_reloc_perform+0x1a4>
            KBELF_ERROR(abort, "Applying relocation 0x" KBELF_FMT_BYTE " failed", type)
42013980:	4201b437          	lui	s0,0x4201b
42013984:	02f00593          	li	a1,47
42013988:	78040513          	add	a0,s0,1920 # 4201b780 <hextab+0x4ab4>
4201398c:	8b52                	mv	s6,s4
4201398e:	a9af70ef          	jal	4200ac28 <kbelfq_strrchr>
42013992:	20050a63          	beqz	a0,42013ba6 <kbelf_reloc_perform+0x562>
42013996:	57fd                	li	a5,-1
42013998:	00150613          	add	a2,a0,1
4201399c:	2cf57163          	bgeu	a0,a5,42013c5e <kbelf_reloc_perform+0x61a>
420139a0:	4201c5b7          	lui	a1,0x4201c
420139a4:	875a                	mv	a4,s6
420139a6:	08500693          	li	a3,133
420139aa:	85058593          	add	a1,a1,-1968 # 4201b850 <hextab+0x4b84>
420139ae:	4505                	li	a0,1
420139b0:	8ebef0ef          	jal	4200329a <logkf>
        return false;
420139b4:	446a                	lw	s0,152(sp)
}
420139b6:	40fa                	lw	ra,156(sp)
        return false;
420139b8:	44da                	lw	s1,148(sp)
420139ba:	494a                	lw	s2,144(sp)
420139bc:	49ba                	lw	s3,140(sp)
420139be:	4a2a                	lw	s4,136(sp)
420139c0:	4b0a                	lw	s6,128(sp)
420139c2:	5bf6                	lw	s7,124(sp)
420139c4:	5c66                	lw	s8,120(sp)
420139c6:	5cd6                	lw	s9,116(sp)
420139c8:	5d46                	lw	s10,112(sp)
420139ca:	5db6                	lw	s11,108(sp)
}
420139cc:	4a9a                	lw	s5,132(sp)
        return false;
420139ce:	4501                	li	a0,0
}
420139d0:	610d                	add	sp,sp,160
420139d2:	8082                	ret
            kbelf_builtin_sym sym = lib->symbols[y];
420139d4:	f6f77be3          	bgeu	a4,a5,4201394a <kbelf_reloc_perform+0x306>
420139d8:	9002                	ebreak
        kbelf_builtin_lib const *lib = reloc->builtins[x];
420139da:	f2f6f2e3          	bgeu	a3,a5,420138fe <kbelf_reloc_perform+0x2ba>
420139de:	9002                	ebreak
            char const *symname = inst->dynstr + inst->dynsym[sym].name_index;
420139e0:	ede5fee3          	bgeu	a1,t5,420138bc <kbelf_reloc_perform+0x278>
420139e4:	9002                	ebreak
        for (size_t y = 0; y < lib->symbols_len; y++) {
420139e6:	5792                	lw	a5,36(sp)
420139e8:	0905                	add	s2,s2,1
420139ea:	f52795e3          	bne	a5,s2,42013934 <kbelf_reloc_perform+0x2f0>
420139ee:	5f32                	lw	t5,44(sp)
    for (size_t x = 0; x < reloc->builtins_len; x++) {
420139f0:	57a2                	lw	a5,40(sp)
420139f2:	0f05                	add	t5,t5,1
420139f4:	efe797e3          	bne	a5,t5,420138e2 <kbelf_reloc_perform+0x29e>
420139f8:	4952                	lw	s2,20(sp)
420139fa:	44e2                	lw	s1,24(sp)
420139fc:	4472                	lw	s0,28(sp)
420139fe:	5702                	lw	a4,32(sp)
42013a00:	4f42                	lw	t5,16(sp)
42013a02:	87ce                	mv	a5,s3
42013a04:	8652                	mv	a2,s4
    for (size_t x = 0; x < reloc->libs_len; x++) {
42013a06:	46b2                	lw	a3,12(sp)
42013a08:	0006ae83          	lw	t4,0(a3)
42013a0c:	120e8963          	beqz	t4,42013b3e <kbelf_reloc_perform+0x4fa>
42013a10:	46b2                	lw	a3,12(sp)
    if (sym.section == SHN_ABS) {
42013a12:	69c1                	lui	s3,0x10
    bool found = false;
42013a14:	4301                	li	t1,0
42013a16:	0046ae03          	lw	t3,4(a3)
    for (size_t x = 0; x < reloc->libs_len; x++) {
42013a1a:	4681                	li	a3,0
            if (KBELF_ST_BIND(sym.info) != STB_WEAK)
42013a1c:	85b6                	mv	a1,a3
            kbelf_symentry sym = inst->dynsym[y];
42013a1e:	fb400a13          	li	s4,-76
    if (sym.section == SHN_ABS) {
42013a22:	19c5                	add	s3,s3,-15 # fff1 <__stack_size+0xdff1>
            if (KBELF_ST_BIND(sym.info) != STB_WEAK)
42013a24:	d25a                	sw	s6,36(sp)
42013a26:	d44a                	sw	s2,40(sp)
42013a28:	d65e                	sw	s7,44(sp)
42013a2a:	da26                	sw	s1,52(sp)
42013a2c:	dc22                	sw	s0,56(sp)
42013a2e:	de56                	sw	s5,60(sp)
42013a30:	c0be                	sw	a5,64(sp)
42013a32:	c2b2                	sw	a2,68(sp)
42013a34:	c4ba                	sw	a4,72(sp)
42013a36:	c6ee                	sw	s11,76(sp)
42013a38:	ca1a                	sw	t1,20(sp)
42013a3a:	d076                	sw	t4,32(sp)
42013a3c:	c87a                	sw	t5,16(sp)
42013a3e:	86f2                	mv	a3,t3
        kbelf_file file = reloc->libs_file[x];
42013a40:	00259713          	sll	a4,a1,0x2
42013a44:	00e687b3          	add	a5,a3,a4
42013a48:	14074063          	bltz	a4,42013b88 <kbelf_reloc_perform+0x544>
42013a4c:	14d7e063          	bltu	a5,a3,42013b8c <kbelf_reloc_perform+0x548>
42013a50:	1e078463          	beqz	a5,42013c38 <kbelf_reloc_perform+0x5f4>
42013a54:	8b8d                	and	a5,a5,3
42013a56:	1e079163          	bnez	a5,42013c38 <kbelf_reloc_perform+0x5f4>
        kbelf_inst inst = reloc->libs_inst[x];
42013a5a:	47b2                	lw	a5,12(sp)
42013a5c:	4790                	lw	a2,8(a5)
42013a5e:	00e607b3          	add	a5,a2,a4
42013a62:	12074063          	bltz	a4,42013b82 <kbelf_reloc_perform+0x53e>
42013a66:	12c7e063          	bltu	a5,a2,42013b86 <kbelf_reloc_perform+0x542>
42013a6a:	1e078463          	beqz	a5,42013c52 <kbelf_reloc_perform+0x60e>
42013a6e:	0037f713          	and	a4,a5,3
42013a72:	1e071063          	bnez	a4,42013c52 <kbelf_reloc_perform+0x60e>
42013a76:	4384                	lw	s1,0(a5)
        for (size_t y = 1; y < inst->dynsym_len; y++) {
42013a78:	1c048c63          	beqz	s1,42013c50 <kbelf_reloc_perform+0x60c>
42013a7c:	0034f793          	and	a5,s1,3
42013a80:	1c079863          	bnez	a5,42013c50 <kbelf_reloc_perform+0x60c>
42013a84:	fb800793          	li	a5,-72
42013a88:	1cf4fc63          	bgeu	s1,a5,42013c60 <kbelf_reloc_perform+0x61c>
42013a8c:	44a0                	lw	s0,72(s1)
42013a8e:	4785                	li	a5,1
42013a90:	0887f563          	bgeu	a5,s0,42013b1a <kbelf_reloc_perform+0x4d6>
42013a94:	4d85                	li	s11,1
42013a96:	87a6                	mv	a5,s1
42013a98:	cc2e                	sw	a1,24(sp)
42013a9a:	84ee                	mv	s1,s11
42013a9c:	ce36                	sw	a3,28(sp)
42013a9e:	8dbe                	mv	s11,a5
            kbelf_symentry sym = inst->dynsym[y];
42013aa0:	194df463          	bgeu	s11,s4,42013c28 <kbelf_reloc_perform+0x5e4>
42013aa4:	04cda683          	lw	a3,76(s11)
42013aa8:	00449613          	sll	a2,s1,0x4
42013aac:	00c687b3          	add	a5,a3,a2
42013ab0:	0c064363          	bltz	a2,42013b76 <kbelf_reloc_perform+0x532>
42013ab4:	0cd7e363          	bltu	a5,a3,42013b7a <kbelf_reloc_perform+0x536>
42013ab8:	16078963          	beqz	a5,42013c2a <kbelf_reloc_perform+0x5e6>
42013abc:	0037f693          	and	a3,a5,3
42013ac0:	16069563          	bnez	a3,42013c2a <kbelf_reloc_perform+0x5e6>
42013ac4:	00e7db83          	lhu	s7,14(a5)
42013ac8:	438c                	lw	a1,0(a5)
42013aca:	0047a903          	lw	s2,4(a5)
42013ace:	00c7c783          	lbu	a5,12(a5)
            if (!sym.section)
42013ad2:	020b8f63          	beqz	s7,42013b10 <kbelf_reloc_perform+0x4cc>
            if (KBELF_ST_BIND(sym.info) == STB_LOCAL)
42013ad6:	0047db13          	srl	s6,a5,0x4
42013ada:	020b0b63          	beqz	s6,42013b10 <kbelf_reloc_perform+0x4cc>
            char const *name = inst->dynstr + sym.name_index;
42013ade:	044da883          	lw	a7,68(s11)
42013ae2:	00b88533          	add	a0,a7,a1
42013ae6:	0805cb63          	bltz	a1,42013b7c <kbelf_reloc_perform+0x538>
42013aea:	09156b63          	bltu	a0,a7,42013b80 <kbelf_reloc_perform+0x53c>
            if (!kbelfq_streq(name, sym_name))
42013aee:	45c2                	lw	a1,16(sp)
42013af0:	96ef70ef          	jal	4200ac5e <kbelfq_streq>
42013af4:	8aaa                	mv	s5,a0
42013af6:	cd09                	beqz	a0,42013b10 <kbelf_reloc_perform+0x4cc>
    if (sym.section == SHN_ABS) {
42013af8:	013b8763          	beq	s7,s3,42013b06 <kbelf_reloc_perform+0x4c2>
        return kbelf_inst_getvaddr(inst, sym.value);
42013afc:	85ca                	mv	a1,s2
42013afe:	856e                	mv	a0,s11
42013b00:	b23fe0ef          	jal	42012622 <kbelf_inst_getvaddr>
42013b04:	892a                	mv	s2,a0
            *out_val = get_sym_value(file, inst, sym);
42013b06:	ceca                	sw	s2,92(sp)
            if (KBELF_ST_BIND(sym.info) != STB_WEAK)
42013b08:	4789                	li	a5,2
42013b0a:	08fb1263          	bne	s6,a5,42013b8e <kbelf_reloc_perform+0x54a>
            found = true;
42013b0e:	ca56                	sw	s5,20(sp)
        for (size_t y = 1; y < inst->dynsym_len; y++) {
42013b10:	0485                	add	s1,s1,1
42013b12:	f88497e3          	bne	s1,s0,42013aa0 <kbelf_reloc_perform+0x45c>
42013b16:	45e2                	lw	a1,24(sp)
42013b18:	46f2                	lw	a3,28(sp)
    for (size_t x = 0; x < reloc->libs_len; x++) {
42013b1a:	5782                	lw	a5,32(sp)
42013b1c:	0585                	add	a1,a1,1
42013b1e:	f2f591e3          	bne	a1,a5,42013a40 <kbelf_reloc_perform+0x3fc>
            if (!find_sym(reloc, symname, &symval))
42013b22:	4352                	lw	t1,20(sp)
42013b24:	5b12                	lw	s6,36(sp)
42013b26:	5922                	lw	s2,40(sp)
42013b28:	5bb2                	lw	s7,44(sp)
42013b2a:	54d2                	lw	s1,52(sp)
42013b2c:	5462                	lw	s0,56(sp)
42013b2e:	5af2                	lw	s5,60(sp)
42013b30:	4786                	lw	a5,64(sp)
42013b32:	4616                	lw	a2,68(sp)
42013b34:	4726                	lw	a4,72(sp)
42013b36:	4db6                	lw	s11,76(sp)
42013b38:	4f42                	lw	t5,16(sp)
42013b3a:	06031463          	bnez	t1,42013ba2 <kbelf_reloc_perform+0x55e>
                KBELF_ERROR(abort, "Unable to find symbol " KBELF_FMT_CSTR "", symname)
42013b3e:	4201b437          	lui	s0,0x4201b
42013b42:	02f00593          	li	a1,47
42013b46:	78040513          	add	a0,s0,1920 # 4201b780 <hextab+0x4ab4>
42013b4a:	8c7a                	mv	s8,t5
42013b4c:	8dcf70ef          	jal	4200ac28 <kbelfq_strrchr>
42013b50:	78040613          	add	a2,s0,1920
42013b54:	c511                	beqz	a0,42013b60 <kbelf_reloc_perform+0x51c>
42013b56:	57fd                	li	a5,-1
42013b58:	00150613          	add	a2,a0,1
42013b5c:	0ef57563          	bgeu	a0,a5,42013c46 <kbelf_reloc_perform+0x602>
42013b60:	4201c5b7          	lui	a1,0x4201c
42013b64:	8762                	mv	a4,s8
42013b66:	08200693          	li	a3,130
42013b6a:	82058593          	add	a1,a1,-2016 # 4201b820 <hextab+0x4b54>
42013b6e:	4505                	li	a0,1
42013b70:	f2aef0ef          	jal	4200329a <logkf>
42013b74:	b581                	j	420139b4 <kbelf_reloc_perform+0x370>
            kbelf_symentry sym = inst->dynsym[y];
42013b76:	f4f6f1e3          	bgeu	a3,a5,42013ab8 <kbelf_reloc_perform+0x474>
42013b7a:	9002                	ebreak
            char const *name = inst->dynstr + sym.name_index;
42013b7c:	f6a8f9e3          	bgeu	a7,a0,42013aee <kbelf_reloc_perform+0x4aa>
42013b80:	9002                	ebreak
        kbelf_inst inst = reloc->libs_inst[x];
42013b82:	eef674e3          	bgeu	a2,a5,42013a6a <kbelf_reloc_perform+0x426>
42013b86:	9002                	ebreak
        kbelf_file file = reloc->libs_file[x];
42013b88:	ecf6f4e3          	bgeu	a3,a5,42013a50 <kbelf_reloc_perform+0x40c>
42013b8c:	9002                	ebreak
42013b8e:	5b12                	lw	s6,36(sp)
42013b90:	5922                	lw	s2,40(sp)
42013b92:	5bb2                	lw	s7,44(sp)
42013b94:	54d2                	lw	s1,52(sp)
42013b96:	5462                	lw	s0,56(sp)
42013b98:	5af2                	lw	s5,60(sp)
42013b9a:	4786                	lw	a5,64(sp)
42013b9c:	4616                	lw	a2,68(sp)
42013b9e:	4726                	lw	a4,72(sp)
42013ba0:	4db6                	lw	s11,76(sp)
        if (!kbelfp_reloc_apply(file, inst, type, symval, addend, (uint8_t *)laddr))
42013ba2:	46f6                	lw	a3,92(sp)
42013ba4:	b915                	j	420137d8 <kbelf_reloc_perform+0x194>
            KBELF_ERROR(abort, "Applying relocation 0x" KBELF_FMT_BYTE " failed", type)
42013ba6:	78040613          	add	a2,s0,1920
42013baa:	bbdd                	j	420139a0 <kbelf_reloc_perform+0x35c>
            if (rel_ent != sizeof(kbelf_relentry))
42013bac:	47a1                	li	a5,8
42013bae:	e0fa03e3          	beq	s4,a5,420139b4 <kbelf_reloc_perform+0x370>
                KBELF_ERROR(abort, "Invalid REL entry size")
42013bb2:	4201b437          	lui	s0,0x4201b
42013bb6:	02f00593          	li	a1,47
42013bba:	78040513          	add	a0,s0,1920 # 4201b780 <hextab+0x4ab4>
42013bbe:	86af70ef          	jal	4200ac28 <kbelfq_strrchr>
42013bc2:	cd29                	beqz	a0,42013c1c <kbelf_reloc_perform+0x5d8>
42013bc4:	577d                	li	a4,-1
42013bc6:	00150613          	add	a2,a0,1
42013bca:	06e57663          	bgeu	a0,a4,42013c36 <kbelf_reloc_perform+0x5f2>
42013bce:	4201b5b7          	lui	a1,0x4201b
42013bd2:	0b000693          	li	a3,176
42013bd6:	7c858593          	add	a1,a1,1992 # 4201b7c8 <hextab+0x4afc>
42013bda:	4505                	li	a0,1
42013bdc:	ebeef0ef          	jal	4200329a <logkf>
42013be0:	bbd1                	j	420139b4 <kbelf_reloc_perform+0x370>
                KBELF_ERROR(abort, "Invalid RELA entry size")
42013be2:	4201b437          	lui	s0,0x4201b
42013be6:	02f00593          	li	a1,47
42013bea:	78040513          	add	a0,s0,1920 # 4201b780 <hextab+0x4ab4>
42013bee:	83af70ef          	jal	4200ac28 <kbelfq_strrchr>
42013bf2:	c115                	beqz	a0,42013c16 <kbelf_reloc_perform+0x5d2>
42013bf4:	577d                	li	a4,-1
42013bf6:	00150613          	add	a2,a0,1
42013bfa:	04e57763          	bgeu	a0,a4,42013c48 <kbelf_reloc_perform+0x604>
42013bfe:	4201b5b7          	lui	a1,0x4201b
42013c02:	0b800693          	li	a3,184
42013c06:	7f458593          	add	a1,a1,2036 # 4201b7f4 <hextab+0x4b28>
42013c0a:	4505                	li	a0,1
42013c0c:	e8eef0ef          	jal	4200329a <logkf>
42013c10:	b355                	j	420139b4 <kbelf_reloc_perform+0x370>
            kbelf_dynentry dyn = inst->dynamic[y];
42013c12:	9002                	ebreak
42013c14:	9002                	ebreak
                KBELF_ERROR(abort, "Invalid RELA entry size")
42013c16:	78040613          	add	a2,s0,1920
42013c1a:	b7d5                	j	42013bfe <kbelf_reloc_perform+0x5ba>
                KBELF_ERROR(abort, "Invalid REL entry size")
42013c1c:	78040613          	add	a2,s0,1920
42013c20:	b77d                	j	42013bce <kbelf_reloc_perform+0x58a>
        kbelf_inst inst = reloc->libs_inst[x];
42013c22:	9002                	ebreak
        size_t         sym    = KBELF_R_SYM(relatab[i].info);
42013c24:	9002                	ebreak
        kbelf_laddr    laddr  = kbelf_inst_getladdr(inst, relatab[i].offset);
42013c26:	9002                	ebreak
            kbelf_symentry sym = inst->dynsym[y];
42013c28:	9002                	ebreak
42013c2a:	9002                	ebreak
        kbelf_addrdiff addend = relatab[i].addend;
42013c2c:	9002                	ebreak
        for (size_t y = 0; y < inst->dynamic_len; y++) {
42013c2e:	9002                	ebreak
42013c30:	9002                	ebreak
        kbelf_file file = reloc->libs_file[x];
42013c32:	9002                	ebreak
        kbelf_inst inst = reloc->libs_inst[x];
42013c34:	9002                	ebreak
                KBELF_ERROR(abort, "Invalid REL entry size")
42013c36:	9002                	ebreak
        kbelf_file file = reloc->libs_file[x];
42013c38:	9002                	ebreak
            kbelf_builtin_sym sym = lib->symbols[y];
42013c3a:	9002                	ebreak
42013c3c:	9002                	ebreak
        for (size_t y = 0; y < lib->symbols_len; y++) {
42013c3e:	9002                	ebreak
42013c40:	9002                	ebreak
        kbelf_builtin_lib const *lib = reloc->builtins[x];
42013c42:	9002                	ebreak
42013c44:	9002                	ebreak
                KBELF_ERROR(abort, "Unable to find symbol " KBELF_FMT_CSTR "", symname)
42013c46:	9002                	ebreak
                KBELF_ERROR(abort, "Invalid RELA entry size")
42013c48:	9002                	ebreak
    for (size_t x = 0; x < reloc->libs_len; x++) {
42013c4a:	9002                	ebreak
        return false;
42013c4c:	4501                	li	a0,0
}
42013c4e:	8082                	ret
        for (size_t y = 1; y < inst->dynsym_len; y++) {
42013c50:	9002                	ebreak
        kbelf_inst inst = reloc->libs_inst[x];
42013c52:	9002                	ebreak
    for (size_t x = 0; x < reloc->builtins_len; x++) {
42013c54:	9002                	ebreak
            char const *symname = inst->dynstr + inst->dynsym[sym].name_index;
42013c56:	9002                	ebreak
42013c58:	9002                	ebreak
42013c5a:	9002                	ebreak
42013c5c:	9002                	ebreak
            KBELF_ERROR(abort, "Applying relocation 0x" KBELF_FMT_BYTE " failed", type)
42013c5e:	9002                	ebreak
        for (size_t y = 1; y < inst->dynsym_len; y++) {
42013c60:	9002                	ebreak

42013c62 <kbelf_reloc_add>:

// Add a loaded instance to a relocation context.
// Returns success status.
bool kbelf_reloc_add(kbelf_reloc reloc, kbelf_file file, kbelf_inst inst) {
    if (!reloc || !file || !inst)
42013c62:	c961                	beqz	a0,42013d32 <kbelf_reloc_add+0xd0>
bool kbelf_reloc_add(kbelf_reloc reloc, kbelf_file file, kbelf_inst inst) {
42013c64:	1101                	add	sp,sp,-32
42013c66:	ca26                	sw	s1,20(sp)
42013c68:	ce06                	sw	ra,28(sp)
42013c6a:	84ae                	mv	s1,a1
    if (!reloc || !file || !inst)
42013c6c:	cdc1                	beqz	a1,42013d04 <kbelf_reloc_add+0xa2>
42013c6e:	c84a                	sw	s2,16(sp)
42013c70:	8932                	mv	s2,a2
42013c72:	ca41                	beqz	a2,42013d02 <kbelf_reloc_add+0xa0>
42013c74:	cc22                	sw	s0,24(sp)
42013c76:	c64e                	sw	s3,12(sp)
42013c78:	c452                	sw	s4,8(sp)
        return false;
    size_t file_sz  = (1 + reloc->libs_len) * sizeof(struct struct_kbelf_file);
42013c7a:	00357793          	and	a5,a0,3
42013c7e:	842a                	mv	s0,a0
42013c80:	ebdd                	bnez	a5,42013d36 <kbelf_reloc_add+0xd4>
42013c82:	411c                	lw	a5,0(a0)
    size_t inst_sz  = (1 + reloc->libs_len) * sizeof(struct struct_kbelf_inst);
    void  *file_mem = kbelfx_realloc(reloc->libs_file, file_sz);
42013c84:	5771                	li	a4,-4
    size_t file_sz  = (1 + reloc->libs_len) * sizeof(struct struct_kbelf_file);
42013c86:	0785                	add	a5,a5,1
42013c88:	00279993          	sll	s3,a5,0x2
42013c8c:	99be                	add	s3,s3,a5
42013c8e:	0992                	sll	s3,s3,0x4
    void  *file_mem = kbelfx_realloc(reloc->libs_file, file_sz);
42013c90:	0ae57663          	bgeu	a0,a4,42013d3c <kbelf_reloc_add+0xda>
42013c94:	4148                	lw	a0,4(a0)
42013c96:	85ce                	mv	a1,s3
42013c98:	fdbf60ef          	jal	4200ac72 <kbelfx_realloc>
    void  *inst_mem = kbelfx_realloc(reloc->libs_inst, inst_sz);
42013c9c:	57e1                	li	a5,-8
    void  *file_mem = kbelfx_realloc(reloc->libs_file, file_sz);
42013c9e:	8a2a                	mv	s4,a0
    void  *inst_mem = kbelfx_realloc(reloc->libs_inst, inst_sz);
42013ca0:	08f47f63          	bgeu	s0,a5,42013d3e <kbelf_reloc_add+0xdc>
42013ca4:	4408                	lw	a0,8(s0)
42013ca6:	85ce                	mv	a1,s3
42013ca8:	fcbf60ef          	jal	4200ac72 <kbelfx_realloc>
    if (file_mem)
42013cac:	060a0c63          	beqz	s4,42013d24 <kbelf_reloc_add+0xc2>
        reloc->libs_file = file_mem;
42013cb0:	01442223          	sw	s4,4(s0)
    if (inst_mem)
42013cb4:	c13d                	beqz	a0,42013d1a <kbelf_reloc_add+0xb8>
        reloc->libs_inst = inst_mem;
    if (!file_mem || !inst_mem)
        return false;
    reloc->libs_file[reloc->libs_len] = file;
42013cb6:	4018                	lw	a4,0(s0)
        reloc->libs_inst = inst_mem;
42013cb8:	c408                	sw	a0,8(s0)
    reloc->libs_file[reloc->libs_len] = file;
42013cba:	00271693          	sll	a3,a4,0x2
42013cbe:	00da07b3          	add	a5,s4,a3
42013cc2:	0406d963          	bgez	a3,42013d14 <kbelf_reloc_add+0xb2>
42013cc6:	04fa6963          	bltu	s4,a5,42013d18 <kbelf_reloc_add+0xb6>
42013cca:	cba5                	beqz	a5,42013d3a <kbelf_reloc_add+0xd8>
42013ccc:	0037f613          	and	a2,a5,3
42013cd0:	e62d                	bnez	a2,42013d3a <kbelf_reloc_add+0xd8>
42013cd2:	c384                	sw	s1,0(a5)
    reloc->libs_inst[reloc->libs_len] = inst;
42013cd4:	00d507b3          	add	a5,a0,a3
42013cd8:	0206db63          	bgez	a3,42013d0e <kbelf_reloc_add+0xac>
42013cdc:	02f56b63          	bltu	a0,a5,42013d12 <kbelf_reloc_add+0xb0>
42013ce0:	cfa1                	beqz	a5,42013d38 <kbelf_reloc_add+0xd6>
42013ce2:	0037f693          	and	a3,a5,3
42013ce6:	eaa9                	bnez	a3,42013d38 <kbelf_reloc_add+0xd6>
42013ce8:	0127a023          	sw	s2,0(a5)
    reloc->libs_len++;
42013cec:	0705                	add	a4,a4,1
    return true;
}
42013cee:	40f2                	lw	ra,28(sp)
    reloc->libs_len++;
42013cf0:	c018                	sw	a4,0(s0)
    return true;
42013cf2:	4462                	lw	s0,24(sp)
42013cf4:	4942                	lw	s2,16(sp)
42013cf6:	49b2                	lw	s3,12(sp)
42013cf8:	4a22                	lw	s4,8(sp)
}
42013cfa:	44d2                	lw	s1,20(sp)
    return true;
42013cfc:	4505                	li	a0,1
}
42013cfe:	6105                	add	sp,sp,32
42013d00:	8082                	ret
42013d02:	4942                	lw	s2,16(sp)
42013d04:	40f2                	lw	ra,28(sp)
42013d06:	44d2                	lw	s1,20(sp)
        return false;
42013d08:	4501                	li	a0,0
}
42013d0a:	6105                	add	sp,sp,32
42013d0c:	8082                	ret
    reloc->libs_inst[reloc->libs_len] = inst;
42013d0e:	fca7f9e3          	bgeu	a5,a0,42013ce0 <kbelf_reloc_add+0x7e>
42013d12:	9002                	ebreak
    reloc->libs_file[reloc->libs_len] = file;
42013d14:	fb47fbe3          	bgeu	a5,s4,42013cca <kbelf_reloc_add+0x68>
42013d18:	9002                	ebreak
42013d1a:	4462                	lw	s0,24(sp)
42013d1c:	4942                	lw	s2,16(sp)
42013d1e:	49b2                	lw	s3,12(sp)
42013d20:	4a22                	lw	s4,8(sp)
42013d22:	b7cd                	j	42013d04 <kbelf_reloc_add+0xa2>
    if (inst_mem)
42013d24:	d97d                	beqz	a0,42013d1a <kbelf_reloc_add+0xb8>
        reloc->libs_inst = inst_mem;
42013d26:	c408                	sw	a0,8(s0)
    if (!file_mem || !inst_mem)
42013d28:	4942                	lw	s2,16(sp)
42013d2a:	4462                	lw	s0,24(sp)
42013d2c:	49b2                	lw	s3,12(sp)
42013d2e:	4a22                	lw	s4,8(sp)
42013d30:	bfd1                	j	42013d04 <kbelf_reloc_add+0xa2>
        return false;
42013d32:	4501                	li	a0,0
}
42013d34:	8082                	ret
    size_t file_sz  = (1 + reloc->libs_len) * sizeof(struct struct_kbelf_file);
42013d36:	9002                	ebreak
    reloc->libs_inst[reloc->libs_len] = inst;
42013d38:	9002                	ebreak
    reloc->libs_file[reloc->libs_len] = file;
42013d3a:	9002                	ebreak
    void  *file_mem = kbelfx_realloc(reloc->libs_file, file_sz);
42013d3c:	9002                	ebreak
    void  *inst_mem = kbelfx_realloc(reloc->libs_inst, inst_sz);
42013d3e:	9002                	ebreak

42013d40 <kbelf_reloc_add_builtin>:

// Add a built-in library to a relocation context.
// Returns success status.
bool kbelf_reloc_add_builtin(kbelf_reloc reloc, kbelf_builtin_lib const *lib) {
    if (!reloc || !lib)
42013d40:	c925                	beqz	a0,42013db0 <kbelf_reloc_add_builtin+0x70>
bool kbelf_reloc_add_builtin(kbelf_reloc reloc, kbelf_builtin_lib const *lib) {
42013d42:	1141                	add	sp,sp,-16
42013d44:	c226                	sw	s1,4(sp)
42013d46:	c606                	sw	ra,12(sp)
42013d48:	84ae                	mv	s1,a1
    if (!reloc || !lib)
42013d4a:	cdb1                	beqz	a1,42013da6 <kbelf_reloc_add_builtin+0x66>
42013d4c:	c422                	sw	s0,8(sp)
        return false;
    size_t cap = (1 + reloc->builtins_len) * sizeof(kbelf_builtin_lib *);
42013d4e:	00357793          	and	a5,a0,3
42013d52:	842a                	mv	s0,a0
42013d54:	e3ad                	bnez	a5,42013db6 <kbelf_reloc_add_builtin+0x76>
42013d56:	57d1                	li	a5,-12
42013d58:	04f57e63          	bgeu	a0,a5,42013db4 <kbelf_reloc_add_builtin+0x74>
42013d5c:	454c                	lw	a1,12(a0)
    void  *mem = kbelfx_realloc(reloc->builtins, cap);
42013d5e:	57c1                	li	a5,-16
    size_t cap = (1 + reloc->builtins_len) * sizeof(kbelf_builtin_lib *);
42013d60:	0585                	add	a1,a1,1
42013d62:	058a                	sll	a1,a1,0x2
    void  *mem = kbelfx_realloc(reloc->builtins, cap);
42013d64:	04f57a63          	bgeu	a0,a5,42013db8 <kbelf_reloc_add_builtin+0x78>
42013d68:	4908                	lw	a0,16(a0)
42013d6a:	f09f60ef          	jal	4200ac72 <kbelfx_realloc>
    if (!mem)
42013d6e:	c91d                	beqz	a0,42013da4 <kbelf_reloc_add_builtin+0x64>
        return false;
    reloc->builtins                      = mem;
    reloc->builtins[reloc->builtins_len] = lib;
42013d70:	4458                	lw	a4,12(s0)
    reloc->builtins                      = mem;
42013d72:	c808                	sw	a0,16(s0)
    reloc->builtins[reloc->builtins_len] = lib;
42013d74:	00271693          	sll	a3,a4,0x2
42013d78:	00d507b3          	add	a5,a0,a3
42013d7c:	0206c163          	bltz	a3,42013d9e <kbelf_reloc_add_builtin+0x5e>
42013d80:	02a7e163          	bltu	a5,a0,42013da2 <kbelf_reloc_add_builtin+0x62>
42013d84:	cb9d                	beqz	a5,42013dba <kbelf_reloc_add_builtin+0x7a>
42013d86:	0037f693          	and	a3,a5,3
42013d8a:	ea85                	bnez	a3,42013dba <kbelf_reloc_add_builtin+0x7a>
42013d8c:	c384                	sw	s1,0(a5)
    reloc->builtins_len++;
42013d8e:	0705                	add	a4,a4,1
    return true;
}
42013d90:	40b2                	lw	ra,12(sp)
    reloc->builtins_len++;
42013d92:	c458                	sw	a4,12(s0)
    return true;
42013d94:	4422                	lw	s0,8(sp)
}
42013d96:	4492                	lw	s1,4(sp)
    return true;
42013d98:	4505                	li	a0,1
}
42013d9a:	0141                	add	sp,sp,16
42013d9c:	8082                	ret
    reloc->builtins[reloc->builtins_len] = lib;
42013d9e:	fef573e3          	bgeu	a0,a5,42013d84 <kbelf_reloc_add_builtin+0x44>
42013da2:	9002                	ebreak
42013da4:	4422                	lw	s0,8(sp)
}
42013da6:	40b2                	lw	ra,12(sp)
42013da8:	4492                	lw	s1,4(sp)
        return false;
42013daa:	4501                	li	a0,0
}
42013dac:	0141                	add	sp,sp,16
42013dae:	8082                	ret
        return false;
42013db0:	4501                	li	a0,0
}
42013db2:	8082                	ret
    size_t cap = (1 + reloc->builtins_len) * sizeof(kbelf_builtin_lib *);
42013db4:	9002                	ebreak
42013db6:	9002                	ebreak
    void  *mem = kbelfx_realloc(reloc->builtins, cap);
42013db8:	9002                	ebreak
    reloc->builtins[reloc->builtins_len] = lib;
42013dba:	9002                	ebreak

42013dbc <kbelfp_file_verify>:
// Perform target-specific verification of `kbelf_file`.
bool kbelfp_file_verify(kbelf_file file) {
    if ((file->header.flags & KBELF_RISCV_FLAG_RVC) && !KBELF_RISCV_HOST_RVC) {
        KBELF_ERROR(abort, "Unsupported machine (RVC requested but not supported)")
    }
    if ((file->header.flags & KBELF_RISCV_MASK_FABI) != KBELF_RISCV_HOST_FABI) {
42013dbc:	0e050963          	beqz	a0,42013eae <kbelfp_file_verify+0xf2>
42013dc0:	00357793          	and	a5,a0,3
42013dc4:	e7ed                	bnez	a5,42013eae <kbelfp_file_verify+0xf2>
42013dc6:	fd000793          	li	a5,-48
42013dca:	0ef57363          	bgeu	a0,a5,42013eb0 <kbelfp_file_verify+0xf4>
42013dce:	591c                	lw	a5,48(a0)
bool kbelfp_file_verify(kbelf_file file) {
42013dd0:	1101                	add	sp,sp,-32
42013dd2:	cc22                	sw	s0,24(sp)
42013dd4:	ce06                	sw	ra,28(sp)
    if ((file->header.flags & KBELF_RISCV_MASK_FABI) != KBELF_RISCV_HOST_FABI) {
42013dd6:	0067f413          	and	s0,a5,6
42013dda:	e421                	bnez	s0,42013e22 <kbelfp_file_verify+0x66>
            "Unsupported machine (FABI " KBELF_FMT_CSTR " requested; acutal FABI " KBELF_FMT_CSTR ")",
            fabi[(file->header.flags & KBELF_RISCV_MASK_FABI) >> 1],
            fabi[(KBELF_RISCV_HOST_FABI) >> 1]
        )
    }
    if ((file->header.flags & KBELF_RISCV_FLAG_RVE) && !KBELF_RISCV_HOST_RVE) {
42013ddc:	8ba1                	and	a5,a5,8
    }
    if (!(file->header.flags & KBELF_RISCV_FLAG_RVE) && KBELF_RISCV_HOST_RVE) {
        KBELF_ERROR(abort, "Unsupported machine (RVI requested but not supported)")
    }

    return true;
42013dde:	4505                	li	a0,1
    if ((file->header.flags & KBELF_RISCV_FLAG_RVE) && !KBELF_RISCV_HOST_RVE) {
42013de0:	e789                	bnez	a5,42013dea <kbelfp_file_verify+0x2e>

abort:
    return false;
}
42013de2:	40f2                	lw	ra,28(sp)
42013de4:	4462                	lw	s0,24(sp)
42013de6:	6105                	add	sp,sp,32
42013de8:	8082                	ret
        KBELF_ERROR(abort, "Unsupported machine (RVE requested but not supported)")
42013dea:	4201c437          	lui	s0,0x4201c
42013dee:	02f00593          	li	a1,47
42013df2:	88840513          	add	a0,s0,-1912 # 4201b888 <hextab+0x4bbc>
42013df6:	e33f60ef          	jal	4200ac28 <kbelfq_strrchr>
42013dfa:	c545                	beqz	a0,42013ea2 <kbelfp_file_verify+0xe6>
42013dfc:	57fd                	li	a5,-1
42013dfe:	00150613          	add	a2,a0,1
42013e02:	0af57e63          	bgeu	a0,a5,42013ebe <kbelfp_file_verify+0x102>
42013e06:	4201c5b7          	lui	a1,0x4201c
42013e0a:	4505                	li	a0,1
42013e0c:	07400693          	li	a3,116
42013e10:	93058593          	add	a1,a1,-1744 # 4201b930 <hextab+0x4c64>
42013e14:	c86ef0ef          	jal	4200329a <logkf>
    return false;
42013e18:	4501                	li	a0,0
}
42013e1a:	40f2                	lw	ra,28(sp)
42013e1c:	4462                	lw	s0,24(sp)
42013e1e:	6105                	add	sp,sp,32
42013e20:	8082                	ret
        char const *fabi[] = {
42013e22:	420177b7          	lui	a5,0x42017
42013e26:	d9c78793          	add	a5,a5,-612 # 42016d9c <hextab+0xd0>
42013e2a:	4390                	lw	a2,0(a5)
42013e2c:	43d4                	lw	a3,4(a5)
42013e2e:	4798                	lw	a4,8(a5)
42013e30:	47dc                	lw	a5,12(a5)
42013e32:	ca26                	sw	s1,20(sp)
        KBELF_ERROR(
42013e34:	4201c4b7          	lui	s1,0x4201c
42013e38:	02f00593          	li	a1,47
42013e3c:	88848513          	add	a0,s1,-1912 # 4201b888 <hextab+0x4bbc>
        char const *fabi[] = {
42013e40:	c032                	sw	a2,0(sp)
42013e42:	c236                	sw	a3,4(sp)
42013e44:	c43a                	sw	a4,8(sp)
42013e46:	c63e                	sw	a5,12(sp)
        KBELF_ERROR(
42013e48:	de1f60ef          	jal	4200ac28 <kbelfq_strrchr>
42013e4c:	cd31                	beqz	a0,42013ea8 <kbelfp_file_verify+0xec>
42013e4e:	57fd                	li	a5,-1
42013e50:	00150613          	add	a2,a0,1
42013e54:	06f57763          	bgeu	a0,a5,42013ec2 <kbelfp_file_verify+0x106>
42013e58:	4791                	li	a5,4
42013e5a:	8005                	srl	s0,s0,0x1
42013e5c:	cbb9                	beqz	a5,42013eb2 <kbelfp_file_verify+0xf6>
42013e5e:	040a                	sll	s0,s0,0x2
42013e60:	870a                	mv	a4,sp
42013e62:	97a2                	add	a5,a5,s0
42013e64:	46c1                	li	a3,16
42013e66:	008705b3          	add	a1,a4,s0
42013e6a:	04f6e563          	bltu	a3,a5,42013eb4 <kbelfp_file_verify+0xf8>
42013e6e:	008707b3          	add	a5,a4,s0
42013e72:	04e7e563          	bltu	a5,a4,42013ebc <kbelfp_file_verify+0x100>
42013e76:	01040793          	add	a5,s0,16
42013e7a:	00278433          	add	s0,a5,sp
42013e7e:	ff042703          	lw	a4,-16(s0)
42013e82:	4201c7b7          	lui	a5,0x4201c
42013e86:	4201c5b7          	lui	a1,0x4201c
42013e8a:	4505                	li	a0,1
42013e8c:	8d078793          	add	a5,a5,-1840 # 4201b8d0 <hextab+0x4c04>
42013e90:	06c00693          	li	a3,108
42013e94:	8dc58593          	add	a1,a1,-1828 # 4201b8dc <hextab+0x4c10>
42013e98:	c02ef0ef          	jal	4200329a <logkf>
    return false;
42013e9c:	4501                	li	a0,0
42013e9e:	44d2                	lw	s1,20(sp)
42013ea0:	bfad                	j	42013e1a <kbelfp_file_verify+0x5e>
        KBELF_ERROR(abort, "Unsupported machine (RVE requested but not supported)")
42013ea2:	88840613          	add	a2,s0,-1912
42013ea6:	b785                	j	42013e06 <kbelfp_file_verify+0x4a>
        KBELF_ERROR(
42013ea8:	88848613          	add	a2,s1,-1912
42013eac:	b775                	j	42013e58 <kbelfp_file_verify+0x9c>
    if ((file->header.flags & KBELF_RISCV_MASK_FABI) != KBELF_RISCV_HOST_FABI) {
42013eae:	9002                	ebreak
42013eb0:	9002                	ebreak
        KBELF_ERROR(
42013eb2:	9002                	ebreak
42013eb4:	97ae                	add	a5,a5,a1
42013eb6:	fab7ece3          	bltu	a5,a1,42013e6e <kbelfp_file_verify+0xb2>
42013eba:	9002                	ebreak
42013ebc:	9002                	ebreak
42013ebe:	ca26                	sw	s1,20(sp)
        KBELF_ERROR(abort, "Unsupported machine (RVE requested but not supported)")
42013ec0:	9002                	ebreak
        KBELF_ERROR(
42013ec2:	9002                	ebreak

42013ec4 <kbelfp_reloc_get_addend>:
    (void)inst;
    (void)type;
    (void)ptr;
    // TODO.
    return 0;
}
42013ec4:	4501                	li	a0,0
42013ec6:	8082                	ret

42013ec8 <kbelfp_reloc_apply>:
// Apply a relocation.
bool kbelfp_reloc_apply(
    kbelf_file file, kbelf_inst inst, uint32_t type, kbelf_addr sym, kbelf_addr addend, uint8_t *ptr
) {
    (void)file;
    switch ((riscv_reloc_t)type) {
42013ec8:	450d                	li	a0,3
42013eca:	0aa60863          	beq	a2,a0,42013f7a <kbelfp_reloc_apply+0xb2>
42013ece:	06c56163          	bltu	a0,a2,42013f30 <kbelfp_reloc_apply+0x68>
42013ed2:	4585                	li	a1,1
42013ed4:	10b61263          	bne	a2,a1,42013fd8 <kbelfp_reloc_apply+0x110>
        case ABS32: store(uint32_t, ptr, S + A); return true;

        case ABS64: store(uint64_t, ptr, S + A); return true;
42013ed8:	9736                	add	a4,a4,a3
        case ABS32: store(uint32_t, ptr, S + A); return true;
42013eda:	0ff77693          	zext.b	a3,a4
42013ede:	cfc9                	beqz	a5,42013f78 <kbelfp_reloc_apply+0xb0>
42013ee0:	00d78023          	sb	a3,0(a5)
42013ee4:	567d                	li	a2,-1
42013ee6:	00875693          	srl	a3,a4,0x8
42013eea:	08c7f763          	bgeu	a5,a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013eee:	00178613          	add	a2,a5,1
42013ef2:	0ff6f693          	zext.b	a3,a3
42013ef6:	c249                	beqz	a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013ef8:	00d780a3          	sb	a3,1(a5)
42013efc:	5679                	li	a2,-2
42013efe:	01075693          	srl	a3,a4,0x10
42013f02:	06c7fb63          	bgeu	a5,a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013f06:	00278613          	add	a2,a5,2
42013f0a:	0ff6f693          	zext.b	a3,a3
42013f0e:	c62d                	beqz	a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013f10:	00d78123          	sb	a3,2(a5)
42013f14:	5675                	li	a2,-3
42013f16:	01875693          	srl	a3,a4,0x18
42013f1a:	04c7ff63          	bgeu	a5,a2,42013f78 <kbelfp_reloc_apply+0xb0>

        case RELATIVE: store(kbelf_addr, ptr, B + A); return true;

        case JUMP_SLOT:
            store(kbelf_addr, ptr, S);
42013f1e:	00378713          	add	a4,a5,3
42013f22:	0ff6f693          	zext.b	a3,a3
42013f26:	cb29                	beqz	a4,42013f78 <kbelfp_reloc_apply+0xb0>
        case ABS32: store(uint32_t, ptr, S + A); return true;
42013f28:	00d781a3          	sb	a3,3(a5)
42013f2c:	4505                	li	a0,1

            // TODO: TLS_* relocations.

        default: return false;
    }
}
42013f2e:	8082                	ret
    switch ((riscv_reloc_t)type) {
42013f30:	4715                	li	a4,5
42013f32:	0ae61663          	bne	a2,a4,42013fde <kbelfp_reloc_apply+0x116>
            store(kbelf_addr, ptr, S);
42013f36:	0ff6f713          	zext.b	a4,a3
42013f3a:	cf9d                	beqz	a5,42013f78 <kbelfp_reloc_apply+0xb0>
42013f3c:	00e78023          	sb	a4,0(a5)
42013f40:	567d                	li	a2,-1
42013f42:	0086d713          	srl	a4,a3,0x8
42013f46:	02c7f963          	bgeu	a5,a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013f4a:	00178613          	add	a2,a5,1
42013f4e:	0ff77713          	zext.b	a4,a4
42013f52:	c21d                	beqz	a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013f54:	00e780a3          	sb	a4,1(a5)
42013f58:	5679                	li	a2,-2
42013f5a:	0106d713          	srl	a4,a3,0x10
42013f5e:	00c7fd63          	bgeu	a5,a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013f62:	00278613          	add	a2,a5,2
42013f66:	0ff77713          	zext.b	a4,a4
42013f6a:	c619                	beqz	a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013f6c:	00e78123          	sb	a4,2(a5)
42013f70:	5775                	li	a4,-3
42013f72:	82e1                	srl	a3,a3,0x18
42013f74:	fae7e5e3          	bltu	a5,a4,42013f1e <kbelfp_reloc_apply+0x56>
42013f78:	9002                	ebreak
42013f7a:	883e                	mv	a6,a5
        case RELATIVE: store(kbelf_addr, ptr, B + A); return true;
42013f7c:	4501                	li	a0,0
42013f7e:	0035ff93          	and	t6,a1,3
42013f82:	58c1                	li	a7,-16
42013f84:	5f31                	li	t5,-20
42013f86:	4e91                	li	t4,4
42013f88:	00351313          	sll	t1,a0,0x3
42013f8c:	d5f5                	beqz	a1,42013f78 <kbelfp_reloc_apply+0xb0>
42013f8e:	fe0f95e3          	bnez	t6,42013f78 <kbelfp_reloc_apply+0xb0>
42013f92:	ff15f3e3          	bgeu	a1,a7,42013f78 <kbelfp_reloc_apply+0xb0>
42013f96:	4990                	lw	a2,16(a1)
42013f98:	d265                	beqz	a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013f9a:	00367693          	and	a3,a2,3
42013f9e:	fee9                	bnez	a3,42013f78 <kbelfp_reloc_apply+0xb0>
42013fa0:	fd167ce3          	bgeu	a2,a7,42013f78 <kbelfp_reloc_apply+0xb0>
42013fa4:	4a14                	lw	a3,16(a2)
42013fa6:	fde679e3          	bgeu	a2,t5,42013f78 <kbelfp_reloc_apply+0xb0>
42013faa:	01462e03          	lw	t3,20(a2)
42013fae:	96ba                	add	a3,a3,a4
42013fb0:	00a78633          	add	a2,a5,a0
42013fb4:	41c686b3          	sub	a3,a3,t3
42013fb8:	0066d6b3          	srl	a3,a3,t1
42013fbc:	faf66ee3          	bltu	a2,a5,42013f78 <kbelfp_reloc_apply+0xb0>
42013fc0:	0ff6f693          	zext.b	a3,a3
42013fc4:	fa080ae3          	beqz	a6,42013f78 <kbelfp_reloc_apply+0xb0>
42013fc8:	00d80023          	sb	a3,0(a6)
42013fcc:	0505                	add	a0,a0,1
42013fce:	0805                	add	a6,a6,1
42013fd0:	fbd51ce3          	bne	a0,t4,42013f88 <kbelfp_reloc_apply+0xc0>
        case ABS32: store(uint32_t, ptr, S + A); return true;
42013fd4:	4505                	li	a0,1
}
42013fd6:	8082                	ret
    switch ((riscv_reloc_t)type) {
42013fd8:	4589                	li	a1,2
42013fda:	00b60463          	beq	a2,a1,42013fe2 <kbelfp_reloc_apply+0x11a>
42013fde:	4501                	li	a0,0
42013fe0:	8082                	ret
        case ABS64: store(uint64_t, ptr, S + A); return true;
42013fe2:	96ba                	add	a3,a3,a4
42013fe4:	0ff6f713          	zext.b	a4,a3
42013fe8:	dbc1                	beqz	a5,42013f78 <kbelfp_reloc_apply+0xb0>
42013fea:	00e78023          	sb	a4,0(a5)
42013fee:	567d                	li	a2,-1
42013ff0:	0086d713          	srl	a4,a3,0x8
42013ff4:	f8c7f2e3          	bgeu	a5,a2,42013f78 <kbelfp_reloc_apply+0xb0>
42013ff8:	00178613          	add	a2,a5,1
42013ffc:	0ff77713          	zext.b	a4,a4
42014000:	de25                	beqz	a2,42013f78 <kbelfp_reloc_apply+0xb0>
42014002:	00e780a3          	sb	a4,1(a5)
42014006:	5679                	li	a2,-2
42014008:	0106d713          	srl	a4,a3,0x10
4201400c:	f6c7f6e3          	bgeu	a5,a2,42013f78 <kbelfp_reloc_apply+0xb0>
42014010:	00278613          	add	a2,a5,2
42014014:	0ff77713          	zext.b	a4,a4
42014018:	d225                	beqz	a2,42013f78 <kbelfp_reloc_apply+0xb0>
4201401a:	00e78123          	sb	a4,2(a5)
4201401e:	5775                	li	a4,-3
42014020:	82e1                	srl	a3,a3,0x18
42014022:	f4e7fbe3          	bgeu	a5,a4,42013f78 <kbelfp_reloc_apply+0xb0>
42014026:	00378613          	add	a2,a5,3
4201402a:	0ff6f713          	zext.b	a4,a3
4201402e:	d629                	beqz	a2,42013f78 <kbelfp_reloc_apply+0xb0>
42014030:	00e781a3          	sb	a4,3(a5)
42014034:	9002                	ebreak
	...
